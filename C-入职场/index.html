<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>C++ 入职场 | jqiange</title>
  <meta name="keywords" content="">
  <meta name="description" content="C++ 入职场 | jqiange">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="世人笑我太疯癫，我笑世人看不穿。">
<meta property="og:type" content="website">
<meta property="og:title" content="人畜无害的姜小强">
<meta property="og:url" content="https://jqiange.github.io/about/index.html">
<meta property="og:site_name" content="jqiange">
<meta property="og:description" content="世人笑我太疯癫，我笑世人看不穿。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image--1.oss-cn-shenzhen.aliyuncs.com/zhou.gif">
<meta property="article:published_time" content="2020-02-18T08:21:04.000Z">
<meta property="article:modified_time" content="2024-06-19T12:40:29.477Z">
<meta property="article:author" content="姜小强">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image--1.oss-cn-shenzhen.aliyuncs.com/zhou.gif">


<link rel="icon" href="/img/jqiange.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/jqiange.png"/>
</a>
<div class="author">
    <span>姜小强</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/jqiange"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(54)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="工具">
                        
                        工具
                        <small>(6)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据库">
                        
                        数据库
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="爬虫">
                        
                        爬虫
                        <small>(10)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="前端">
                        
                        前端
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="深度学习">
                        
                        深度学习
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据分析">
                        
                        数据分析
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="chip">
                        
                        chip
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="CPP">
                        
                        CPP
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Linux">
                        
                        Linux
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="python">
                        
                        python
                        <small>(15)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="54">
<input type="hidden" id="yelog_site_word_count" value="241.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CSS-Xpath</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Markdown</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Matplotlib</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mysql</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Numpy</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Pandas</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pip</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Pyecharts</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pygal</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pymysql-ORM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>RE</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Scrapy</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Seaborn</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Selenium</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>yield</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 python "
           href="/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"
           data-tag="RE"
           data-author="" >
            <span class="post-title" title="正则表达式详解">正则表达式详解</span>
            <span class="post-date" title="2020-02-26 09:25:46">2020/02/26</span>
        </a>
        
        <a  class="全部文章 chip "
           href="/%E8%AE%A1%E7%AE%97%E5%85%89%E5%88%BBOPC%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算光刻 OPC 名词解释">计算光刻 OPC 名词解释</span>
            <span class="post-date" title="2025-08-26 21:44:36">2025/08/26</span>
        </a>
        
        <a  class="全部文章 chip "
           href="/%E8%8A%AF%E7%89%87%E5%88%B6%E9%80%A0%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%B7%A5%E8%89%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="芯片制造流程与工艺">芯片制造流程与工艺</span>
            <span class="post-date" title="2025-06-14 12:13:17">2025/06/14</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/C-%E5%85%A5%E8%81%8C%E5%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++ 入职场">C++ 入职场</span>
            <span class="post-date" title="2024-06-22 15:52:55">2024/06/22</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/Protocol-Buffers-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Protocol Buffers 入门使用">Protocol Buffers 入门使用</span>
            <span class="post-date" title="2024-06-22 15:50:39">2024/06/22</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/C-python%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B-boost/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++python 混合编程 -boost">C++python 混合编程 -boost</span>
            <span class="post-date" title="2024-06-22 15:36:18">2024/06/22</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/C-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%A8%A1%E6%9D%BF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++ 泛型编程与模板">C++ 泛型编程与模板</span>
            <span class="post-date" title="2024-06-22 15:27:49">2024/06/22</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/C-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++ 入门学习笔记">C++ 入门学习笔记</span>
            <span class="post-date" title="2024-06-22 14:53:46">2024/06/22</span>
        </a>
        
        <a  class="全部文章 Linux "
           href="/shell%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="shell 编程">shell 编程</span>
            <span class="post-date" title="2022-03-07 20:24:24">2022/03/07</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git 版本控制工具">Git 版本控制工具</span>
            <span class="post-date" title="2022-03-05 23:23:45">2022/03/05</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%9A%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hexo 博客迁移与多平台使用">Hexo 博客迁移与多平台使用</span>
            <span class="post-date" title="2022-03-05 01:26:56">2022/03/05</span>
        </a>
        
        <a  class="全部文章 python "
           href="/python%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E9%87%8D%E9%9A%BE%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 中的基础知识与重难点汇总">python 中的基础知识与重难点汇总</span>
            <span class="post-date" title="2020-11-17 23:05:15">2020/11/17</span>
        </a>
        
        <a  class="全部文章 前端 "
           href="/javascript%E5%85%A5%E9%97%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JavaScript 入门">JavaScript 入门</span>
            <span class="post-date" title="2020-11-09 20:46:08">2020/11/09</span>
        </a>
        
        <a  class="全部文章 python "
           href="/python%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 中的语法糖">python 中的语法糖</span>
            <span class="post-date" title="2020-11-06 10:53:29">2020/11/06</span>
        </a>
        
        <a  class="全部文章 python "
           href="/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 中的进程，线程与协程">python 中的进程，线程与协程</span>
            <span class="post-date" title="2020-11-04 21:29:16">2020/11/04</span>
        </a>
        
        <a  class="全部文章 Linux "
           href="/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="linux 常见命令学习">linux 常见命令学习</span>
            <span class="post-date" title="2020-06-17 22:33:28">2020/06/17</span>
        </a>
        
        <a  class="全部文章 深度学习 "
           href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机器学习经典算法">机器学习经典算法</span>
            <span class="post-date" title="2020-06-16 10:36:50">2020/06/16</span>
        </a>
        
        <a  class="全部文章 深度学习 "
           href="/tensorflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tensorflow 学习笔记">tensorflow 学习笔记</span>
            <span class="post-date" title="2020-06-05 01:49:53">2020/06/05</span>
        </a>
        
        <a  class="全部文章 深度学习 "
           href="/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度理解卷积神经网络工作原理">深度理解卷积神经网络工作原理</span>
            <span class="post-date" title="2020-06-04 13:24:45">2020/06/04</span>
        </a>
        
        <a  class="全部文章 python "
           href="/%E7%88%AC%E8%99%AB%E7%9A%84%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="爬虫的定时执行">爬虫的定时执行</span>
            <span class="post-date" title="2020-04-06 22:44:47">2020/04/06</span>
        </a>
        
        <a  class="全部文章 python "
           href="/Token-%EF%BC%8CCookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Token ，Cookie 和 Session 的区别">Token ，Cookie 和 Session 的区别</span>
            <span class="post-date" title="2020-04-03 10:46:54">2020/04/03</span>
        </a>
        
        <a  class="全部文章 python "
           href="/%E5%9C%A8python%E4%B8%AD%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91-%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E5%8F%8A%E5%90%88%E5%B9%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="在 python 中进行视频 - 音频处理及合并">在 python 中进行视频 - 音频处理及合并</span>
            <span class="post-date" title="2020-03-29 10:56:44">2020/03/29</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8BJS%E8%A7%A3%E5%AF%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="反反爬虫之 JS 解密">反反爬虫之 JS 解密</span>
            <span class="post-date" title="2020-03-24 10:04:43">2020/03/24</span>
        </a>
        
        <a  class="全部文章 python "
           href="/%E7%90%86%E8%A7%A3python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="理解 python 中的闭包与装饰器">理解 python 中的闭包与装饰器</span>
            <span class="post-date" title="2020-03-21 17:34:45">2020/03/21</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/Mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mongodb 数据库入门">Mongodb 数据库入门</span>
            <span class="post-date" title="2020-03-17 22:50:33">2020/03/17</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8A%A0%E4%B8%AA%E7%A9%BA%E6%A0%BC%E5%91%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="为什么不加个空格呢">为什么不加个空格呢</span>
            <span class="post-date" title="2020-03-14 13:53:44">2020/03/14</span>
        </a>
        
        <a  class="全部文章 python "
           href="/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"
           data-tag="yield"
           data-author="" >
            <span class="post-title" title="迭代器与生成器">迭代器与生成器</span>
            <span class="post-date" title="2020-03-13 21:58:25">2020/03/13</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8B%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="反反爬虫之滑块验证码">反反爬虫之滑块验证码</span>
            <span class="post-date" title="2020-03-08 21:00:17">2020/03/08</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8B%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="反反爬虫之图片验证码">反反爬虫之图片验证码</span>
            <span class="post-date" title="2020-03-08 16:16:16">2020/03/08</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/Python%E6%93%8D%E4%BD%9CRedis/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Python 操作 Redis">Python 操作 Redis</span>
            <span class="post-date" title="2020-03-07 16:15:44">2020/03/07</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/Scrapy-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Scrapy-Redis 分布式爬虫">Scrapy-Redis 分布式爬虫</span>
            <span class="post-date" title="2020-03-07 15:35:50">2020/03/07</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E7%88%AC%E8%99%ABRequest%E5%8E%BB%E9%87%8D%E5%8F%8A%E8%BF%87%E6%BB%A4%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="爬虫 Request 去重及过滤器">爬虫 Request 去重及过滤器</span>
            <span class="post-date" title="2020-03-07 15:22:23">2020/03/07</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 数据库">Redis 数据库</span>
            <span class="post-date" title="2020-03-06 20:30:00">2020/03/06</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/Pymysql%E4%B8%8EORM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag="pymysql-ORM"
           data-author="" >
            <span class="post-title" title="Pymysql 与 ORM 操作数据库">Pymysql 与 ORM 操作数据库</span>
            <span class="post-date" title="2020-03-06 10:49:03">2020/03/06</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag="Mysql"
           data-author="" >
            <span class="post-title" title="MySql 数据库">MySql 数据库</span>
            <span class="post-date" title="2020-03-04 23:31:02">2020/03/04</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/Scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/"
           data-tag="Scrapy"
           data-author="" >
            <span class="post-title" title="Scrapy 框架爬虫">Scrapy 框架爬虫</span>
            <span class="post-date" title="2020-03-02 10:44:55">2020/03/02</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%88%AC%E8%99%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多线程与多进程爬虫">多线程与多进程爬虫</span>
            <span class="post-date" title="2020-03-01 15:33:08">2020/03/01</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/Selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A8%A1%E6%8B%9F/"
           data-tag="Selenium"
           data-author="" >
            <span class="post-title" title="Selenium 自动化测试模拟">Selenium 自动化测试模拟</span>
            <span class="post-date" title="2020-02-29 21:29:54">2020/02/29</span>
        </a>
        
        <a  class="全部文章 python "
           href="/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据持久化 - 文件保存本地">数据持久化 - 文件保存本地</span>
            <span class="post-date" title="2020-02-27 22:01:14">2020/02/27</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="爬虫基础入门">爬虫基础入门</span>
            <span class="post-date" title="2020-02-26 20:44:27">2020/02/26</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8EXpath%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/"
           data-tag="CSS-Xpath"
           data-author="" >
            <span class="post-title" title="CSS 选择器与 Xpath 数据提取">CSS 选择器与 Xpath 数据提取</span>
            <span class="post-date" title="2020-02-26 19:07:35">2020/02/26</span>
        </a>
        
        <a  class="全部文章 数据分析 "
           href="/Seaborn-Pygal-Pyecharts%E5%8F%AF%E8%A7%86%E5%8C%96/"
           data-tag="Seaborn,pygal,Pyecharts"
           data-author="" >
            <span class="post-title" title="Seaborn-Pygal-Pyecharts 可视化">Seaborn-Pygal-Pyecharts 可视化</span>
            <span class="post-date" title="2020-02-22 16:24:55">2020/02/22</span>
        </a>
        
        <a  class="全部文章 数据分析 "
           href="/python%E4%B9%8BMatplotlib%E5%8F%AF%E8%A7%86%E5%8C%96/"
           data-tag="Matplotlib"
           data-author="" >
            <span class="post-title" title="python 之 Matplotlib 可视化">python 之 Matplotlib 可视化</span>
            <span class="post-date" title="2020-02-20 20:28:44">2020/02/20</span>
        </a>
        
        <a  class="全部文章 数据分析 "
           href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E5%AE%9E%E6%93%8D/"
           data-tag="Pandas"
           data-author="" >
            <span class="post-title" title="Pandas 数据分析处理实操">Pandas 数据分析处理实操</span>
            <span class="post-date" title="2020-02-20 10:51:39">2020/02/20</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/Markdown%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E6%8A%80%E5%B7%A7/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="Markdown 文本编辑技巧">Markdown 文本编辑技巧</span>
            <span class="post-date" title="2020-02-18 16:31:40">2020/02/18</span>
        </a>
        
        <a  class="全部文章 数据分析 "
           href="/Python%E4%B9%8BPandas%E5%BA%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag="Pandas"
           data-author="" >
            <span class="post-title" title="Python 之 Pandas 库从入门到实战">Python 之 Pandas 库从入门到实战</span>
            <span class="post-date" title="2020-02-15 20:46:52">2020/02/15</span>
        </a>
        
        <a  class="全部文章 数据分析 "
           href="/Python%E4%B9%8BNumpy%E5%BA%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag="Numpy"
           data-author="" >
            <span class="post-title" title="Python 之 Numpy 库从入门到实战">Python 之 Numpy 库从入门到实战</span>
            <span class="post-date" title="2020-02-13 23:15:38">2020/02/13</span>
        </a>
        
        <a  class="全部文章 python "
           href="/python%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E9%95%9C%E5%83%8F%E6%BA%90%E7%BD%91%E5%9D%80/"
           data-tag="pip"
           data-author="" >
            <span class="post-title" title="python pip 国内镜像大全及库的安装">python pip 国内镜像大全及库的安装</span>
            <span class="post-date" title="2020-02-13 23:13:16">2020/02/13</span>
        </a>
        
        <a  class="全部文章 python "
           href="/python%E7%9A%84%E4%B8%89%E7%A7%8D%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 的三种输出格式">python 的三种输出格式</span>
            <span class="post-date" title="2020-02-13 23:04:49">2020/02/13</span>
        </a>
        
        <a  class="全部文章 python "
           href="/python%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 中的时间模块">python 中的时间模块</span>
            <span class="post-date" title="2020-02-13 23:01:16">2020/02/13</span>
        </a>
        
        <a  class="全部文章 python "
           href="/python%E6%9F%A5%E7%9C%8B%E4%BB%BB%E4%BD%95%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 查看任何第三方库的用法的方法">python 查看任何第三方库的用法的方法</span>
            <span class="post-date" title="2020-02-13 22:57:50">2020/02/13</span>
        </a>
        
        <a  class="全部文章 python "
           href="/Anaconda%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8Epyinstaller%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Anaconda 环境配置与 pyinstaller 程序打包">Anaconda 环境配置与 pyinstaller 程序打包</span>
            <span class="post-date" title="2020-02-13 20:01:52">2020/02/13</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="使用 Hexo+Github 搭建个人免费博客">使用 Hexo+Github 搭建个人免费博客</span>
            <span class="post-date" title="2020-02-13 15:44:02">2020/02/13</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/%E5%85%B3%E4%BA%8Ehexo%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"
           data-tag="Hexo"
           data-author="" >
            <span class="post-title" title="关于 hexo 使用过程中报错问题汇总">关于 hexo 使用过程中报错问题汇总</span>
            <span class="post-date" title="2020-02-12 23:03:46">2020/02/12</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-C-入职场" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">C++ 入职场</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="CPP">CPP</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-06-22 15:56:55'>2024-06-22 15:52</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:12.2k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E5%AE%8F"><span class="toc-text">1、重新认识宏 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%20%E5%88%9D%E8%AF%86%E5%AE%8F"><span class="toc-text">1.1 初识宏 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%20%E5%86%8D%E8%AE%A4%E8%AF%86%E5%AE%8F"><span class="toc-text">1.2 再认识宏 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%20%E7%A9%BA%E5%AE%8F"><span class="toc-text">1.2.1 空宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%20%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-text">1.2.2 空指针 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%20%E5%8F%96%E6%B6%88%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">1.2.3 取消宏定义 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%20%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F"><span class="toc-text">1.3 带参数的宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%20%E5%B8%A6%E5%8F%82%E5%AE%8F%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-text">1.3 1 带参宏的形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%20%E4%B8%89%E4%B8%AA%E7%AC%A6%E5%8F%B7"><span class="toc-text">1.3.2 三个符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%20%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">1.3.3 可变参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%20%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%8F"><span class="toc-text">1.4 多行的宏 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%20%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-text">1.5 预定义宏 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%20%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-text">1.5 预处理指令 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%20%E5%AE%8F%E7%9A%84%E8%B0%83%E8%AF%95"><span class="toc-text">1.6 宏的调试 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E5%A5%87%E6%80%AA%E7%9A%84%E5%8D%95%E5%86%92%E5%8F%B7"><span class="toc-text">2、奇怪的单冒号 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%20%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%AD"><span class="toc-text">2.1 在类的声明中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%20%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD"><span class="toc-text">2.2 在构造函数中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%20%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD"><span class="toc-text">2.3 在结构体中 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E5%A5%87%E6%80%AA%E7%9A%84%E5%8F%8C%E5%86%92%E5%8F%B7"><span class="toc-text">3、奇怪的双冒号 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%20%E5%9C%A8%E7%B1%BB%20-%20%E7%BB%93%E6%9E%84%E4%BD%93%20-%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%8E"><span class="toc-text">3.1 在类 &#x2F; 结构体 &#x2F; 命名空间后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%20%E5%9C%A8%E5%87%BD%E6%95%B0%20-%20%E5%8F%98%E9%87%8F%E5%89%8D"><span class="toc-text">3.2 在函数 &#x2F; 变量前</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81inline%20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">4、inline 内联函数 </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81Boost%20%E5%BA%93"><span class="toc-text">5、Boost 库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Boost%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">5.1 Boost 智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-shared-ptr%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">5.1.2 shared_ptr 智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-make-shared%20%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="toc-text">5.1.3 make_shared 工厂函数 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Boost-geometry"><span class="toc-text">5.2 Boost geometry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%20%E7%A9%BA%E9%97%B4%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%20rtree"><span class="toc-text">5.2.1 空间索引中的 rtree</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0%20assert"><span class="toc-text">6、断言函数 assert</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E4%BC%A0%E5%8F%82%E8%B5%8B%E5%80%BC"><span class="toc-text">7、传参赋值 </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81C%20%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">8、C 库函数 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%20%E5%A4%8D%E5%88%B6"><span class="toc-text">8.1 复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-memcpy"><span class="toc-text">8.1.1 memcpy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-strcpy"><span class="toc-text">8.1.2 strcpy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%20%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">8.2 数据持久化 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%20%E6%89%93%E5%BC%80%20-%20%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-text">8.2.1 打开 &#x2F; 创建文件 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%20%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text">8.2.2 读取文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-1-%20%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%8F%96%E5%87%BD%E6%95%B0"><span class="toc-text">8.2.2.1 字符读取函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-2-%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%BB%E5%8F%96%E5%87%BD%E6%95%B0"><span class="toc-text">8.2.2.2 字符串读取函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-3-%20%E5%9D%97%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E5%87%BD%E6%95%B0"><span class="toc-text">8.2.2.3 块数据读取函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-%20%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-text">8.2.3 关闭文件 </span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96%E5%92%8C%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2"><span class="toc-text">9、隐式转化和显示转换 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit%20%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">explicit 关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GDB%20%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-text">GDB 调试工具 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%B9%8B%E5%89%8D"><span class="toc-text">调试之前 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%20GDB%20%E8%B0%83%E8%AF%95"><span class="toc-text">启用 GDB 调试 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%80%E5%87%BA%20GDB"><span class="toc-text">退出 GDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-text">显示源代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9"><span class="toc-text">设置断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9"><span class="toc-text">条件断点 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E4%B8%8E%E6%89%93%E5%8D%B0"><span class="toc-text">断点与打印 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E5%80%BC"><span class="toc-text">设置变量值 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%A0%86%E6%A0%88"><span class="toc-text">查看堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C"><span class="toc-text">查看结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">查看变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B"><span class="toc-text">查看线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C"><span class="toc-text">单步执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0"><span class="toc-text">退出局部函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%BD%AC"><span class="toc-text">跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E6%96%AD%E7%82%B9"><span class="toc-text">临时断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E8%A7%86"><span class="toc-text">监视</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%80%80"><span class="toc-text">回退</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9"><span class="toc-text">帮助</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDB%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95"><span class="toc-text">GDB 多线程调试 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%20-1"><span class="toc-text"> 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4"><span class="toc-text">一些命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%9C%AF%E8%AF%AD"><span class="toc-text">一些术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-text">设置线程锁 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%20core%20%E6%96%87%E4%BB%B6"><span class="toc-text">调试 core 文件 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-text">参考文档 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%20log%20%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">编译 log 重定向</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">声明全局变量 </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81%20Mutex"><span class="toc-text">多线程和锁 Mutex</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda 表达式 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="toc-text">捕获列表 </span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在实际开发过程中，会碰到 C++ 中一些”奇怪”的用法，好像跟我们学的不一样，这里对 C++ 的知识做一个延伸。</p>
</blockquote>
<h1 id="1、重新认识宏"><a href="#1、重新认识宏" class="headerlink" title="1、重新认识宏"></a>1、重新认识宏 </h1><p> 宏是 C/C++ 所支持的一种语言特性，我们对它最初的认识，可能就是替换代码中的符号，比如定义一个圆周率 <code>PI</code>，之后在代码中使用<code>PI</code> 来代替具体圆周率的值。<br>确实如此，宏提供了一种机制，能够使你在编译期替换代码中的符号或者语句。当你的代码中存在大量相似的、重复的代码时，使用宏可以极大的减少代码量，便于书写。</p>
<p>在 C++ 基础知识的学习中，了解了宏的基本使用，但是真正进入职场，这些远远不够，因此有必要对宏进行一个系统的了解。</p>
<p>宏分为 <strong> 系统预定义的宏 </strong>，和程序员<strong> 自定义的宏</strong>。</p>
<h2 id="1-1- 初识宏"><a href="#1-1- 初识宏" class="headerlink" title="1.1 初识宏"></a>1.1 初识宏 </h2><p> 自定义宏使用 <code>#define</code> 定义，也称为宏常量，是一个全局常量。</p>
<p>一种简单的定义如下：</p>
<ul>
<li><p><strong>#define 宏名 常量表达式</strong></p>
<p>常量表达式可以是：数值，字符串，运算表达式等，只要是一个常量就行。</p>
</li>
</ul>
<pre><code class="c++">#define PI 3.14
#define NAME &quot;Lisa&quot;
#define SIZE (4*512)
#define RANDOM (-1.0 + 2.0*(double)rand() / RAND_MAX)

double perimeter = diameter * PI;</code></pre>
<p>代码在编译时，编译器会把 宏名 替换为它所定义的值进行编译。</p>
<h2 id="1-2- 再认识宏"><a href="#1-2- 再认识宏" class="headerlink" title="1.2 再认识宏"></a>1.2 再认识宏 </h2><h3 id="1-2-1- 空宏"><a href="#1-2-1- 空宏" class="headerlink" title="1.2.1 空宏"></a>1.2.1 空宏</h3><p> 有时候我们会看见，只指定了宏名，却没有指定宏值：</p>
<pre><code class="c++">#define m_DDL 

class m_DDL class&#123;...&#125;

// 等价于
class class&#123;...&#125;</code></pre>
<p><strong>空宏 </strong>(未定义的宏) 都展开为空字符串。但定义为空字符串的宏一般被视为是在预处理表达式定义的，这个后面会介绍。</p>
<h3 id="1-2-2- 空指针"><a href="#1-2-2- 空指针" class="headerlink" title="1.2.2 空指针"></a>1.2.2 空指针 </h3><p> 我们常用 <code>NULL</code> 表示一个空指针，其实它是一个已经预定义的宏。预定义指的是你不必亲自定义，编译器在编译时，已经提前定义好了。</p>
<pre><code class="c++">#define NULL ((void*)0)</code></pre>
<blockquote>
<p>空指针：指向地址 0</p>
</blockquote>
<h3 id="1-2-3- 取消宏定义"><a href="#1-2-3- 取消宏定义" class="headerlink" title="1.2.3 取消宏定义"></a>1.2.3 取消宏定义 </h3><pre><code># undef 宏名</code></pre><h2 id="1-3- 带参数的宏"><a href="#1-3- 带参数的宏" class="headerlink" title="1.3 带参数的宏"></a>1.3 带参数的宏</h2><h3 id="1-3-1- 带参宏的形式"><a href="#1-3-1- 带参宏的形式" class="headerlink" title="1.3 1 带参宏的形式"></a>1.3 1 带参宏的形式</h3><p> 带参数的宏的定义如下：</p>
<ul>
<li><p><strong>#define 宏名称([形参列表] ) 表达式</strong></p>
</li>
<li><p><strong>#define 宏名称([形参列表,] …) 表达式</strong></p>
<p>C99 标准允许定义有省略号的宏，省略号必须放在参数列表的后面，以表示可选参数。1.3.3 章节介绍。</p>
</li>
</ul>
<pre><code class="c++">#define MUL(x, y) x * y

int ret = MUL(2, 3);   // ==&gt; int ret = 2 * 3;</code></pre>
<p>注意宏是直接替换的关系。举一个例子：</p>
<pre><code class="c++">#define MUL(x, y) x * y

int ret = MUL(2+3, 3);   // ==&gt; int ret = 2 + 3 * 3;</code></pre>
<h3 id="1-3-2- 三个符号"><a href="#1-3-2- 三个符号" class="headerlink" title="1.3.2 三个符号"></a>1.3.2 三个符号</h3><ul>
<li><strong><code>#</code>符号把一个宏参数直接转换为字符串</strong></li>
</ul>
<pre><code class="c++">#define STR(x) #x

string a = STR(qwer);   //a 就是“qwer”</code></pre>
<ul>
<li><strong><code>##</code>符号会连接两边的值，产生一个新的值</strong></li>
</ul>
<pre><code class="c++">#define VAR(x) index_##x

int VAR(1);    // ==&gt; int index_1;</code></pre>
<ul>
<li><strong><code>#@</code>符号会把一个宏参数直接转换为字符</strong></li>
</ul>
<pre><code class="c++">#define CHR(x) #@x

char m_a = CHR(s);   // m_a 就是 &#39;s&#39;</code></pre>
<h3 id="1-3-3- 可变参数"><a href="#1-3-3- 可变参数" class="headerlink" title="1.3.3 可变参数"></a>1.3.3 可变参数</h3><pre><code class="c++">#define PLog(fmt, ...) printf(fmt, __VA_ARGS__)

// 这样我们就可以使用我们自己定义的宏 trace 来打印日志了
PLog(&quot;got a number %d&quot;, 34);</code></pre>
<p>当调用有可选参数的宏时，预处理器会将所有可选参数连同分隔它们的逗号打包在一起作为一个参数。在替换文本中，标识符 <strong>VA_ARGS</strong> 对应一组前述打包的可选参数。</p>
<p>预处理器把上面第四行代码替换成如下形式：</p>
<pre><code>printf(fmt, &quot;got a number %d&quot;, 34)</code></pre><blockquote>
<p><code>__VA_ARGS__</code>为空时，之前的逗号不会删除，会报错，故可以在 <code>__VA_ARGS__</code> 之前添加 <code>##</code> 符号</p>
</blockquote>
<h2 id="1-4- 多行的宏"><a href="#1-4- 多行的宏" class="headerlink" title="1.4 多行的宏"></a>1.4 多行的宏 </h2><p> 如果宏的内容很长，很多，那么可以写成多行，每行的末尾添加<code>\</code>，以表明后面的一行依然是宏的内容。比如</p>
<pre><code class="c++">#define ADD(x, y) do &#123; int sum = (x) + (y); return sum; &#125; while (0)
// 宏的内容比较长，也没有缩进，易读性较差，因此转为多行
#define ADD(x, y) \
do \
&#123;\
    int sum = (x) + (y);\
    return sum;\
&#125; while (0)</code></pre>
<h2 id="1-5- 预定义宏"><a href="#1-5- 预定义宏" class="headerlink" title="1.5 预定义宏"></a>1.5 预定义宏 </h2><p> 为了方便处理一些有用的信息，预处理器定义了一些预处理标识符，也就是预定义宏。预定义宏的名称都是以 <code>__</code> 两条下划线开头和结尾的。</p>
<p>如果宏名是由两个单词组成，那么中间以<code>_</code>（一条下划线）进行连接。并且，宏名称一般都由大写字符组成。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td><code>__DATE__</code></td>
<td>当前所编译的文件名称(绝对路径)</td>
</tr>
<tr>
<td><code>__FILE__</code></td>
<td>当前源文件的名称，用字符串常量表示</td>
</tr>
<tr>
<td><code>__LINE__</code></td>
<td>当前源文件中的行号，用十进制整数常量表示，它可以随 #line 指令改变</td>
</tr>
<tr>
<td><code>__TIME__</code></td>
<td>当前源文件的最新编译吋间，用“hh:mm:ss”形式的字符串常量表示</td>
</tr>
</tbody></table>
<p>各种编译器的预定义宏不尽相同，但是一般都会支持上面的四种宏。</p>
<p><strong>获取不同平台下 gcc(mingw)编译器预定义宏的方式：</strong></p>
<ul>
<li>Linux：                    <code>gcc -posix -E -dM - &lt; /dev/null</code></li>
<li>Windows：             <code>gcc -posix -E -dM - &lt; nul</code></li>
</ul>
<h2 id="1-5- 预处理指令"><a href="#1-5- 预处理指令" class="headerlink" title="1.5 预处理指令"></a>1.5 预处理指令 </h2><p> 通过预定义宏，配合程序员使用 <code>#ifdef</code> 与<code>#endif</code>等预处理指令，就可使平台相关代码只在适合于当前平台的代码上编译，从而在同一套代码中完成对多平台的支持。</p>
<p>我们通过预定义宏和预处理指令配合，达到一定的 <strong> 代码开关控制</strong>，对不同的操作系统启用不同的代码。</p>
<pre><code class="c++">#ifdef _WIN32 // 查看是否定义了该宏，Windows 默认会定义该宏

    // 如果是 Windows 系统则会编译此段代码
    OutputDebugString(&quot;this is a Windows log&quot;);

#else
    // 如果是 mac，则会编译此段代码
    NSLog(@&quot;this is a mac log&quot;);

#endif</code></pre>
<blockquote>
<p>宏条件语句关键词有：<code>#ifdef</code>  <code>#if</code>   <code>#else</code>   <code>#endif</code></p>
</blockquote>
<h2 id="1-6- 宏的调试"><a href="#1-6- 宏的调试" class="headerlink" title="1.6 宏的调试"></a>1.6 宏的调试 </h2><p> 宏的调试语法：</p>
<ul>
<li><p><strong>#pragma message(“输出的内容”)</strong></p>
<p>该指令必须接收一个字符串，而不能是其他的对象</p>
</li>
</ul>
<pre><code class="c++">#define SOMEMACRO 123456
#define MACROTOSTR2(x) #x
#define PRINTMACRO(x) #x &quot; = &quot; MACROTOSTR2(x)
#pragma message(PRINTMACRO(SOMEMACRO))            </code></pre>
<p>编译上述代码便会在输出窗口打印 <code>SOMEMACRO = 123456</code> 的内容。</p>
<h1 id="2、奇怪的单冒号"><a href="#2、奇怪的单冒号" class="headerlink" title="2、奇怪的单冒号"></a>2、奇怪的单冒号 </h1><h2 id="2-1- 在类的声明中"><a href="#2-1- 在类的声明中" class="headerlink" title="2.1 在类的声明中"></a>2.1 在类的声明中</h2><p> 在单冒号熟知的用法中，一般是这样的：</p>
<pre><code class="C++">class Son: public Father&#123;&#125;</code></pre>
<p>这里的单冒号作用为：<strong>表示类的继承</strong>。Son 继承 Father 的属性和方法。</p>
<h2 id="2-2- 在构造函数中"><a href="#2-2- 在构造函数中" class="headerlink" title="2.2 在构造函数中"></a>2.2 在构造函数中</h2><pre><code class="C++">class Father&#123;
public:
    Father()&#123;&#125;;
    ~Father()&#123;&#125;

    int a;
    const int b;
&#125;

Father::Father():a(1),b(2)&#123;&#125;;</code></pre>
<p>第 10 行的单冒号，<strong>表示成员属性的初始化</strong>。成员属性 a 初始化为 1，b 初始化为 2。</p>
<p>注意：</p>
<ol>
<li><p>初始化成员属性的作用相当于在构造函数内进行相应成员属性的赋值，但两者是有差别的。</p>
<p>在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两都的差别在对于像 const 类型数据的操作上表现得尤为明显。const 类型的变量必须在定义时进行初始化，而不能对 const 型的变量进行赋值。因此 const 类型的成员变量只能（而且必须）在初始化列表中进行初始化。</p>
</li>
<li><p>初始化的顺序与成员属性声名的顺序相同。</p>
<pre><code>Father::Father():a(1),b(a)&#123;&#125;;   // 这样 b 是一个随机数，并不是 1</code></pre></li>
<li><p>对于继承的类来说，在初始化列表中也可以进行基类的初始化，初始化的顺序是先基类初始化，然后再根据该类自己的变量的声明顺序进行初始化。</p>
</li>
</ol>
<h2 id="2-3- 在结构体中"><a href="#2-3- 在结构体中" class="headerlink" title="2.3 在结构体中"></a>2.3 在结构体中 </h2><p> 单冒号接数字。</p>
<pre><code class="C++">struct Mt&#123;
    int A:2;
    int B:1;
&#125;</code></pre>
<p>第 2 和 3 行的单冒号：<strong>表示该变量所占几个 bit 的空间</strong>。变量 A 占 2 个 bit 空间，变量 B 占 1 个 bit 空间。</p>
<p>举个例子：</p>
<pre><code class="c++">#include&lt;bitset&gt;

using namespace std;

struct student &#123;
    int aa:1;
    int bb:1;
    int cc:2;
    int dd:2;
&#125;;

void main() &#123;

    student s1;
    s1.aa = 1;
    s1.bb = 2;
    s1.cc = 1;
    s1.dd = 2;

    cout &lt;&lt; bitset&lt;1&gt;(s1.aa) &lt;&lt; endl;  //1
    cout &lt;&lt; bitset&lt;1&gt;(s1.bb) &lt;&lt; endl;  //0
    cout &lt;&lt; bitset&lt;2&gt;(s1.cc) &lt;&lt; endl;  //01
    cout &lt;&lt; bitset&lt;2&gt;(s1.dd) &lt;&lt; endl;  //10

&#125;</code></pre>
<h1 id="3、奇怪的双冒号"><a href="#3、奇怪的双冒号" class="headerlink" title="3、奇怪的双冒号"></a>3、奇怪的双冒号 </h1><h2 id="3-1- 在类 - 结构体 - 命名空间后"><a href="#3-1- 在类 - 结构体 - 命名空间后" class="headerlink" title="3.1 在类 / 结构体 / 命名空间后"></a>3.1 在类 / 结构体 / 命名空间后</h2><p> 这个是最常见的用法：</p>
<pre><code>std::cout     // 命名空间 std 中的 cout 类对象
Person::A     //Person 类走过的成员属性 A</code></pre><p>这里的双冒号：<strong>表示作用域</strong>。某作用域中的某对象。</p>
<h2 id="3-2- 在函数 - 变量前"><a href="#3-2- 在函数 - 变量前" class="headerlink" title="3.2 在函数 / 变量前"></a>3.2 在函数 / 变量前</h2><pre><code class="c++">string name=&quot;lisa&quot;;

void get_info() &#123;

    string name = &quot;jack&quot;;

    name = &quot;Mr &quot; + name;           // 局部变量 name
    ::name = &quot;Miss &quot; + ::name;     // 全局变量 name

    cout &lt;&lt; name &lt;&lt; endl;

    cout &lt;&lt; ::name &lt;&lt; endl;

&#125;</code></pre>
<p>这里第 8 行和第 12 行中的双冒号：<strong>表示该函数 / 变量是全局的</strong>。以区分局部变量。</p>
<h1 id="4、inline 内联函数"><a href="#4、inline 内联函数" class="headerlink" title="4、inline 内联函数"></a>4、inline 内联函数 </h1><p> 函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。</p>
<p>一个 C/C++ 程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如<code>return 0;</code>）来结束自己的生命，从而结束整个程序。</p>
<p><strong>函数调用是有时间和空间开销的</strong>。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p>
<p>一般情况下，这个开销可以忽略不计。但是，如果一个函数内部没有几条语句，执行时间本来就非常短，那么这个函数调用产生的额外开销和函数本身执行的时间相比，就显得不能忽略了。假如这样的函数在一个循环中被上千万次地执行，函数调用导致的时间开销可能就会使得程序运行明显变慢。</p>
<p>为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换。</p>
<p>这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。</p>
<p>语法：</p>
<ul>
<li><strong>inline 函数声明 / 定义 </strong>：在函数声明或定义时，加一个<strong>inline</strong> 关键字即可</li>
</ul>
<pre><code class="c++">inline void fuc(int a, int b)&#123;...&#125;</code></pre>
<p>内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。这样做也是有代价的，占用了更多内存。</p>
<p><strong>一般只将那些短小的、频繁调用的函数声明为内联函数。</strong></p>
<p>在【代码执行时间】和【处理函数调用机制的时间】之间寻找平衡。</p>
<blockquote>
<p>内联函数不能递归</p>
</blockquote>
<h1 id="5、Boost 库"><a href="#5、Boost 库" class="headerlink" title="5、Boost 库"></a>5、Boost 库</h1><h2 id="5-1-Boost 智能指针"><a href="#5-1-Boost 智能指针" class="headerlink" title="5.1 Boost 智能指针"></a>5.1 Boost 智能指针</h2><p>Boost 是一个功能强大、构造精巧、跨平台、开源并且完全免费的 C++ 程序库。该库涵盖字符串处理、正则表达式、容器与数据结构、并发编程、函数式编程、泛型编程、设计模式实现等许多领域，极大地丰富了 C++ 的功能和表现力，能够使 C++ 软件开发更加简洁、优雅、灵活和高效。</p>
<p>该库需要手动安装。</p>
<ul>
<li><p>下载地址：<a target="_blank" rel="noopener" href="https://www.boost.org/users/history/">Boost Version History</a></p>
</li>
<li><p>解压至目标文件夹：如 <code>D:\boost\boost_1_62_0</code></p>
</li>
<li><p>安装：常使用的 boost 库函数是不需要安装的。</p>
</li>
<li><p>配置 VS2019：</p>
<ul>
<li><p>在【项目】- 【项目名属性】中添加包含目录 <em>Configuration Properties &gt; C/C++ &gt; General &gt; Additional Include Directories<em>，例如</em>D:\boost\boost_1_62_0</em></p>
</li>
<li><p>更改配置 将<em>Configuration Properties &gt; C/C++ &gt; Precompiled Headers</em> 改为<em>Not Using Precompiled Headers</em>。</p>
</li>
</ul>
</li>
</ul>
<p>做完以上配置即可在 VS2019 中使用。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/004c99828af2">在 windows 下安装 Boost 1.62.0 - 简书 (jianshu.com)</a></p>
<h3 id="5-1-2-shared-ptr 智能指针"><a href="#5-1-2-shared-ptr 智能指针" class="headerlink" title="5.1.2 shared_ptr 智能指针"></a>5.1.2 shared_ptr 智能指针</h3><pre><code class="c++">#include &lt;boost/shared_ptr.hpp&gt;

boost::shared_ptr&lt;int&gt; p1    // 声明一个 int 类型的 p1 指针，注意这里不需要 * 号指明是个指针</code></pre>
<p><strong>p1 指针不用手动去释放资源，它会智能地在合适的时候去自动释放。</strong></p>
<p>boost::shared_ptr 的实现机制其实比较简单，就是对指针引用的对象进行引用计数，当引用计数为 0 时，会自动释放。</p>
<p>创建指针例子：</p>
<pre><code class="c++">boost::shared_ptr&lt;int&gt; p2(nullptr);        // 传入空指针 nullptr
boost::shared_ptr&lt;int&gt; p3(new int(10));   //p3 指向值为 10 的堆空间</code></pre>
<p>目前仅作了解即可。</p>
<p><code>boost::shared_ptr</code>消除了显式的 <code>delete</code>调用，很大程度上避免了程序员忘记 <code>delete</code>而导致的内存泄漏。但 <code>shared_ptr</code>的构造依然需要<code>new</code>，这导致了代码中的某种不对称性，它应该使用工厂模式来解决。</p>
<h3 id="5-1-3-make-shared 工厂函数"><a href="#5-1-3-make-shared 工厂函数" class="headerlink" title="5.1.3 make_shared 工厂函数"></a>5.1.3 make_shared 工厂函数 </h3><p><code>Boost</code> 库提供了一个自由工厂函数 <code>make shared&lt;T&gt;()</code>，来消除显式的 <code>new</code> 调用，声明如下：</p>
<pre><code class="c++">template&lt;class T, class... Args&gt;
boost::shared_ptr&lt;T&gt; make_shared(Args &amp;&amp; ... args);</code></pre>
<p>make_shared()函数模板使用变长参数模板，最多可接受 10 个参数然后把它们传递给 T 的构造函数，创建一个 shared_ptr<T>的对象并返回。make_shared()函数要比直接创建 shared_ptr 对象的方式更高效，因为它內部仅分配一次內存。使用时需要包含头文件。</p>
<p>举个例子：</p>
<pre><code class="c++">#include &lt;boost/make_shared.hpp&gt;
class  A
&#123;
public:
    A(int a, float b, char c, string d)
    &#123;
        m_a = a; m_b = b; m_c = c; m_d = d;
        cout &lt;&lt; &quot; 构造 A 类对象！&quot; &lt;&lt; endl;
    &#125;
    ~A()
    &#123;
        cout &lt;&lt; &quot; 析构 A 类对象！&quot; &lt;&lt; endl;
    &#125;
    int m_a;
    float m_b;
    char m_c;
    string m_d;
&#125;;

int main()
&#123;
    // 原始的方式构造 shared_ptr，需要 new，产生一种不对称性
    boost::shared_ptr&lt;A&gt;  p1(new A(100, 1.234f, &#39;C&#39;, &quot;hello&quot;));
    cout &lt;&lt; p1-&gt;a &lt;&lt; &quot;, &quot; &lt;&lt; p1-&gt;b &lt;&lt; &quot;, &quot; &lt;&lt; p1-&gt;c &lt;&lt; &quot;, &quot; &lt;&lt; p1-&gt;d &lt;&lt; endl;

    // 推荐使用工厂函数，屏蔽 new , 更高效
    boost::shared_ptr&lt;A&gt;  p2 = boost::make_shared&lt;A&gt;(100, 1.234f, &#39;C&#39;, &quot;hello&quot;);
    cout &lt;&lt; p2-&gt;a &lt;&lt; &quot;, &quot; &lt;&lt; p2-&gt;b &lt;&lt; &quot;, &quot; &lt;&lt; p2-&gt;c &lt;&lt; &quot;, &quot; &lt;&lt; p2-&gt;d &lt;&lt; endl;


    return 0;
&#125;</code></pre>
<h2 id="5-2-Boost-geometry"><a href="#5-2-Boost-geometry" class="headerlink" title="5.2 Boost geometry"></a>5.2 Boost geometry</h2><p>Boost.Geometry（又名 Generic Geometry Library，GGL）是 Boost C++ Libraries 集合的一部分，定义了解决几何问题的概念、基元和算法。</p>
<p>Boost.Geometry 包含一个与维度无关、与坐标系无关且可扩展的内核，基于概念、元函数和标签调度。在该内核之上，构建了算法：面积，长度，周长，质心，凸壳，交叉点（修剪），包含（多边形中的点），距离，包络（边界框），简化，变换等等。该库支持高精度算术数字，如 <a target="_blank" rel="noopener" href="http://www.ttmath.org/">ttmath</a>。</p>
<h3 id="5-2-1- 空间索引中的 rtree"><a href="#5-2-1- 空间索引中的 rtree" class="headerlink" title="5.2.1 空间索引中的 rtree"></a>5.2.1 空间索引中的 rtree</h3><p>描述：这是一种自平衡空间索引，能够存储各种类型的值和平衡算法。</p>
<p>参数：用户必须传递一个定义参数的类型，这些参数将在 rtree 创建过程中使用。该类型用于指定具有特定参数的平衡算法，如节点中的最小和最大元素数量。</p>
<p>带有编译时参数的预定义算法如下：</p>
<ul>
<li><code>boost::geometry::index::linear</code>,</li>
<li><code>boost::geometry::index::quadratic</code>,</li>
<li><code>boost::geometry::index::rstar</code>.</li>
</ul>
<p>带有运行时参数的预定义算法如下：</p>
<ul>
<li><code>boost::geometry::index::dynamic_linear</code>,</li>
<li><code>boost::geometry::index::dynamic_quadratic</code>,</li>
<li><code>boost::geometry::index::dynamic_rstar</code>.</li>
</ul>
<p>这里记录一个代码中的 rtree：</p>
<pre><code class="c++">typedef bgi::rtree&lt;pt_value, bgi::quadratic&lt;64&gt; &gt; pt_vrtree;

pt_vrtree boundary_pt_tree(pt_values.begin(), pt_values.end());
////define boundary_pt_tree and initialization,   pt_values=&#123;[pt]=&#123;patchid1,segid1&#125;,... &#125;

boundary_pt_tree.query(bgi::intersects(util::Box(pts.left_bottom, pts.top_right)), back_inserter(queried_result));
//query the same pt sharing the same [patchid, segid] and give result to queried_result&#123;&#123;pt,&#123;patchid1,segid1&#125;&#125;, &#123;pt,&#123;patchid2,segid2&#125;&#125;</code></pre>
<h1 id="6、断言函数 assert"><a href="#6、断言函数 assert" class="headerlink" title="6、断言函数 assert"></a>6、断言函数 assert</h1><p>断言函数，用于在调试过程中捕 <strong> 捉程序错误</strong>。断言（assertion）是编程中的一种常用手段，在通常情况下，断言就是将一个返回值总是真（或者我们需要是真）的判别式放在语句中，用以排除在设计逻辑上不应该出现的情况。</p>
<p>从本质上看，assert 是个宏，其用法像是一种”契约式编程”。</p>
<ul>
<li>如果其值为假，那么它先向 stderr 打印一条出错信息，然后通过调用 abort 来终止程序运行。</li>
<li>如果其值为真，不做任何处理，程序继续。</li>
</ul>
<pre><code class="c++"># include&lt;iostream&gt;
# include&lt;string&gt;
#include &lt;assert.h&gt;

using namespace std;

int main() &#123;
    int m, n, result;
    cin &gt;&gt; m &gt;&gt; n;
    assert(n);
    result = m / n;
    cout &lt;&lt; result &lt;&lt; endl;
    return 0;
&#125;</code></pre>
<p>使用 assert 的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。</p>
<p>在调试结束后，可以通过在包含 #include 的语句之前插入 #define NDEBUG 来禁用 assert 调用，示例代码如下：</p>
<pre><code>#include &lt;bitset&gt;
#define NDEBUG 
#include &quot;logger.h&quot;</code></pre><h1 id="7、传参赋值"><a href="#7、传参赋值" class="headerlink" title="7、传参赋值"></a>7、传参赋值 </h1><p> 一般情况下，我们给函数定义形参，是需要传值使用，但是有时候，定义形参是为了赋值。</p>
<pre><code class="c++">class  A
&#123;
public:
    int m_a;
    int m_b;
&#125;;

void setA(int* arr, int&amp; a, int&amp; b) &#123;
    a = arr[0];
    b = arr[1];
&#125;

int main()
&#123;
    A* p = new A;
    int arr[2] = &#123; 10, 20 &#125;;
    setA(arr, p-&gt;m_a, p-&gt;m_b);

    cout &lt;&lt; p-&gt;m_a &lt;&lt; endl;

    return 0;
&#125;</code></pre>
<h1 id="8、C 库函数"><a href="#8、C 库函数" class="headerlink" title="8、C 库函数"></a>8、C 库函数 </h1><h2 id="8-1- 复制"><a href="#8-1- 复制" class="headerlink" title="8.1 复制"></a>8.1 复制</h2><p>C 库函数提供了两种复制函数：<strong>strcpy</strong> 和<strong>memcpy</strong></p>
<p><strong>strcpy</strong>和 <strong>memcpy</strong> 主要有以下 3 方面的区别。</p>
<ol>
<li><p>复制的内容不同。strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。</p>
</li>
<li><p>复制的方法不同。strcpy 不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy 则是根据其第 3 个参数决定复制的长度。</p>
</li>
<li><p>用途不同。通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy。</p>
</li>
</ol>
<h3 id="8-1-1-memcpy"><a href="#8-1-1-memcpy" class="headerlink" title="8.1.1 memcpy"></a>8.1.1 memcpy</h3><p>函数原型：</p>
<pre><code>void *memcpy(void *dest, const void *src, size_t n)</code></pre><ul>
<li><strong>dest</strong> – 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li>
<li><strong>src</strong> – 指向要复制的数据源，类型强制转换为 void* 指针。</li>
<li><strong>n</strong> – 要被复制的字节数。</li>
</ul>
<p>该函数 <strong> 返回 </strong> 一个指向目标存储区 dest 的指针。</p>
<p><strong>memcpy()</strong> 会复制 src 所指的内存内容的前 n 个字节到 dest 所指的内存地址上。</p>
<ul>
<li><strong>memcpy() 并不关心被复制的数据类型，只是逐字节地进行复制，这给函数的使用带来了很大的灵活性，可以面向任何数据类型进行复制。</strong>也就是说，可以把结构体复制给 int 类型的变量。</li>
<li>dest 指针要分配足够的空间，也即大于等于 num 字节的空间。如果没有分配空间，会出现断错误。</li>
<li>dest 和 src 所指的内存空间不能重叠（如果发生了重叠，使用 [memmove()]会更加安全）。</li>
</ul>
<p>完整复制示例：</p>
<pre><code class="c++">// 将字符串复制到数组 dest 中
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;   // 必须包含这个头文件

int main ()
&#123;
   const char src[50] = &quot;http://www.runoob.com&quot;;
   char dest[50];

   memcpy(dest, src, strlen(src)+1);   // 这里加 1 是为了把 src 字符串的结尾符 \0 也复制给 dest,
   printf(&quot;dest = %s\n&quot;, dest);        // 以让 dest 输出时遇到结尾符停止输出，不然会输出 50 个字符。

   return(0);
&#125;</code></pre>
<p>切片复制：</p>
<pre><code class="c++">#include &lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
&#123;
  char *s=&quot;http://www.runoob.com&quot;;
  char d[20];
  memcpy(d, s+11, 6);    // 从第 11 个字符 (r) 开始复制，连续复制 6 个字符(runoob)
  // 或者 memcpy(d, s+11*sizeof(char), 6*sizeof(char));
  d[6]=&#39;\0&#39;;
  printf(&quot;%s&quot;, d);
  return 0;
&#125;</code></pre>
<h3 id="8-1-2-strcpy"><a href="#8-1-2-strcpy" class="headerlink" title="8.1.2 strcpy"></a>8.1.2 strcpy</h3><p>函数原型：</p>
<pre><code class="c">char * strcpy(char * dest, const char * src)    // 实现 src 到 dest 的复制</code></pre>
<ul>
<li><p>strcpy 只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。</p>
</li>
<li><p>memcpy 提供了一般内存的复制。即 memcpy 对于需要复制的内容没有限制，因此用途更广。</p>
</li>
</ul>
<p>示例：</p>
<pre><code class="c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
&#123;
   char src[40];
   char dest[100];

   memset(dest, &#39;\0&#39;, sizeof(dest));      // 赋值为 &#39;\0&#39; 和 0 是等价的，因为字符 &#39;\0&#39; 在内存中就是 0
   strcpy(src, &quot;This is runoob.com&quot;);
   strcpy(dest, src);

   printf(&quot; 最终的目标字符串： %s\n&quot;, dest);

   return(0);
&#125;</code></pre>
<p>memset() 的作用是在一段内存块中填充某个给定的值。因为它只能填充一个值，所以该函数的初始化为原始初始化，无法将变量初始化为程序中需要的数据。用 memset 初始化完后，后面程序中再向该内存空间中存放需要的数据。</p>
<p>memset 一般使用“0”初始化内存单元，而且通常是给数组或结构体进行初始化。一般的变量如 char、int、float、double 等类型的变量直接初始化即可，没有必要用 memset。如果用 memset 的话反而显得麻烦。</p>
<h2 id="8-2- 数据持久化"><a href="#8-2- 数据持久化" class="headerlink" title="8.2 数据持久化"></a>8.2 数据持久化 </h2><p> 一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。</p>
<h3 id="8-2-1- 打开 - 创建文件"><a href="#8-2-1- 打开 - 创建文件" class="headerlink" title="8.2.1 打开 / 创建文件"></a>8.2.1 打开 / 创建文件 </h3><p> 可以使用 <strong>fopen()</strong> 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 <strong>FILE</strong> 的一个对象，类型 <strong>FILE</strong> 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p>
<pre><code class="c">FILE *fopen(const char * filename, const char * mode);</code></pre>
<p><strong>mode</strong> 支持：</p>
<ul>
<li><strong>r</strong>     打开一个已有的文本文件，允许读取文件。</li>
<li><strong>w</strong>    打开一个文本文件，以覆盖模式写入文件。如果文件不存在，则会创建一个新文件。</li>
<li><strong>a</strong>     打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。</li>
<li><strong>r+</strong>   打开一个已有文本文件，允许读写文件。</li>
<li><strong>w+</strong>  打开一个文本文件，允许读写文件。</li>
<li><strong>a+</strong>   打开一个文本文件，允许追加读写文件。如果文件不存在，则会创建一个新文件。</li>
</ul>
<p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：<strong>加 b，代表二进制。</strong></p>
<pre><code>&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;rb+&quot;, &quot;r+b&quot;, &quot;wb+&quot;, &quot;w+b&quot;, &quot;ab+&quot;, &quot;a+b&quot;</code></pre><p>示例：</p>
<pre><code class="c++">string outfile=&quot;layer_main.dat&quot;;
FILE* fp = fopen(outfile.c_str(), &quot;wb&quot;);</code></pre>
<h3 id="8-2-2- 读取文件"><a href="#8-2-2- 读取文件" class="headerlink" title="8.2.2 读取文件"></a>8.2.2 读取文件</h3><h4 id="8-2-2-1- 字符读取函数"><a href="#8-2-2-1- 字符读取函数" class="headerlink" title="8.2.2.1 字符读取函数"></a>8.2.2.1 字符读取函数</h4><ul>
<li><strong>fgetc()</strong>从指定的文件中读取一个字符：</li>
</ul>
<pre><code>int fgetc (FILE *fp);</code></pre><p>fp 为文件指针。fgetc() 读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回 EOF。EOF 是在 stdio.h 中定义的宏，它的值是一个负数。</p>
<ul>
<li><strong>fputc()</strong>向指定的文件中写入一个字符:</li>
</ul>
<pre><code class="c++">int fputc (int ch, FILE *fp);</code></pre>
<p>ch 为要写入的字符，fp 为文件指针。fputc() 写入成功时返回写入的字符，失败时返回 EOF。</p>
<h4 id="8-2-2-2- 字符串读取函数"><a href="#8-2-2-2- 字符串读取函数" class="headerlink" title="8.2.2.2 字符串读取函数"></a>8.2.2.2 字符串读取函数</h4><ul>
<li><strong>fgets()</strong> 函数用来从指定的文件中读取一个字符串，并保存到字符数组中。</li>
</ul>
<pre><code class="c++">char *fgets (char *str, int n, FILE *fp);</code></pre>
<p>str 为字符数组，n 为要读取的字符数目，fp 为文件指针。</p>
<ul>
<li>fputs() 函数用来向指定的文件写入一个字符串，它的用法为：</li>
</ul>
<pre><code class="c++">int fputs(char *str, FILE *fp);</code></pre>
<p>str 为要写入的字符串，fp 为文件指针。写入成功返回非负数，失败返回 EOF。</p>
<p><strong>fgets() 有局限性，每次最多只能从文件中读取一行内容，因为 fgets() 遇到换行符就结束读取。如果希望读取多行内容，需要使用 fread() 函数；相应地写入函数为 fwrite()。</strong></p>
<h4 id="8-2-2-3- 块数据读取函数"><a href="#8-2-2-3- 块数据读取函数" class="headerlink" title="8.2.2.3 块数据读取函数"></a>8.2.2.3 块数据读取函数</h4><ul>
<li>fread() 函数用来从指定文件中读取块数据。所谓块数据，也就是若干个字节的数据，可以是一个字符，可以是一个字符串，可以是多行数据，并没有什么限制。fread() 的原型为：</li>
</ul>
<pre><code class="c++">size_t fread (void *ptr, size_t size, size_t count, FILE *fp);</code></pre>
<ul>
<li>fwrite() 函数用来向文件中写入块数据，它的原型为：</li>
</ul>
<pre><code class="c++">size_t fwrite (void * ptr, size_t size, size_t count, FILE *fp);</code></pre>
<p>ptr 为内存区块的指针，它可以是数组、变量、结构体等。fread() 中的 ptr 用来存放读取到的数据，fwrite() 中的 ptr 用来存放要写入的数据。</p>
<p>size：表示每个数据块的字节数。</p>
<p>count：表示要读写的数据块的块数。</p>
<p>fp：表示文件指针。</p>
<p>理论上，每次读写 size*count 个字节的数据。</p>
<p>返回值：返回成功读写的块数，也即 count。如果返回值小于 count：</p>
<ul>
<li><p>对于 fwrite() 来说，肯定发生了写入错误，可以用 ferror() 函数检测。</p>
</li>
<li><p>对于 fread() 来说，可能读到了文件末尾，可能发生了错误，都会返回 EOF。可以用 ferror() 或 feof() 检测到底是错误还是读到了文件结尾。</p>
<p><strong>feof()</strong>：<code>int feof(FILE *stream)</code>，检查文件的结束标志（是否读到了文件结尾处），没有返回 0，检查到了结束标志就返回非 0。</p>
</li>
</ul>
<p><strong>ferror()</strong>：<code>int ferror(FILE *stream)</code>，检测文件读取操作是否出错，当 ferror 函数返回为真时就表示有错误发生。在实际的程序中，应该每执行一次文件操作，就用 ferror 函数检测是否出错。</p>
<h3 id="8-2-3- 关闭文件"><a href="#8-2-3- 关闭文件" class="headerlink" title="8.2.3 关闭文件"></a>8.2.3 关闭文件 </h3><p> 使用 fclose() 函数。函数的原型如下：</p>
<pre><code> int fclose(FILE *fp);</code></pre><p>如果成功关闭文件，<strong>fclose()</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。</p>
<h1 id="9、隐式转化和显示转换"><a href="#9、隐式转化和显示转换" class="headerlink" title="9、隐式转化和显示转换"></a>9、隐式转化和显示转换 </h1><p> 在 CPP 中，编译器会自动帮我们进行隐式转换。下面举例说明：</p>
<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class Point &#123;
public:
    int x, y;
    Point(int x = 0, int y = 0): x(x), y(y) &#123;&#125;
&#125;;

void displayPoint(const Point&amp; p) 
&#123;
    cout &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; 
         &lt;&lt; p.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;
&#125;

int main()
&#123;
    displayPoint(1);   // 输出（1,0）
    Point p = 1;
&#125;</code></pre>
<p>在第 18 行中，函数 displayPoint 应该传入一个 poin 类型的数据，但是这里传入了一个 int 类型数据，程序不会报错，而是正常运行完毕。这是因为这隐式调用。</p>
<p>另外, 在第 19 行中，在对象刚刚定义时, 即使你使用的是赋值操作符 <code>=</code>, 也是会调用构造函数, 而不是重载的<code>operator=</code> 运算符。</p>
<p>这样悄悄发生的事情， 有时可以带来便利。而有时却会带来意想不到的后果， <code>explicit</code>关键字用来避免这样的情况发生。</p>
<h2 id="explicit 关键字"><a href="#explicit 关键字" class="headerlink" title="explicit 关键字"></a><strong>explicit 关键字</strong></h2><p>CPP 官方参考手册解释如下：</p>
<ol>
<li>指定构造函数或转换函数 (C++11 起)为显式， 即它不能用于隐式转换和复制初始化。</li>
<li>explicit 指定符可以与常量表达式一同使用。函数若且唯若该常量表达式求值为 true 才为显式。(C++20 起)</li>
</ol>
<p>什么情况下使用 explicit：能用就用。</p>
<p>如果我们能预料到某种情况的发生, 就不要把隐式转换的控制权交给编译器。</p>
<h1 id="GDB 调试工具"><a href="#GDB 调试工具" class="headerlink" title="GDB 调试工具"></a>GDB 调试工具 </h1><p> 这里介绍 <strong>linux</strong> 下的 C++ 调试工具 GDB。</p>
<h2 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述</h2><p>GDB 全称“GNU symbolic debugger“，是 <strong>Linux</strong> 下常用的程序调试器。当下的 GDB 支持调试多种编程语言编写的程序，包括 C、C++、Go、Objective-C、OpenCL、Ada 等。实际场景中，GDB 更常用来调试 C 和 C++ 程序。一般来说，GDB 主要帮助我们完成以下四个方面的功能：</p>
<ol>
<li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li>
<li>在某个指定的地方或条件下暂停程序。</li>
<li>当程序被停住时，可以检查此时你的程序中所发生的事。</li>
<li>在程序执行过程中修改程序中的变量或条件，将一个 bug 产生的影响修正从而测试其他 bug。</li>
</ol>
<h2 id="调试之前"><a href="# 调试之前" class="headerlink" title="调试之前"></a>调试之前 </h2><p> 在启动调试之前，需要先将源码编译。编译有两种工具：GCC 和 G++。</p>
<ul>
<li><p>默认情况下，用 gcc 只能编译 c 代码，g++ 编译 c++ 代码</p>
<pre><code class="shell"># 生成可执行文件 a.out
gcc test.c     
g++ test.cpp   </code></pre>
</li>
<li><p>gcc 命令不能自动和 C＋+ 程序使用的库链接接，需要这样写：</p>
<pre><code class="shell">gcc test.cpp -lstdc++   #这样和 g++ test.cpp 结果是一样的</code></pre>
</li>
</ul>
<p>执行 a.out：<code>./a.out</code></p>
<p><strong>下面正式介绍 GDB：</strong></p>
<p>使用 GDB 调试程序，有以下两点需要注意：</p>
<ol>
<li><p>要使用 GDB 调试某个程序，该程序编译时必须加上编译选项 <strong><code>-g</code></strong>，否则该程序是不包含调试信息的；</p>
<pre><code class="shell">g++ -g test.cpp            # 编译生成 a.out 可执行文件
g++ -g test.cpp -o test1   # 编译生成 test1 可执行文件</code></pre>
<blockquote>
<p>如果没有<strong><code>-g</code></strong>，你将看不见程序的函数名，变量名，所代替的全是运行时的内存地址。</p>
</blockquote>
</li>
<li><p>GCC 编译器支持 <strong><code>-O</code></strong> 和 <strong><code>-g</code></strong> 一起参与编译。GCC 编译过程对进行优化的程度可分为 5 个等级，具体可自行百度 ：</p>
</li>
</ol>
<h2 id="启用 GDB 调试"><a href="# 启用 GDB 调试" class="headerlink" title="启用 GDB 调试"></a>启用 GDB 调试 </h2><p> 在 C++ 源码编译后，可以对编译后的可执行文件启用 GDB 调试。</p>
<p>GDB 调试主要有三种方式：</p>
<ol>
<li>直接调试目标程序：gdb a.out</li>
<li>附加进程 id：gdb attach pid</li>
<li>调试 core 文件：gdb filename corename</li>
</ol>
<p><strong>启动调试：</strong></p>
<pre><code>&gt;&gt;&gt; gdb a.out
#输出如下代表成功：
...
Reading symbols from ./practice_p1/a.out...done.
(gdb)</code></pre><p>这样就进入调试模式：如果在第 6 行继续输入 r，会全部运行完毕。我们应该添加断点。</p>
<p><strong>添加断点：</strong></p>
<pre><code class="shell">&gt;&gt;&gt; (gdb) b 14                                     #在第 14 行添加断点
Breakpoint 1 at 0x40086f: file p1.cpp, line 14.

&gt;&gt;&gt; (gdb) b 17
Breakpoint 2 at 0x40088d: file p1.cpp, line 17.

&gt;&gt;&gt; (gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000040086f in main() at p1.cpp:14
2       breakpoint     keep y   0x000000000040088d in main() at p1.cpp:17</code></pre>
<p><strong>开始调试：</strong></p>
<pre><code class="shell">&gt;&gt;&gt; (gdb) r                                  #开始执行
Starting program: ./practice_p1/a.out
10

Breakpoint 1, main () at p1.cpp:14
14          cout&lt;&lt;b&lt;&lt;endl;

&gt;&gt;&gt; (gdb) c                                  # 继续执行
Continuing.
20

Breakpoint 2, main () at p1.cpp:17
17             cout&lt;&lt;i&lt;&lt;endl;

#当程序执行完毕，会显示：[Inferior 1 (process 389700) exited normally]</code></pre>
<h2 id="退出 GDB"><a href="# 退出 GDB" class="headerlink" title="退出 GDB"></a>退出 GDB</h2><ul>
<li>可以用命令：<strong>q（quit 的缩写）或者 Ctr + d</strong> 退出 GDB。</li>
<li>如果 GDB attach 某个进程，退出 GDB 之前要用命令 <strong>detach</strong> 解除附加进程。</li>
</ul>
<h2 id="常用命令"><a href="# 常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>命令名称</th>
<th>命令缩写</th>
<th>命令说明</th>
</tr>
</thead>
<tbody><tr>
<td>run</td>
<td>r</td>
<td>运行一个待调试的程序</td>
</tr>
<tr>
<td>continue</td>
<td>c</td>
<td>让暂停的程序继续运行到下一个断点处</td>
</tr>
<tr>
<td>next</td>
<td>n</td>
<td>运行到下一行，单步调试（遇到函数不进入内部）</td>
</tr>
<tr>
<td>step</td>
<td>s</td>
<td>运行到下一行，单步执行（遇到函数会进入）</td>
</tr>
<tr>
<td>finish</td>
<td>finish</td>
<td>跳出当前函数，常与 s 配合使用</td>
</tr>
<tr>
<td>return</td>
<td>return</td>
<td>跳出当前函数，并返回指定值，到上一层函数调用处</td>
</tr>
<tr>
<td>until</td>
<td>u</td>
<td>退出循环体（自动一次性执行完剩余的循环）</td>
</tr>
<tr>
<td>jump</td>
<td>j</td>
<td>将当前程序执行流跳转到指定行或地址</td>
</tr>
<tr>
<td>print</td>
<td>p</td>
<td>打印变量或寄存器值，执行完毕到下一行才能 p 前一行的变量值</td>
</tr>
<tr>
<td>backtrace</td>
<td>bt</td>
<td>查看当前线程的调用堆栈</td>
</tr>
<tr>
<td>frame</td>
<td>f</td>
<td>切换到当前调用线程的指定堆栈</td>
</tr>
<tr>
<td>thread</td>
<td>thread</td>
<td>切换到指定线程</td>
</tr>
<tr>
<td>break</td>
<td>b</td>
<td>添加断点</td>
</tr>
<tr>
<td>tbreak</td>
<td>tb</td>
<td>添加临时断点</td>
</tr>
<tr>
<td>delete</td>
<td>d</td>
<td>删除断点</td>
</tr>
<tr>
<td>enable</td>
<td>enable</td>
<td>启用某个断点</td>
</tr>
<tr>
<td>disable</td>
<td>disable</td>
<td>禁用某个断点</td>
</tr>
<tr>
<td>watch</td>
<td>watch</td>
<td>监视某一个变量或内存地址的值是否发生变化</td>
</tr>
<tr>
<td>list</td>
<td>l</td>
<td>显示源码，默认 10 行</td>
</tr>
<tr>
<td>info</td>
<td>i</td>
<td>查看断点 / 线程等信息</td>
</tr>
<tr>
<td>ptype</td>
<td>ptype</td>
<td>查看变量类型</td>
</tr>
<tr>
<td>disassemble</td>
<td>dis</td>
<td>查看汇编代码</td>
</tr>
<tr>
<td>set args</td>
<td>set args</td>
<td>设置程序启动命令行参数</td>
</tr>
<tr>
<td>show args</td>
<td>show args</td>
<td>查看设置的命令行参数</td>
</tr>
<tr>
<td>wh</td>
<td>wh</td>
<td>打开监视窗口，窗口上半部分为代码区，下半部分为调试区，退出为 ctrl+x+a</td>
</tr>
</tbody></table>
<p><strong>下面做一些详细的介绍：</strong></p>
<h3 id="显示源代码"><a href="# 显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h3><ul>
<li><p><strong>list</strong>    打印源码，默认 10 行</p>
</li>
<li><p><strong>list line_num</strong>   打印指定行的代码以及前 5 行，后 4 行</p>
</li>
<li><p><strong>list func</strong>       #打印函数名为 func 的函数</p>
</li>
<li><p><strong>show listsize</strong>，查看 <strong>list</strong> 命令显示的代码行数；</p>
</li>
<li><p><strong>set listsize count</strong>，设置 <strong>list</strong> 命令显示的代码行数为 <strong>count</strong>;</p>
</li>
</ul>
<h3 id="设置断点"><a href="# 设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p> break 命令（简写为 b）用于添加断点，可以使用以下几种方式添加断点：</p>
<ul>
<li><strong>break LineNo</strong>，在 <strong> 当前文件 </strong> 行号为 <strong>LineNo</strong> 处添加断点；</li>
<li><strong>break FunctionName</strong>，在函数的入口处添加一个断点；</li>
<li><strong>info break</strong>，显示所有断点。</li>
<li><strong>disable 断点编号</strong>，禁用某个断点，使得断点不会被触发；</li>
<li><strong>enable 断点编号</strong>，启用某个被禁用的断点；</li>
<li><strong>delete 断点编号</strong>，删除某个断点。</li>
<li><strong>clear 行号</strong>，删除该行的断点</li>
<li><strong>break FileName:LineNo</strong>，在 <strong>FileName</strong> 文件行号为 <strong>LineNo</strong> 处添加一个断点；</li>
<li><strong>break FileName:FunctionName</strong>，在 <strong>FileName</strong> 文件的 <strong>FunctionName</strong> 函数的入口处添加断点；</li>
<li><strong>break -/+offset</strong>，在当前程序暂停位置的前 / 后 offset 行处下断点；</li>
<li><strong>break … if cond</strong>，设置条件断点；</li>
</ul>
<p>Tips：</p>
<blockquote>
<p>如果有时发现用函数名打不上，记得加作用域（类名或命名空间）。</p>
</blockquote>
<h3 id="条件断点"><a href="# 条件断点" class="headerlink" title="条件断点"></a>条件断点 </h3><p> 当我们进入一个循环时，需要分析第 50 次循环时，不可能手动循环 50 次去查看，这时候就需要使用【条件断点】</p>
<pre><code class="linux">(gdb) b test.cc:120 if i==50</code></pre>
<p>注意断点的位置，要有 <code>i</code> 这个值。</p>
<p>另外，gdb 也支持修改断点的条件：<code>condition 断点编号 条件表达式</code></p>
<pre><code>(gdb) condition 1 i==100 &amp;&amp; j==20</code></pre><p>修改断点的条件时，只能向后修改，不能返回。修改完后，按 <code>c</code> 执行到指定条件的断点。</p>
<p><code>(gdb) condition &lt; 断点编号 &gt;</code>：删除该断点的条件。</p>
<h3 id="断点与打印"><a href="# 断点与打印" class="headerlink" title="断点与打印"></a>断点与打印 </h3><p> 每次断点发生时候，想要查看的变量很多时，如果每个变量都手动 print 需要浪费很多时间。断点命令可以在断点发生时批量执行 GDB 命令。下面是断点命令的设置方式：</p>
<ul>
<li><code>(gdb) commands 断点编号</code></li>
<li><code>(gdb) &gt;print x</code></li>
<li><code>(gdb) &gt;print y</code></li>
<li><code>(gdb) &gt;end</code><br>首先输入 GDB 命令 commands &lt; 断点编号 &gt; 然后回车，这时候会出现 &gt; 提示符。出现 &gt; 提示符后可以输入断点发生时需要执行的 GDB 命令，每行一条，全部输入完成后输入 end 结束断点命令。</li>
</ul>
<h3 id="设置变量值"><a href="# 设置变量值" class="headerlink" title="设置变量值"></a>设置变量值 </h3><p> 对变量的值进行控制，可以更快的调试自己的程序。下面就是设置变量值的方法：</p>
<ul>
<li><code>(gdb) set variable &lt; 变量 &gt; = &lt; 表达式 &gt;</code>：将变量的值设定为指定表达式的值。例如 <code>set variable x=10</code></li>
</ul>
<h3 id="查看堆栈"><a href="# 查看堆栈" class="headerlink" title="查看堆栈"></a>查看堆栈</h3><p> 命令格式及作用：</p>
<ul>
<li><strong>backtrace</strong>，也可简写为 <strong>bt</strong>，用于查看当前调用堆栈。</li>
<li><strong>frame 堆栈编号</strong>，也可简写为 <strong>f 堆栈编号</strong>，用于切换到其他堆栈处。</li>
</ul>
<h3 id="查看结果"><a href="# 查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p> 命令格式及作用：</p>
<ul>
<li><strong>print param</strong>，用于在调试过程中查看变量的值；<strong>注意执行完毕到下一行才能 p 前一行的变量值</strong></li>
<li><strong>print param=value</strong>，用于在调试过程中修改变量的值；</li>
<li><strong>print a+b+c</strong>，可以进行一定的表达式计算，这里是计算 a、b、c 三个变量之和；</li>
<li><strong>print func()</strong>，输出 <code>func</code> 函数执行的结果，常见的用途是打印系统函数执行失败原因：<code>print strerror(errno)</code>；</li>
<li><strong>print *this</strong>，在 c++ 对象中，可以输出当前对象的各成员变量的值；</li>
<li><strong>set print elements 0</strong>，使得打印字符数不受限制。默认为 200 个字符。<ul>
<li><strong>show print elements</strong>，显示当前打印字符的限制数。</li>
</ul>
</li>
<li><strong>set print pretty on</strong>，格式化显示结构体。</li>
</ul>
<h3 id="查看变量类型"><a href="# 查看变量类型" class="headerlink" title="查看变量类型"></a>查看变量类型</h3><p> 命令格式及功能：</p>
<ul>
<li><strong>whatis val</strong>，用于查看变量类型；</li>
<li><strong>ptype val</strong>，作用和 <strong>whatis</strong> 类似，但功能更强大，可以查看复合数据类型，会打印出该类型的成员变量。</li>
</ul>
<h3 id="查看线程"><a href="# 查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p> 命令格式及作用：</p>
<ul>
<li><strong>info thread</strong>，查看当前进程的所有线程运行情况；</li>
<li><strong>thread 线程编号</strong>，切换到具体编号的线程上去；</li>
</ul>
<h3 id="单步执行"><a href="# 单步执行" class="headerlink" title="单步执行"></a>单步执行</h3><p> <strong>next</strong> 和 <strong>step</strong> 都是单步执行，但也有差别：</p>
<ul>
<li><strong>next</strong> 是 <strong>单步步过（step over）</strong>，其最大的特点是当遇到包含调用函数的语句时，无论函数内部包含多少行代码，<code>next</code> 指令都会一步执行完。也就是说，对于调用的函数来说，<code>next</code> 命令只会将其视作一行代码。</li>
<li><strong>step</strong> 是 <strong>单步步入（step into）</strong>，当<code>step</code> 命令所执行的代码行中包含函数时，会进入该函数内部，并在函数第一行代码处停止执行。</li>
</ul>
<h3 id="退出局部函数"><a href="# 退出局部函数" class="headerlink" title="退出局部函数"></a>退出局部函数</h3><p> <strong>return</strong> 和 <strong>finish</strong> 都是退出函数，但也有差别：</p>
<ul>
<li><strong>return</strong> 命令是立即退出当前函数，剩下的代码不会执行了，<strong>return</strong> 还可以指定函数的返回值。</li>
<li><strong>finish</strong> 命令是会继续执行完该函数剩余代码再正常退出。</li>
</ul>
<h3 id="跳转"><a href="# 跳转" class="headerlink" title="跳转"></a>跳转</h3><p> 命令格式及作用：</p>
<ul>
<li><p><strong>jump LineNo</strong>，跳转到代码的 <strong>LineNo</strong> 行的位置；</p>
</li>
<li><p><strong>jump +10</strong>，跳转到距离当前代码下 10 行的位置；</p>
</li>
<li><p><strong>jump *0x12345678</strong>，跳转到 <strong>0x12345678</strong> 地址的代码处，地址前要加星号；</p>
<p><strong>jump</strong> 命令有两点需要注意的：</p>
</li>
</ul>
<ol>
<li>中间跳过的代码是不会执行的；</li>
<li>跳到的位置后如果没有断点，那么 GDB 会自动继续往后执行；</li>
</ol>
<h3 id="参数传递"><a href="# 参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p> 很多程序启动需要我们传递参数，<strong>set args</strong> 就是用来设置程序启动参数的，<strong>show args</strong> 命令用来查询通过 <strong>set args</strong> 设置的参数，命令格式：</p>
<ul>
<li><strong>set args args1</strong>，设置单个启动参数 <strong>args1</strong>；</li>
<li><strong>set args “-p” “password”</strong>，如果单个参数之间有空格，可以使用引号将参数包裹起来；</li>
<li><strong>set args args1 args2 args3</strong>，设置多个启动参数，参数之间用空格隔开；</li>
<li><strong>set args</strong>，不带参数，则清除之前设置的参数；</li>
</ul>
<h3 id="临时断点"><a href="# 临时断点" class="headerlink" title="临时断点"></a>临时断点</h3><p>tbreak:  该命令时添加一个临时断点，断点一旦被触发就自动删除，使用方法同 <strong>break</strong>。</p>
<h3 id="监视"><a href="# 监视" class="headerlink" title="监视"></a>监视</h3><p> <strong>watch</strong> 命令用来监视一个变量或者一段内存，当这个变量或者内存的值发生变化时，GDB 就会中断下来。被监视的某个变量或内存地址会产生一个 <strong>watch point（观察点）</strong>。</p>
<p> 命令格式：</p>
<ul>
<li><strong>watch 整型变量</strong>；</li>
<li><strong>watch 指针变量</strong>，监视的是指针变量本身；</li>
<li><strong>watch * 指针变量</strong>，监视的是指针所指的内容；</li>
<li><strong>watch 数组变量或内存区间</strong>；</li>
</ul>
<h3 id="回退"><a href="# 回退" class="headerlink" title="回退"></a>回退</h3><blockquote>
<p>GDB7.0 以上版本的调试器才支持。</p>
</blockquote>
<p>能够回退的代码行，必须事先 <strong>record</strong> 才行。注意：启动 record 会导致程序运行变慢。</p>
<pre><code class="shell">&gt;&gt;&gt; gdb a.out
&gt;&gt;&gt; (gdb) b 14
&gt;&gt;&gt; (gdb) c
&gt;&gt;&gt; (gdb) record    #启动进程记录回放
&gt;&gt;&gt; (gdb) n
&gt;&gt;&gt; (gdb) n
&gt;&gt;&gt; (gdb) n
&gt;&gt;&gt; (gdb) reverse-next   #向上回退一行</code></pre>
<p><strong>reverse-continue</strong>: 反向运行程序到 record 的位置，或者观察点</p>
<p><strong>reverse-step</strong>：反向运行程序到 上一行（如有函数会进入）</p>
<p><strong>reverse-next</strong>：反向运行程序到 上一行（不会进入函数）</p>
<p><strong>reverse-finish</strong>：反向运行程序回到调用当前函数的地方。</p>
<p><strong>reverse-stepi</strong>：反向运行程序到上一条机器指令</p>
<p><strong>reverse-nexti</strong>：反向运行到上一条机器指令，除非这条指令用来返回一个函数调用、否则整个函数将会被反向执行。</p>
<h3 id="帮助"><a href="# 帮助" class="headerlink" title="帮助"></a>帮助</h3><p> 通过 <strong>help</strong> 命令可以查看目标命令的具体用法。</p>
<h2 id="GDB 多线程调试"><a href="#GDB 多线程调试" class="headerlink" title="GDB 多线程调试"></a>GDB 多线程调试 </h2><h3 id="概述 -1"><a href="# 概述 -1" class="headerlink" title="概述"></a> 概述</h3><p> 多线程程序的编写更容易产生异常或 Bug（例如线程之间因竞争同一资源发生了死锁、多个线程同时对同一资源进行读和写等等）。GDB 调试器不仅仅支持调试单线程程序，还支持调试多线程程序。本质上讲，使用 GDB 调试多线程程序的过程和调试单线程程序类似，不同之处在于，调试多线程程序需要监控多个线程的执行过程。</p>
<p> 用 GDB 调试多线程程序时，该程序的编译需要添加 <strong><code>-lpthread</code></strong> 参数。</p>
<h3 id="一些命令"><a href="# 一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><ol>
<li><strong>info thread</strong>，查看当前调试程序启动了多少个线程，并打印出各个线程信息；</li>
<li><strong>thread 线程编号</strong>，将该编号的线程切换为当前线程；</li>
<li><strong>thread apply 线程编号 1 线程编号 2 … command</strong>，将 GDB 命令作用指定对应编号的线程，可以指定多个线程，若要指定所有线程，用 <strong>all</strong> 替换线程编号；</li>
<li><strong>break location thread 线程编号</strong>，在 <strong>location</strong> 位置设置普通断点，该断点只作用在特定编号的线程上；</li>
</ol>
<h3 id="一些术语"><a href="# 一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ul>
<li><p><strong>all-stop mode</strong>，全停模式，当程序由于任何原因在 GDB 下停止时，不止当前的线程停止，所有的执行线程都停止。这样允许你检查程序的整体状态，包括线程切换，不用担心当下会有什么改变。</p>
</li>
<li><p><strong>non-stop mode</strong>，不停模式，调试器（如 VS2008 和老版本的 GDB）往往只支持 <strong>all-stop</strong> 模式，但在某些场景中，我们可能需要调试个别的线程，并且不想在调试过程中影响其他线程的运行，这样可以把 GDB 的调式模式由 <strong>all-stop</strong> 改成 <strong>non-stop</strong>，<strong>7.0</strong> 版本的 GDB 引入了 <strong>non-stop</strong> 模式。在 <strong>non-stop</strong> 模式下 <strong>continue、next、step</strong> 命令只针对当前线程。</p>
</li>
<li><p><strong>record mode</strong>，记录模式；</p>
</li>
<li><p><strong>replay mode</strong>，回放模式；</p>
</li>
<li><p><strong>scheduler-locking</strong> ，调度锁；</p>
</li>
<li><p><strong>schedule-multiple</strong>，多进程调度；</p>
</li>
</ul>
<h3 id="设置线程锁"><a href="# 设置线程锁" class="headerlink" title="设置线程锁"></a>设置线程锁 </h3><p> 使用 GDB 调试多线程程序时，默认的调试模式是：<strong> 一个线程暂停运行，其他线程也随即暂停；一个线程启动运行，其他线程也随即启动 </strong>。但在一些场景中，我们希望只让特定线程运行，其他线程都维持在暂停状态，即要防止<strong> 线程切换</strong>，要达到这种效果，需要借助 <strong>set scheduler-locking</strong> 命令。</p>
<p> 命令格式及作用：</p>
<ul>
<li><strong>set scheduler-locking on</strong>，锁定线程，只有当前或指定线程可以运行；</li>
<li><strong>set scheduler-locking off</strong>，不锁定线程，会有线程切换；</li>
<li><strong>set scheduler-locking step</strong>，当单步执行某一线程时，其他线程不会执行，同时保证在调试过程中当前线程不会发生改变。但如果在该模式下执行 <strong>continue、until、finish</strong> 命令，则其他线程也会执行；</li>
<li><strong>show scheduler-locking</strong>，查看线程锁定状态；</li>
</ul>
<h2 id="调试 core 文件"><a href="# 调试 core 文件" class="headerlink" title="调试 core 文件"></a>调试 core 文件 </h2><p> 当程序运行过程中出现 Segmentation fault (core dumped)错误时，程序停止运行，并产生 core 文件。</p>
<p>core 文件是程序运行状态的内存映象。</p>
<p>使用 gdb 调试 core 文件，可以帮助我们快速定位程序出现段错误的位置。</p>
<p>该错误产生的主要原因有：(1)访问不存在的内存地址；(2)访问系统保护的内存地址；(3)数组访问越界等。</p>
<p><strong>控制 core 文件是否生成</strong></p>
<ol>
<li>使用 ulimit -c 命令可查看 core 文件的生成开关。若结果为 0，则表示关闭了此功能，不会生成 core 文件。</li>
<li>使用 ulimit -c unlimited，则表示生成 core 文件的大小不受限制。ulimit -c filesize 命令，可以限制 core 文件的大小（filesize 的单位为 KB）</li>
</ol>
<p><strong>调试 core</strong></p>
<p>方法 1：</p>
<ol>
<li>进入 gdb 模式：gdb binary , 我们一般是定义好了 debug.sh, 直接运行 sh debug.sh </li>
<li>输入：core-file core.xxxx</li>
<li>输入 bt</li>
</ol>
<p>类似的可以这样做：</p>
<ol>
<li>gdb binary core_XXXX</li>
<li>bt</li>
</ol>
<h2 id="参考文档"><a href="# 参考文档" class="headerlink" title="参考文档"></a>参考文档 </h2><p><a target="_blank" rel="noopener" href="https://link.zhihu.com/?dest=http%3A//www.gnu.org/software/gdb/documentation/"> 官方参考文档</a></p>
<p><a target="_blank" rel="noopener" href="https://link.zhihu.com/?dest=https%3A//blog.csdn.net/Roland_Sun/article/details/42460663">GDB 常用命令</a></p>
<p><a target="_blank" rel="noopener" href="https://link.zhihu.com/?dest=http%3A//c.biancheng.net/gdb/">GDB 调试教程：1 小时玩转 Linux gdb 命令</a></p>
<h1 id="编译 log 重定向"><a href="# 编译 log 重定向" class="headerlink" title="编译 log 重定向"></a>编译 log 重定向</h1><p>Linux 上有时候我们编译，屏幕上会打印超级多的 error message，使得我们很难去定位问题，这时候可以把屏幕输出的 log 重定向到指定文件里，然后进行搜索，找到问题所在：</p>
<pre><code class="shell">make -j10 &gt; ../error-message.txt 2&gt;&amp;1</code></pre>
<ul>
<li>2&gt;&amp;1 表示错误信息输出到 &amp;1 中，而 &amp;1 又代表了 error-message.txt</li>
</ul>
<p>linux 系统中默认有 3 个输出设备，分别为 stdin、stdout、sdterr，分别表示标准输入设备、标准输出设备和标准错误设备。</p>
<table>
<thead>
<tr>
<th>设备名称</th>
<th>标准叫法</th>
<th>代号</th>
</tr>
</thead>
<tbody><tr>
<td>标准输入设备</td>
<td>stdin = standard input</td>
<td>0</td>
</tr>
<tr>
<td>标准输出设备</td>
<td>stdout = standard output</td>
<td>1</td>
</tr>
<tr>
<td>标准错误设备</td>
<td>stderr = standard error</td>
<td>2</td>
</tr>
</tbody></table>
<h1 id="声明全局变量"><a href="# 声明全局变量" class="headerlink" title="声明全局变量"></a>声明全局变量 </h1><p> 很多人可能直接把全局变量写进.h 文件，然后用多个文件包含这个头文件，编译时就会报错：变量重定义…</p>
<p>正确的做法是：</p>
<p>首先在.c/cpp 文件中声明</p>
<pre><code>int g_a;</code></pre><p>然后在对应头文件里：</p>
<pre><code>extern int g_a;</code></pre><h1 id="多线程和锁 Mutex"><a href="# 多线程和锁 Mutex" class="headerlink" title="多线程和锁 Mutex"></a>多线程和锁 Mutex</h1><p>忘了系统性总结，后面再写</p>
<h1 id="Lambda 表达式"><a href="#Lambda 表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式 </h1><p> 使用 STL 时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个 <strong> 对象也只使用了一次，编写这样的函数对象类就有点浪费。</strong></p>
<p>对于只使用一次的函数对象类，直接在使用它的地方定义：Lambda 表达式能够解决这个问题。使用 Lambda 表达式可以减少程序中函数对象类的数量，使得程序更加优雅。</p>
<p>Lambda 表达式实际上是一个函数，只是它没有名字。</p>
<p>Lambda 表达式的定义形式如下：</p>
<pre><code>[捕获列表] (参数表) -&gt; 返回值类型
&#123;
   语句块
&#125;</code></pre><ul>
<li>捕获列表：可省略</li>
<li><code>-&gt; 返回值类型</code> 可省略</li>
</ul>
<p>举个例子：</p>
<pre><code class="c++">auto Add = [](int a, int b) &#123;return a+b;&#125;
std::cout&lt;&lt; Add(1,2);

std::cout&lt;&lt; [](int a, int b) &#123;return a+b;&#125;(1,2);   与上等价，可以取名，也可以不取名直接使用</code></pre>
<p>再举个例子：</p>
<pre><code class="c++">auto Cmpt = [](const db::Point &amp;p1, const db::Point &amp;p2)
&#123;
    return p1.x&lt;p2.x || (p1.x==p2.x &amp;&amp; p1.y&lt;p2.y);

&#125;
std::set&lt;db::Point, Cmpt&gt; s_points;</code></pre>
<h2 id="捕获列表"><a href="# 捕获列表" class="headerlink" title="捕获列表"></a>捕获列表 </h2><p> 作用是：提供一种访问外部变量的接口</p>
<pre><code class="c++">int a = 12;
auto Add = [a](int b, int c)-&gt;int &#123;
    return a;            // 访问了外部变量，必须将 a 通过捕获列表传进来
&#125;;
std::cout &lt;&lt; Add(1, 2) &lt;&lt; std::endl;</code></pre>
<p>上述写法，不能改变 a 的值，因为 a 是按值传递的。</p>
<pre><code>int a = 12;
auto Add = [&amp;a](int b, int c)-&gt;int &#123;             // 得按引用传递
    a=a+1;
    return a;         
&#125;;
std::cout &lt;&lt; Add(1, 2) &lt;&lt; std::endl;</code></pre><p>捕获列表使用总结：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[]</td>
<td align="left">空捕获列表，Lambda 不能使用所在函数中的变量。</td>
</tr>
<tr>
<td align="center">[names]</td>
<td align="left">names 是一个逗号分隔的名字列表，这些名字都是 Lambda 所在函数的局部变量。默认情况下，这些变量会被拷贝，然后按值传递，名字前面如果使用了 &amp;，则按引用传递</td>
</tr>
<tr>
<td align="center">[&amp;]</td>
<td align="left">隐式捕获列表，Lambda 体内使用的局部变量都按引用方式传递</td>
</tr>
<tr>
<td align="center">[=]</td>
<td align="left">隐式捕获列表，Lanbda 体内使用的局部变量都按值传递</td>
</tr>
<tr>
<td align="center">[&amp;,identifier_list]</td>
<td align="left">identifier_list 是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量，这些变量采用值捕获的方式，其他变量则被隐式捕获，采用引用方式传递，identifier_list 中的名字前面不能使用 &amp;。</td>
</tr>
<tr>
<td align="center">[=,identifier_list]</td>
<td align="left">identifier_list 中的变量采用引用方式捕获，而被隐式捕获的变量都采用按值传递的方式捕获。identifier_list 中的名字不能包含 this，且这些名字面前必须使用 &amp;。</td>
</tr>
</tbody></table>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎各位看官及技术大佬前来交流指导呀，可以邮件至 jqiange@yeah.net </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2020-2025 Jqiange
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
