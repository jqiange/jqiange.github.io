<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>python 中的进程，线程与协程 | jqiange</title>
  <meta name="keywords" content="">
  <meta name="description" content="python 中的进程，线程与协程 | jqiange">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="世人笑我太疯癫，我笑世人看不穿。">
<meta property="og:type" content="website">
<meta property="og:title" content="人畜无害的姜小强">
<meta property="og:url" content="https://jqiange.github.io/about/index.html">
<meta property="og:site_name" content="jqiange">
<meta property="og:description" content="世人笑我太疯癫，我笑世人看不穿。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image--1.oss-cn-shenzhen.aliyuncs.com/zhou.gif">
<meta property="article:published_time" content="2020-02-18T08:21:04.000Z">
<meta property="article:modified_time" content="2025-12-13T05:23:10.695Z">
<meta property="article:author" content="姜小强">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image--1.oss-cn-shenzhen.aliyuncs.com/zhou.gif">


<link rel="icon" href="/img/jqiange.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

</head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/jqiange.png"/>
</a>
<div class="author">
    <span>姜小强</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/jqiange"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(59)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="工具">
                        
                        工具
                        <small>(8)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据库">
                        
                        数据库
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="脚本语言">
                        
                        脚本语言
                        <small>(17)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="每日一学">
                        
                        每日一学
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="爬虫">
                        
                        爬虫
                        <small>(11)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="其他">
                        
                        其他
                        <small>(4)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据分析">
                        
                        数据分析
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="chip">
                        
                        chip
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="CPP">
                        
                        CPP
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="59">
<input type="hidden" id="yelog_site_word_count" value="264.8k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CSS-Xpath</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Markdown</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Matplotlib</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mysql</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Numpy</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Pandas</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pip</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Pyecharts</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pygal</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pymysql-ORM</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>RE</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Scrapy</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Seaborn</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Selenium</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>yield</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 脚本语言 "
           href="/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"
           data-tag="RE"
           data-author="" >
            <span class="post-title" title="正则表达式详解">正则表达式详解</span>
            <span class="post-date" title="2020-02-26 09:25:46">2020/02/26</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/python%E6%89%A7%E8%A1%8C%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 执行外部命令">python 执行外部命令</span>
            <span class="post-date" title="2026-01-15 10:07:31">2026/01/15</span>
        </a>
        
        <a  class="全部文章 chip "
           href="/tcl%E4%B8%8Eopc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tcl 与 opc">tcl 与 opc</span>
            <span class="post-date" title="2025-09-24 13:36:07">2025/09/24</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/hexo%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="hexo 文章加密方法">hexo 文章加密方法</span>
            <span class="post-date" title="2025-09-21 22:33:03">2025/09/21</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/tcl%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tcl 语言入门">tcl 语言入门</span>
            <span class="post-date" title="2025-09-14 22:43:20">2025/09/14</span>
        </a>
        
        <a  class="全部文章 每日一学 "
           href="/%E6%95%85%E4%BA%8B%E4%BC%9A%E4%B8%8E%E4%BC%81%E4%B8%9A%E8%82%A1%E6%9D%83%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="故事会与企业股权架构设计">故事会与企业股权架构设计</span>
            <span class="post-date" title="2025-08-30 09:42:43">2025/08/30</span>
        </a>
        
        <a  class="全部文章 chip "
           href="/%E8%AE%A1%E7%AE%97%E5%85%89%E5%88%BBOPC%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算光刻 OPC 名词解释">计算光刻 OPC 名词解释</span>
            <span class="post-date" title="2025-08-26 21:44:36">2025/08/26</span>
        </a>
        
        <a  class="全部文章 chip "
           href="/%E8%8A%AF%E7%89%87%E5%88%B6%E9%80%A0%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%B7%A5%E8%89%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="芯片制造流程与工艺">芯片制造流程与工艺</span>
            <span class="post-date" title="2025-06-14 12:13:17">2025/06/14</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/C-%E5%85%A5%E8%81%8C%E5%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++ 入职场">C++ 入职场</span>
            <span class="post-date" title="2024-06-22 15:52:55">2024/06/22</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/Protocol-Buffers-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Protocol Buffers 入门使用">Protocol Buffers 入门使用</span>
            <span class="post-date" title="2024-06-22 15:50:39">2024/06/22</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/C-python%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B-boost/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++python 混合编程 -boost">C++python 混合编程 -boost</span>
            <span class="post-date" title="2024-06-22 15:36:18">2024/06/22</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/C-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%A8%A1%E6%9D%BF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++ 泛型编程与模板">C++ 泛型编程与模板</span>
            <span class="post-date" title="2024-06-22 15:27:49">2024/06/22</span>
        </a>
        
        <a  class="全部文章 CPP "
           href="/C-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++ 入门学习笔记">C++ 入门学习笔记</span>
            <span class="post-date" title="2024-06-22 14:53:46">2024/06/22</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/shell%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="shell 编程">shell 编程</span>
            <span class="post-date" title="2022-03-07 20:24:24">2022/03/07</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Git 版本控制工具">Git 版本控制工具</span>
            <span class="post-date" title="2022-03-05 23:23:45">2022/03/05</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%9A%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hexo 博客迁移与多平台使用">Hexo 博客迁移与多平台使用</span>
            <span class="post-date" title="2022-03-05 01:26:56">2022/03/05</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/python%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E9%87%8D%E9%9A%BE%E7%82%B9%E6%B1%87%E6%80%BB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 中的基础知识与重难点汇总">python 中的基础知识与重难点汇总</span>
            <span class="post-date" title="2020-11-17 23:05:15">2020/11/17</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/javascript%E5%85%A5%E9%97%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JavaScript 入门">JavaScript 入门</span>
            <span class="post-date" title="2020-11-09 20:46:08">2020/11/09</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/python%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 中的语法糖">python 中的语法糖</span>
            <span class="post-date" title="2020-11-06 10:53:29">2020/11/06</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 中的进程，线程与协程">python 中的进程，线程与协程</span>
            <span class="post-date" title="2020-11-04 21:29:16">2020/11/04</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="linux 常见命令学习">linux 常见命令学习</span>
            <span class="post-date" title="2020-06-17 22:33:28">2020/06/17</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机器学习经典算法">机器学习经典算法</span>
            <span class="post-date" title="2020-06-16 10:36:50">2020/06/16</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/tensorflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tensorflow 学习笔记">tensorflow 学习笔记</span>
            <span class="post-date" title="2020-06-05 01:49:53">2020/06/05</span>
        </a>
        
        <a  class="全部文章 其他 "
           href="/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度理解卷积神经网络工作原理">深度理解卷积神经网络工作原理</span>
            <span class="post-date" title="2020-06-04 13:24:45">2020/06/04</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="定时执行">定时执行</span>
            <span class="post-date" title="2020-04-06 22:44:47">2020/04/06</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/Token-Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Token、Cookie 和 Session 的区别">Token、Cookie 和 Session 的区别</span>
            <span class="post-date" title="2020-04-03 10:46:54">2020/04/03</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/%E5%9C%A8python%E4%B8%AD%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91-%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E5%8F%8A%E5%90%88%E5%B9%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="在 python 中进行视频 - 音频处理及合并">在 python 中进行视频 - 音频处理及合并</span>
            <span class="post-date" title="2020-03-29 10:56:44">2020/03/29</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8BJS%E8%A7%A3%E5%AF%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="反反爬虫之 JS 解密">反反爬虫之 JS 解密</span>
            <span class="post-date" title="2020-03-24 10:04:43">2020/03/24</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/%E7%90%86%E8%A7%A3python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="理解 python 中的闭包与装饰器">理解 python 中的闭包与装饰器</span>
            <span class="post-date" title="2020-03-21 17:34:45">2020/03/21</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/Mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mongodb 数据库入门">Mongodb 数据库入门</span>
            <span class="post-date" title="2020-03-17 22:50:33">2020/03/17</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8A%A0%E4%B8%AA%E7%A9%BA%E6%A0%BC%E5%91%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="为什么不加个空格呢">为什么不加个空格呢</span>
            <span class="post-date" title="2020-03-14 13:53:44">2020/03/14</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"
           data-tag="yield"
           data-author="" >
            <span class="post-title" title="迭代器与生成器">迭代器与生成器</span>
            <span class="post-date" title="2020-03-13 21:58:25">2020/03/13</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8B%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="反反爬虫之滑块验证码">反反爬虫之滑块验证码</span>
            <span class="post-date" title="2020-03-08 21:00:17">2020/03/08</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8B%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="反反爬虫之图片验证码">反反爬虫之图片验证码</span>
            <span class="post-date" title="2020-03-08 16:16:16">2020/03/08</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/Python%E6%93%8D%E4%BD%9CRedis/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Python 操作 Redis">Python 操作 Redis</span>
            <span class="post-date" title="2020-03-07 16:15:44">2020/03/07</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/Scrapy-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Scrapy-Redis 分布式爬虫">Scrapy-Redis 分布式爬虫</span>
            <span class="post-date" title="2020-03-07 15:35:50">2020/03/07</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E7%88%AC%E8%99%ABRequest%E5%8E%BB%E9%87%8D%E5%8F%8A%E8%BF%87%E6%BB%A4%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="爬虫 Request 去重及过滤器">爬虫 Request 去重及过滤器</span>
            <span class="post-date" title="2020-03-07 15:22:23">2020/03/07</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis 数据库">Redis 数据库</span>
            <span class="post-date" title="2020-03-06 20:30:00">2020/03/06</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/Pymysql%E4%B8%8EORM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag="pymysql-ORM"
           data-author="" >
            <span class="post-title" title="Pymysql 与 ORM 操作数据库">Pymysql 与 ORM 操作数据库</span>
            <span class="post-date" title="2020-03-06 10:49:03">2020/03/06</span>
        </a>
        
        <a  class="全部文章 数据库 "
           href="/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/"
           data-tag="Mysql"
           data-author="" >
            <span class="post-title" title="MySql 数据库">MySql 数据库</span>
            <span class="post-date" title="2020-03-04 23:31:02">2020/03/04</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/Scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/"
           data-tag="Scrapy"
           data-author="" >
            <span class="post-title" title="Scrapy 框架爬虫">Scrapy 框架爬虫</span>
            <span class="post-date" title="2020-03-02 10:44:55">2020/03/02</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%88%AC%E8%99%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多线程与多进程爬虫">多线程与多进程爬虫</span>
            <span class="post-date" title="2020-03-01 15:33:08">2020/03/01</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/Selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A8%A1%E6%8B%9F/"
           data-tag="Selenium"
           data-author="" >
            <span class="post-title" title="Selenium 自动化测试模拟">Selenium 自动化测试模拟</span>
            <span class="post-date" title="2020-02-29 21:29:54">2020/02/29</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据持久化 - 文件保存本地">数据持久化 - 文件保存本地</span>
            <span class="post-date" title="2020-02-27 22:01:14">2020/02/27</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="爬虫基础入门">爬虫基础入门</span>
            <span class="post-date" title="2020-02-26 20:44:27">2020/02/26</span>
        </a>
        
        <a  class="全部文章 爬虫 "
           href="/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8EXpath%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/"
           data-tag="CSS-Xpath"
           data-author="" >
            <span class="post-title" title="CSS 选择器与 Xpath 数据提取">CSS 选择器与 Xpath 数据提取</span>
            <span class="post-date" title="2020-02-26 19:07:35">2020/02/26</span>
        </a>
        
        <a  class="全部文章 数据分析 "
           href="/Seaborn-Pygal-Pyecharts%E5%8F%AF%E8%A7%86%E5%8C%96/"
           data-tag="Seaborn,pygal,Pyecharts"
           data-author="" >
            <span class="post-title" title="Seaborn-Pygal-Pyecharts 可视化">Seaborn-Pygal-Pyecharts 可视化</span>
            <span class="post-date" title="2020-02-22 16:24:55">2020/02/22</span>
        </a>
        
        <a  class="全部文章 数据分析 "
           href="/python%E4%B9%8BMatplotlib%E5%8F%AF%E8%A7%86%E5%8C%96/"
           data-tag="Matplotlib"
           data-author="" >
            <span class="post-title" title="python 之 Matplotlib 可视化">python 之 Matplotlib 可视化</span>
            <span class="post-date" title="2020-02-20 20:28:44">2020/02/20</span>
        </a>
        
        <a  class="全部文章 数据分析 "
           href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E5%AE%9E%E6%93%8D/"
           data-tag="Pandas"
           data-author="" >
            <span class="post-title" title="Pandas 数据分析处理实操">Pandas 数据分析处理实操</span>
            <span class="post-date" title="2020-02-20 10:51:39">2020/02/20</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/Markdown%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E6%8A%80%E5%B7%A7/"
           data-tag="Markdown"
           data-author="" >
            <span class="post-title" title="Markdown 文本编辑技巧">Markdown 文本编辑技巧</span>
            <span class="post-date" title="2020-02-18 16:31:40">2020/02/18</span>
        </a>
        
        <a  class="全部文章 数据分析 "
           href="/Python%E4%B9%8BPandas%E5%BA%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag="Pandas"
           data-author="" >
            <span class="post-title" title="Python 之 Pandas 库从入门到实战">Python 之 Pandas 库从入门到实战</span>
            <span class="post-date" title="2020-02-15 20:46:52">2020/02/15</span>
        </a>
        
        <a  class="全部文章 数据分析 "
           href="/Python%E4%B9%8BNumpy%E5%BA%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"
           data-tag="Numpy"
           data-author="" >
            <span class="post-title" title="Python 之 Numpy 库从入门到实战">Python 之 Numpy 库从入门到实战</span>
            <span class="post-date" title="2020-02-13 23:15:38">2020/02/13</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/python%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E9%95%9C%E5%83%8F%E6%BA%90%E7%BD%91%E5%9D%80/"
           data-tag="pip"
           data-author="" >
            <span class="post-title" title="python pip 国内镜像大全及库的安装">python pip 国内镜像大全及库的安装</span>
            <span class="post-date" title="2020-02-13 23:13:16">2020/02/13</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/python%E7%9A%84%E4%B8%89%E7%A7%8D%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 的三种输出格式">python 的三种输出格式</span>
            <span class="post-date" title="2020-02-13 23:04:49">2020/02/13</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/python%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 中的时间模块">python 中的时间模块</span>
            <span class="post-date" title="2020-02-13 23:01:16">2020/02/13</span>
        </a>
        
        <a  class="全部文章 脚本语言 "
           href="/python%E6%9F%A5%E7%9C%8B%E4%BB%BB%E4%BD%95%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="python 查看任何第三方库的用法的方法">python 查看任何第三方库的用法的方法</span>
            <span class="post-date" title="2020-02-13 22:57:50">2020/02/13</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/Anaconda%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8Epyinstaller%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Anaconda 环境配置与 pyinstaller 程序打包">Anaconda 环境配置与 pyinstaller 程序打包</span>
            <span class="post-date" title="2020-02-13 20:01:52">2020/02/13</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="使用 Hexo+Github 搭建个人免费博客">使用 Hexo+Github 搭建个人免费博客</span>
            <span class="post-date" title="2020-02-13 15:44:02">2020/02/13</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/%E5%85%B3%E4%BA%8Ehexo%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"
           data-tag="Hexo"
           data-author="" >
            <span class="post-title" title="关于 hexo 使用过程中报错问题汇总">关于 hexo 使用过程中报错问题汇总</span>
            <span class="post-date" title="2020-02-12 23:03:46">2020/02/12</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-python中的进程，线程与协程" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">python 中的进程，线程与协程</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="脚本语言">脚本语言</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2026-01-24 15:17:06'>2020-11-04 21:29</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:11k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 基本概念 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-GIL%20%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81"><span class="toc-text">1.1 GIL 全局解释器锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%20%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B"><span class="toc-text">1.2 进程、线程与协程 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%20%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%88%96%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.3 如何选择多进程或多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%20%E6%A0%B9%E6%8D%AE%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E9%80%89%E6%8B%A9"><span class="toc-text">1.3.1 根据应用场景选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9%E5%AF%B9%E6%AF%94"><span class="toc-text">1.3.2 多进程池工具选择对比 </span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">2 多进程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%20%E5%9F%BA%E6%9C%AC%E5%AE%9E%E4%BE%8B"><span class="toc-text">2.1 基本实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%20%E6%A0%B8%E5%BF%83%20process-%20%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.2 核心 process 功能详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF"><span class="toc-text">2.3 多进程之间的通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-Queue-%20%E9%98%9F%E5%88%97%E9%80%9A%E8%AE%AF"><span class="toc-text">2.3.1 Queue 队列通讯 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-Pipe%20%E7%AE%A1%E9%81%93%E9%80%9A%E8%AE%AF"><span class="toc-text">2.3.2 Pipe 管道通讯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%20%E8%BF%9B%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="toc-text">2.4 进程数据共享 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-multiprocessing%20%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-text">2.5 multiprocessing 的进程池 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.5.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-async-%20%E5%BC%82%E6%AD%A5%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-text">2.5.2 async 异步进程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-async-%20%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">2.5.3 async 返回值 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">2.5.4 回调函数 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-concurrent-futures%20%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-text">2.6 concurrent.futures 中的进程池 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%20%E5%9F%BA%E6%9C%AC%E5%AE%9E%E4%BE%8B"><span class="toc-text">2.6.1 基本实例 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%20%E5%A4%96%E9%83%A8%E6%89%A7%E8%A1%8C%20shell%20%E8%84%9A%E6%9C%AC%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">2.6.2 外部执行 shell 脚本的两种方法 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%20%E6%89%A7%E8%A1%8C%20shell%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%B3%95%201"><span class="toc-text">2.6.3 执行 shell 脚本方法 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-4-%20%E6%89%A7%E8%A1%8C%20shell%20%E8%84%9A%E6%9C%AC%E6%96%B9%E6%B3%95%202"><span class="toc-text">2.6.4 执行 shell 脚本方法 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-5-with%20%E7%BB%93%E6%9E%84%E7%9A%84%E5%9D%91"><span class="toc-text">2.6.5 with 结构的坑 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-6-%20%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-text">2.6.6 线程生命周期和子进程的独立性 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-6-%20%E5%9C%A8%20GUI%20%E4%B8%AD%E5%B9%B6%E5%8F%91%E5%A4%96%E9%83%A8%E4%BB%BB%E5%8A%A1"><span class="toc-text">2.6.6 在 GUI 中并发外部任务 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="toc-text">2.7 多进程进度条 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. 多线程的实现 </span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%20%E5%9F%BA%E6%9C%AC%E5%AE%9E%E4%BE%8B"><span class="toc-text">3.1 基本实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%20%E6%A0%B8%E5%BF%83%20Thread%20%E5%8A%9F%E8%83%BD"><span class="toc-text">3.2 核心 Thread 功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%20%E9%94%81"><span class="toc-text">3.3 锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-concurrent-futures%20%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">3.4 concurrent.futures 中的线程池 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%20%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">3.4.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%20%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%20ThreadPoolExecutor"><span class="toc-text">3.4.2 核心方法 ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-submit%20%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.4.3 submit 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-map%20%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.4.4 map 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-%20%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD"><span class="toc-text">3.4.5 高级功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%20%E5%8D%8F%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-text">4. 协程示例 </span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1- 基本概念"><a href="#1- 基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念 </h1><h2 id="1-1-GIL 全局解释器锁"><a href="#1-1-GIL 全局解释器锁" class="headerlink" title="1.1 GIL 全局解释器锁"></a>1.1 GIL 全局解释器锁</h2><p> 在提到进程、线程和协程前，不得不提下<strong>GIL</strong>(<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97218985">Global Interpreter Lock</a>)，全局解释器锁。</p>
<p><strong>GIL</strong>是一个互斥锁（mutex），是 CPython（Python 解释器）限制了同一时间内，一个进程里只能有一个线程运行。它阻止了 多个线程同时执行 Python 字节码，毫无疑问，这降低了执行效率。</p>
<p>Python 最初的设计理念在于，<strong>为了解决多线程之间数据完整性和状态同步的问题，设计为在任意时刻只有一个线程在解释器中运行。</strong>而当执行多线程程序时，由 GIL 来控制同一时刻只有一个线程能够运行。即 Python 中的多线程是表面多线程，也可以理解为‘假’多线程，不是真正的多线程。</p>
<p>为什么要这样做呢？举个例子，比如用 python 计算：n=n+1。这个操作被分成了四步：</p>
<ul>
<li>加载全局变量 n</li>
<li>加载常数 1</li>
<li>进行二进制加法运算</li>
<li>将运算结果存入变量 n</li>
</ul>
<p>以上的过程是非原子操作的，根据前面的线程释放 GIL 锁原则，线程 a 执行这四步的过程中，有可能会让出 GIL。如果这样，n=n+1 的运算过程就被打乱了。</p>
<p>这就是为什么我们说 GIL 是粗粒度的，它只保证了一定程度的安全。如果要做到线程的绝对安全，是不是所有的非 IO 操作，我们都需要自己再加一把锁呢？答案是否定的。在 python 中，有些操作是是原子级的，它本身就是一个字节码，GIL 无法在执行过程中释放。对于这种原子级的方法操作，我们无需担心它的安全。比如 sort 方法，[1,4,2].sort()，翻译成字节码就是 CALL METHOD 0。只有一行，无法再分，所以它是线程安全的。</p>
<p>同一时刻只有一个线程能够运行，那么是怎么执行多线程程序的呢？其实原理很简单：解释器的 <strong> 分时复用 </strong>。即多个线程的代码，<strong> 轮流 </strong> 被解释器 <strong> 执行 </strong>，只不过切换的很频繁很快，给人一种多线程“同时”在执行的错觉。聊的学术化一点，其实就是“<strong> 并发</strong>”。</p>
<p><strong>“并发”和“并行”：</strong></p>
<ul>
<li>并发：不同的代码块交替执行</li>
<li>并行：不同的代码块同时执行</li>
</ul>
<p><strong>GIL 锁最终是保证 Python 解释器中原子操作的线程安全</strong>。</p>
<p><strong>GIL 是怎么起作用的：</strong></p>
<ul>
<li>由于 GIL 的机制，单核 CPU 在同一时刻只有一个线程在运行，当线程遇到 IO（读写）操作或 Timer  Tick 到期，释放 GIL 锁。其他的两个线程去竞争这把锁，得到锁之后，才开始运行。</li>
<li>线程释放 GIL 锁有两种情况，一是遇到 IO 操作，二是 Time Tick 到期（执行完 100 个字节码指令或者 15ms）。IO 操作很好理解，比如发出一个 http 请求，等待响应。而 Time Tick 规定了线程的最长执行时间，超过时间后自动释放 GIL 锁。</li>
</ul>
<p>在多核 CPU 下，由于 GIL 锁的全局特性，无法发挥多核的特性，GIL 锁会使得多线程任务的效率大大降低。线程 1（Thread1）在 CPU1 上运行，线程 2（Thread2）在 CPU2 上运行。GIL 是全局的，CPU2 上的 Thread2 需要等待 CPU1 上的 Thread1 让出 GIL 锁，才有可能执行。如果在多次竞争中，Thread1 都胜出，Thread2 没有得到 GIL 锁，意味着 CPU2 一直是闲置的，无法发挥多核的优势。为了避免同一线程霸占 CPU，在 python3.x 中，线程会自动的调整自己的优先级，使得多线程任务执行效率更高。</p>
<p><strong>GIL 的优缺点：</strong></p>
<ul>
<li><p>GIL 的优点是显而易见的，GIL 可以保证我们在多线程编程时，无需考虑多线程之间数据完整性和状态同步的问题。</p>
</li>
<li><p>GIL 缺点是：我们的多线程程序执行起来是“并发”，而不是“并行”。因此执行效率会很低，会不如单线程的执行效率。</p>
</li>
</ul>
<p><strong>原子操作：</strong></p>
<ul>
<li>原子操作就是不会因为进程并发或者线程并发而导致被中断的操作。<strong>原子操作 </strong> 的特点就是 <strong> 要么一次全部执行，要么全不执行</strong>。不存在执行了一半而被中断的情况。</li>
</ul>
<p><strong>Python 解释器：</strong></p>
<ul>
<li>python 解释器是有多个版本的：CPython, Jpython 等。CPython 就是用 C 语言实现 Python 解释器，JPython 是用 Java 实现 Python 解释器。那么 GIL 的问题实际上是存在于 CPython 中的。</li>
</ul>
<p>最初是为了利用多核，Python 开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。后来发现这种‘加锁’是低效的。但 <strong> 当大家试图去拆分和去除 GIL 的时候，发现大量库代码开发者已经重度依赖 GIL 而非常难以去除了</strong>。</p>
<p><strong>在 Python 编程中，如果想利用计算机的多核提高程序执行效率，用多进程代替多线程。</strong></p>
<p>使用多进程的好处：完全并行，无 GIL 的限制，可充分利用多 cpu 多核的环境。</p>
<p>虽说一般使用多进程对电脑系统资源占用比较多，但是在类 unix 系统中，创建线程的开销并不比进程小，因此在并发操作时，多线程的效率还是受到了很大制约的。所以后来人们发现通过 yield 来中断代码片段的执行，同时交出了 cpu 的使用权，于是协程的概念产生了。</p>
<h2 id="1-2- 进程、线程与协程"><a href="#1-2- 进程、线程与协程" class="headerlink" title="1.2 进程、线程与协程"></a>1.2 进程、线程与协程 </h2><p><strong> 进程（process）是系统资源分配的最小单位，线程（thread）是程序执行的最小单位</strong>。</p>
<p><strong>而协程（Coroutine）不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</strong></p>
<p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201105220526734.png" alt=""></p>
<p>一个程序（进程）在计算机上运行时，操作系统会以进程为单位，分配系统资源（CPU 时间片、内存等资源），当这个进程存在多个线程时，由于 GIL 锁，系统资源的红箭头会随机指向其中一个进程，供其使用。遇到 IO 操作或者 Time Tick 到期（执行完 100 个字节码指令或者 15ms），该线程被设置成睡眠状态，红箭头就又会随机重新指向其中一个线程执行（按优先级），这就是多线程。</p>
<p>协程的概念应该是从进程和线程演变而来的，协程其实并不真正存在，它只是人为设想的一种产物，由程序或用户可随意切换执行。协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p><strong>协程的特点在一个线程中执行，那和多线程比，协程有何优势？</strong></p>
<ul>
<li><strong>极高的执行效率 </strong>：因为<strong> 子程序切换不是线程切换，而是由程序自身控制 </strong>，因此，<strong> 没有线程切换的开销</strong>，和多线程比，线程数量越多，协程的性能优势就越明显；</li>
<li><strong>不需要多线程的锁机制 </strong>：因为只有一个线程，也不存在同时写变量冲突，<strong> 在协程中控制共享资源不加锁</strong>，只需要判断状态就好了，所以执行效率比多线程高很多。</li>
</ul>
<p>当你程序中方法需要等待时间的话，就可以用协程，效率高，消耗资源少。</p>
<p>python 可以通过 yield/send 的方式实现 <strong> 协程 </strong>。以此有程序员<strong> 控制函数的中断与执行</strong>。</p>
<p>在 Python3.4 正式引入了协程的概念，代码示例如下：</p>
<pre><code class="python">import asyncio

# Borrowed from http://curio.readthedocs.org/en/latest/tutorial.html.
@asyncio.coroutine
def countdown(number, n):
    while n &gt; 0:
        print(&#39;T-minus&#39;, n, &#39;(&#123;&#125;)&#39;.format(number))
        yield from asyncio.sleep(1)
        n -= 1

loop = asyncio.get_event_loop()
tasks = [asyncio.ensure_future(countdown(&quot;A&quot;, 2)),
    asyncio.ensure_future(countdown(&quot;B&quot;, 3))]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()</code></pre>
<p>示例显示了在 Python3.4 引入两个重要概念 <strong> 协程 </strong> 和<strong>事件循环 </strong>。<br> 通过修饰符 @asyncio.coroutine 定义了一个协程，而通过 event loop 来执行 tasks 中所有的协程任务。</p>
<p>之后在 Python3.5 引入了新的 async &amp; await 语法，从而有了原生协程的概念。</p>
<h2 id="1-3- 如何选择多进程或多线程"><a href="#1-3- 如何选择多进程或多线程" class="headerlink" title="1.3 如何选择多进程或多线程"></a>1.3 如何选择多进程或多线程</h2><h3 id="1-3-1- 根据应用场景选择"><a href="#1-3-1- 根据应用场景选择" class="headerlink" title="1.3.1 根据应用场景选择"></a>1.3.1 根据应用场景选择</h3><ul>
<li>多进程，常用于任务的并行处理，适合 CPU 密集型任务，能够实现真正的并发。</li>
<li>多线程，也可用于任务的并发处理， 多个任务在同一时间段内交替执行，看起来“同时进行”。但是无法充分利多核的优势，因为 GIL 锁的存在，无法真正并行，但在 I/O 操作时会释放 GIL，因此线程仍然适 I/O 密集型任务</li>
</ul>
<h3 id="1-3-2- 多进程池工具选择对比"><a href="#1-3-2- 多进程池工具选择对比" class="headerlink" title="1.3.2 多进程池工具选择对比"></a>1.3.2 多进程池工具选择对比 </h3><p><code>multiprocessing</code> 模块和 <code>concurrent.futures.ProcessPoolExecutor</code> 都是 Python 中用于实现<strong> 多进程并行计算 </strong> 的工具，适用于 <strong>CPU 密集型任务</strong>（如科学计算、图像处理、大数据分析等），以绕过 CPython 的 <strong>GIL（全局解释器锁）</strong> 限制。但它们在接口设计、易用性、功能抽象层级等方面有明显区别。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>multiprocessing.Pool</code></th>
<th><code>ProcessPoolExecutor</code></th>
</tr>
</thead>
<tbody><tr>
<td>所属模块</td>
<td><code>multiprocessing</code></td>
<td><code>concurrent.futures</code></td>
</tr>
<tr>
<td>接口风格</td>
<td>传统、底层</td>
<td>现代、高级（PEP 3148）</td>
</tr>
<tr>
<td>返回值类型</td>
<td>直接结果或 <code>AsyncResult</code></td>
<td>统一返回 <code>Future</code> 对象</td>
</tr>
<tr>
<td>任务提交方式</td>
<td><code>apply</code>, <code>apply_async</code>, <code>map</code>, <code>imap</code> 等</td>
<td><code>submit</code>, <code>map</code></td>
</tr>
<tr>
<td>结果获取</td>
<td>多种方式（阻塞 / 非阻塞）</td>
<td>通过 <code>Future.result()</code></td>
</tr>
<tr>
<td>回调支持</td>
<td><code>apply_async(callback=...)</code></td>
<td><code>Future.add_done_callback()</code></td>
</tr>
<tr>
<td>上下文管理</td>
<td>需手动 <code>close()</code> + <code>join()</code></td>
<td>支持 <code>with</code> 语句自动管理</td>
</tr>
<tr>
<td>异常处理</td>
<td>较复杂（需在回调或 get 中捕获）</td>
<td>更统一（通过 <code>Future.exception()</code>）</td>
</tr>
<tr>
<td>可组合性</td>
<td>较弱</td>
<td>与 <code>as_completed</code>, <code>wait</code> 等工具无缝集成</td>
</tr>
<tr>
<td>推荐程度</td>
<td>旧项目或特殊需求</td>
<td>✅ <strong>新项目首选</strong></td>
</tr>
</tbody></table>
<h1 id="2- 多进程的实现"><a href="#2- 多进程的实现" class="headerlink" title="2 多进程的实现"></a>2 多进程的实现</h1><p><code>multiprocessing</code> 是 Python 的标准模块，它既可以用来编写多进程，也可以用来编写多线程。</p>
<p>其中 <strong>Process</strong> 类是创建和管理子进程的核心工具。它可以让任务在 <strong> 独立的进程 </strong> 中运行，充分利用多核 CPU 的性能（并行）。</p>
<h2 id="2-1- 基本实例"><a href="#2-1- 基本实例" class="headerlink" title="2.1 基本实例"></a>2.1 基本实例</h2><pre><code class="python">import multiprocessing       #导入多进程库
import time

def upload():
    print(&quot; 开始上传文件...&quot;)
    time.sleep(5)
    print(&quot; 完成上传文件...&quot;)

def download():
    print(&quot; 开始下载文件...&quot;)
    time.sleep(2)
    print(&quot; 完成下载文件...&quot;)

def main():
    start=time.time()

    ### 同时开启两个子进程
    multiprocessing.Process(target=upload).start()
    multiprocessing.Process(target=download).start()

    end=time.time()
    print(&#39; 主函数总耗时：%s&#39;%(end-start))

if __name__ == &#39;__main__&#39;:
    begin = time.time()

    main()

    stop=time.time()

    print(&#39; 主程序总耗时：%s&#39;%(stop-begin))

#输出结果：
主函数总耗时：0.02892470359802246
主程序总耗时：0.02892470359802246
 开始上传文件...
 开始下载文件...
 完成下载文件...
 完成上传文件...
</code></pre>
<p>这一个程序相当于有三个进程，该程序的这个 <strong> 主进程 </strong> 加上两个 <strong> 子进程 upload 和 download</strong>。</p>
<p>upload 和 download 两个子进程是独立于主进程的，各自【新开】进程独立运行，不影响主进程。</p>
<h2 id="2-2- 核心 process- 功能详解"><a href="#2-2- 核心 process- 功能详解" class="headerlink" title="2.2 核心 process 功能详解"></a>2.2 核心 process 功能详解</h2><pre><code># 构造方法：
Process([group [, target [, name [, args [, kwargs]]]]])
　　group: 线程组 
　　target: 要执行的方法
　　name: 进程名
　　args/kwargs: 要传入方法的参数

# 实例方法：
　　is_alive()：返回进程是否在运行,bool 类型。
　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的 timeout（可选参数）。
　　start()：进程准备就绪，等待 CPU 调度
　　run()：strat()调用 run 方法，如果实例进程时未制定传入 target，这 star 执行 t 默认 run()方法。
　　terminate()：不管任务是否完成，立即停止工作进程

# 属性：
　　daemon：和线程的 setDeamon 功能一样
　　name：进程名字
　　pid：进程号 </code></pre><h2 id="2-3- 多进程之间的通讯"><a href="#2-3- 多进程之间的通讯" class="headerlink" title="2.3 多进程之间的通讯"></a>2.3 多进程之间的通讯</h2><p><code>Process</code> 之间肯定是需要通信的。Python 的 <code>multiprocessing</code> 模块包装了底层的机制，提供了 <code>Queue</code>、<code>Pipes</code> 等多种方式来交换数据。</p>
<ul>
<li><strong>Queue</strong>队列是一种经常用于在多个进程之间传递数据的机制。它基于先进先出（FIFO）的原则，可以安全地在多个进程之间共享数据。队列适用于 <strong> 大规模的数据传输</strong>，例如多个进程同时往队列中放入或取出数据。</li>
<li><strong>Pipe</strong>管道是一种用于在两个进程之间传递数据的机制。它由两个连接的端点组成，分别是发送端和接收端。通过创建管道对象，我们可以在进程之间传递数据。。管道适用于 <strong> 小规模的数据传输</strong>，例如传递字符串、字节数据或数据对象。</li>
</ul>
<h3 id="2-3-1-Queue- 队列通讯"><a href="#2-3-1-Queue- 队列通讯" class="headerlink" title="2.3.1 Queue 队列通讯"></a>2.3.1 Queue 队列通讯 </h3><p> 我们以 <code>Queue</code> 为例，在父进程中创建两个子进程，一个往 <code>Queue</code> 里写数据，一个从 <code>Queue</code> 里读数据：</p>
<pre><code class="shell">from multiprocessing import Process, Queue
import os, time, random

# 写数据进程执行的代码:
def write(q):
    print(&#39;Process to write: %s&#39; % os.getpid())
    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:
        print(&#39;Put %s to queue...&#39; % value)
        q.put(value)
        time.sleep(random.random())

# 读数据进程执行的代码:
def read(q):
    print(&#39;Process to read: %s&#39; % os.getpid())
    while True:
        value = q.get(True)
        print(&#39;Get %s from queue.&#39; % value)

if __name__==&#39;__main__&#39;:
    # 1 父进程创建 Queue，并传给各个子进程：
    q = Queue()
    pw = Process(target=write, args=(q,))
    pr = Process(target=read, args=(q,))
    # 2 启动子进程 pw，写入:
    pw.start()
    # 3 启动子进程 pr，读取:
    pr.start()
    # 4 等待 pw 结束:
    pw.join()
    # 5 pr 进程里是死循环，无法等待其结束，只能强行终止:
    pr.terminate()
</code></pre>
<p>用 <code>put()</code> 方法往队列中放入数据，用 <code>get()</code> 方法从队列中取出数据。</p>
<p>队列的主要特点包括：</p>
<ul>
<li>支持多个进程之间的数据共享；</li>
<li>使用先进先出（FIFO）的原则；</li>
<li>适用于大规模的数据传输。</li>
</ul>
<h3 id="2-3-2-Pipe 管道通讯"><a href="#2-3-2-Pipe 管道通讯" class="headerlink" title="2.3.2 Pipe 管道通讯"></a>2.3.2 Pipe 管道通讯</h3><pre><code class="python">from multiprocessing import Process, Pipe

def sender(conn):
    conn.send(&quot;Hello from sender process!&quot;)
    conn.close()

def receiver(conn):
    message = conn.recv()
    print(&quot;Received message:&quot;, message)
    conn.close()

if __name__ == &#39;__main__&#39;:
    parent_conn, child_conn = Pipe()   #关键点，pipe 实例化生成一个双向管

    sender_process = Process(target=sender, args=(child_conn,))
    receiver_process = Process(target=receiver, args=(parent_conn,))

    sender_process.start()
    receiver_process.start()

    sender_process.join()
    receiver_process.join()
</code></pre>
<p>通过调用其 <code>recv()</code> 和<code>send(message)</code>方法在两个进程之间传递数据</p>
<p>管道的主要特点包括：</p>
<ul>
<li>在两个进程之间传递数据；</li>
<li>是双向的，可以在父进程和子进程之间进行双向通信；</li>
<li>适用于小规模的数据传输。</li>
</ul>
<h2 id="2-4- 进程数据共享"><a href="#2-4- 进程数据共享" class="headerlink" title="2.4 进程数据共享"></a>2.4 进程数据共享 </h2><p> 不同的进程通常有独立的内存空间，这使得进程间共享数据变得困难。</p>
<p><code>multiprocessing.Manager()</code> 提供了一种方便的方式来创建可以在不同进程间共享的 共享对象（Shared Objects），例如共享的列表、字典、命名空间等。它本质上是启动了一个 管理器进程（Manager Process），其他工作进程通过 代理（Proxy） 访问这个管理器进程中的真实对象。</p>
<p>由于 <code>Manager</code> 是基于 代理 和 网络通信（Sockets） 实现的，所有对共享对象的访问都需要通过管理器进程进行序列化和反序列化（Pickling/Unpickling）以及进程间通信（IPC）。这比直接在同一进程内操作数据要慢得多，尤其是当操作频繁或数据量大时。</p>
<pre><code class="python">from multiprocessing import Process, Manager

def modify_list(shared_list):
   shared_list.append(4)

def modify_dict(shared_dict):
   shared_dict[&#39;key3&#39;] = &#39;value3&#39;

if __name__ == &#39;__main__&#39;:
   with Manager() as manager:
       # 定义两个共享数据结构
       shared_list = manager.list([1, 2, 3])
       shared_dict = manager.dict(&#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;&#125;)

       # 开始启动子进程
       p1 = Process(target=modify_list, args=(shared_list,))
       p2 = Process(target=modify_dict, args=(shared_dict,))
       p1.start()
       p2.start()
       p1.join()
       p2.join()

       # debug 打印输出
       print(shared_list) # [1, 2, 3, 4]
       print(shared_dict) # &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;, &#39;key3&#39;: &#39;value3&#39;&#125;</code></pre>
<p>可以看到主进程定义了一个列表和一个字典，在子进程中，可以添加和修改字典的内容，在列表中插入新的数据，实现进程间的数据共享，即可以共同修改同一份数据。</p>
<h2 id="2-5-multiprocessing 的进程池"><a href="#2-5-multiprocessing 的进程池" class="headerlink" title="2.5 multiprocessing 的进程池"></a>2.5 multiprocessing 的进程池 </h2><h3 id="2-5-1- 基本介绍"><a href="#2-5-1- 基本介绍" class="headerlink" title="2.5.1 基本介绍"></a>2.5.1 基本介绍</h3><p> 当我们需要启动大量的独立任务时，并保持一定量的多任务并发，我们可以采用进程池，自动调节任务的启动。</p>
<p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
<p><strong>multiprocessing.Pool</strong> 是创建进程池的主要工具。<code>pool = multiprocessing.Pool(10)</code></p>
<p>Pool 类有以下 4 种非常常用提交任务的方法。</p>
<ul>
<li>apply(func [, args [, kwargs]])：阻塞，任务其实是一个一个执行完的。无法实现并行效果。<strong>所以这个函数其实没啥用</strong></li>
<li>map(func, iterable, chunksize=None)：与上一致。区别是针对多次运行同一个任务，如果只是参数不同，可以把参数做成一个迭代器。<strong>这个函数其实也没啥用</strong></li>
<li><strong>apply_async(func [, args [, kwargs]], callback)</strong>：非阻塞，且支持结果返回后进行回调</li>
<li><strong>map_async(func, iterable, chunksize, callback)</strong>：与上一致，区别是针对多次运行同一个任务，如果只是参数不同，可以把参数做成一个迭代器。</li>
</ul>
<p>进程池的管理函数：</p>
<ul>
<li><strong>pool.close()</strong>：关闭进程池（pool），使其不在接受新的任务。</li>
<li><strong>pool.terminal()</strong>：结束工作进程，不在处理未处理的任务。</li>
<li><strong>pool.join()</strong>：主进程阻塞等待子进程的退出，join 方法要在 close 或 terminate 之后使用。</li>
</ul>
<h3 id="2-5-2-async- 异步进程池"><a href="#2-5-2-async- 异步进程池" class="headerlink" title="2.5.2 async 异步进程池"></a>2.5.2 async 异步进程池</h3><p>apply_async 举例：</p>
<pre><code class="python">import os, time, random
from multiprocessing import Pool

def work(n):
    print(&#39;%s run&#39; %os.getpid())
    time.sleep(random.randint(3,5))
    return n**2

if __name__ == &#39;__main__&#39;:
    p=Pool(3)      #创建 3 个子进程运行任务
    res_l=[]

    # 异步运行，根据进程池中有的进程数，每次最多 3 个子进程在异步执行
    for i in range(10):
        res = p.apply_async(work,args=(i,)) 
        res_l.append(res)

    p.close()
    p.join()   #主进程需要使用 join，等待进程池内任务都处理完，然后可以用 get 收集结果
    for res in res_l:
        print(res.get()) #使用 get 来获取 apply_aync 的结果</code></pre>
<p>map_async 举例：</p>
<pre><code class="python">import os, time, random
from multiprocessing import Pool

def test_func(v):
    print(v)
    sleep(10/2-v/2)  # v 越大 运行时间越少
    return v

# 所需要测试的数据
data = range(10)

n_proc = 5
pool = mp.Pool(n_proc)
res = pool.map_async(test_func, data)
pool.close()
pool.join()

print(res.get())</code></pre>
<h3 id="2-5-3-async- 返回值"><a href="#2-5-3-async- 返回值" class="headerlink" title="2.5.3 async 返回值"></a>2.5.3 async 返回值 </h3><p> 方法 <code>apply_async()</code> 和<code>map_async()</code>的返回值是 AsyncResul 的实例 obj。实例具有以下方法：</p>
<p><code>obj.get()</code>：返回结果，如果有必要则等待结果到达。timeout 是可选的。如果在指定时间内还没有到达，将引发一场。如果远程操作中引发了异常，它将在调用此方法时再次被引发。</p>
<p><code>obj.ready()</code>：如果调用完成，返回 True</p>
<p><code>obj.successful()</code>：如果调用完成且没有引发异常，返回 True，如果在结果就绪之前调用此方法，引发异常</p>
<p><code>obj.wait([timeout])</code>：等待结果变为可用。</p>
<h3 id="2-5-4- 回调函数"><a href="#2-5-4- 回调函数" class="headerlink" title="2.5.4 回调函数"></a>2.5.4 回调函数 </h3><p> 需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数</p>
<p>我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了 I/O 的过程，直接拿到的是任务的结果。</p>
<pre><code class="python">import os, time, random
from multiprocessing import Pool

def log(v):
    callback_res.append(v)

def test_func(v):
    print(v)
    sleep(10/2-v/2)  # v 越大 运行时间越少
    return v

data = range(10)
callback_res = []

n_proc = 5
pool = mp.Pool(n_proc)

for d in data:
    pool.apply_async(test_func, (d,), callback=log)
pool.close()
pool.join()
print(callback_res)  # [4, 3, 2, 1, 0, 6, 8, 7, 9, 5]</code></pre>
<h2 id="2-6-concurrent-futures 中的进程池"><a href="#2-6-concurrent-futures 中的进程池" class="headerlink" title="2.6 concurrent.futures 中的进程池"></a>2.6 concurrent.futures 中的进程池 </h2><p> 当我们需要启动大量的独立任务时，并保持一定量的多任务并发，我们可以采用进程池，自动调节任务的启动。</p>
<p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
<h3 id="2-6-1- 基本实例"><a href="#2-6-1- 基本实例" class="headerlink" title="2.6.1 基本实例"></a>2.6.1 基本实例 </h3><p><code>concurrent.futures.ProcessPoolExecutor</code> 是更现代的一种用来调用 <strong> 进程池 </strong> 的工具。</p>
<pre><code class="python">from concurrent.futures import ProcessPoolExecutor, as_completed
import os
import time

def cpu_bound_task(n):
    pid = os.getpid()
    start_time = time.time()
    print(f&quot;[&#123;time.strftime(&#39;%H:%M:%S&#39;)&#125;] 任务 &#123;n&#125; 在进程 &#123;pid&#125; 中开始执行 &quot;)

    total = sum(i * i for i in range(n * 8000000))

    end_time = time.time()
    duration = end_time - start_time
    print(f&quot;[&#123;time.strftime(&#39;%H:%M:%S&#39;)&#125;] 任务 &#123;n&#125; 在进程 &#123;pid&#125; 中结束，耗时 &#123;duration:.2f&#125; 秒 &quot;)
    return f&quot; 任务 &#123;n&#125; 结果: &#123;total&#125;&quot;

if __name__ == &#39;__main__&#39;:

    with ProcessPoolExecutor(max_workers=3) as executor:
        # 提交 5 个任务
        futures = [executor.submit(cpu_bound_task, i) for i in range(5, 0, -1)]  # [5,4,3,2,1]

        # 按完成顺序输出结果
        for future in as_completed(futures):
            result = future.result()
            print(f&quot;[&#123;time.strftime(&#39;%H:%M:%S&#39;)&#125;] 收到结果: &#123;result&#125;&quot;)
#结果输出：
[18:37:53] 任务 5 在进程 15352 中开始执行
[18:37:53] 任务 4 在进程 14736 中开始执行
[18:37:53] 任务 3 在进程 15192 中开始执行
[18:37:55] 任务 3 在进程 15192 中结束，耗时 2.11 秒
[18:37:55] 任务 2 在进程 15192 中开始执行
[18:37:55] 收到结果: 任务 3 结果: 4607999712000004000000
[18:37:56] 任务 4 在进程 14736 中结束，耗时 2.91 秒
[18:37:56] 收到结果: 任务 4 结果: 10922666154666672000000
[18:37:56] 任务 1 在进程 14736 中开始执行
[18:37:56] 任务 2 在进程 15192 中结束，耗时 1.38 秒
[18:37:56] 收到结果: 任务 2 结果: 1365333205333336000000
[18:37:56] 任务 1 在进程 14736 中结束，耗时 0.70 秒
[18:37:56] 收到结果: 任务 1 结果: 170666634666668000000
[18:37:56] 任务 5 在进程 15352 中结束，耗时 3.63 秒
[18:37:56] 收到结果: 任务 5 结果: 21333332533333340000000</code></pre>
<blockquote>
<p>根据上面测试，看时间，可以看到先提交前三个任务，任务 3 结束后，再加了任务 2，保持占满池子（3 个）</p>
</blockquote>
<p>ProcessPoolExecutor 用法和线程池一模一样，接口完全一致。两者都继承自同一个抽象基类 <code>Executor</code>，因此两者用法完全相同</p>
<p>使用用法可以直接参考 3.4 章节。只需改一行代码即可切换线程 / 进程。</p>
<p>虽然接口一样，但底层行为不同。</p>
<h3 id="2-6-2- 外部执行 shell 脚本的两种方法"><a href="#2-6-2- 外部执行 shell 脚本的两种方法" class="headerlink" title="2.6.2 外部执行 shell 脚本的两种方法"></a>2.6.2 外部执行 shell 脚本的两种方法 </h3><p> 如果我们需要使用 python 执行一个外部的 shell 命令，这个 shell 命令是 CPU 密集型的耗时任务，有两个选择：</p>
<ul>
<li>使用<code>subprocess.run</code> 或者<code>subprocess.Popen</code></li>
</ul>
<p>上述命令介绍见<a href="https://jqiange.github.io/python 执行外部命令 /">python 执行外部命令 | jqiange</a></p>
<p>这里主要介绍使用进程池来执行多个外部 shell 命令。实现两种方式： </p>
<ul>
<li>使用<code>ProcessPoolExecutor</code> +<code>subprocess.run</code> </li>
<li>使用<code>ThreadPoolExecutor</code> +<code>subprocess.Popen</code> </li>
</ul>
<p>两种方案表格对比：</p>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left"><code>ProcessPoolExecutor + subprocess.run</code></th>
<th align="left"><code>ThreadPoolExecutor + subprocess.Popen</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>并发控制</strong></td>
<td align="left">✅ 支持（通过 <code>max_workers</code>）</td>
<td align="left">✅ 支持</td>
</tr>
<tr>
<td align="left"><strong>资源开销</strong></td>
<td align="left">❌ <strong>高</strong>：每个 worker 是一个完整 Python 进程（内存复制、IPC 开销）</td>
<td align="left">✅ <strong>低</strong>：线程共享内存，仅启动外部进程</td>
</tr>
<tr>
<td align="left"><strong>启动速度</strong></td>
<td align="left">❌ 慢（需 fork + import 模块）</td>
<td align="left">✅ 快（线程轻量）</td>
</tr>
<tr>
<td align="left"><strong>适用任务类型</strong></td>
<td align="left">理论上适合 CPU 密集型，但此处不必要</td>
<td align="left">更适合 I/O 等待型（如等待外部命令）</td>
</tr>
<tr>
<td align="left"><strong>跨平台兼容性</strong></td>
<td align="left">⚠️ Windows 上 <code>ProcessPoolExecutor</code> 使用 <code>spawn</code>，启动更慢</td>
<td align="left">✅ 更一致</td>
</tr>
<tr>
<td align="left"><strong>能否杀死子进程树</strong></td>
<td align="left">❌ 困难（worker 进程可能无法访问子进程 PID）</td>
<td align="left">✅ 容易（在同一线程中管理 <code>Popen</code> 对象）</td>
</tr>
<tr>
<td align="left"><strong>超时控制</strong></td>
<td align="left">✅ <code>subprocess.run(timeout=...)</code> 支持</td>
<td align="left">✅ <code>Popen.communicate(timeout=...)</code> 支持</td>
</tr>
<tr>
<td align="left"><strong>内存占用（并发 4 个个任务）</strong></td>
<td align="left">高（4 个 Python worker 进程 + 4 个 cad 进程）</td>
<td align="left">低（1 个 Python 进程 + 4 个 cad 进程）</td>
</tr>
</tbody></table>
<p>如果使用<code>ProcessPoolExecutor</code> +<code>subprocess.run</code> 会被认为是过度设计。</p>
<ul>
<li><code>cad -f test.rule</code> 是 <strong> 外部二进制程序 </strong>，它运行在<strong> 独立的操作系统进程 </strong> 中。</li>
<li>Python 的作用仅仅是：<ul>
<li>启动它（<code>fork/exec</code>）</li>
<li>等待它结束</li>
<li>读取输出</li>
</ul>
</li>
<li>这个过程 <strong> 不消耗 Python 的 CPU</strong>，只是“挂起等待”，属于 <strong>I/O 等待型操作</strong>（尽管 <code>cad</code> 自身是 CPU 密集型）。</li>
<li>因此，<strong>用线程池完全足够</strong>，且更高效。</li>
</ul>
<p>所以，推荐使用方法 2。</p>
<h3 id="2-6-3- 执行 shell 脚本方法 1"><a href="#2-6-3- 执行 shell 脚本方法 1" class="headerlink" title="2.6.3 执行 shell 脚本方法 1"></a>2.6.3 执行 shell 脚本方法 1</h3><pre><code class="python">import subprocess
from concurrent.futures import ProcessPoolExecutor, as_completed
import os
import multiprocessing

# 假设你有 n 个 CPU 密集型 shell 脚本
script_paths = [
    &quot;./cpu_task1.sh&quot;,
    &quot;./cpu_task2.sh&quot;,
    &quot;./cpu_task3.sh&quot;,
    &quot;./cpu_task4.sh&quot;,
    # ...
]

def run_cpu_intensive_script(script_path):
    &quot;&quot;&quot; 在独立进程中运行 CPU 密集型 shell 脚本 &quot;&quot;&quot;
    try:
        # 确保脚本可执行（可选）
        os.chmod(script_path, 0o755)

        result = subprocess.run([script_path],  # 或 [&quot;/bin/bash&quot;, script_path]
            capture_output=True,  # 自动捕获输出或异常
            text=True,  #返回字符串而非 bytes
            check=False,  # 不自动抛异常，手动处理 returncode
            timeout=600   # 10 分钟超时（按需调整）
        ) # subprocess.run 是阻塞的
        return &#123;
            &quot;script&quot;: script_path,
            &quot;returncode&quot;: result.returncode,
            &quot;stdout&quot;: result.stdout,
            &quot;stderr&quot;: result.stderr
        &#125;
    except subprocess.TimeoutExpired:
        return &#123;
            &quot;script&quot;: script_path,
            &quot;returncode&quot;: -1,
            &quot;stdout&quot;: &quot;&quot;,
            &quot;stderr&quot;: &quot;Script timed out&quot;
        &#125;
    except Exception as e:
        return &#123;
            &quot;script&quot;: script_path,
            &quot;returncode&quot;: -2,
            &quot;stdout&quot;: &quot;&quot;,
            &quot;stderr&quot;: str(e)
        &#125;

def main():

    max_workers = 5

    with ProcessPoolExecutor(max_workers=max_workers) as executor:
        # 提交所有任务
        futures = [executor.submit(run_cpu_intensive_script, script) for script in script_paths]

        # 按完成顺序处理结果
        for future in concurrent.futures.as_completed(futures):
            res = future.result()
            if res[&quot;returncode&quot;] == 0:
                print(f&quot;&#123;res[&#39;script&#39;]&#125; 成功完成 &quot;)
            else:
                print(f&quot;&#123;res[&#39;script&#39;]&#125; 失败 (返回码: &#123;res[&#39;returncode&#39;]&#125;)&quot;)
                print(f&quot;   错误: &#123;res[&#39;stderr&#39;][:200]&#125;...&quot;)  # 截断长错误

if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<h3 id="2-6-4- 执行 shell 脚本方法 2"><a href="#2-6-4- 执行 shell 脚本方法 2" class="headerlink" title="2.6.4 执行 shell 脚本方法 2"></a>2.6.4 执行 shell 脚本方法 2</h3><p>使用<code>threadPoolExecutor</code> +<code>subprocess.Popen</code> 执行外部 shell 的 CPU 耗时任务</p>
<pre><code class="python">import subprocess
import concurrent.futures
import time
import signal
import os

WORK_DIR = &quot;/path/to/your/workdir&quot;  # cad 所需的工作目录

def run_cad_task(task_id):

    try:
        # 启动子进程
        proc = subprocess.Popen([&quot;./run_cad.sh&quot;],
            cwd=WORK_DIR,
            stdout=subprocess.PIPE,  #通过管道将 &quot;./run_cad.sh&quot; 的结果传递给 proc.stdout
            stderr=subprocess.PIPE,  #这两行可以用 capture_output=True 代替
            text=True,  #返回字符串而非 bytes
            preexec_fn=os.setsid  # 创建新进程组（便于后续杀死整个进程树）
        )  #subprocess.Popen 是非阻塞的

        # 等待完成或超时
        try:
            stdout, stderr = proc.communicate(timeout=3600*24) 
            #communicate 是阻塞的，必须阻塞，否则进程池控制失效
            returncode = proc.returncode
        except subprocess.TimeoutExpired:
            # 超时：杀死整个进程组
            try:
                os.killpg(os.getpgid(proc.pid), signal.SIGTERM)  # 发送终止信号 signal.SIGTERM
                proc.wait(timeout=10)
            except:
                os.killpg(os.getpgid(proc.pid), signal.SIGKILL)  # 发送强杀信号 signal.SIGKILL
                proc.wait()
            return (task_id, False, f&quot; 任务超时 &quot;)

        # 检查结果
        if returncode == 0:
            return (task_id, True, &quot; 成功完成 &quot;)
        else:
            return (task_id, False, f&quot; 失败，退出码: &#123;returncode&#125;\nstderr: &#123;stderr[-500:]&#125;&quot;)  # 截断长错误

    except Exception as e:
        return (task_id, False, f&quot; 异常: &#123;str(e)&#125;&quot;)


def main():

    task_ids = [f&quot;task_&#123;i&#125;&quot; for i in range(10)]  # 示例：10 个任务

    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        # 提交所有任务
        future_to_task = &#123;
            executor.submit(run_cad_task, tid): tid
            for tid in task_ids
        &#125;

        # 按完成顺序处理结果
        for future in concurrent.futures.as_completed(future_to_task):
            task_id, success, msg = future.result()
            if success:
                print(f&quot;[&#123;task_id&#125;] &#123;msg&#125;&quot;)
            else:
                print(f&quot;[&#123;task_id&#125;] &#123;msg&#125;&quot;)

if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<blockquote>
<p>注意：在多线程任务 <code>run_cad_task</code> 里面，必须阻塞，否则线程池会认为它立马执行结束，会再加新的任务，失去了控制并发数为 5 的初衷</p>
</blockquote>
<p>这个方法考虑了从 <code>subprocess.Popen</code> 里面传递 log，如果不需要传递 log，<strong>只管提交，不等待</strong>，通过其他方法监控任务，可以采用：</p>
<pre><code class="python">import subprocess
import concurrent.futures
import time
import signal
import os

WORK_DIR = &quot;/path/to/your/workdir&quot;  # cad 所需的工作目录

def run_cad_task(task_cmd):

    proc = subprocess.Popen(
        task_cmd, # 启动子进程 task_cmd
        shell=True,
        cwd=WORK_DIR,
        preexec_fn=os.setsid  # 创建新进程组（便于后续杀死整个进程树）
    )  #subprocess.Popen 是非阻塞的

    proc.wait()  # run_cad_task 函数必须阻塞，否则多进程失效

def submit_all_jobs(task_cmds):
    executor = concurrent.futures.ThreadPoolExecutor(max_workers=5)
    future_to_task = &#123;
        executor.submit(run_cad_task, task): task
        for task in task_cmds
    &#125;
    print(&quot;all job are submited&quot;)
    executor.shutdown(wait=False)

def main():

    task_cmds = [...]  # 示例：多个任务
    submit_all_jobs(task_cmds)


if __name__ == &quot;__main__&quot;:
    main()</code></pre>
<h3 id="2-6-5-with 结构的坑"><a href="#2-6-5-with 结构的坑" class="headerlink" title="2.6.5 with 结构的坑"></a>2.6.5 with 结构的坑 </h3><p> 很多时候我们只想提交任务，不需要等到完成进行后续的操作，或者自有其他手段监控 log。</p>
<pre><code class="python">def submit_all_jobs(task_cmds):
    with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
        # 提交所有任务
        future_to_task = &#123;
            executor.submit(run_cad_task, task): task
            for task in task_cmds
        &#125;
    print(&quot;all job are submited&quot;)

##=================
### 使用 with 结构会发现，只有所有任务完成后才会打印 &quot;all job are submited&quot;
##================= </code></pre>
<p>在使用 ThreadPoolExecutor 的 with 结构，<strong>只有当池子里面所有的任务全部完成后，才会退出 with 结构</strong>！！！</p>
<p><code>with ThreadPoolExecutor(...) as executor:</code> 的作用域</p>
<ul>
<li><code>with</code> 块结束时，会调用 <code>executor.shutdown(wait=True)</code>（默认）；</li>
<li>这会等待所有已提交的任务（即 <code>run_cad_task</code> 函数）完成；</li>
<li>它会一直等到所有的子线程 <code>run_cad_task</code> 结束才会退出 with 语句；</li>
</ul>
<p>所以，下面采用不使用 with 结构：<strong>只管提交，不等待</strong></p>
<pre><code class="python">def submit_all_jobs(task_cmds):
    executor = concurrent.futures.ThreadPoolExecutor(max_workers=5)
    future_to_task = &#123;
        executor.submit(run_cad_task, task): task
        for task in task_cmds
    &#125;
    print(&quot;all job are submited&quot;)
    executor.shutdown(wait=False)</code></pre>
<p>所以我们不采用 with 结构，只管提交任务，打印”all job are submited”，而后通过其他手段监控任务。</p>
<p>仔细一想：如果 <code>submit_all_jobs</code> 瞬间执行结束，退出这个函数后，多线程对象 executor 还存在吗，队列还存在吗，会被销毁吗？</p>
<p>下节进行详细的介绍。</p>
<h3 id="2-6-6- 线程生命周期和子进程的独立性"><a href="#2-6-6- 线程生命周期和子进程的独立性" class="headerlink" title="2.6.6 线程生命周期和子进程的独立性"></a>2.6.6 线程生命周期和子进程的独立性 </h3><p><strong> 几点结论</strong>：</p>
<ul>
<li><p>已经由<code>subprocess.Popen</code> 启动的任务不受其他影响，进程仍然会继续在操作系统中运行。</p>
<ul>
<li>因为它们是独立的 Linux 进程，不依赖于 Python 线程或 executor 的存在。</li>
</ul>
</li>
<li><p><code>executor = ThreadPoolExecutor</code> 只要还有工作线程在排队，其就不会被垃圾回收。</p>
<ul>
<li>submit 的非阻塞式的，会把所有任务在瞬间提交，无论线程池是否忙碌</li>
<li>所有任务进入待执行队列。这个队列由 self._work_queue 管理，这个队列是 executor 实例的私有属性。</li>
<li>只要还有工作线程在运行（因为队列非空），executor 对象就不会被 GC（因为工作线程持有对它的弱引用或队列引用）。</li>
</ul>
</li>
</ul>
<h3 id="2-6-6- 在 GUI 中并发外部任务"><a href="#2-6-6- 在 GUI 中并发外部任务" class="headerlink" title="2.6.6 在 GUI 中并发外部任务"></a>2.6.6 在 GUI 中并发外部任务 </h3><p> 在使用 GUI 提交并发任务（任务是外部 linux 命令）时，<strong>建议在 QThread 中维持线程 / 进程池任务</strong>，不要交给外部函数，不然会有一定的风险和不便之处。</p>
<pre><code class="python">import ...

class TaskRunner(QThread):
    log_signal = pyqtSignal(str)  # 用于 GUI 日志输出

    def __init__(self):
        super().__init__()
        #...

    def run_task(self, task):
        proc = subprocess.Popen(
            cmd,
            shell=True,
            cwd=str(self.work_dir)
        )
        proc.wait()
        self.log_signal.emit(f&quot;&#123;cmd&#125; finshed&quot;)


    def run(self):
        self.log_signal.emit(&quot;xxx&quot;)
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = [executor.submit(self.run_task, cmd)
                for cmd in self.tasks
            ]
            # 可选：等待所有完成（但 GUI 不会卡，因为在线程中）
            for future in futures:
                future.result()  # 确保异常能被抛出（可选）
            ### 这部分可要可不要

        self.log_signal.emit(&quot;All tasks submitted and completed!&quot;)


class MainWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;Long-Running Task Launcher&quot;)
        self.resize(600, 400)
        #...
        self.runner = None
    #def...

    def start_tasks(self):

        if self.runner and self.runner.isRunning():
            self.append_log(&quot;⚠️ A task is already running!&quot;)
            return

        self.runner = TaskRunner(tasks, max_works, log_dir)
        self.runner.log_signal.connect(self.show_log)
        self.runner.start()   #会执行里面的 run 函数


if __name__ == &quot;__main__&quot;:
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())</code></pre>
<blockquote>
<p>上述例子中，self.runner = TaskRunner 维持了一个 TaskRunner 实例对象，由 TaskRunner 控制任务的启动</p>
<p>TaskRunner 的 run 函数会被 with…as executor 结构所阻塞</p>
</blockquote>
<h2 id="2-7- 多进程进度条"><a href="#2-7- 多进程进度条" class="headerlink" title="2.7 多进程进度条"></a>2.7 多进程进度条 </h2><p> 采用 <code>tqdm</code> 生成进度条，然后使用 labmda 操作符，将其转换为函数，然后作为回调对象。那么进程池每处理完一个任务，就会调用一次 tqdm 的 update()。从而实现多进程的进度条显示。</p>
<pre><code class="python">from tqdm import tqdm
import multiprocessing as mp
from time import sleep

def test_func(v):
    sleep(10/2-v/2)  # v 越大 运行时间越少
    return v

if __name__ == &#39;__main__&#39;:

    data = range(10)

    pbar = tqdm(total=len(data), position=0, leave=True)  #total 需要知道总数量才能计算进度百分比
    pbar.set_description(&#39;Sleep&#39;)

    update = lambda *args: pbar.update()

    n_proc = 5
    pool = mp.Pool(n_proc)
    for d in data:
        pool.apply_async(test_func, (d,), callback=update)
    pool.close()
    pool.join()
    pbar.close()</code></pre>
<h1 id="3- 多线程的实现"><a href="#3- 多线程的实现" class="headerlink" title="3. 多线程的实现"></a>3. 多线程的实现 </h1><p> 当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行流的最小单元。</p>
<p>当设置多线程时，主线程会创建多个子线程，在 python 中，主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。</p>
<p>不同线程共享同一个全局解释器锁（GIL），这意味着所有线程共享相同的全局命名空间。</p>
<p>Python 有一个全局解释器锁（GIL），它确保同一时间只有一个线程执行 Python 字节码， 并且所有线程共享相同的全局命名空间。</p>
<p>这意味着 <strong> 线程在 CPU 密集型任务中并不能真正实现并行，但在 I/O 操作时会释放 GIL，因此线程仍然适 I/O 密集型任务</strong></p>
<p>Python 的标准库提供了 <code>threading</code> 模块，来实现多线程编程。</p>
<h2 id="3-1- 基本实例"><a href="#3-1- 基本实例" class="headerlink" title="3.1 基本实例"></a>3.1 基本实例</h2><pre><code class="python">import threading
import time

def worker(name):
    &quot;&quot;&quot; 工作函数 &quot;&quot;&quot;
    for i in range(3):
        print(f&quot; 线程 &#123;name&#125; 正在工作: &#123;i&#125;&quot;)
        time.sleep(1)

# 创建线程
thread1 = threading.Thread(target=worker, args=(&quot;A&quot;,))
thread2 = threading.Thread(target=worker, args=(&quot;B&quot;,))

# 启动线程
thread1.start()
thread2.start()

# 等待线程完成
thread1.join()   # join() 阻塞当前线程，直到该线程结束（可设超时）
thread2.join()

print(&quot; 所有线程完成 &quot;)

# 输出
线程 A 正在工作: 0
线程 B 正在工作: 0
线程 B 正在工作: 1
线程 A 正在工作: 1
线程 A 正在工作: 2
线程 B 正在工作: 2
所有线程完成</code></pre>
<h2 id="3-2- 核心 Thread 功能"><a href="#3-2- 核心 Thread 功能" class="headerlink" title="3.2 核心 Thread 功能"></a>3.2 核心 Thread 功能</h2><pre><code># 构造方法
Thread(
    group=None,          # 保留参数，必须为 None
    target=None,         # 线程要执行的函数
    name=None,           # 线程名称（自动生成如 Thread-1）
    args=(),             # 传递给 target 的位置参数
    kwargs=&#123;&#125;,           # 传递给 target 的关键字参数
    daemon=None          # 是否为守护线程（默认继承主线程）
)

# 实例方法
start()                    # 启动线程（调用后会执行 run()）
join(timeout=None)        # 阻塞当前线程，直到该线程结束（可设超时）
is_alive()                # 判断线程是否仍在运行
getName() / setName()    # 获取 / 设置线程名（现推荐用 name 属性）
daemon                  # 属性，设置或获取是否为守护线程 </code></pre><h2 id="3-3- 锁"><a href="#3-3- 锁" class="headerlink" title="3.3 锁"></a>3.3 锁</h2><p> 当多个线程访问共享资源时，需要使用锁来避免竞态条件：</p>
<pre><code class="python">import threading

# 创建锁
lock = threading.Lock()
counter = 0

def increment():
    global counter
    for _ in range(100000):
        with lock:  # 使用锁保护共享资源
            counter += 1

# 创建多个线程
threads = []
for i in range(5):
    t = threading.Thread(target=increment)
    threads.append(t)
    t.start()

# 等待所有线程完成
for t in threads:
    t.join()

print(f&quot; 最终计数: &#123;counter&#125;&quot;)  #最终计数: 500000</code></pre>
<h2 id="3-4-concurrent-futures 中的线程池"><a href="#3-4-concurrent-futures 中的线程池" class="headerlink" title="3.4 concurrent.futures 中的线程池"></a>3.4 concurrent.futures 中的线程池 </h2><h3 id="3-4-1- 基本介绍"><a href="#3-4-1- 基本介绍" class="headerlink" title="3.4.1 基本介绍"></a>3.4.1 基本介绍</h3><p> 采用 <code>concurrent.futures</code> 模块。池的好处是，对于多个线程，它能进行合理调控，比如可以设置同时只能进行 5 个任务，避免 python 占用过多的电脑资源，当运行中的 5 个任务完成了其中 3 个，池会自动进行补调，保证同时 5 个任务的进行。</p>
<p><strong>线程池是一种高效管理和复用线程的工具，特别适用于 IO 密集型任务（如网络请求、文件读写）</strong></p>
<pre><code class="python">from concurrent.futures import ThreadPoolExecutor

def download_one_page(url, name):
    print(&#39;&#123;&#125; 对应的 &#123;&#125; 下载完毕 &#39;.format(url,name))

if __name__ == &quot;__main__&quot;:

    with ThreadPoolExecutor(max_workers=3) as executor:
         for url, name in result:  # 每一次循环都启动一个新的线程
             host_url = &#39;http://www.shuquge.com/txt/8659/&#39;
             executor.map(download_one_page, host_url + url, name)</code></pre>
<h3 id="3-4-2- 核心方法 ThreadPoolExecutor"><a href="#3-4-2- 核心方法 ThreadPoolExecutor" class="headerlink" title="3.4.2 核心方法 ThreadPoolExecutor"></a>3.4.2 核心方法 ThreadPoolExecutor</h3><pre><code>ThreadPoolExecutor(max_workers=None,       # 最大线程数（默认 min(32, (os.cpu_count() or 1) + 4)）
    thread_name_prefix=&quot;&quot;,  # 线程名前缀（便于调试）
    initializer=None,       # 每个工作线程启动时调用的初始化函数
    initargs=()             # 传递给 initializer 的参数)</code></pre><p><strong>执行器 ThreadPoolExecutor 的方法：</strong></p>
<p><code>submit(fn, *args, **kwargs)</code></p>
<ul>
<li>提交一个可调用对象（函数）到线程池。</li>
<li><strong>立即返回 </strong> 一个 <code>Future</code> 对象（不阻塞）。</li>
<li>适合不同函数或不同参数组合的任务。</li>
</ul>
<p><code>map(fn, *iterables, timeout=None, chunksize=1)</code></p>
<ul>
<li>将 <code>fn</code> 应用于 <code>iterables</code> 中的每个元素。</li>
<li>返回一个 <strong> 结果迭代器</strong>（惰性求值）。结果在遍历时才逐个获取。不直接返回 <code>Future</code>，无法单独设置回调</li>
<li>默认按输入顺序返回结果（即使任务完成顺序不同）。</li>
</ul>
<p><code>shutdown(wait=True)</code></p>
<ul>
<li>关闭线程池，不再接受新任务。</li>
<li>若 <code>wait=True</code>（默认），则等待所有已提交任务完成。</li>
<li>使用 <code>with</code> 语句时会自动调用。</li>
</ul>
<h3 id="3-4-3-submit 示例"><a href="#3-4-3-submit 示例" class="headerlink" title="3.4.3 submit 示例"></a>3.4.3 submit 示例</h3><pre><code class="python">from concurrent.futures import ThreadPoolExecutor
from concurrent.futures import as_completed
import time

def task(name, delay):
    time.sleep(delay)
    return f&quot;&#123;name&#125; 完成，耗时 &#123;delay&#125;s&quot;

with ThreadPoolExecutor(max_workers=3) as executor:
    # 提交多个任务
    futures = [executor.submit(task, &quot;A&quot;, 2),
        executor.submit(task, &quot;B&quot;, 1),
        executor.submit(task, &quot;C&quot;, 3)
    ]

    # 按完成顺序获取结果（as_completed）
    for future in as_completed(futures):
        print(future.result())

### 输出顺序可能是 B → A → C（按完成时间），因为 as_completed 返回的是最先完成的任务。</code></pre>
<ul>
<li>每次调用返回一个 <code>Future</code> 对象</li>
<li>可以混合不同函数、不同参数</li>
<li>需手动收集 <code>Future</code> 并调用 <code>.result()</code></li>
<li>支持 <code>add_done_callback</code> 回调</li>
<li>结果默认 <strong> 不保序</strong>（除非按原列表顺序遍历）</li>
</ul>
<p><code>submit()</code> 返回的 <code>Future</code> 对象代表一个 <strong> 异步计算的结果</strong>，提供以下方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>result(timeout=None)</code></td>
<td>获取结果（阻塞，可设超时）</td>
</tr>
<tr>
<td><code>exception(timeout=None)</code></td>
<td>获取任务抛出的异常（若有）</td>
</tr>
<tr>
<td><code>done()</code></td>
<td>判断任务是否完成（True/False）</td>
</tr>
<tr>
<td><code>add_done_callback(fn)</code></td>
<td>注册回调函数（任务完成后自动调用）</td>
</tr>
</tbody></table>
<h3 id="3-4-4-map 示例"><a href="#3-4-4-map 示例" class="headerlink" title="3.4.4 map 示例"></a>3.4.4 map 示例</h3><pre><code class="python">from concurrent.futures import ThreadPoolExecutor
import time

def task(name, delay):
    time.sleep(delay)
    return f&quot;&#123;name&#125; 完成，耗时 &#123;delay&#125;s&quot;

with ThreadPoolExecutor(max_workers=3) as executor:
    names = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]
    delays = [2, 1, 3]

    results = executor.map(task, names, delays)

    # 按输入顺序输出结果（即使 C 先完成，也会等 A、B 按序输出）
    for res in results:
        print(res)</code></pre>
<ul>
<li>所有任务调用 <strong> 同一个函数</strong></li>
<li>输入是 <strong> 可迭代对象</strong>（如列表、元组），自动打包参数并分发任务</li>
<li>希望结果 <strong> 按输入顺序返回</strong>，结果在遍历时才逐个获取。不直接返回 <code>Future</code>，无法单独设置回调</li>
</ul>
<h3 id="3-4-5- 高级功能"><a href="#3-4-5- 高级功能" class="headerlink" title="3.4.5 高级功能"></a>3.4.5 高级功能</h3><ol>
<li>按完成顺序处理任务：<code>as_completed</code></li>
</ol>
<pre><code class="python">from concurrent.futures import as_completed

if __name__ == &#39;__main__&#39;:
    with ProcessPoolExecutor() as executor:
        futures = [executor.submit(time.sleep, t) or t for t in [3, 1, 2]]
        # 注意：上面写法不严谨，仅示意；实际应封装函数

        # 谁先完成就先处理
        for future in as_completed(futures):
            print(f&quot; 任务完成: &#123;future.result()&#125;&quot;)</code></pre>
<ol start="2">
<li>等待一组任务：<code>wait</code></li>
</ol>
<pre><code class="python">from concurrent.futures import wait, FIRST_COMPLETED

futures = [executor.submit(task, i) for i in range(5)]

# 等待第一个任务完成
done, not_done = wait(futures, return_when=FIRST_COMPLETED)
print(f&quot; 已完成: &#123;len(done)&#125;, 未完成: &#123;len(not_done)&#125;&quot;)</code></pre>
<ol start="3">
<li>回调函数：<code>add_done_callback</code></li>
</ol>
<pre><code class="python">from concurrent.futures import ThreadPoolExecutor, wait
import time
import random

# 模拟一个耗时任务（I/O 密集型）
def task(task_id):
    # ...
    return result

# 回调函数：接收一个 Future 对象作为参数
def callback(future):
    try:
        result = future.result()  # 获取任务结果
        print(f&quot; 回调函数收到结果: &#123;result&#125;&quot;)
    except Exception as exc:
        print(f&quot; 任务发生异常: &#123;exc&#125;&quot;)

# 主程序
if __name__ == &quot;__main__&quot;:
    with ThreadPoolExecutor(max_workers=3) as executor:
        futures = []
        for i in range(5):
            future = executor.submit(task, i)
            future.add_done_callback(callback)  # 注册回调, 一旦任务完成，就会自动回调
            futures.append(future)

        # 可选：等待所有任务完成（其实 with 语句已隐式等待）
        wait(futures)</code></pre>
<h1 id="4- 协程示例"><a href="#4- 协程示例" class="headerlink" title="4. 协程示例"></a>4. 协程示例 </h1><p>async/await 关键字是出现在 python3.5 版本中的新功能，是一种关于<strong> 协程 </strong> 的语法糖。从此 python 就正式有了原生协程的概念。</p>
<p>正常的函数在执行时是不会中断的，所以你要写一个能够中断的函数，就需要添加 async 关键词。</p>
<p><code>async</code> 用来声明一个函数为异步函数，异步函数的特点是能在函数执行过程中挂起，去执行其他异步函数，等到挂起条件消失后，再回来执行。</p>
<p><code>await</code> 用来声明程序挂起，比如异步程序执行到某一步时需要等待的时间很长，就将此挂起，去执行其他的异步程序，await 后面只能跟异步程序函数或有 <code>__await__</code> 属性的对象，也就是说 await 表达式中的对象必须是 awaitable 的。</p>
<p>awaitable 对象必须满足如下条件中其中之一：</p>
<ul>
<li><strong>原生协程对象</strong></li>
<li>types.coroutine()修饰的 <strong> 基于生成器的协程对象</strong></li>
<li>实现了 await method，并在其中返回了<strong>iterator 的对象（可迭代对象）</strong></li>
</ul>
<p><strong>举例一：</strong></p>
<pre><code class="python">def main():

    //1、定义异步函数
    async def funcA():             #声明 funcA 为一个异步函数（或者叫协程函数）
        await asyncio.sleep(4)
        print(&#39;A 函数执行完毕 &#39;)

    async def funcB():              #定义的协程函数就是原生协程对象
        await asyncio.sleep(2)
        print(&#39;B 函数执行完毕 &#39;)

    async def funcD():
        await asyncio.sleep(8)
        print(&#39;D 函数执行完毕 &#39;)

    //2、创建一个事件循环    
    loop = asyncio.get_event_loop() 

    //3、将异步函数加入事件队列
    tasks=[funcA(),funcB(),funcD()]

    //4、执行事件队列, 直到最晚的一个事件被处理完毕后结束
    loop.run_until_complete(asyncio.wait(tasks))

    //5、如果不再使用 loop, 建议养成良好关闭的习惯
    loop.close()

if __name__==&#39;__main__&#39;:
    start=time.time()
    main()
    end=time.time()
    print(&#39; 总耗时为：&#39;+ str(end-start))

#输出结果为：
B 函数执行完毕
A 函数执行完毕
D 函数执行完毕
总耗时为：8.006016969680786s
</code></pre>
<p><strong>举例二：</strong></p>
<pre><code class="python">import asyncio
import requests
import time


async def download(url): 
    print(&quot;get %s&quot; % url)    
    response = requests.get(url)
    print(response.status_code)


async def wait_download(url):
    await download(url)        # 这里 download(url)就是一个原生的协程对象
    print(&quot;get &#123;&#125; data complete.&quot;.format(url))


async def main():
    start = time.time()
    await asyncio.wait([wait_download(&quot;http://www.163.com&quot;),
        wait_download(&quot;http://www.mi.com&quot;),
        wait_download(&quot;http://www.baidu.com&quot;)])
    end = time.time()
    print(&quot;Complete in &#123;&#125; seconds&quot;.format(end - start))


loop = asyncio.get_event_loop()
loop.run_until_complete(main())

#运行结果：
get http://www.163.com
200
get http://www.163.com data complete.
get http://www.baidu.com
200
get http://www.baidu.com data complete.
get http://www.mi.com
200
get http://www.mi.com data complete.
Complete in 0.49027466773986816 seconds</code></pre>
<p>程序可以运行，不过仍然有一个问题就是：它并没有真正地异步执行。</p>
<p>这里程序始终是同步执行的，这就说明仅仅是把涉及 I/O 操作的代码封装到 async 当中是不能实现异步执行的。必须使用支持异步操作的非阻塞代码才能实现真正的异步。目前支持非阻塞异步 I/O 的库是 aiohttp。</p>
<pre><code class="python">import asyncio
import aiohttp
import time

async def download(url): # 通过 async def 定义的函数是原生的协程对象
    print(&quot;get: %s&quot; % url)
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            print(resp.status)
            # response = await resp.read()

# 此处的封装不再需要
# async def wait_download(url):
#    await download(url) 
#    print(&quot;get &#123;&#125; data complete.&quot;.format(url))


async def main():
    start = time.time()
    await asyncio.wait([download(&quot;http://www.163.com&quot;),
        download(&quot;http://www.mi.com&quot;),
        download(&quot;http://www.baidu.com&quot;)])
    end = time.time()
    print(&quot;Complete in &#123;&#125; seconds&quot;.format(end - start))


loop = asyncio.get_event_loop()
loop.run_until_complete(main())

#测试结果：
get: http://www.mi.com
get: http://www.163.com
get: http://www.baidu.com
200
200
200
Complete in 0.27292490005493164 seconds</code></pre>
<p>可以看出这次是真正的异步了。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎各位看官及技术大佬前来交流指导呀，可以邮件至 jqiange@yeah.net </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2021 Jqiange
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
