<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>tcl 语言入门</title>
      <link href="/tcl%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
      <url>/tcl%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1- 简介"><a href="#1- 简介" class="headerlink" title="1. 简介"></a>1. 简介 </h1><p>TCL（Tool Command Language，工具命令语言）是一种功能强大且易于学习的<strong> 脚本语言</strong>，广泛应用于快速开发、测试自动化、过程控制及嵌入式系统等领域。</p><ul><li><p><strong>来源</strong>：TCL 最初由 John Ousterhout 于 1980 年代末在加州大学伯克利分校开发，用于创建用户界面工具。</p></li><li><p><strong>特点</strong>：简单灵活、内置字符串处理功能强大、易于嵌入到其他应用程序中。</p></li><li><p><strong>运行 TCL 脚本</strong>：使用 tclsh 命令来执行 TCL 脚本文件，例如 tclsh script.tcl。</p></li></ul><h2 id="1-1- 语言特点"><a href="#1-1- 语言特点" class="headerlink" title="1.1 语言特点"></a>1.1 语言特点</h2><ul><li><p>一个 TCL 脚本可以包含一个或多个命令。</p></li><li><p>命令之间必须用换行符或分号隔开。</p></li><li><p>TCL 的每一个命令包含一个或几个单词，第一个单词代表命令名，另外的单词则是这个命令的 <br> 参数，单词之间必须用空格或 TAB 键隔开。</p></li><li><p>使用 <code>#</code> 进行注释</p></li></ul><p>TCL 解释器对一个命令的求值过程分为两部分：分析和执行。</p><ul><li>在分析阶段，TCL 解释器运用规 则把命令分成一个个独立的单词，同时进行必要的置换(substitution)；</li><li>在执行阶段，TCL 解释器会把第一个单词当作命令名，并查看这个命令是否有定义，如果有定义就激活这个命令对应 的 C/C++ 过程，并把所有的单词作为参数传递给该命令过程，让命令过程进行处理。</li></ul><h1 id="2- 开始 TCL"><a href="#2- 开始 TCL" class="headerlink" title="2. 开始 TCL"></a>2. 开始 TCL</h1><h2 id="2-1 变量声明与赋值"><a href="#2-1 变量声明与赋值" class="headerlink" title="2.1 变量声明与赋值"></a>2.1 变量声明与赋值</h2><h3 id="2-1-1- 赋值与输出"><a href="#2-1-1- 赋值与输出" class="headerlink" title="2.1.1 赋值与输出"></a>2.1.1 赋值与输出</h3><blockquote><p>TCL 中基本数据类型只有一种：字符串类型，tcl 的所有数据类型最终都可以表示为字符串。</p><p>赋值时无需声明变量类型。</p></blockquote><p>变量声明语法：<code>set 变量名 数据</code></p><p>数据类型分为：</p><ul><li>字符串或数字。引号可带可不带，当字符串中有空格时，才必须加引号；数字内部存储为字符串</li><li>列表，用大括号（花括号）表示</li><li>数组</li><li>句柄</li></ul><pre><code class="tcl">#!/bin/tclshset aa &quot;hello world&quot;            ;# 字符串set bb    10                      ;# 字符串set cc &#123;red bule green&#125;         ;# 列表set marks(english) 92           ;# 数组set myfile [open &quot;filename&quot; r]  ;# 句柄unset cc marks myfileputs $aaputs $bb</code></pre><p>使用 <strong>puts</strong> 来输出变量的值：<code>puts  $ 变量名</code></p><p>使用 <strong>unset</strong> 来删除变量：<code>unset 变量名 1 变量名 2...</code></p><p>一个 TCL 的简单变量包含两个部分：名字和值。名字和值都可以是任意字符串。</p><p>例如一个名为“1323 7&amp;*: hdgg”的变量在 TCL 中都是合法的。不过为了更好的使用置换(substitution)， 变量名最好按 C\C++ 语言中标识符的命名规则命名。 TCL 解释器在分析一个变量置换时，只把从＄符号往后直到第一个不是字母、数字或下划线的字符之间的单词符号作为要被置换的变量的名字。</p><p>为了界定变量名的开始和结束，建议使用 <code>&#123; &#125;</code> 限制变量名</p><p>TCL 中的 set 命令能生成一个变量、也能读取或改变一个变量的值。</p><h3 id="2-1-2- 更改变量"><a href="#2-1-2- 更改变量" class="headerlink" title="2.1.2 更改变量"></a>2.1.2 更改变量</h3><ul><li>append: 加文本</li><li>incr：加值</li></ul><pre><code class="tcl">#!/bin/tclshset aa &quot;hello&quot;append aa &quot; world&quot;puts $aa ;# 输出：hello worldset x1 10incr x1 1puts $x1 ; 输出：11</code></pre><h2 id="2-2- 置换"><a href="#2-2- 置换" class="headerlink" title="2.2 置换"></a>2.2 置换</h2><blockquote><p>TCL 解释器在分析命令时，把所有的命令参数都当作字符串看待</p></blockquote><h3 id="2-2-1- 变量置换 -variable-subtitution"><a href="#2-2-1- 变量置换 -variable-subtitution" class="headerlink" title="2.2.1 变量置换 variable subtitution"></a>2.2.1 变量置换 variable subtitution</h3><p>变量置换由一个 <strong>＄</strong> 符号标记，变量置换会将变量代表的值进行替换。</p><pre><code class="tcl">#!/bin/tclshset x 10set y $x+100puts $y ;# 输出为：10+100</code></pre><p>这时，y 的值还不是我们想要的值 110，而是 10+100，因为 TCL 解释器把 10+100 看成是一个字符串而不是表达式，y 要想得到值 110，还必须用命令置换，使得 TCL 会把 10+100 看成一个表达式并求值。  </p><h3 id="2-2-2- 命令置换 -command-substitution"><a href="#2-2-2- 命令置换 -command-substitution" class="headerlink" title="2.2.2 命令置换 command substitution"></a>2.2.2 命令置换 command substitution</h3><p>命令置换是由 <strong>[]</strong> 括起来的 TCL 命令及其参数，命令置换会导致某一个命令的所有或部分单词被另一个命令的结果所代替。</p><pre><code class="tcl">#!/bin/tclshset x 10set y [expr $x+100]puts $y ; #输出为：110</code></pre><p>当 TCL 解释器遇到字符’[‘时，它就会把随后的 expr 作为一个命令名，从 而激活与 expr 对应的 C/C++ 过程，并把’expr’和变量置换后得到的’10+110’传递给该命令过 程进行处理。  </p><p>注意，[]中必须是一个合法的 TCL 脚本，长度不限。</p><p>[]中脚本的值为最后一个命令的返回值， 例如：  </p><pre><code class="tcl">#!/bin/tclshset y [expr $x+100;set b 300]puts $y ; #输出为：300</code></pre><p>有了命令置换，实际上就表示命令之间是可以嵌套的，即一个命令的结果可以作为别的命令的参数。</p><h3 id="2-2-3- 反斜杠置换 -backslash-substitution"><a href="#2-2-3- 反斜杠置换 -backslash-substitution" class="headerlink" title="2.2.3 反斜杠置换(backslash substitution)"></a>2.2.3 反斜杠置换(backslash substitution)</h3><p>TCL 语言中的反斜杠置换类似于 C 语言中反斜杠的用法，主要用于在单词符号中插入诸如换行符、空格、[、$ 等被 TCL 解释器当作特殊符号对待的字符。</p><p>反斜杠置换符 <code>\</code> 主要用于连接两行或者取消空格的分隔符属性，或者取消其他的特殊符号的作用</p><pre><code class="tcl">#!/bin/tclshset aa hello\ world; #空格为分隔符, \ 后接空格会取消空格的分割作用set x 10set y \$xputs $y   ; #输出为 $x</code></pre><h2 id="2-3- 双引号和括号"><a href="#2-3- 双引号和括号" class="headerlink" title="2.3 双引号和括号"></a>2.3 双引号和括号 </h2><p>TCL 解释器对双引号<code>&quot; &quot;</code> 中的各种分隔符将不作处理，但是对换行符及 <code>＄</code> 和<code>[]</code>两种置换符会照常处理。例如：  </p><pre><code class="tcl">#!/bin/tclshset aa &quot;hello world&quot;set bb &quot;$aa nihao!&quot;</code></pre><p>而在花括号 <code>&#123; &#125;</code> 中，所有特殊字符都将成为普通字符，失去其特殊意义，TCL 解释器不会对其作特 殊处理。例如：</p><pre><code class="tcl">#!/bin/tclshset bb &#123;$aa nihao!&#125;</code></pre><h2 id="2-4- 注释"><a href="#2-4- 注释" class="headerlink" title="2.4 注释"></a>2.4 注释</h2><p>TCL 中的注释符是’＃’，’＃’和直到所在行结尾的所有字符都被 TCL 看作注释，TCL 解释器对注释将不作任何处理。不过，要注意的是，’＃’必须出现在 TCL 解释器期望命令的第一个字符出现的地方，才被当作注释。  </p><pre><code class="tcl">#!/bin/tclsh#This is a comment  set a 100 # Not a comment  wrong # args: should be &quot;set varName ?newValue?&quot;  set b 101 ; # this is a comment  </code></pre><blockquote><p>要在命令行后面写注释，需要用分号分隔符</p></blockquote><p>第二行中’＃’就不被当作注释符，因为它出现在命令的中间，TCL 解释器把它和后面的字符当作命令的参数处理，从而导致错误。而第四行的’＃’就被作为注释，因为前一个命令已经用一个分号结束，TCL 解释器期望下一个命令接着出现。现在在这个位置出现’#’，随后的字符就被当作注释了。 </p><h2 id="2-5- 数组"><a href="#2-5- 数组" class="headerlink" title="2.5 数组"></a>2.5 数组 </h2><p> 数组是一些元素的集合。TCL 的数组和普通计算机语言中的数组有很大的区别。在 TCL 中，不能单独声明一个数组，数组只能和数组元素一起声明。数组中，数组元素的名字包含两部分：数组名和数组中元素的名字，TCL 中数组元素的名字（下标〕可以为任何字符串。例如：</p><pre><code class="tcl">#!/bin/tclshset day(monday) 1  set day(tuesday) 2</code></pre><p>第一个命令生成一个名为 day 的数组，同时在数组中生成一个名为 monday 的数组元素，并把值置为 1，第二个命令生成一个名为 tuesday 的数组元素，并把值置为 2。</p><p>monday 和 tuesday 可以理解为数组的下标。</p><pre><code class="tcl">#!/bin/tclshset day(monday) 1  set b $day(monday); #b 的值为 1</code></pre><p>获取数组元素个数：</p><pre><code>[array size variablename]</code></pre><h2 id="2-6- 操作数"><a href="#2-6- 操作数" class="headerlink" title="2.6 操作数"></a>2.6 操作数</h2><p>TCL 表达式的操作数通常是整数或实数。整数一般是十进制的， 但如果整数的第一个字符是 0(zero)，那么 TCL 将把这个整数看作八进制的，如果前两个字符是 0x 则这个整数被看作是十 六进制的。TCL 的实数的写法与 ANSI C 中完全一样。</p><p><code>2.1  7.9e+12   6e4   3.</code>等都是合法的数字书写方式。</p><p>TCL 支持多种运算符，比如 算术运算符，关系运算符，逻辑运算符，按位运算符，三元运算符等。参阅<a href="https://www.w3ccoo.com/tcl-tk/tcl_operators.html">Tcl 运算符 | Tcl/Tk 教程</a></p><p>TCL 支持常用的数学函数，表达式中数学函数的写法类似于 C\C++ 语言的写法。参阅<a href="https://www.w3ccoo.com/tcl-tk/tcl_builtin_functions.html">Tcl - 内置函数</a></p><p>这里额外介绍下条件运算符</p><p><code>exp?:value1:value2</code></p><pre><code class="tcl">#!/usr/bin/tclshset a 10;set b [expr $a == 1 ? 20: 30]puts &quot;Value of b is $b\n&quot;set b [expr $a == 10 ? 20: 30]puts &quot;Value of b is $b\n&quot;</code></pre><h2 id="2-7- 列表"><a href="#2-7- 列表" class="headerlink" title="2.7 列表"></a>2.7 列表</h2><p>list 这个概念在 TCL 中是用来表示集合的。TCL 中 list 是由一堆元素组成的有序集合，list 可以嵌套定义，list 每个元素可以是任意字符串，也可以是 list。下面都是 TCL 中的合法的 list：</p><p>{} // 空 list  </p><p>{a b c d}  </p><p>{a {b c} d}  //list 可以嵌套 </p><h3 id="2-7-1- 创建列表"><a href="#2-7-1- 创建列表" class="headerlink" title="2.7.1 创建列表"></a>2.7.1 创建列表</h3><pre><code class="tcl">set listName &#123; item1 item2 item3 .. itemn &#125;# orset listName [list item1 item2 item3]# or set listName [split &quot;items separated by a character&quot; split_character]</code></pre><h3 id="2-7-2- 列表方法"><a href="#2-7-2- 列表方法" class="headerlink" title="2.7.2 列表方法"></a>2.7.2 列表方法 </h3><p><code>concat listN1 listN2...</code> 合并多个 list</p><p><code>lindex list index</code> 返回 list 的第 index 个 (0-based) 元素</p><p><code>llength list</code>返回 list 的元素个数</p><p><code>linsert list index value1 value2...</code>插入新的元素</p><p><code>lreplace list first last value1 value2 ...</code>替换成新的元素</p><p><code>lrange list first last</code>切片</p><p><code>lappend varname value1 value2...</code>附加新元素</p><p><code>lsearch -exact -glob -regexp list pattern</code>  返回匹配到的索引</p><ul><li>-exact、-glob、 -regexp 是三种模式匹配的技术。</li><li>-exact 表示精确匹配；-glob 的匹配方式和 string match 命令的匹配方式相同；-regexp 表示正规表达式匹配</li></ul><p><code>lsort options list</code> 排序</p><ul><li>-ascii 按 ASCII 字符的顺序排序比较，默认方式</li><li>-dictionary 按字典排序，与 -ascii 不同的地方是不考虑大小写，如果元素中有数字的话, 数字被当作整数来排序</li><li>-integer 把 list 的元素转换成整数, 按整数排序. </li><li>-real 把 list 的元素转换成浮点数, 按浮点数排序. </li><li>-increasing 升序(按 ASCII 字符比较) </li><li>-decreasing 降序(按 ASCII 字符比较) </li><li>-command command TCL 自动利用 command 命令把每两个元素一一比较, 然后给出排序 <br> 结果。  </li></ul><p><code>split string splitChars</code> 分割字符串成 list</p><ul><li>如果 splitChars 没有给出, 以空格为分隔符</li></ul><p><code>join list joinString</code>  合并 list 为字符串</p><h2 id="2-8- 控制流"><a href="#2-8- 控制流" class="headerlink" title="2.8 控制流"></a>2.8 控制流</h2><p>TCL 中的控制流和 C 语言类似，包括 if、while、for、foreach、switch、break、continue 等命令。 </p><h3 id="2-8-1-if"><a href="#2-8-1-if" class="headerlink" title="2.8.1 if"></a>2.8.1 if</h3><p>语法为：</p><pre><code>if &#123; $x&gt;0 &#125; &#123;  .....  &#125;elseif&#123; $x＝＝1 &#125; &#123;  .....  &#125;elseif &#123; $x＝＝2 &#125; &#123;  ....  &#125;else&#123;  .....  &#125;  </code></pre><blockquote><p>注意，上例中’{‘一定要写在上一行，因为如果不这样，TCL 解释器会认为 if 命令在换行符处已结束，下一行会被当成新的命令，从而导致错误的结果。</p></blockquote><h3 id="2-8-2-for"><a href="#2-8-2-for" class="headerlink" title="2.8.2 for"></a>2.8.2 for</h3><p>语法为：</p><pre><code class="tcl">#!/bin/tclshfor &#123; set i 0&#125; &#123;$i &lt; 10 &#125; &#123;incr i&#125; &#123;    puts &quot;value of a: $a&quot;&#125;</code></pre><h3 id="2-8-3-foreach"><a href="#2-8-3-foreach" class="headerlink" title="2.8.3 foreach"></a>2.8.3 foreach</h3><p>语法为：</p><pre><code class="tcl">#!/bin/tclshset values &#123;0 1 2 3 4 5&#125;foreach item $values &#123;    puts $item&#125;</code></pre><p>还有另一种方式：成对取值</p><pre><code class="tcl">set x &#123;&#125;  foreach &#123;i j&#125; &#123;a b c d e f&#125; &#123;      lappend x $j $i  &#125;  #这时总共有三次循环，x 的值为 &quot;b a d c f e&quot;。 set x &#123;&#125;  foreach i &#123;a b c&#125; j &#123;d e f g&#125; &#123;      lappend x $i $j  &#125;  #这时总共有四次循环，x 的值为 &quot;a d b e c f &#123;&#125; g&quot;。set x &#123;&#125;  foreach i &#123;a b c&#125; &#123;j k&#125; &#123;d e f g&#125; &#123;  lappend x $i $j $k  &#125;  #这时总共有三次循环，x 的值为 &quot;a d e b f g c &#123;&#125; &#123;&#125;&quot;。</code></pre><h3 id="2-8-4-while"><a href="#2-8-4-while" class="headerlink" title="2.8.4 while"></a>2.8.4 while</h3><p>语法为：</p><pre><code>while &#123;$i &gt; 0&#125; &#123;...&#125;</code></pre><p>在循环体中，可以用 break 和 continue 命令中断循环。</p><p>其中 break 命令结束整个循环过程， 并从循环中跳出</p><p>continue 只是结束本次循环。 </p><h3 id="2-8-5-switch"><a href="#2-8-5-switch" class="headerlink" title="2.8.5 switch"></a>2.8.5 switch</h3><p>switch 命令的语法为: </p><p>switch options string {pattern body pattern body …} </p><p>第一个是可选参数 options，表示进行匹配的方式。TCL 支持三种匹配方式：</p><ul><li><p>-glob 方式的匹配方式和 string match 命令的匹配方式相同，缺省情况表示 -glob 方式。</p></li><li><p>-exact 方式表示的是精确匹配</p></li><li><p>-regexp 方式是正规表达式的</p></li></ul><p>第二个参数 string 是要被用来作测试的值，第三个参数是括起来的一个或多个元素对。</p><p>例子：</p><pre><code class="tcl">switch $grade  &#123;    A &#123; puts &quot;Well done!&quot; &#125;      B &#123; puts &quot;Excellent!&quot; &#125;      C &#123; puts &quot;You passed!&quot;  &#125;     F &#123; puts &quot;Better try again&quot;   &#125;       default &#123;     puts &quot;Invalid grade&quot;   &#125;&#125;</code></pre><h2 id="2-9- 过程 procedure"><a href="#2-9- 过程 procedure" class="headerlink" title="2.9 过程 procedure"></a>2.9 过程 procedure</h2><p>TCL 支持过程的定义和调用，在 TCL 中，过程可以看作是用 TCL 脚本实现的命令，效果与 TCL 的固有命令相似。我们可以在任何时候使用 proc 命令定义自己的过程，TCL 中的过程类似于 C 中的函数。  </p><p>语法为：</p><pre><code>proc name &#123; 形参 1 形参 2 ...&#125; &#123;    ...&#125;</code></pre><p>举个例子：</p><pre><code class="tcl">proc add &#123;x y &#125; &#123;    expr $x+$y&#125;proc abs &#123;x&#125; &#123;  if &#123;$x &gt;= 0&#125; &#123; return $x &#125;      return [expr -$x]  &#125;proc add &#123;val1 &#123;val2 2&#125; &#123;val3 3&#125;&#125;&#123;      expr $val1+$val2+$val3  &#125;  #给 val2 和 val3 指定默认值</code></pre><h2 id="2-10- 字典"><a href="#2-10- 字典" class="headerlink" title="2.10 字典"></a>2.10 字典 </h2><h3 id="2-10-1- 字典定义"><a href="#2-10-1- 字典定义" class="headerlink" title="2.10.1 字典定义"></a>2.10.1 字典定义</h3><p> 字典是将值映射到键的一种安排。 传统字典的语法如下所示：</p><p><code>dict set dictname key value</code></p><p>或者：</p><p><code>dict create dictname key1 value1 key2 value2 .. keyn valuen</code></p><p>举例说明：</p><pre><code class="tcl">set colours [dict create colour1 &quot;black&quot; colour2 &quot;white&quot;]puts $coloursdict set colours  colour3 red dict set colours  colour4 greenputs $colours</code></pre><h3 id="2-10-2- 字典的使用"><a href="#2-10-2- 字典的使用" class="headerlink" title="2.10.2 字典的使用"></a>2.10.2 字典的使用 </h3><p> 获取字典键值对个数：<code>[dict size dictname]</code></p><p>字典中的所有键：<code>[dict keys $dictname]</code></p><p>字典中是否存在键：<code>[dict exists $dictname $key]</code></p><p>根据键获取值：<code>[dict get $dictname $keyname]</code></p><p>字典中的所有值：<code>[dict values $dictname]</code></p><p>字典的迭代：</p><pre><code class="tcl">set colours [dict create colour1 &quot;black&quot; colour2 &quot;white&quot;]foreach item [dict keys $colours] &#123;   set value [dict get $colours $item]   puts $value&#125;</code></pre><h2 id="2-11- 全局变量和局部变量"><a href="#2-11- 全局变量和局部变量" class="headerlink" title="2.11 全局变量和局部变量"></a>2.11 全局变量和局部变量 </h2><p> 对于在过程中定义的变量，因为它们只能在过程中被访问，并且当过程退出时会被自动删除，所以称为局部变量；在所有过程之外定义的变量我们称之为全局变量。TCL 中，局部变量和全局变量可以同名，两者的作用域的交集为空：局部变量的作用域是它所在的过程的内部；全局变量的作用域则不包括所有过程的内部。</p><p>如果我们想在过程内部引用一个全局变量的值，可以使用 global 命令</p><pre><code class="tcl">proc sample &#123; x &#125; &#123;      global a      incr a      return [expr $a+$x]  &#125;  </code></pre><p>全局变量 a 在过程中被访问。在过程中对 a 的改变会直接反映到全局上。如果去掉语句 global a，TCL 会出错，因为它不认识变量 a。</p><h2 id="2-12- 系统函数"><a href="#2-12- 系统函数" class="headerlink" title="2.12 系统函数"></a>2.12 系统函数</h2><p>Tcl 中重要的系统函数包括，</p><ul><li><strong>clock seconds</strong> − 秒函数，返回当前时间（以秒为单位）。</li><li><strong>clock format</strong> − format 函数，将秒格式化为日期和时间。</li><li><strong>clock scan</strong> − scan 函数，扫描输入字符串并将其转换为秒。</li><li><strong>open</strong> − 函数，用于打开文件。</li><li><strong>exec</strong> − 函数，用于执行系统命令。</li><li><strong>close</strong> − 函数，用于关闭文件。</li></ul><p>下面给些示例：</p><pre><code class="tcl">#!/usr/bin/tclsh#get secondsset currentTime [clock seconds]puts $currentTime#get format puts &quot;The time is: [clock format $currentTime -format %H:%M:%S]&quot;puts &quot;The date is: [clock format $currentTime -format %D]&quot;set date &quot;Jun 15, 2014&quot;puts [clock scan $date -format &#123;%b %d, %Y&#125;]puts [exec ls]puts [exec dir]set a  [open input.txt]puts [read $a];puts $aclose $a</code></pre><h2 id="2-13- 面向对象编程"><a href="#2-13- 面向对象编程" class="headerlink" title="2.13 面向对象编程"></a>2.13 面向对象编程</h2><p>tcl 支持面向对象编程（OOP），主要通过扩展库实现。它类似于 C++ 对 C 的扩展，为 Tcl 提供了更结构化的编程方式，同时保持了 Tcl 的灵活性和简洁性。</p><p><strong>类和对象</strong> 是 Tcl 面向对象编程的基础。</p><p>类是对象的模板，定义了变量和方法。对象是类的实例，拥有独立的数据和行为。</p><p>以下是一个简单的类定义示例：</p><pre><code class="tcl">package require Itclnamespace import itcl::*itcl::class Person &#123;    variable name    variable age    constructor &#123;name age&#125; &#123;        set this-&gt;name $name        set this-&gt;age $age    &#125;    method introduce &#123;&#125; &#123;        return &quot;Hi, I am $name and I am $age years old.&quot;    &#125;&#125;# 创建对象并调用方法set person [Person new &quot;Alice&quot; 25]puts [$person introduce]</code></pre><p>Tcl 的 OOP 还支持以下特性：</p><ol><li><strong>继承</strong>：通过 <em>inherit</em> 关键字实现类的继承，子类可以复用父类的变量和方法。</li><li><strong>多态</strong>：子类可以重写父类的方法，实现不同的行为。</li><li><strong>封装</strong>：支持 <em>public<em>、</em>protected</em> 和 <em>private</em> 修饰符，用于控制变量和方法的访问权限。</li></ol><p>Tcl 使用命名空间（<em>namespace</em>）来组织代码，避免命名冲突。命名空间可以包含变量、过程和类。</p><p>这里不做更多介绍，熟悉 c/c++ 语言的朋友（正是笔者在下！）对 tcl 的类应该会举一反三，这些特性非常相似。而且一般 tcl 中我们也用不到继承多态封装的一些高级技术。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>故事会与企业股权架构设计</title>
      <link href="/%E6%95%85%E4%BA%8B%E4%BC%9A%E4%B8%8E%E4%BC%81%E4%B8%9A%E8%82%A1%E6%9D%83%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/%E6%95%85%E4%BA%8B%E4%BC%9A%E4%B8%8E%E4%BC%81%E4%B8%9A%E8%82%A1%E6%9D%83%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>拿手机刷着视频，偶然刷到一个叫 <strong> 冯唐 </strong> 的个人账号，他自我介绍着履历，什么协和医院博士啊，麦肯锡（ps: 全球领先咨询公司）合伙人啊，中信资本高管啊，华润医疗 CEO 啊，著名作家啊等，甚是震惊，怎么一个人可以做到这样的成绩。</p><p>虽然之前有听说这号人（也没仔细查过，就感觉名字有点碰瓷王勃的《滕王阁序》里的“冯唐易老，李广难封”），印象中他只是个作家，没想到还有如此背景。于是百科了他，才知道他所言不假，作为一个医科专业博士，在其他领域也如此成功，比如著作小说有多篇长篇小说，中篇小说，短篇小说，散文集，是一个将医生，商人，作家三种职业集于一身的顶尖男人，更加震惊与好奇，倍感自己的渺小！</p><p>在检索冯唐的同时，看见了“老罗（罗永浩）背后的男人冯唐”相关的词条，哎？罗永浩怎么也认识这么牛逼的男人？二人关系还如此之好！进一步查阅发现，据说罗永浩是早期来北京混的时候，碰巧租了冯唐的房子，二人才得以结识，并发展为好朋友的。这是何等的机遇，租个房子能租到如此贵人，果然名人就是有 BUF 加成，叠加各种利好。</p><p>我们更为熟知的是，老罗做锤子手机背负了约 6 个亿的债务（暂不算后续新加的），却不知道是冯唐帮助了他偿还了这些债务。当初老罗进入直播带货领域，想趁着这波风口大赚一笔，却被冯唐告诫，“赚差价的都是小生意，想要还清 6 个亿的债务，最少也要六七年”，在冯唐的帮助下，搭建了罗永浩的“交个朋友”的商业版图，以直播带货造势打造商业流量，进行资本运作，最终在 2020 年某电缆公司以 5.89 亿的价格收购了罗永浩的成都星空野望 40% 的股份，借此才还了 6 个亿的债务。</p><p>老罗在创办锤子科技的时候，为了给公司融资，个人担保了巨量债务，他死了老婆也要接着还。冯唐告诫他，开公司一定要搭建防火墙，隔离风险，否则个人将面临背负债务的风险。</p><p>借此机会，学习了企业公司架构设计，补充了一些公司法知识。再结合身边的一些公司，都有类似的股权设计。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20250830103720116.png" alt="企业股权结构设计简图"></p><p>PS：虽然我这辈子很难成为一个商人，机遇不够，难以实现个人价值与财富的巨大提升，但是还是多多了解吧！</p>]]></content>
      
      
      <categories>
          
          <category> 每日一学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算光刻 OPC 名词解释</title>
      <link href="/%E8%AE%A1%E7%AE%97%E5%85%89%E5%88%BBOPC%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
      <url>/%E8%AE%A1%E7%AE%97%E5%85%89%E5%88%BBOPC%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="名词解释"><a href="# 名词解释" class="headerlink" title="名词解释"></a> 名词解释 </h1><h2 id="EL-Energy-Latitude"><a href="#EL-Energy-Latitude" class="headerlink" title="EL(Energy Latitude)"></a>EL(Energy Latitude)</h2><ul><li> 表征了图形 CD 在一定 tolerance 范围内 dose 能够变化的比例 </li><li>EL 意为曝光容忍度，也称为曝光裕度，是工艺窗口的重要参数之一，光学曝光系统可以形成符合设计版图要求的曝光能量范围 </li><li> 通常使用曝光结果检测的 CD 值在 10% 变化范围内的曝光能量选择范围来定义。即如果抗蚀剂在偏离最佳曝光能量的情况下，图形线宽变化较小的，说明该抗蚀剂有较大的曝光宽容度。</li><li>EL 越大越好，EL 越大，意味着 Process Window 越大 </li></ul><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20250826220054000.png" alt="EL 计算公式" style="zoom:50%;" /><blockquote><p> 在计算 EL 时，需要用到 best Energy，这个值是从 cd-energy 折线图中计算而得，知道了 target cd，此时需要的 energy 就可得 </p></blockquote><h2 id="焦距能量矩阵（Focus-Energy-Matrix，-FEM）"><a href="# 焦距能量矩阵（Focus-Energy-Matrix，-FEM）" class="headerlink" title="焦距能量矩阵（Focus Energy Matrix， FEM）"></a> 焦距能量矩阵（Focus Energy Matrix， FEM）</h2><ul><li> 在进行曝光时，从一个方向以固定的步长改变聚焦值（focus），另一个方向以固定的步长改变曝光能量（Energy），所得的图形线宽的二维数据表格 </li><li> 用来检查光刻工艺窗口和确定最佳曝光条件的测试方法，通过在一个硅片上不同的区域使用不同的曝光能量和焦距，可以产生不同工艺条件的组合 </li><li> 通过此方法可以在硅片上进行实验确定聚焦深度，曝光量所允许的范围和最佳焦距（best focus）、最佳曝光能量（best Energy），以确定最佳光刻工艺窗口（Process Window）。</li></ul><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20250826222319164.png" alt="FEM 示意" style="zoom:50%;" /><h2 id="Fab 产品名词"><a href="#Fab 产品名词" class="headerlink" title="Fab 产品名词"></a>Fab 产品名词 </h2><ul><li>NTO：首次全掩模工程产品流片（NTO）是指当制造流程和技术参数都已经确定后，首次进行的全掩模制造。这意味着整个晶圆上生产的都是同一种芯片设计 </li><li>TQV：内部用于工艺测试验证的图形，Technology Qualification Vehicle，早期工艺开发抓手。</li><li>MPW：多项目晶圆流片，由不同小客户出 chips，出一张 mask，搭便车，节省成本，在一片晶圆上同时生产不同的芯片。</li><li>TestKey：一些重复周期性图形，fab 内部如 PIE 部门测试用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> chip </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>芯片制造流程与工艺</title>
      <link href="/%E8%8A%AF%E7%89%87%E5%88%B6%E9%80%A0%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%B7%A5%E8%89%BA/"/>
      <url>/%E8%8A%AF%E7%89%87%E5%88%B6%E9%80%A0%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%B7%A5%E8%89%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="一、芯片制造流程简介"><a href="# 一、芯片制造流程简介" class="headerlink" title="一、芯片制造流程简介"></a>一、芯片制造流程简介</h1><h2 id="1-1- 硅片制备"><a href="#1-1- 硅片制备" class="headerlink" title="1.1 硅片制备"></a>1.1 硅片制备</h2><ul><li><strong>原料提纯</strong>：从石英砂中提取高纯度硅，制成单晶硅棒并切割为晶圆片。  </li><li><strong>晶圆清洗</strong>：去除表面杂质，确保后续工艺的洁净度。</li></ul><h2 id="1-2- 薄膜沉积"><a href="#1-2- 薄膜沉积" class="headerlink" title="1.2 薄膜沉积"></a>1.2 薄膜沉积</h2><ul><li><strong>氧化层 / 介质层沉积</strong>：通过热氧化或化学气相沉积（CVD）在晶圆表面生成二氧化硅（SiO₂）等绝缘层。  </li><li><strong>金属层沉积</strong>：采用物理气相沉积（PVD）或电镀法形成铜、铝等金属互连层。</li></ul><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20250614155516352.png" alt="薄膜沉积层示例图" style="zoom:50%;" /><h2 id="1-3- 光刻工艺"><a href="#1-3- 光刻工艺" class="headerlink" title="1.3 光刻工艺"></a>1.3 光刻工艺</h2><ul><li><strong>光刻胶涂覆 </strong>：在晶圆表面旋涂光敏材料（<strong> 光刻胶</strong>）。  </li><li><strong>曝光与显影</strong>：通过掩膜版将电路图案投影到光刻胶上，显影后形成保护层。</li></ul><h2 id="1-4- 刻蚀与掺杂"><a href="#1-4- 刻蚀与掺杂" class="headerlink" title="1.4 刻蚀与掺杂"></a>1.4 刻蚀与掺杂</h2><ul><li><strong>干法 / 湿法刻蚀</strong>：利用等离子体或化学试剂去除未被光刻胶保护的薄膜，形成电路结构。  </li><li><strong>离子注入</strong>：向特定区域掺入磷、硼等杂质，形成 N 型或 P 型半导体。</li></ul><h2 id="1-5- 化学机械平坦化（CMP）"><a href="#1-5- 化学机械平坦化（CMP）" class="headerlink" title="1.5 化学机械平坦化（CMP）"></a>1.5 化学机械平坦化（CMP）</h2><ul><li><strong>作用阶段</strong>：在每层金属或介质层沉积后，通过 CMP 去除表面多余材料（如铜、氧化硅），实现全局平坦化。  </li><li><strong>工艺目标</strong>：消除台阶效应，为下一层光刻提供平整基底，避免电路短路或信号干扰。</li><li>CMP 主要应用于以下关键节点：  <ol><li><strong>金属互连层平坦化</strong>  <ul><li>在铜或钨金属沉积后，通过 CMP 去除多余金属，仅保留沟槽内的布线结构，防止短路。  </li></ul></li><li><strong>层间介质（ILD）平坦化</strong>  <ul><li>氧化硅等绝缘层沉积后，CMP 消除表面起伏，确保光刻精度。  </li></ul></li><li><strong>多晶硅层处理</strong>  <ul><li>用于栅极结构平坦化，提升晶体管性能一致性。</li></ul></li></ol></li></ul><h2 id="1-6- 多层互连重复"><a href="#1-6- 多层互连重复" class="headerlink" title="1.6 多层互连重复"></a>1.6 多层互连重复</h2><ul><li>上述步骤（薄膜沉积→光刻→刻蚀→掺杂→CMP）循环进行，构建多层金属互连结构（通常 6 层以上）。</li></ul><h2 id="1-7- 封装与测试"><a href="#1-7- 封装与测试" class="headerlink" title="1.7 封装与测试"></a>1.7 封装与测试</h2><ul><li><strong>切割晶圆</strong>：将晶圆分割为单个芯片。  </li><li><strong>封装</strong>：通过引线键合、塑封等工艺保护芯片并连接外部引脚。  </li><li><strong>功能测试</strong>：验证芯片性能与可靠性。</li></ul><hr><h1 id="二、Dummy 的作用"><a href="# 二、Dummy 的作用" class="headerlink" title="二、Dummy 的作用"></a>二、Dummy 的作用 </h1><h2 id="2-1- 什么是 dummy"><a href="#2-1- 什么是 dummy" class="headerlink" title="2.1  什么是 dummy"></a>2.1  什么是 dummy</h2><p> 在芯片的空白区域（距离芯片设计图形 main pattern 大于 1um 左右开外），填充一些规整的矩形图形，不承担实际的任何芯片电路功能。虽不参与实际的功能运转，却对芯片这座假想的城市布局的稳定性至关重要。它由和芯片相同的材料构成，安静地 “待” 在芯片未被利用的空间里，不介入任何电路或逻辑运作。</p><p>为什么要加 dummy 呢？</p><p>芯片设计中，通常会出现 <strong> 不均匀布局，这会导致芯片表面局部密度出现显著差异 </strong>。此外，为了提高良率，<strong> 在存储器或处理器中引入的冗余单元 (Redundancy Cells) 呈集中分布，这将进一步加剧芯片表面密度的波动。</strong></p><p>在 CMP（化学机械平坦化）工艺过程中，需要做一些机械摩擦去除表面粗糙部位，对于表面材料分布不均匀的芯片，其不同区域因材料密度 (如金属、氧化物等) 的差异会导致抛光速率的不一致。低密度区域可能因过度抛光而出现凹陷(dishing)，高密度区域可能因支撑不足而产生侵蚀(erosion)。这种抛光不均匀性会直接影响多层互连结构的平面度，进而引发短路或断路的问题。此外，金属线的侵蚀也会导致较为严重的 IR-Drop 以及信号线上的延迟。</p><p>为避免在图形平坦化过程中出现侵蚀和凹陷现象，需确保芯片整体密度的均匀性与一致性。通常的做法是在版图布线完成后，在标准单元间隙插入填充单元(如图 2 所示)，填充单元是定义在标准单元库中且与电路逻辑无关的填充结构，即 Dummy。</p><p>dummy 常放在：</p><ul><li><p><strong>边缘区域</strong>：在晶圆的边缘，由于工艺限制和机械应力的影响，这里往往不是最佳的功能电路布局区域。放置 dummy 结构可以减少这些区域对内部有效电路的影响，并有助于均匀化蚀刻等工艺步骤。</p></li><li><p><strong>切割道</strong>（scribe line, or street）：划分各个芯片（die）的隐形边界，就像地图上的经纬线，为晶圆划片（dicing）提供精确引导，确保每个 die 被精准切割。</p></li><li><p><strong>器件周围</strong>：为了提高制造工艺的一致性，特别是在晶体管或其他关键器件周围放置 dummy 图案。这有助于确保在进行化学机械抛光(CMP)、蚀刻等制程时，能有更均匀的结果，从而减少局部不规则性带来的影响。</p></li><li><p><strong>空旷区域</strong>：如果某个区域没有功能性电路元件，可能会在这个区域内添加 dummy 结构。这样做不仅有助于平衡整个芯片表面的密度，还能帮助维持工艺步骤中如沉积、蚀刻等过程的稳定性。</p></li><li><p><strong>特定功能区</strong>：在某些情况下，dummy 结构可能被用于特定的技术目的，例如改善电磁特性、热管理或者作为测试结构的一部分。</p></li></ul><h2 id="2-2-dummy 的作用"><a href="#2-2-dummy 的作用" class="headerlink" title="2.2 dummy 的作用"></a>2.2 dummy 的作用</h2><ul><li><p>加固芯片 “防线”：Dummy 填充芯片空白区域，优化物理结构，增强晶圆边缘强度，有效减少划片和封装时芯片受损的可能，就像给脆弱的芯片边缘穿上了一层 “防护铠甲”。</p></li><li><p>工艺的 “稳定器”：晶圆边缘与中心区域电路密度不同，容易导致工艺不均匀。Dummy 通过模拟中心区域的电路布局，使整个晶圆的工艺保持均匀一致，确保每一处芯片制造工艺都 “整齐划一”。</p></li><li><p>制造过程的 “护航者”：光刻环节中，光线的反射与衍射容易引发曝光问题，导致蚀刻失败，影响关键元器件精度和尺寸。Dummy 能有效规避这些风险，保障制造顺利进行，让芯片制造的每一步都精准无误。</p></li><li><p>应力与翘曲的 “调节师”：芯片制造工艺易引发晶圆应力不均和翘曲，影响性能。Dummy 能够平衡应力分布，让晶圆保持平整，确保芯片性能稳定可靠。</p></li><li><p>信号的 “守护者”：在关键信号周围布置 Dummy 结构，能够有效阻挡杂波干扰，保证信号稳定传输，让芯片内部的 “信息高速公路” 畅通无阻。</p></li><li><p>性能测试的 “小助手”：芯片设计完成后，Dummy 可以协助测试功耗、速度、温度等性能指标，帮助工程师全方位了解芯片性能，为后续优化提供依据。</p></li></ul><h1 id="三、PTD 和 NTD 工艺"><a href="# 三、PTD 和 NTD 工艺" class="headerlink" title="三、PTD 和 NTD 工艺"></a>三、PTD 和 NTD 工艺</h1><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20250823112010888.png" alt="PTD & NTD 工艺" style="zoom: 50%;" /><h2 id="3-1-PTD 正显影"><a href="#3-1-PTD 正显影" class="headerlink" title="3.1 PTD 正显影"></a>3.1 PTD 正显影 </h2><p><strong> 正显影 </strong>，即 Positive Tone Develop，简写 PTD。它是结合使用<strong> 负胶</strong>，搭配正显影液来实现。</p><p>负胶（负光刻胶，负光阻， Negative Photoresist）暴露在光照下的区域会发生交联反应，变得更加难溶于显影液，最终保留在硅片表面，而未曝光区域则被冲洗掉。</p><p>负胶由于分辨率不如正胶，更多应用在对线宽要求不极端苛刻的领域。用于 193nm 光刻的多数光刻胶是正性胶。</p><h2 id="3-2-NTD- 负显影"><a href="#3-2-NTD- 负显影" class="headerlink" title="3.2 NTD 负显影"></a>3.2 NTD 负显影 </h2><p><strong> 负显影 </strong>，即 Negative Tone Develop，简写 NTD。它是结合使用<strong> 正胶</strong>，搭配负显影液来实现。</p><p>当正胶受到曝光时，光敏基团发生光化学反应，会生成酸性基团，放出氮气，酸性基团与显影液反应，光刻胶的结构被破坏，因此曝光后的光刻胶便被洗去。由于曝光后的光刻胶含有很多酸性基团，所以显影液一般为微碱性的溶液。</p><p>业内的 NTD 技术一般应用在 20nm 或 14nm 以下先进工艺节点量产中。</p>]]></content>
      
      
      <categories>
          
          <category> chip </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 入职场</title>
      <link href="/C-%E5%85%A5%E8%81%8C%E5%9C%BA/"/>
      <url>/C-%E5%85%A5%E8%81%8C%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在实际开发过程中，会碰到 C++ 中一些”奇怪”的用法，好像跟我们学的不一样，这里对 C++ 的知识做一个延伸。</p></blockquote><h1 id="1、重新认识宏"><a href="#1、重新认识宏" class="headerlink" title="1、重新认识宏"></a>1、重新认识宏 </h1><p> 宏是 C/C++ 所支持的一种语言特性，我们对它最初的认识，可能就是替换代码中的符号，比如定义一个圆周率 <code>PI</code>，之后在代码中使用<code>PI</code> 来代替具体圆周率的值。<br>确实如此，宏提供了一种机制，能够使你在编译期替换代码中的符号或者语句。当你的代码中存在大量相似的、重复的代码时，使用宏可以极大的减少代码量，便于书写。</p><p>在 C++ 基础知识的学习中，了解了宏的基本使用，但是真正进入职场，这些远远不够，因此有必要对宏进行一个系统的了解。</p><p>宏分为 <strong> 系统预定义的宏 </strong>，和程序员<strong> 自定义的宏</strong>。</p><h2 id="1-1- 初识宏"><a href="#1-1- 初识宏" class="headerlink" title="1.1 初识宏"></a>1.1 初识宏 </h2><p> 自定义宏使用 <code>#define</code> 定义，也称为宏常量，是一个全局常量。</p><p>一种简单的定义如下：</p><ul><li><p><strong>#define 宏名 常量表达式</strong></p><p>常量表达式可以是：数值，字符串，运算表达式等，只要是一个常量就行。</p></li></ul><pre><code class="c++">#define PI 3.14#define NAME &quot;Lisa&quot;#define SIZE (4*512)#define RANDOM (-1.0 + 2.0*(double)rand() / RAND_MAX)double perimeter = diameter * PI;</code></pre><p>代码在编译时，编译器会把 宏名 替换为它所定义的值进行编译。</p><h2 id="1-2- 再认识宏"><a href="#1-2- 再认识宏" class="headerlink" title="1.2 再认识宏"></a>1.2 再认识宏 </h2><h3 id="1-2-1- 空宏"><a href="#1-2-1- 空宏" class="headerlink" title="1.2.1 空宏"></a>1.2.1 空宏</h3><p> 有时候我们会看见，只指定了宏名，却没有指定宏值：</p><pre><code class="c++">#define m_DDL class m_DDL class&#123;...&#125;// 等价于class class&#123;...&#125;</code></pre><p><strong>空宏 </strong>(未定义的宏) 都展开为空字符串。但定义为空字符串的宏一般被视为是在预处理表达式定义的，这个后面会介绍。</p><h3 id="1-2-2- 空指针"><a href="#1-2-2- 空指针" class="headerlink" title="1.2.2 空指针"></a>1.2.2 空指针 </h3><p> 我们常用 <code>NULL</code> 表示一个空指针，其实它是一个已经预定义的宏。预定义指的是你不必亲自定义，编译器在编译时，已经提前定义好了。</p><pre><code class="c++">#define NULL ((void*)0)</code></pre><blockquote><p>空指针：指向地址 0</p></blockquote><h3 id="1-2-3- 取消宏定义"><a href="#1-2-3- 取消宏定义" class="headerlink" title="1.2.3 取消宏定义"></a>1.2.3 取消宏定义 </h3><pre><code># undef 宏名</code></pre><h2 id="1-3- 带参数的宏"><a href="#1-3- 带参数的宏" class="headerlink" title="1.3 带参数的宏"></a>1.3 带参数的宏</h2><h3 id="1-3-1- 带参宏的形式"><a href="#1-3-1- 带参宏的形式" class="headerlink" title="1.3 1 带参宏的形式"></a>1.3 1 带参宏的形式</h3><p> 带参数的宏的定义如下：</p><ul><li><p><strong>#define 宏名称([形参列表] ) 表达式</strong></p></li><li><p><strong>#define 宏名称([形参列表,] …) 表达式</strong></p><p>C99 标准允许定义有省略号的宏，省略号必须放在参数列表的后面，以表示可选参数。1.3.3 章节介绍。</p></li></ul><pre><code class="c++">#define MUL(x, y) x * yint ret = MUL(2, 3);   // ==&gt; int ret = 2 * 3;</code></pre><p>注意宏是直接替换的关系。举一个例子：</p><pre><code class="c++">#define MUL(x, y) x * yint ret = MUL(2+3, 3);   // ==&gt; int ret = 2 + 3 * 3;</code></pre><h3 id="1-3-2- 三个符号"><a href="#1-3-2- 三个符号" class="headerlink" title="1.3.2 三个符号"></a>1.3.2 三个符号</h3><ul><li><strong><code>#</code>符号把一个宏参数直接转换为字符串</strong></li></ul><pre><code class="c++">#define STR(x) #xstring a = STR(qwer);   //a 就是“qwer”</code></pre><ul><li><strong><code>##</code>符号会连接两边的值，产生一个新的值</strong></li></ul><pre><code class="c++">#define VAR(x) index_##xint VAR(1);    // ==&gt; int index_1;</code></pre><ul><li><strong><code>#@</code>符号会把一个宏参数直接转换为字符</strong></li></ul><pre><code class="c++">#define CHR(x) #@xchar m_a = CHR(s);   // m_a 就是 &#39;s&#39;</code></pre><h3 id="1-3-3- 可变参数"><a href="#1-3-3- 可变参数" class="headerlink" title="1.3.3 可变参数"></a>1.3.3 可变参数</h3><pre><code class="c++">#define PLog(fmt, ...) printf(fmt, __VA_ARGS__)// 这样我们就可以使用我们自己定义的宏 trace 来打印日志了PLog(&quot;got a number %d&quot;, 34);</code></pre><p>当调用有可选参数的宏时，预处理器会将所有可选参数连同分隔它们的逗号打包在一起作为一个参数。在替换文本中，标识符 <strong>VA_ARGS</strong> 对应一组前述打包的可选参数。</p><p>预处理器把上面第四行代码替换成如下形式：</p><pre><code>printf(fmt, &quot;got a number %d&quot;, 34)</code></pre><blockquote><p><code>__VA_ARGS__</code>为空时，之前的逗号不会删除，会报错，故可以在 <code>__VA_ARGS__</code> 之前添加 <code>##</code> 符号</p></blockquote><h2 id="1-4- 多行的宏"><a href="#1-4- 多行的宏" class="headerlink" title="1.4 多行的宏"></a>1.4 多行的宏 </h2><p> 如果宏的内容很长，很多，那么可以写成多行，每行的末尾添加<code>\</code>，以表明后面的一行依然是宏的内容。比如</p><pre><code class="c++">#define ADD(x, y) do &#123; int sum = (x) + (y); return sum; &#125; while (0)// 宏的内容比较长，也没有缩进，易读性较差，因此转为多行#define ADD(x, y) \do \&#123;\    int sum = (x) + (y);\    return sum;\&#125; while (0)</code></pre><h2 id="1-5- 预定义宏"><a href="#1-5- 预定义宏" class="headerlink" title="1.5 预定义宏"></a>1.5 预定义宏 </h2><p> 为了方便处理一些有用的信息，预处理器定义了一些预处理标识符，也就是预定义宏。预定义宏的名称都是以 <code>__</code> 两条下划线开头和结尾的。</p><p>如果宏名是由两个单词组成，那么中间以<code>_</code>（一条下划线）进行连接。并且，宏名称一般都由大写字符组成。</p><table><thead><tr><th>宏</th><th>描 述</th></tr></thead><tbody><tr><td><code>__DATE__</code></td><td>当前所编译的文件名称(绝对路径)</td></tr><tr><td><code>__FILE__</code></td><td>当前源文件的名称，用字符串常量表示</td></tr><tr><td><code>__LINE__</code></td><td>当前源文件中的行号，用十进制整数常量表示，它可以随 #line 指令改变</td></tr><tr><td><code>__TIME__</code></td><td>当前源文件的最新编译吋间，用“hh:mm:ss”形式的字符串常量表示</td></tr></tbody></table><p>各种编译器的预定义宏不尽相同，但是一般都会支持上面的四种宏。</p><p><strong>获取不同平台下 gcc(mingw)编译器预定义宏的方式：</strong></p><ul><li>Linux：                    <code>gcc -posix -E -dM - &lt; /dev/null</code></li><li>Windows：             <code>gcc -posix -E -dM - &lt; nul</code></li></ul><h2 id="1-5- 预处理指令"><a href="#1-5- 预处理指令" class="headerlink" title="1.5 预处理指令"></a>1.5 预处理指令 </h2><p> 通过预定义宏，配合程序员使用 <code>#ifdef</code> 与<code>#endif</code>等预处理指令，就可使平台相关代码只在适合于当前平台的代码上编译，从而在同一套代码中完成对多平台的支持。</p><p>我们通过预定义宏和预处理指令配合，达到一定的 <strong> 代码开关控制</strong>，对不同的操作系统启用不同的代码。</p><pre><code class="c++">#ifdef _WIN32 // 查看是否定义了该宏，Windows 默认会定义该宏    // 如果是 Windows 系统则会编译此段代码    OutputDebugString(&quot;this is a Windows log&quot;);#else    // 如果是 mac，则会编译此段代码    NSLog(@&quot;this is a mac log&quot;);#endif</code></pre><blockquote><p>宏条件语句关键词有：<code>#ifdef</code>  <code>#if</code>   <code>#else</code>   <code>#endif</code></p></blockquote><h2 id="1-6- 宏的调试"><a href="#1-6- 宏的调试" class="headerlink" title="1.6 宏的调试"></a>1.6 宏的调试 </h2><p> 宏的调试语法：</p><ul><li><p><strong>#pragma message(“输出的内容”)</strong></p><p>该指令必须接收一个字符串，而不能是其他的对象</p></li></ul><pre><code class="c++">#define SOMEMACRO 123456#define MACROTOSTR2(x) #x#define PRINTMACRO(x) #x &quot; = &quot; MACROTOSTR2(x)#pragma message(PRINTMACRO(SOMEMACRO))            </code></pre><p>编译上述代码便会在输出窗口打印 <code>SOMEMACRO = 123456</code> 的内容。</p><h1 id="2、奇怪的单冒号"><a href="#2、奇怪的单冒号" class="headerlink" title="2、奇怪的单冒号"></a>2、奇怪的单冒号 </h1><h2 id="2-1- 在类的声明中"><a href="#2-1- 在类的声明中" class="headerlink" title="2.1 在类的声明中"></a>2.1 在类的声明中</h2><p> 在单冒号熟知的用法中，一般是这样的：</p><pre><code class="C++">class Son: public Father&#123;&#125;</code></pre><p>这里的单冒号作用为：<strong>表示类的继承</strong>。Son 继承 Father 的属性和方法。</p><h2 id="2-2- 在构造函数中"><a href="#2-2- 在构造函数中" class="headerlink" title="2.2 在构造函数中"></a>2.2 在构造函数中</h2><pre><code class="C++">class Father&#123;public:    Father()&#123;&#125;;    ~Father()&#123;&#125;    int a;    const int b;&#125;Father::Father():a(1),b(2)&#123;&#125;;</code></pre><p>第 10 行的单冒号，<strong>表示成员属性的初始化</strong>。成员属性 a 初始化为 1，b 初始化为 2。</p><p>注意：</p><ol><li><p>初始化成员属性的作用相当于在构造函数内进行相应成员属性的赋值，但两者是有差别的。</p><p>在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两都的差别在对于像 const 类型数据的操作上表现得尤为明显。const 类型的变量必须在定义时进行初始化，而不能对 const 型的变量进行赋值。因此 const 类型的成员变量只能（而且必须）在初始化列表中进行初始化。</p></li><li><p>初始化的顺序与成员属性声名的顺序相同。</p><pre><code>Father::Father():a(1),b(a)&#123;&#125;;   // 这样 b 是一个随机数，并不是 1</code></pre></li><li><p>对于继承的类来说，在初始化列表中也可以进行基类的初始化，初始化的顺序是先基类初始化，然后再根据该类自己的变量的声明顺序进行初始化。</p></li></ol><h2 id="2-3- 在结构体中"><a href="#2-3- 在结构体中" class="headerlink" title="2.3 在结构体中"></a>2.3 在结构体中 </h2><p> 单冒号接数字。</p><pre><code class="C++">struct Mt&#123;    int A:2;    int B:1;&#125;</code></pre><p>第 2 和 3 行的单冒号：<strong>表示该变量所占几个 bit 的空间</strong>。变量 A 占 2 个 bit 空间，变量 B 占 1 个 bit 空间。</p><p>举个例子：</p><pre><code class="c++">#include&lt;bitset&gt;using namespace std;struct student &#123;    int aa:1;    int bb:1;    int cc:2;    int dd:2;&#125;;void main() &#123;    student s1;    s1.aa = 1;    s1.bb = 2;    s1.cc = 1;    s1.dd = 2;    cout &lt;&lt; bitset&lt;1&gt;(s1.aa) &lt;&lt; endl;  //1    cout &lt;&lt; bitset&lt;1&gt;(s1.bb) &lt;&lt; endl;  //0    cout &lt;&lt; bitset&lt;2&gt;(s1.cc) &lt;&lt; endl;  //01    cout &lt;&lt; bitset&lt;2&gt;(s1.dd) &lt;&lt; endl;  //10&#125;</code></pre><h1 id="3、奇怪的双冒号"><a href="#3、奇怪的双冒号" class="headerlink" title="3、奇怪的双冒号"></a>3、奇怪的双冒号 </h1><h2 id="3-1- 在类 - 结构体 - 命名空间后"><a href="#3-1- 在类 - 结构体 - 命名空间后" class="headerlink" title="3.1 在类 / 结构体 / 命名空间后"></a>3.1 在类 / 结构体 / 命名空间后</h2><p> 这个是最常见的用法：</p><pre><code>std::cout     // 命名空间 std 中的 cout 类对象Person::A     //Person 类走过的成员属性 A</code></pre><p>这里的双冒号：<strong>表示作用域</strong>。某作用域中的某对象。</p><h2 id="3-2- 在函数 - 变量前"><a href="#3-2- 在函数 - 变量前" class="headerlink" title="3.2 在函数 / 变量前"></a>3.2 在函数 / 变量前</h2><pre><code class="c++">string name=&quot;lisa&quot;;void get_info() &#123;    string name = &quot;jack&quot;;    name = &quot;Mr &quot; + name;           // 局部变量 name    ::name = &quot;Miss &quot; + ::name;     // 全局变量 name    cout &lt;&lt; name &lt;&lt; endl;    cout &lt;&lt; ::name &lt;&lt; endl;&#125;</code></pre><p>这里第 8 行和第 12 行中的双冒号：<strong>表示该函数 / 变量是全局的</strong>。以区分局部变量。</p><h1 id="4、inline 内联函数"><a href="#4、inline 内联函数" class="headerlink" title="4、inline 内联函数"></a>4、inline 内联函数 </h1><p> 函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。</p><p>一个 C/C++ 程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是 main()，终点也是 main()。当 main() 调用完了所有的函数，它会返回一个值（例如<code>return 0;</code>）来结束自己的生命，从而结束整个程序。</p><p><strong>函数调用是有时间和空间开销的</strong>。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p><p>一般情况下，这个开销可以忽略不计。但是，如果一个函数内部没有几条语句，执行时间本来就非常短，那么这个函数调用产生的额外开销和函数本身执行的时间相比，就显得不能忽略了。假如这样的函数在一个循环中被上千万次地执行，函数调用导致的时间开销可能就会使得程序运行明显变慢。</p><p>为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换。</p><p>这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。</p><p>语法：</p><ul><li><strong>inline 函数声明 / 定义 </strong>：在函数声明或定义时，加一个<strong>inline</strong> 关键字即可</li></ul><pre><code class="c++">inline void fuc(int a, int b)&#123;...&#125;</code></pre><p>内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。这样做也是有代价的，占用了更多内存。</p><p><strong>一般只将那些短小的、频繁调用的函数声明为内联函数。</strong></p><p>在【代码执行时间】和【处理函数调用机制的时间】之间寻找平衡。</p><blockquote><p>内联函数不能递归</p></blockquote><h1 id="5、Boost 库"><a href="#5、Boost 库" class="headerlink" title="5、Boost 库"></a>5、Boost 库</h1><h2 id="5-1-Boost 智能指针"><a href="#5-1-Boost 智能指针" class="headerlink" title="5.1 Boost 智能指针"></a>5.1 Boost 智能指针</h2><p>Boost 是一个功能强大、构造精巧、跨平台、开源并且完全免费的 C++ 程序库。该库涵盖字符串处理、正则表达式、容器与数据结构、并发编程、函数式编程、泛型编程、设计模式实现等许多领域，极大地丰富了 C++ 的功能和表现力，能够使 C++ 软件开发更加简洁、优雅、灵活和高效。</p><p>该库需要手动安装。</p><ul><li><p>下载地址：<a href="https://www.boost.org/users/history/">Boost Version History</a></p></li><li><p>解压至目标文件夹：如 <code>D:\boost\boost_1_62_0</code></p></li><li><p>安装：常使用的 boost 库函数是不需要安装的。</p></li><li><p>配置 VS2019：</p><ul><li><p>在【项目】- 【项目名属性】中添加包含目录 <em>Configuration Properties &gt; C/C++ &gt; General &gt; Additional Include Directories<em>，例如</em>D:\boost\boost_1_62_0</em></p></li><li><p>更改配置 将<em>Configuration Properties &gt; C/C++ &gt; Precompiled Headers</em> 改为<em>Not Using Precompiled Headers</em>。</p></li></ul></li></ul><p>做完以上配置即可在 VS2019 中使用。</p><p><a href="https://www.jianshu.com/p/004c99828af2">在 windows 下安装 Boost 1.62.0 - 简书 (jianshu.com)</a></p><h3 id="5-1-2-shared-ptr 智能指针"><a href="#5-1-2-shared-ptr 智能指针" class="headerlink" title="5.1.2 shared_ptr 智能指针"></a>5.1.2 shared_ptr 智能指针</h3><pre><code class="c++">#include &lt;boost/shared_ptr.hpp&gt;boost::shared_ptr&lt;int&gt; p1    // 声明一个 int 类型的 p1 指针，注意这里不需要 * 号指明是个指针</code></pre><p><strong>p1 指针不用手动去释放资源，它会智能地在合适的时候去自动释放。</strong></p><p>boost::shared_ptr 的实现机制其实比较简单，就是对指针引用的对象进行引用计数，当引用计数为 0 时，会自动释放。</p><p>创建指针例子：</p><pre><code class="c++">boost::shared_ptr&lt;int&gt; p2(nullptr);        // 传入空指针 nullptrboost::shared_ptr&lt;int&gt; p3(new int(10));   //p3 指向值为 10 的堆空间</code></pre><p>目前仅作了解即可。</p><p><code>boost::shared_ptr</code>消除了显式的 <code>delete</code>调用，很大程度上避免了程序员忘记 <code>delete</code>而导致的内存泄漏。但 <code>shared_ptr</code>的构造依然需要<code>new</code>，这导致了代码中的某种不对称性，它应该使用工厂模式来解决。</p><h3 id="5-1-3-make-shared 工厂函数"><a href="#5-1-3-make-shared 工厂函数" class="headerlink" title="5.1.3 make_shared 工厂函数"></a>5.1.3 make_shared 工厂函数 </h3><p><code>Boost</code> 库提供了一个自由工厂函数 <code>make shared&lt;T&gt;()</code>，来消除显式的 <code>new</code> 调用，声明如下：</p><pre><code class="c++">template&lt;class T, class... Args&gt;boost::shared_ptr&lt;T&gt; make_shared(Args &amp;&amp; ... args);</code></pre><p>make_shared()函数模板使用变长参数模板，最多可接受 10 个参数然后把它们传递给 T 的构造函数，创建一个 shared_ptr<T>的对象并返回。make_shared()函数要比直接创建 shared_ptr 对象的方式更高效，因为它內部仅分配一次內存。使用时需要包含头文件。</p><p>举个例子：</p><pre><code class="c++">#include &lt;boost/make_shared.hpp&gt;class  A&#123;public:    A(int a, float b, char c, string d)    &#123;        m_a = a; m_b = b; m_c = c; m_d = d;        cout &lt;&lt; &quot; 构造 A 类对象！&quot; &lt;&lt; endl;    &#125;    ~A()    &#123;        cout &lt;&lt; &quot; 析构 A 类对象！&quot; &lt;&lt; endl;    &#125;    int m_a;    float m_b;    char m_c;    string m_d;&#125;;int main()&#123;    // 原始的方式构造 shared_ptr，需要 new，产生一种不对称性    boost::shared_ptr&lt;A&gt;  p1(new A(100, 1.234f, &#39;C&#39;, &quot;hello&quot;));    cout &lt;&lt; p1-&gt;a &lt;&lt; &quot;, &quot; &lt;&lt; p1-&gt;b &lt;&lt; &quot;, &quot; &lt;&lt; p1-&gt;c &lt;&lt; &quot;, &quot; &lt;&lt; p1-&gt;d &lt;&lt; endl;    // 推荐使用工厂函数，屏蔽 new , 更高效    boost::shared_ptr&lt;A&gt;  p2 = boost::make_shared&lt;A&gt;(100, 1.234f, &#39;C&#39;, &quot;hello&quot;);    cout &lt;&lt; p2-&gt;a &lt;&lt; &quot;, &quot; &lt;&lt; p2-&gt;b &lt;&lt; &quot;, &quot; &lt;&lt; p2-&gt;c &lt;&lt; &quot;, &quot; &lt;&lt; p2-&gt;d &lt;&lt; endl;    return 0;&#125;</code></pre><h2 id="5-2-Boost-geometry"><a href="#5-2-Boost-geometry" class="headerlink" title="5.2 Boost geometry"></a>5.2 Boost geometry</h2><p>Boost.Geometry（又名 Generic Geometry Library，GGL）是 Boost C++ Libraries 集合的一部分，定义了解决几何问题的概念、基元和算法。</p><p>Boost.Geometry 包含一个与维度无关、与坐标系无关且可扩展的内核，基于概念、元函数和标签调度。在该内核之上，构建了算法：面积，长度，周长，质心，凸壳，交叉点（修剪），包含（多边形中的点），距离，包络（边界框），简化，变换等等。该库支持高精度算术数字，如 <a href="http://www.ttmath.org/">ttmath</a>。</p><h3 id="5-2-1- 空间索引中的 rtree"><a href="#5-2-1- 空间索引中的 rtree" class="headerlink" title="5.2.1 空间索引中的 rtree"></a>5.2.1 空间索引中的 rtree</h3><p>描述：这是一种自平衡空间索引，能够存储各种类型的值和平衡算法。</p><p>参数：用户必须传递一个定义参数的类型，这些参数将在 rtree 创建过程中使用。该类型用于指定具有特定参数的平衡算法，如节点中的最小和最大元素数量。</p><p>带有编译时参数的预定义算法如下：</p><ul><li><code>boost::geometry::index::linear</code>,</li><li><code>boost::geometry::index::quadratic</code>,</li><li><code>boost::geometry::index::rstar</code>.</li></ul><p>带有运行时参数的预定义算法如下：</p><ul><li><code>boost::geometry::index::dynamic_linear</code>,</li><li><code>boost::geometry::index::dynamic_quadratic</code>,</li><li><code>boost::geometry::index::dynamic_rstar</code>.</li></ul><p>这里记录一个代码中的 rtree：</p><pre><code class="c++">typedef bgi::rtree&lt;pt_value, bgi::quadratic&lt;64&gt; &gt; pt_vrtree;pt_vrtree boundary_pt_tree(pt_values.begin(), pt_values.end());////define boundary_pt_tree and initialization,   pt_values=&#123;[pt]=&#123;patchid1,segid1&#125;,... &#125;boundary_pt_tree.query(bgi::intersects(util::Box(pts.left_bottom, pts.top_right)), back_inserter(queried_result));//query the same pt sharing the same [patchid, segid] and give result to queried_result&#123;&#123;pt,&#123;patchid1,segid1&#125;&#125;, &#123;pt,&#123;patchid2,segid2&#125;&#125;</code></pre><h1 id="6、断言函数 assert"><a href="#6、断言函数 assert" class="headerlink" title="6、断言函数 assert"></a>6、断言函数 assert</h1><p>断言函数，用于在调试过程中捕 <strong> 捉程序错误</strong>。断言（assertion）是编程中的一种常用手段，在通常情况下，断言就是将一个返回值总是真（或者我们需要是真）的判别式放在语句中，用以排除在设计逻辑上不应该出现的情况。</p><p>从本质上看，assert 是个宏，其用法像是一种”契约式编程”。</p><ul><li>如果其值为假，那么它先向 stderr 打印一条出错信息，然后通过调用 abort 来终止程序运行。</li><li>如果其值为真，不做任何处理，程序继续。</li></ul><pre><code class="c++"># include&lt;iostream&gt;# include&lt;string&gt;#include &lt;assert.h&gt;using namespace std;int main() &#123;    int m, n, result;    cin &gt;&gt; m &gt;&gt; n;    assert(n);    result = m / n;    cout &lt;&lt; result &lt;&lt; endl;    return 0;&#125;</code></pre><p>使用 assert 的缺点是，频繁的调用会极大的影响程序的性能，增加额外的开销。</p><p>在调试结束后，可以通过在包含 #include 的语句之前插入 #define NDEBUG 来禁用 assert 调用，示例代码如下：</p><pre><code>#include &lt;bitset&gt;#define NDEBUG #include &quot;logger.h&quot;</code></pre><h1 id="7、传参赋值"><a href="#7、传参赋值" class="headerlink" title="7、传参赋值"></a>7、传参赋值 </h1><p> 一般情况下，我们给函数定义形参，是需要传值使用，但是有时候，定义形参是为了赋值。</p><pre><code class="c++">class  A&#123;public:    int m_a;    int m_b;&#125;;void setA(int* arr, int&amp; a, int&amp; b) &#123;    a = arr[0];    b = arr[1];&#125;int main()&#123;    A* p = new A;    int arr[2] = &#123; 10, 20 &#125;;    setA(arr, p-&gt;m_a, p-&gt;m_b);    cout &lt;&lt; p-&gt;m_a &lt;&lt; endl;    return 0;&#125;</code></pre><h1 id="8、C 库函数"><a href="#8、C 库函数" class="headerlink" title="8、C 库函数"></a>8、C 库函数 </h1><h2 id="8-1- 复制"><a href="#8-1- 复制" class="headerlink" title="8.1 复制"></a>8.1 复制</h2><p>C 库函数提供了两种复制函数：<strong>strcpy</strong> 和<strong>memcpy</strong></p><p><strong>strcpy</strong>和 <strong>memcpy</strong> 主要有以下 3 方面的区别。</p><ol><li><p>复制的内容不同。strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类等。</p></li><li><p>复制的方法不同。strcpy 不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy 则是根据其第 3 个参数决定复制的长度。</p></li><li><p>用途不同。通常在复制字符串时用 strcpy，而需要复制其他类型数据时则一般用 memcpy。</p></li></ol><h3 id="8-1-1-memcpy"><a href="#8-1-1-memcpy" class="headerlink" title="8.1.1 memcpy"></a>8.1.1 memcpy</h3><p>函数原型：</p><pre><code>void *memcpy(void *dest, const void *src, size_t n)</code></pre><ul><li><strong>dest</strong> – 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。</li><li><strong>src</strong> – 指向要复制的数据源，类型强制转换为 void* 指针。</li><li><strong>n</strong> – 要被复制的字节数。</li></ul><p>该函数 <strong> 返回 </strong> 一个指向目标存储区 dest 的指针。</p><p><strong>memcpy()</strong> 会复制 src 所指的内存内容的前 n 个字节到 dest 所指的内存地址上。</p><ul><li><strong>memcpy() 并不关心被复制的数据类型，只是逐字节地进行复制，这给函数的使用带来了很大的灵活性，可以面向任何数据类型进行复制。</strong>也就是说，可以把结构体复制给 int 类型的变量。</li><li>dest 指针要分配足够的空间，也即大于等于 num 字节的空间。如果没有分配空间，会出现断错误。</li><li>dest 和 src 所指的内存空间不能重叠（如果发生了重叠，使用 [memmove()]会更加安全）。</li></ul><p>完整复制示例：</p><pre><code class="c++">// 将字符串复制到数组 dest 中#include &lt;stdio.h&gt;#include &lt;string.h&gt;   // 必须包含这个头文件int main ()&#123;   const char src[50] = &quot;http://www.runoob.com&quot;;   char dest[50];   memcpy(dest, src, strlen(src)+1);   // 这里加 1 是为了把 src 字符串的结尾符 \0 也复制给 dest,   printf(&quot;dest = %s\n&quot;, dest);        // 以让 dest 输出时遇到结尾符停止输出，不然会输出 50 个字符。   return(0);&#125;</code></pre><p>切片复制：</p><pre><code class="c++">#include &lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123;  char *s=&quot;http://www.runoob.com&quot;;  char d[20];  memcpy(d, s+11, 6);    // 从第 11 个字符 (r) 开始复制，连续复制 6 个字符(runoob)  // 或者 memcpy(d, s+11*sizeof(char), 6*sizeof(char));  d[6]=&#39;\0&#39;;  printf(&quot;%s&quot;, d);  return 0;&#125;</code></pre><h3 id="8-1-2-strcpy"><a href="#8-1-2-strcpy" class="headerlink" title="8.1.2 strcpy"></a>8.1.2 strcpy</h3><p>函数原型：</p><pre><code class="c">char * strcpy(char * dest, const char * src)    // 实现 src 到 dest 的复制</code></pre><ul><li><p>strcpy 只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。</p></li><li><p>memcpy 提供了一般内存的复制。即 memcpy 对于需要复制的内容没有限制，因此用途更广。</p></li></ul><p>示例：</p><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123;   char src[40];   char dest[100];   memset(dest, &#39;\0&#39;, sizeof(dest));      // 赋值为 &#39;\0&#39; 和 0 是等价的，因为字符 &#39;\0&#39; 在内存中就是 0   strcpy(src, &quot;This is runoob.com&quot;);   strcpy(dest, src);   printf(&quot; 最终的目标字符串： %s\n&quot;, dest);   return(0);&#125;</code></pre><p>memset() 的作用是在一段内存块中填充某个给定的值。因为它只能填充一个值，所以该函数的初始化为原始初始化，无法将变量初始化为程序中需要的数据。用 memset 初始化完后，后面程序中再向该内存空间中存放需要的数据。</p><p>memset 一般使用“0”初始化内存单元，而且通常是给数组或结构体进行初始化。一般的变量如 char、int、float、double 等类型的变量直接初始化即可，没有必要用 memset。如果用 memset 的话反而显得麻烦。</p><h2 id="8-2- 数据持久化"><a href="#8-2- 数据持久化" class="headerlink" title="8.2 数据持久化"></a>8.2 数据持久化 </h2><p> 一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。</p><h3 id="8-2-1- 打开 - 创建文件"><a href="#8-2-1- 打开 - 创建文件" class="headerlink" title="8.2.1 打开 / 创建文件"></a>8.2.1 打开 / 创建文件 </h3><p> 可以使用 <strong>fopen()</strong> 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 <strong>FILE</strong> 的一个对象，类型 <strong>FILE</strong> 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p><pre><code class="c">FILE *fopen(const char * filename, const char * mode);</code></pre><p><strong>mode</strong> 支持：</p><ul><li><strong>r</strong>     打开一个已有的文本文件，允许读取文件。</li><li><strong>w</strong>    打开一个文本文件，以覆盖模式写入文件。如果文件不存在，则会创建一个新文件。</li><li><strong>a</strong>     打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。</li><li><strong>r+</strong>   打开一个已有文本文件，允许读写文件。</li><li><strong>w+</strong>  打开一个文本文件，允许读写文件。</li><li><strong>a+</strong>   打开一个文本文件，允许追加读写文件。如果文件不存在，则会创建一个新文件。</li></ul><p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：<strong>加 b，代表二进制。</strong></p><pre><code>&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;rb+&quot;, &quot;r+b&quot;, &quot;wb+&quot;, &quot;w+b&quot;, &quot;ab+&quot;, &quot;a+b&quot;</code></pre><p>示例：</p><pre><code class="c++">string outfile=&quot;layer_main.dat&quot;;FILE* fp = fopen(outfile.c_str(), &quot;wb&quot;);</code></pre><h3 id="8-2-2- 读取文件"><a href="#8-2-2- 读取文件" class="headerlink" title="8.2.2 读取文件"></a>8.2.2 读取文件</h3><h4 id="8-2-2-1- 字符读取函数"><a href="#8-2-2-1- 字符读取函数" class="headerlink" title="8.2.2.1 字符读取函数"></a>8.2.2.1 字符读取函数</h4><ul><li><strong>fgetc()</strong>从指定的文件中读取一个字符：</li></ul><pre><code>int fgetc (FILE *fp);</code></pre><p>fp 为文件指针。fgetc() 读取成功时返回读取到的字符，读取到文件末尾或读取失败时返回 EOF。EOF 是在 stdio.h 中定义的宏，它的值是一个负数。</p><ul><li><strong>fputc()</strong>向指定的文件中写入一个字符:</li></ul><pre><code class="c++">int fputc (int ch, FILE *fp);</code></pre><p>ch 为要写入的字符，fp 为文件指针。fputc() 写入成功时返回写入的字符，失败时返回 EOF。</p><h4 id="8-2-2-2- 字符串读取函数"><a href="#8-2-2-2- 字符串读取函数" class="headerlink" title="8.2.2.2 字符串读取函数"></a>8.2.2.2 字符串读取函数</h4><ul><li><strong>fgets()</strong> 函数用来从指定的文件中读取一个字符串，并保存到字符数组中。</li></ul><pre><code class="c++">char *fgets (char *str, int n, FILE *fp);</code></pre><p>str 为字符数组，n 为要读取的字符数目，fp 为文件指针。</p><ul><li>fputs() 函数用来向指定的文件写入一个字符串，它的用法为：</li></ul><pre><code class="c++">int fputs(char *str, FILE *fp);</code></pre><p>str 为要写入的字符串，fp 为文件指针。写入成功返回非负数，失败返回 EOF。</p><p><strong>fgets() 有局限性，每次最多只能从文件中读取一行内容，因为 fgets() 遇到换行符就结束读取。如果希望读取多行内容，需要使用 fread() 函数；相应地写入函数为 fwrite()。</strong></p><h4 id="8-2-2-3- 块数据读取函数"><a href="#8-2-2-3- 块数据读取函数" class="headerlink" title="8.2.2.3 块数据读取函数"></a>8.2.2.3 块数据读取函数</h4><ul><li>fread() 函数用来从指定文件中读取块数据。所谓块数据，也就是若干个字节的数据，可以是一个字符，可以是一个字符串，可以是多行数据，并没有什么限制。fread() 的原型为：</li></ul><pre><code class="c++">size_t fread (void *ptr, size_t size, size_t count, FILE *fp);</code></pre><ul><li>fwrite() 函数用来向文件中写入块数据，它的原型为：</li></ul><pre><code class="c++">size_t fwrite (void * ptr, size_t size, size_t count, FILE *fp);</code></pre><p>ptr 为内存区块的指针，它可以是数组、变量、结构体等。fread() 中的 ptr 用来存放读取到的数据，fwrite() 中的 ptr 用来存放要写入的数据。</p><p>size：表示每个数据块的字节数。</p><p>count：表示要读写的数据块的块数。</p><p>fp：表示文件指针。</p><p>理论上，每次读写 size*count 个字节的数据。</p><p>返回值：返回成功读写的块数，也即 count。如果返回值小于 count：</p><ul><li><p>对于 fwrite() 来说，肯定发生了写入错误，可以用 ferror() 函数检测。</p></li><li><p>对于 fread() 来说，可能读到了文件末尾，可能发生了错误，都会返回 EOF。可以用 ferror() 或 feof() 检测到底是错误还是读到了文件结尾。</p><p><strong>feof()</strong>：<code>int feof(FILE *stream)</code>，检查文件的结束标志（是否读到了文件结尾处），没有返回 0，检查到了结束标志就返回非 0。</p></li></ul><p><strong>ferror()</strong>：<code>int ferror(FILE *stream)</code>，检测文件读取操作是否出错，当 ferror 函数返回为真时就表示有错误发生。在实际的程序中，应该每执行一次文件操作，就用 ferror 函数检测是否出错。</p><h3 id="8-2-3- 关闭文件"><a href="#8-2-3- 关闭文件" class="headerlink" title="8.2.3 关闭文件"></a>8.2.3 关闭文件 </h3><p> 使用 fclose() 函数。函数的原型如下：</p><pre><code> int fclose(FILE *fp);</code></pre><p>如果成功关闭文件，<strong>fclose()</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。</p><h1 id="9、隐式转化和显示转换"><a href="#9、隐式转化和显示转换" class="headerlink" title="9、隐式转化和显示转换"></a>9、隐式转化和显示转换 </h1><p> 在 CPP 中，编译器会自动帮我们进行隐式转换。下面举例说明：</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;class Point &#123;public:    int x, y;    Point(int x = 0, int y = 0): x(x), y(y) &#123;&#125;&#125;;void displayPoint(const Point&amp; p) &#123;    cout &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot;          &lt;&lt; p.y &lt;&lt; &quot;)&quot; &lt;&lt; endl;&#125;int main()&#123;    displayPoint(1);   // 输出（1,0）    Point p = 1;&#125;</code></pre><p>在第 18 行中，函数 displayPoint 应该传入一个 poin 类型的数据，但是这里传入了一个 int 类型数据，程序不会报错，而是正常运行完毕。这是因为这隐式调用。</p><p>另外, 在第 19 行中，在对象刚刚定义时, 即使你使用的是赋值操作符 <code>=</code>, 也是会调用构造函数, 而不是重载的<code>operator=</code> 运算符。</p><p>这样悄悄发生的事情， 有时可以带来便利。而有时却会带来意想不到的后果， <code>explicit</code>关键字用来避免这样的情况发生。</p><h2 id="explicit 关键字"><a href="#explicit 关键字" class="headerlink" title="explicit 关键字"></a><strong>explicit 关键字</strong></h2><p>CPP 官方参考手册解释如下：</p><ol><li>指定构造函数或转换函数 (C++11 起)为显式， 即它不能用于隐式转换和复制初始化。</li><li>explicit 指定符可以与常量表达式一同使用。函数若且唯若该常量表达式求值为 true 才为显式。(C++20 起)</li></ol><p>什么情况下使用 explicit：能用就用。</p><p>如果我们能预料到某种情况的发生, 就不要把隐式转换的控制权交给编译器。</p><h1 id="GDB 调试工具"><a href="#GDB 调试工具" class="headerlink" title="GDB 调试工具"></a>GDB 调试工具 </h1><p> 这里介绍 <strong>linux</strong> 下的 C++ 调试工具 GDB。</p><h2 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述</h2><p>GDB 全称“GNU symbolic debugger“，是 <strong>Linux</strong> 下常用的程序调试器。当下的 GDB 支持调试多种编程语言编写的程序，包括 C、C++、Go、Objective-C、OpenCL、Ada 等。实际场景中，GDB 更常用来调试 C 和 C++ 程序。一般来说，GDB 主要帮助我们完成以下四个方面的功能：</p><ol><li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li><li>在某个指定的地方或条件下暂停程序。</li><li>当程序被停住时，可以检查此时你的程序中所发生的事。</li><li>在程序执行过程中修改程序中的变量或条件，将一个 bug 产生的影响修正从而测试其他 bug。</li></ol><h2 id="调试之前"><a href="# 调试之前" class="headerlink" title="调试之前"></a>调试之前 </h2><p> 在启动调试之前，需要先将源码编译。编译有两种工具：GCC 和 G++。</p><ul><li><p>默认情况下，用 gcc 只能编译 c 代码，g++ 编译 c++ 代码</p><pre><code class="shell"># 生成可执行文件 a.outgcc test.c     g++ test.cpp   </code></pre></li><li><p>gcc 命令不能自动和 C＋+ 程序使用的库链接接，需要这样写：</p><pre><code class="shell">gcc test.cpp -lstdc++   #这样和 g++ test.cpp 结果是一样的</code></pre></li></ul><p>执行 a.out：<code>./a.out</code></p><p><strong>下面正式介绍 GDB：</strong></p><p>使用 GDB 调试程序，有以下两点需要注意：</p><ol><li><p>要使用 GDB 调试某个程序，该程序编译时必须加上编译选项 <strong><code>-g</code></strong>，否则该程序是不包含调试信息的；</p><pre><code class="shell">g++ -g test.cpp            # 编译生成 a.out 可执行文件g++ -g test.cpp -o test1   # 编译生成 test1 可执行文件</code></pre><blockquote><p>如果没有<strong><code>-g</code></strong>，你将看不见程序的函数名，变量名，所代替的全是运行时的内存地址。</p></blockquote></li><li><p>GCC 编译器支持 <strong><code>-O</code></strong> 和 <strong><code>-g</code></strong> 一起参与编译。GCC 编译过程对进行优化的程度可分为 5 个等级，具体可自行百度 ：</p></li></ol><h2 id="启用 GDB 调试"><a href="# 启用 GDB 调试" class="headerlink" title="启用 GDB 调试"></a>启用 GDB 调试 </h2><p> 在 C++ 源码编译后，可以对编译后的可执行文件启用 GDB 调试。</p><p>GDB 调试主要有三种方式：</p><ol><li>直接调试目标程序：gdb a.out</li><li>附加进程 id：gdb attach pid</li><li>调试 core 文件：gdb filename corename</li></ol><p><strong>启动调试：</strong></p><pre><code>&gt;&gt;&gt; gdb a.out#输出如下代表成功：...Reading symbols from ./practice_p1/a.out...done.(gdb)</code></pre><p>这样就进入调试模式：如果在第 6 行继续输入 r，会全部运行完毕。我们应该添加断点。</p><p><strong>添加断点：</strong></p><pre><code class="shell">&gt;&gt;&gt; (gdb) b 14                                     #在第 14 行添加断点Breakpoint 1 at 0x40086f: file p1.cpp, line 14.&gt;&gt;&gt; (gdb) b 17Breakpoint 2 at 0x40088d: file p1.cpp, line 17.&gt;&gt;&gt; (gdb) info bNum     Type           Disp Enb Address            What1       breakpoint     keep y   0x000000000040086f in main() at p1.cpp:142       breakpoint     keep y   0x000000000040088d in main() at p1.cpp:17</code></pre><p><strong>开始调试：</strong></p><pre><code class="shell">&gt;&gt;&gt; (gdb) r                                  #开始执行Starting program: ./practice_p1/a.out10Breakpoint 1, main () at p1.cpp:1414          cout&lt;&lt;b&lt;&lt;endl;&gt;&gt;&gt; (gdb) c                                  # 继续执行Continuing.20Breakpoint 2, main () at p1.cpp:1717             cout&lt;&lt;i&lt;&lt;endl;#当程序执行完毕，会显示：[Inferior 1 (process 389700) exited normally]</code></pre><h2 id="退出 GDB"><a href="# 退出 GDB" class="headerlink" title="退出 GDB"></a>退出 GDB</h2><ul><li>可以用命令：<strong>q（quit 的缩写）或者 Ctr + d</strong> 退出 GDB。</li><li>如果 GDB attach 某个进程，退出 GDB 之前要用命令 <strong>detach</strong> 解除附加进程。</li></ul><h2 id="常用命令"><a href="# 常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th>命令名称</th><th>命令缩写</th><th>命令说明</th></tr></thead><tbody><tr><td>run</td><td>r</td><td>运行一个待调试的程序</td></tr><tr><td>continue</td><td>c</td><td>让暂停的程序继续运行到下一个断点处</td></tr><tr><td>next</td><td>n</td><td>运行到下一行，单步调试（遇到函数不进入内部）</td></tr><tr><td>step</td><td>s</td><td>运行到下一行，单步执行（遇到函数会进入）</td></tr><tr><td>finish</td><td>finish</td><td>跳出当前函数，常与 s 配合使用</td></tr><tr><td>return</td><td>return</td><td>跳出当前函数，并返回指定值，到上一层函数调用处</td></tr><tr><td>until</td><td>u</td><td>退出循环体（自动一次性执行完剩余的循环）</td></tr><tr><td>jump</td><td>j</td><td>将当前程序执行流跳转到指定行或地址</td></tr><tr><td>print</td><td>p</td><td>打印变量或寄存器值，执行完毕到下一行才能 p 前一行的变量值</td></tr><tr><td>backtrace</td><td>bt</td><td>查看当前线程的调用堆栈</td></tr><tr><td>frame</td><td>f</td><td>切换到当前调用线程的指定堆栈</td></tr><tr><td>thread</td><td>thread</td><td>切换到指定线程</td></tr><tr><td>break</td><td>b</td><td>添加断点</td></tr><tr><td>tbreak</td><td>tb</td><td>添加临时断点</td></tr><tr><td>delete</td><td>d</td><td>删除断点</td></tr><tr><td>enable</td><td>enable</td><td>启用某个断点</td></tr><tr><td>disable</td><td>disable</td><td>禁用某个断点</td></tr><tr><td>watch</td><td>watch</td><td>监视某一个变量或内存地址的值是否发生变化</td></tr><tr><td>list</td><td>l</td><td>显示源码，默认 10 行</td></tr><tr><td>info</td><td>i</td><td>查看断点 / 线程等信息</td></tr><tr><td>ptype</td><td>ptype</td><td>查看变量类型</td></tr><tr><td>disassemble</td><td>dis</td><td>查看汇编代码</td></tr><tr><td>set args</td><td>set args</td><td>设置程序启动命令行参数</td></tr><tr><td>show args</td><td>show args</td><td>查看设置的命令行参数</td></tr><tr><td>wh</td><td>wh</td><td>打开监视窗口，窗口上半部分为代码区，下半部分为调试区，退出为 ctrl+x+a</td></tr></tbody></table><p><strong>下面做一些详细的介绍：</strong></p><h3 id="显示源代码"><a href="# 显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h3><ul><li><p><strong>list</strong>    打印源码，默认 10 行</p></li><li><p><strong>list line_num</strong>   打印指定行的代码以及前 5 行，后 4 行</p></li><li><p><strong>list func</strong>       #打印函数名为 func 的函数</p></li><li><p><strong>show listsize</strong>，查看 <strong>list</strong> 命令显示的代码行数；</p></li><li><p><strong>set listsize count</strong>，设置 <strong>list</strong> 命令显示的代码行数为 <strong>count</strong>;</p></li></ul><h3 id="设置断点"><a href="# 设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p> break 命令（简写为 b）用于添加断点，可以使用以下几种方式添加断点：</p><ul><li><strong>break LineNo</strong>，在 <strong> 当前文件 </strong> 行号为 <strong>LineNo</strong> 处添加断点；</li><li><strong>break FunctionName</strong>，在函数的入口处添加一个断点；</li><li><strong>info break</strong>，显示所有断点。</li><li><strong>disable 断点编号</strong>，禁用某个断点，使得断点不会被触发；</li><li><strong>enable 断点编号</strong>，启用某个被禁用的断点；</li><li><strong>delete 断点编号</strong>，删除某个断点。</li><li><strong>clear 行号</strong>，删除该行的断点</li><li><strong>break FileName:LineNo</strong>，在 <strong>FileName</strong> 文件行号为 <strong>LineNo</strong> 处添加一个断点；</li><li><strong>break FileName:FunctionName</strong>，在 <strong>FileName</strong> 文件的 <strong>FunctionName</strong> 函数的入口处添加断点；</li><li><strong>break -/+offset</strong>，在当前程序暂停位置的前 / 后 offset 行处下断点；</li><li><strong>break … if cond</strong>，设置条件断点；</li></ul><p>Tips：</p><blockquote><p>如果有时发现用函数名打不上，记得加作用域（类名或命名空间）。</p></blockquote><h3 id="条件断点"><a href="# 条件断点" class="headerlink" title="条件断点"></a>条件断点 </h3><p> 当我们进入一个循环时，需要分析第 50 次循环时，不可能手动循环 50 次去查看，这时候就需要使用【条件断点】</p><pre><code class="linux">(gdb) b test.cc:120 if i==50</code></pre><p>注意断点的位置，要有 <code>i</code> 这个值。</p><p>另外，gdb 也支持修改断点的条件：<code>condition 断点编号 条件表达式</code></p><pre><code>(gdb) condition 1 i==100 &amp;&amp; j==20</code></pre><p>修改断点的条件时，只能向后修改，不能返回。修改完后，按 <code>c</code> 执行到指定条件的断点。</p><p><code>(gdb) condition &lt; 断点编号 &gt;</code>：删除该断点的条件。</p><h3 id="断点与打印"><a href="# 断点与打印" class="headerlink" title="断点与打印"></a>断点与打印 </h3><p> 每次断点发生时候，想要查看的变量很多时，如果每个变量都手动 print 需要浪费很多时间。断点命令可以在断点发生时批量执行 GDB 命令。下面是断点命令的设置方式：</p><ul><li><code>(gdb) commands 断点编号</code></li><li><code>(gdb) &gt;print x</code></li><li><code>(gdb) &gt;print y</code></li><li><code>(gdb) &gt;end</code><br>首先输入 GDB 命令 commands &lt; 断点编号 &gt; 然后回车，这时候会出现 &gt; 提示符。出现 &gt; 提示符后可以输入断点发生时需要执行的 GDB 命令，每行一条，全部输入完成后输入 end 结束断点命令。</li></ul><h3 id="设置变量值"><a href="# 设置变量值" class="headerlink" title="设置变量值"></a>设置变量值 </h3><p> 对变量的值进行控制，可以更快的调试自己的程序。下面就是设置变量值的方法：</p><ul><li><code>(gdb) set variable &lt; 变量 &gt; = &lt; 表达式 &gt;</code>：将变量的值设定为指定表达式的值。例如 <code>set variable x=10</code></li></ul><h3 id="查看堆栈"><a href="# 查看堆栈" class="headerlink" title="查看堆栈"></a>查看堆栈</h3><p> 命令格式及作用：</p><ul><li><strong>backtrace</strong>，也可简写为 <strong>bt</strong>，用于查看当前调用堆栈。</li><li><strong>frame 堆栈编号</strong>，也可简写为 <strong>f 堆栈编号</strong>，用于切换到其他堆栈处。</li></ul><h3 id="查看结果"><a href="# 查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p> 命令格式及作用：</p><ul><li><strong>print param</strong>，用于在调试过程中查看变量的值；<strong>注意执行完毕到下一行才能 p 前一行的变量值</strong></li><li><strong>print param=value</strong>，用于在调试过程中修改变量的值；</li><li><strong>print a+b+c</strong>，可以进行一定的表达式计算，这里是计算 a、b、c 三个变量之和；</li><li><strong>print func()</strong>，输出 <code>func</code> 函数执行的结果，常见的用途是打印系统函数执行失败原因：<code>print strerror(errno)</code>；</li><li><strong>print *this</strong>，在 c++ 对象中，可以输出当前对象的各成员变量的值；</li><li><strong>set print elements 0</strong>，使得打印字符数不受限制。默认为 200 个字符。<ul><li><strong>show print elements</strong>，显示当前打印字符的限制数。</li></ul></li><li><strong>set print pretty on</strong>，格式化显示结构体。</li></ul><h3 id="查看变量类型"><a href="# 查看变量类型" class="headerlink" title="查看变量类型"></a>查看变量类型</h3><p> 命令格式及功能：</p><ul><li><strong>whatis val</strong>，用于查看变量类型；</li><li><strong>ptype val</strong>，作用和 <strong>whatis</strong> 类似，但功能更强大，可以查看复合数据类型，会打印出该类型的成员变量。</li></ul><h3 id="查看线程"><a href="# 查看线程" class="headerlink" title="查看线程"></a>查看线程</h3><p> 命令格式及作用：</p><ul><li><strong>info thread</strong>，查看当前进程的所有线程运行情况；</li><li><strong>thread 线程编号</strong>，切换到具体编号的线程上去；</li></ul><h3 id="单步执行"><a href="# 单步执行" class="headerlink" title="单步执行"></a>单步执行</h3><p> <strong>next</strong> 和 <strong>step</strong> 都是单步执行，但也有差别：</p><ul><li><strong>next</strong> 是 <strong>单步步过（step over）</strong>，其最大的特点是当遇到包含调用函数的语句时，无论函数内部包含多少行代码，<code>next</code> 指令都会一步执行完。也就是说，对于调用的函数来说，<code>next</code> 命令只会将其视作一行代码。</li><li><strong>step</strong> 是 <strong>单步步入（step into）</strong>，当<code>step</code> 命令所执行的代码行中包含函数时，会进入该函数内部，并在函数第一行代码处停止执行。</li></ul><h3 id="退出局部函数"><a href="# 退出局部函数" class="headerlink" title="退出局部函数"></a>退出局部函数</h3><p> <strong>return</strong> 和 <strong>finish</strong> 都是退出函数，但也有差别：</p><ul><li><strong>return</strong> 命令是立即退出当前函数，剩下的代码不会执行了，<strong>return</strong> 还可以指定函数的返回值。</li><li><strong>finish</strong> 命令是会继续执行完该函数剩余代码再正常退出。</li></ul><h3 id="跳转"><a href="# 跳转" class="headerlink" title="跳转"></a>跳转</h3><p> 命令格式及作用：</p><ul><li><p><strong>jump LineNo</strong>，跳转到代码的 <strong>LineNo</strong> 行的位置；</p></li><li><p><strong>jump +10</strong>，跳转到距离当前代码下 10 行的位置；</p></li><li><p><strong>jump *0x12345678</strong>，跳转到 <strong>0x12345678</strong> 地址的代码处，地址前要加星号；</p><p><strong>jump</strong> 命令有两点需要注意的：</p></li></ul><ol><li>中间跳过的代码是不会执行的；</li><li>跳到的位置后如果没有断点，那么 GDB 会自动继续往后执行；</li></ol><h3 id="参数传递"><a href="# 参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p> 很多程序启动需要我们传递参数，<strong>set args</strong> 就是用来设置程序启动参数的，<strong>show args</strong> 命令用来查询通过 <strong>set args</strong> 设置的参数，命令格式：</p><ul><li><strong>set args args1</strong>，设置单个启动参数 <strong>args1</strong>；</li><li><strong>set args “-p” “password”</strong>，如果单个参数之间有空格，可以使用引号将参数包裹起来；</li><li><strong>set args args1 args2 args3</strong>，设置多个启动参数，参数之间用空格隔开；</li><li><strong>set args</strong>，不带参数，则清除之前设置的参数；</li></ul><h3 id="临时断点"><a href="# 临时断点" class="headerlink" title="临时断点"></a>临时断点</h3><p>tbreak:  该命令时添加一个临时断点，断点一旦被触发就自动删除，使用方法同 <strong>break</strong>。</p><h3 id="监视"><a href="# 监视" class="headerlink" title="监视"></a>监视</h3><p> <strong>watch</strong> 命令用来监视一个变量或者一段内存，当这个变量或者内存的值发生变化时，GDB 就会中断下来。被监视的某个变量或内存地址会产生一个 <strong>watch point（观察点）</strong>。</p><p> 命令格式：</p><ul><li><strong>watch 整型变量</strong>；</li><li><strong>watch 指针变量</strong>，监视的是指针变量本身；</li><li><strong>watch * 指针变量</strong>，监视的是指针所指的内容；</li><li><strong>watch 数组变量或内存区间</strong>；</li></ul><h3 id="回退"><a href="# 回退" class="headerlink" title="回退"></a>回退</h3><blockquote><p>GDB7.0 以上版本的调试器才支持。</p></blockquote><p>能够回退的代码行，必须事先 <strong>record</strong> 才行。注意：启动 record 会导致程序运行变慢。</p><pre><code class="shell">&gt;&gt;&gt; gdb a.out&gt;&gt;&gt; (gdb) b 14&gt;&gt;&gt; (gdb) c&gt;&gt;&gt; (gdb) record    #启动进程记录回放&gt;&gt;&gt; (gdb) n&gt;&gt;&gt; (gdb) n&gt;&gt;&gt; (gdb) n&gt;&gt;&gt; (gdb) reverse-next   #向上回退一行</code></pre><p><strong>reverse-continue</strong>: 反向运行程序到 record 的位置，或者观察点</p><p><strong>reverse-step</strong>：反向运行程序到 上一行（如有函数会进入）</p><p><strong>reverse-next</strong>：反向运行程序到 上一行（不会进入函数）</p><p><strong>reverse-finish</strong>：反向运行程序回到调用当前函数的地方。</p><p><strong>reverse-stepi</strong>：反向运行程序到上一条机器指令</p><p><strong>reverse-nexti</strong>：反向运行到上一条机器指令，除非这条指令用来返回一个函数调用、否则整个函数将会被反向执行。</p><h3 id="帮助"><a href="# 帮助" class="headerlink" title="帮助"></a>帮助</h3><p> 通过 <strong>help</strong> 命令可以查看目标命令的具体用法。</p><h2 id="GDB 多线程调试"><a href="#GDB 多线程调试" class="headerlink" title="GDB 多线程调试"></a>GDB 多线程调试 </h2><h3 id="概述 -1"><a href="# 概述 -1" class="headerlink" title="概述"></a> 概述</h3><p> 多线程程序的编写更容易产生异常或 Bug（例如线程之间因竞争同一资源发生了死锁、多个线程同时对同一资源进行读和写等等）。GDB 调试器不仅仅支持调试单线程程序，还支持调试多线程程序。本质上讲，使用 GDB 调试多线程程序的过程和调试单线程程序类似，不同之处在于，调试多线程程序需要监控多个线程的执行过程。</p><p> 用 GDB 调试多线程程序时，该程序的编译需要添加 <strong><code>-lpthread</code></strong> 参数。</p><h3 id="一些命令"><a href="# 一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><ol><li><strong>info thread</strong>，查看当前调试程序启动了多少个线程，并打印出各个线程信息；</li><li><strong>thread 线程编号</strong>，将该编号的线程切换为当前线程；</li><li><strong>thread apply 线程编号 1 线程编号 2 … command</strong>，将 GDB 命令作用指定对应编号的线程，可以指定多个线程，若要指定所有线程，用 <strong>all</strong> 替换线程编号；</li><li><strong>break location thread 线程编号</strong>，在 <strong>location</strong> 位置设置普通断点，该断点只作用在特定编号的线程上；</li></ol><h3 id="一些术语"><a href="# 一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ul><li><p><strong>all-stop mode</strong>，全停模式，当程序由于任何原因在 GDB 下停止时，不止当前的线程停止，所有的执行线程都停止。这样允许你检查程序的整体状态，包括线程切换，不用担心当下会有什么改变。</p></li><li><p><strong>non-stop mode</strong>，不停模式，调试器（如 VS2008 和老版本的 GDB）往往只支持 <strong>all-stop</strong> 模式，但在某些场景中，我们可能需要调试个别的线程，并且不想在调试过程中影响其他线程的运行，这样可以把 GDB 的调式模式由 <strong>all-stop</strong> 改成 <strong>non-stop</strong>，<strong>7.0</strong> 版本的 GDB 引入了 <strong>non-stop</strong> 模式。在 <strong>non-stop</strong> 模式下 <strong>continue、next、step</strong> 命令只针对当前线程。</p></li><li><p><strong>record mode</strong>，记录模式；</p></li><li><p><strong>replay mode</strong>，回放模式；</p></li><li><p><strong>scheduler-locking</strong> ，调度锁；</p></li><li><p><strong>schedule-multiple</strong>，多进程调度；</p></li></ul><h3 id="设置线程锁"><a href="# 设置线程锁" class="headerlink" title="设置线程锁"></a>设置线程锁 </h3><p> 使用 GDB 调试多线程程序时，默认的调试模式是：<strong> 一个线程暂停运行，其他线程也随即暂停；一个线程启动运行，其他线程也随即启动 </strong>。但在一些场景中，我们希望只让特定线程运行，其他线程都维持在暂停状态，即要防止<strong> 线程切换</strong>，要达到这种效果，需要借助 <strong>set scheduler-locking</strong> 命令。</p><p> 命令格式及作用：</p><ul><li><strong>set scheduler-locking on</strong>，锁定线程，只有当前或指定线程可以运行；</li><li><strong>set scheduler-locking off</strong>，不锁定线程，会有线程切换；</li><li><strong>set scheduler-locking step</strong>，当单步执行某一线程时，其他线程不会执行，同时保证在调试过程中当前线程不会发生改变。但如果在该模式下执行 <strong>continue、until、finish</strong> 命令，则其他线程也会执行；</li><li><strong>show scheduler-locking</strong>，查看线程锁定状态；</li></ul><h2 id="调试 core 文件"><a href="# 调试 core 文件" class="headerlink" title="调试 core 文件"></a>调试 core 文件 </h2><p> 当程序运行过程中出现 Segmentation fault (core dumped)错误时，程序停止运行，并产生 core 文件。</p><p>core 文件是程序运行状态的内存映象。</p><p>使用 gdb 调试 core 文件，可以帮助我们快速定位程序出现段错误的位置。</p><p>该错误产生的主要原因有：(1)访问不存在的内存地址；(2)访问系统保护的内存地址；(3)数组访问越界等。</p><p><strong>控制 core 文件是否生成</strong></p><ol><li>使用 ulimit -c 命令可查看 core 文件的生成开关。若结果为 0，则表示关闭了此功能，不会生成 core 文件。</li><li>使用 ulimit -c unlimited，则表示生成 core 文件的大小不受限制。ulimit -c filesize 命令，可以限制 core 文件的大小（filesize 的单位为 KB）</li></ol><p><strong>调试 core</strong></p><p>方法 1：</p><ol><li>进入 gdb 模式：gdb binary , 我们一般是定义好了 debug.sh, 直接运行 sh debug.sh </li><li>输入：core-file core.xxxx</li><li>输入 bt</li></ol><p>类似的可以这样做：</p><ol><li>gdb binary core_XXXX</li><li>bt</li></ol><h2 id="参考文档"><a href="# 参考文档" class="headerlink" title="参考文档"></a>参考文档 </h2><p><a href="https://link.zhihu.com/?dest=http%3A//www.gnu.org/software/gdb/documentation/"> 官方参考文档</a></p><p><a href="https://link.zhihu.com/?dest=https%3A//blog.csdn.net/Roland_Sun/article/details/42460663">GDB 常用命令</a></p><p><a href="https://link.zhihu.com/?dest=http%3A//c.biancheng.net/gdb/">GDB 调试教程：1 小时玩转 Linux gdb 命令</a></p><h1 id="编译 log 重定向"><a href="# 编译 log 重定向" class="headerlink" title="编译 log 重定向"></a>编译 log 重定向</h1><p>Linux 上有时候我们编译，屏幕上会打印超级多的 error message，使得我们很难去定位问题，这时候可以把屏幕输出的 log 重定向到指定文件里，然后进行搜索，找到问题所在：</p><pre><code class="shell">make -j10 &gt; ../error-message.txt 2&gt;&amp;1</code></pre><ul><li>2&gt;&amp;1 表示错误信息输出到 &amp;1 中，而 &amp;1 又代表了 error-message.txt</li></ul><p>linux 系统中默认有 3 个输出设备，分别为 stdin、stdout、sdterr，分别表示标准输入设备、标准输出设备和标准错误设备。</p><table><thead><tr><th>设备名称</th><th>标准叫法</th><th>代号</th></tr></thead><tbody><tr><td>标准输入设备</td><td>stdin = standard input</td><td>0</td></tr><tr><td>标准输出设备</td><td>stdout = standard output</td><td>1</td></tr><tr><td>标准错误设备</td><td>stderr = standard error</td><td>2</td></tr></tbody></table><h1 id="声明全局变量"><a href="# 声明全局变量" class="headerlink" title="声明全局变量"></a>声明全局变量 </h1><p> 很多人可能直接把全局变量写进.h 文件，然后用多个文件包含这个头文件，编译时就会报错：变量重定义…</p><p>正确的做法是：</p><p>首先在.c/cpp 文件中声明</p><pre><code>int g_a;</code></pre><p>然后在对应头文件里：</p><pre><code>extern int g_a;</code></pre><h1 id="多线程和锁 Mutex"><a href="# 多线程和锁 Mutex" class="headerlink" title="多线程和锁 Mutex"></a>多线程和锁 Mutex</h1><p>忘了系统性总结，后面再写</p><h1 id="Lambda 表达式"><a href="#Lambda 表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式 </h1><p> 使用 STL 时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个 <strong> 对象也只使用了一次，编写这样的函数对象类就有点浪费。</strong></p><p>对于只使用一次的函数对象类，直接在使用它的地方定义：Lambda 表达式能够解决这个问题。使用 Lambda 表达式可以减少程序中函数对象类的数量，使得程序更加优雅。</p><p>Lambda 表达式实际上是一个函数，只是它没有名字。</p><p>Lambda 表达式的定义形式如下：</p><pre><code>[捕获列表] (参数表) -&gt; 返回值类型&#123;   语句块&#125;</code></pre><ul><li>捕获列表：可省略</li><li><code>-&gt; 返回值类型</code> 可省略</li></ul><p>举个例子：</p><pre><code class="c++">auto Add = [](int a, int b) &#123;return a+b;&#125;std::cout&lt;&lt; Add(1,2);std::cout&lt;&lt; [](int a, int b) &#123;return a+b;&#125;(1,2);   与上等价，可以取名，也可以不取名直接使用</code></pre><p>再举个例子：</p><pre><code class="c++">auto Cmpt = [](const db::Point &amp;p1, const db::Point &amp;p2)&#123;    return p1.x&lt;p2.x || (p1.x==p2.x &amp;&amp; p1.y&lt;p2.y);&#125;std::set&lt;db::Point, Cmpt&gt; s_points;</code></pre><h2 id="捕获列表"><a href="# 捕获列表" class="headerlink" title="捕获列表"></a>捕获列表 </h2><p> 作用是：提供一种访问外部变量的接口</p><pre><code class="c++">int a = 12;auto Add = [a](int b, int c)-&gt;int &#123;    return a;            // 访问了外部变量，必须将 a 通过捕获列表传进来&#125;;std::cout &lt;&lt; Add(1, 2) &lt;&lt; std::endl;</code></pre><p>上述写法，不能改变 a 的值，因为 a 是按值传递的。</p><pre><code>int a = 12;auto Add = [&amp;a](int b, int c)-&gt;int &#123;             // 得按引用传递    a=a+1;    return a;         &#125;;std::cout &lt;&lt; Add(1, 2) &lt;&lt; std::endl;</code></pre><p>捕获列表使用总结：</p><table><thead><tr><th align="center">符号</th><th align="left">解释</th></tr></thead><tbody><tr><td align="center">[]</td><td align="left">空捕获列表，Lambda 不能使用所在函数中的变量。</td></tr><tr><td align="center">[names]</td><td align="left">names 是一个逗号分隔的名字列表，这些名字都是 Lambda 所在函数的局部变量。默认情况下，这些变量会被拷贝，然后按值传递，名字前面如果使用了 &amp;，则按引用传递</td></tr><tr><td align="center">[&amp;]</td><td align="left">隐式捕获列表，Lambda 体内使用的局部变量都按引用方式传递</td></tr><tr><td align="center">[=]</td><td align="left">隐式捕获列表，Lanbda 体内使用的局部变量都按值传递</td></tr><tr><td align="center">[&amp;,identifier_list]</td><td align="left">identifier_list 是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量，这些变量采用值捕获的方式，其他变量则被隐式捕获，采用引用方式传递，identifier_list 中的名字前面不能使用 &amp;。</td></tr><tr><td align="center">[=,identifier_list]</td><td align="left">identifier_list 中的变量采用引用方式捕获，而被隐式捕获的变量都采用按值传递的方式捕获。identifier_list 中的名字不能包含 this，且这些名字面前必须使用 &amp;。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Protocol Buffers 入门使用</title>
      <link href="/Protocol-Buffers-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"/>
      <url>/Protocol-Buffers-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1、什么是 protocol"><a href="#1、什么是 protocol" class="headerlink" title="1、什么是 protocol"></a>1、什么是 protocol</h2><p>protobuf（Protocol Buffers ）是 Google 的开源项目，是 Google 的 <strong> 中立于语言、平台 </strong>，可扩展的用于<strong> 序列化结构化数据 </strong> 的解决方案。</p><p>简单的说，protobuf 是用来对数据进行 <strong> 序列化 </strong> 和<strong>反序列化</strong>。支持的开发语言包括 C++、Java、Python、Objective-C、C#、JavaNano、JavaScript、Ruby、Go、PHP 等。</p><p><strong>序列化 (Serialization)：</strong>将数据结构或对象转换成二进制串的过程。</p><p><strong>反序列化（Deserialization）：</strong>将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</p><h2 id="2、数据为啥要序列化"><a href="#2、数据为啥要序列化" class="headerlink" title="2、数据为啥要序列化"></a>2、数据为啥要序列化 </h2><p> 存储或者传输数据时，需要将当前数据对象转换成字节流便于 <strong> 网络传输或者存储</strong>。</p><p>当我们需要再次使用这些数据时，需要将接收到的或者读取的字节流进行 <strong> 反序列化，重建我们的数据对象</strong>。</p><p>我们常使用的一个场景是：在分布式处理任务时，主服务器（master）会将每个子任务分发到每个子节点 (works) 进行单独计算，每个子节点的数据都是临时存储在其内存当中，计算完毕后需要 <strong> 将数据传回 master 上</strong>，master 再进行综合处理（合并，数据持久化等操作）。</p><p>这个将数据传回 master 上，就需要将这些数据进行序列化，借助 protobuf，将数据转换成二进制串，传回 master 后，再进行反序列化，将 worker 传过来的数据转换成开发语言（如 C++）的数据结构，再将这些反序列化后数据在 master 上进行一些其他的操作。</p><h2 id="3、怎么使用 protobuf"><a href="#3、怎么使用 protobuf" class="headerlink" title="3、怎么使用 protobuf"></a>3、怎么使用 protobuf</h2><p>假设有以下数据，需要将其序列化：</p><pre><code class="c++">struct Student&#123;    Student():m_age(0), m_gender(0), m_scores(0)&#123;&#125;    Student(std::string name, int age, int gender, int scores):m_name(name),m_age(age),m_gender(gender), m_scores(scores)&#123;&#125;    std::string m_name;    int m_age;    int m_gender;   // 0 female; 1 male    int m_scores;&#125;;std::map&lt;int, std::vector&lt;Student&gt; &gt; work_students;   // 班级 - 学生</code></pre><p>需要将 <code>work_students</code> 这里面的数据序列化后传输到 master 上。</p><h3 id="第一步：编写 proto 文件（studentResult-proto）"><a href="# 第一步：编写 proto 文件（studentResult-proto）" class="headerlink" title="第一步：编写 proto 文件（studentResult.proto）"></a>第一步：编写 proto 文件（studentResult.proto）</h3><pre><code class="protobuf">syntax=&quot;proto2&quot;;                   // 指定使用 proto 语法版本package StMessage;                 // 指定 package 名字，以防止不同项目名字冲突message Student                    // 定义消息&#123;    required string name = 1;      // 定义第一个字段 格式： 字段修饰符 数据类型 字段名 = 唯一标识符    required int32 age = 2;    required int32 gender = 3;    required int32 scores = 4;&#125;message studentResult    // 这个是核心消息，从这里开始&#123;    required int32 classid = 1;    repeated Student students = 2;&#125;</code></pre><ul><li><strong>syntax</strong>，支持 proto2 和 proto3，二者语法有差异，我们常使用 proto2，如有空，也可去了解下 proto3。</li><li><strong>package</strong>， .proto 文件以一个 package 声明开始。这个声明是为了防止不同项目之间的命名冲突。对应到 C++ 中去，你用这个.proto 文件生成的类将被放置在一个与 package 名相同的 <strong> 命名空间 </strong> 中。</li><li><strong>message</strong>，定义一个消息，一个消息就是某些类型的 <strong> 字段 </strong> 的集合，对应着 C++ 里面的数据。</li></ul><p><strong>字段</strong>：</p><ul><li><p><strong>修饰符</strong></p><ul><li><strong>required</strong> 必须提供字段值，否则对应的消息就会被认为是“未初始化的”。</li><li><strong>repeated：</strong>字段会重复 N 次（N 可以为 0）。重复的值的顺序将被保存在 protocol buffer 中。你只要将重复的字段视为动态大小的数组就可以了。</li><li><strong>optional：</strong>字段值指定与否都可以。如果没有指定一个 optional 的字段值，它就会使用默认值（0）。对简单类型来说，你可以指定你自己的默认值。</li></ul></li><li><p><strong>数据类型</strong></p><ul><li><strong>基本数据类型</strong></li></ul><table><thead><tr><th>proto 文件消息类型</th><th>C++ 类型</th><th>说明</th></tr></thead><tbody><tr><td>double</td><td>double</td><td></td></tr><tr><td>float</td><td>float</td><td></td></tr><tr><td>int32</td><td>int32</td><td>使用可变长编码方式，负数时不够高效，应该使用 sint32</td></tr><tr><td>int64</td><td>int64</td><td>同上</td></tr><tr><td>uint32</td><td>uint32</td><td>使用可变长编码方式</td></tr><tr><td>uint64</td><td>uint64</td><td>同上</td></tr><tr><td>bool</td><td>bool</td><td></td></tr><tr><td>string</td><td>string</td><td>一个字符串必须是 utf-8 编码或者 7-bit 的 ascii 编码的文本</td></tr><tr><td>bytes</td><td>string</td><td>可能包含任意顺序的字节数据</td></tr><tr><td>fixed32</td><td>uint32</td><td>总是 4 个字节，如果数值总是比 2^28 大的话，这个类型会比 uint32 高效</td></tr><tr><td>fixed64</td><td>uint64</td><td>总是 8 个字节，如果数值总是比 2^56 大的话，这个类型会比 uint64 高效</td></tr><tr><td>sfixed32</td><td>int32</td><td>总是 4 个字节</td></tr><tr><td>sfixed64</td><td>int64</td><td>总是 8 个字节</td></tr></tbody></table><ul><li><p><strong>自定义数据类型</strong></p><p>可以使用自定义的 message 作为另一个 message 的某些字段的数据类型。</p><p>例如上述在 studentResult message 中，使用了自定义的数据类型，这个数据类型其实就是我们在上面定义的一个 message Student。</p></li></ul></li><li><p><strong>唯一标识符</strong></p><ul><li>在每一项后面的、类似于“= 1”，“= 2”的标志指出了该字段在二进制编码中使用的唯一“标识（tag）”。标识号 1-15 编码所需的字节数比更大的标识号使用的字节数要少 1 个，所以，如果你想寻求优化，可以为经常使用或者重复的项采用 1~15 的标识（tag），其他经常使用的 optional 项采用≥16 的标识（tag）。在重复的字段中，每一项都要求重编码标识号（tag number），所以重复的字段特别适用于这种优化情况。</li></ul></li></ul><p>【注意】：字段名最好全用小写字母，不要使用大写字母，因为在编译后的 pb.h 文件中，字段名全部会转成小写，可能在 C++ 中使用错误，找不到这个名字。</p><h3 id="第二步：将我们的核心 message 加到总的 proto 文件里"><a href="# 第二步：将我们的核心 message 加到总的 proto 文件里" class="headerlink" title="第二步：将我们的核心 message 加到总的 proto 文件里"></a>第二步：将我们的核心 message 加到总的 proto 文件里 </h3><p> 这里我们总的 proto 文件叫 attached_data.proto，与分 proto 文件在同级目录里。</p><pre><code class="protobuf">syntax=&quot;proto2&quot;;package protocol;import &quot;studentResult.proto&quot;message AttachedData&#123;    #...    optional StMessage.studentResult st_result = 6;   // 格式：修饰符 package 名. 要使用的核心消息 字段名 = 标识符&#125;</code></pre><h3 id="第三步：编译 proto 文件（studentResult-proto）"><a href="# 第三步：编译 proto 文件（studentResult-proto）" class="headerlink" title="第三步：编译 proto 文件（studentResult.proto）"></a>第三步：编译 proto 文件（studentResult.proto）</h3><p>在定义好 proto 文件后，需要将其编译，用于生成.pb.h 文件（proto 文件中自定义类的头文件）和 .pb.cc（proto 文件中自定义类的实现文件）。</p><p>这样我们才能在 C++ 中使用相关的接口，进行数据的处理。</p><p>在 studentResult.proto 的同级目录下，编写一个 shell 文件，用于编译 proto：</p><p>当然，我们现在已经有这个 shell 文件，就不用再去写了，直接用 sh 运行它即可。</p><p>如果没有这个 shell 文件，就需要我们去编写它</p><pre><code class="shell">#!/bin/bashexport ORIG_LD_LIBRARY_PATH=$LD_LIBRARY_PATHproto34_path=&#39;/home/proto3.4_env&#39;export LD_LIBRARY_PATH=$proto34_path/lib:$ORIG_LD_LIBRARY_PATH$proto34_path/bin/protoc --cpp_out=./3.4/ *.proto                    #重要的是这一行proto37_path=&#39;/home/proto3.7_env&#39;export LD_LIBRARY_PATH=$proto37_path/lib:$ORIG_LD_LIBRARY_PATH$proto37_path/bin/protoc --cpp_out=./3.7/ *.proto                    #重要的是这一行</code></pre><p>[protoc 程序]  –cpp_out=[输出路径]  [指定需要编译的 proto 文件]</p><p>编译完毕后，生成的 pb 文件可以在编译时指定的路径中找到，注意这个文件不要去编辑它。</p><h2 id="4、编写序列化函数"><a href="#4、编写序列化函数" class="headerlink" title="4、编写序列化函数"></a>4、编写序列化函数 </h2><p> 准备好 pb 文件后，就可以在 C++ 中使用它了，序列化 C++ 数据：还是以 <code>std::map&lt;int, std::vector&lt;Student&gt; &gt; class_students;</code> 为例</p><p>写一个序列化函数：</p><pre><code class="c++">#include &quot;studentResult.pb.h&quot;       // 添加对应的 pb 头文件namespace StMessage          // 这个写在实现函数的头文件里。这里就不做分离了&#123;    class studentResult;&#125;void StResultManager::serialize(StMessage::studentResult* st_result)&#123;    for(auto pit=work_students.begin(); pit!=work_students.end(); ++pit)    &#123;        st_result-&gt;set_classid(pit-&gt;first);        const std::vector&lt;Student&gt;&amp; students = pit-&gt;second;        for(size_t i=0; i&lt;students.size(); ++i)        &#123;            StMessage::Student* st = st_result-&gt;add_students();            st-&gt;set_name(students[i].m_name);            st-&gt;set_age(students[i].m_age);            st-&gt;set_gender(students[i].m_gender);            st-&gt;set_scores(students[i].m_scores);        &#125;    &#125;&#125;</code></pre><p><code>StMessage::studentResult</code>  StMessage 是 proto 里的 package 名（在 C++ 里就成了命名空间），studentResult 是 proto 里的核心 message 名，也就是最外层的那个 message。</p><p>在进行数据序列化的时候，添加数据有几种接口（函数）：</p><ul><li><p>set_开头的：对应 required 修饰符。<code>set__字段名()</code></p></li><li><p>add_开头的：对应 repeated 修饰符。<code>add__字段名()</code></p></li><li><p>mutable_开头的：对应 required 修饰符以及数据类型为自定义 message 类型的。还可对应 optional 修饰符的字段。</p></li></ul><p>常用的就这三个，基本就能满足使用了。</p><p>这个函数在 work 上调用！</p><h2 id="5、编写反序列化函数"><a href="#5、编写反序列化函数" class="headerlink" title="5、编写反序列化函数"></a>5、编写反序列化函数 </h2><p> 反序列化函数在 master 上调用。</p><pre><code class="c++">#include &quot;studentResult.pb.h&quot;         // 添加对应的 pb 头文件std::map&lt;int, std::vector&lt;Student&gt; &gt; master_datas;   // 将反序列化的数据存储在这里void StResultManager::deserialize(const StMessage::studentResult* st_result)&#123;    const int calssid = st_result-&gt;classid()    for(int i=0;i&lt;st_result-&gt;students_size(); ++i)    &#123;        const StMessage::Student&amp; stt = st_result-&gt;students(i);        const Student&amp; st = Student(stt.name(), stt.age(), stt.gender(), stt.scores());        master_datas[calssid].push_back(st);    &#125;&#125;</code></pre><p>这样就完成了数据的传输。</p><p>当然如有兴趣，可以阅读.pb.h 文件，看看从 proto 定义的 message 是怎么对应到 C++ 函数的。一般来讲，无需纠结这个。</p><h2 id="7、参考"><a href="#7、参考" class="headerlink" title="7、参考"></a>7、参考</h2><p><a href="https://cloud.tencent.com/developer/article/1176660">Protocol Buffers C++ 入门教程 - 腾讯云开发者社区 - 腾讯云 (tencent.com)</a></p><p><a href="https://www.cnblogs.com/lianshuiwuyi/p/12228544.html">Proto3：C++ 基本使用 - 落雷 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/weixin_43679037/article/details/121744886"> protobuf 使用系列详解三：补充四种 API 的使用：mutable_<em>、ParseFrom*、set_allocated_</em>_谢白羽的博客 -CSDN 博客_mutable proto</a></p><p><a href="https://www.cnblogs.com/lidabo/p/5405545.html">protobuf 中的嵌套消息的使用 主要对 set_allocated_和 mutable_的使用 - DoubleLi - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++python 混合编程 -boost</title>
      <link href="/C-python%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B-boost/"/>
      <url>/C-python%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B-boost/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习转自：JasonLiThirty</p></blockquote><h1 id="一、前言"><a href="# 一、前言" class="headerlink" title="一、前言"></a>一、前言 </h1><h2 id="1-1-boost"><a href="#1-1-boost" class="headerlink" title="1.1 boost"></a>1.1 boost</h2><p>boost::python 用于将 C++ 的函数和对象导出，<strong> 方便 python 调用 </strong> 对象和方法，用来实现 C++ 和 Python 的混合编程。</p><p>一言概之：boost 库的作用就是：将 C++ 的对象 <strong> 转化 </strong> 为 python 能直接调用的对象。用 C++ 写程序，用 python 解释器调用。</p><h2 id="1-2- 安装"><a href="#1-2- 安装" class="headerlink" title="1.2 安装"></a>1.2 安装 </h2><p> 库的安装参阅：<a href="https://www.jianshu.com/p/2cabb894404e">C++ 和 Python 的混合编程 -Boost::python 的编译和配置 - 简书 (jianshu.com)</a></p><h2 id="1-3- 前菜"><a href="#1-3- 前菜" class="headerlink" title="1.3 前菜"></a>1.3 前菜 </h2><p> 直接看一个 C++ 和 python 混合编程的例子：</p><pre><code class="c++">#define BOOST_PYTHON_STATIC_LIB   //boost::python 库的 config.hpp 中规定，如没定义 BOOST_PYTHON_STATIC_LIB ，则采用动态编译的库#include &lt;boost/python.hpp&gt;#include &lt;iostream&gt;struct StructionData&#123;    void hello()    &#123;        std::cout &lt;&lt; &quot;hello, this is boost::python sample!&quot; &lt;&lt; std::endl;    &#125;    void printmsg()    &#123;        std::cout &lt;&lt; &quot;print message done!&quot; &lt;&lt; std::endl;    &#125;&#125;;BOOST_PYTHON_MODULE(Boost_Python_Sample)&#123;    //struct    boost::python::class_&lt;StructionData&gt;(&quot;StructionData&quot;)        .def(&quot;hello_p&quot;, &amp;StructionData::hello)        .def(&quot;printmsg_p&quot;, &amp;StructionData::printmsg);&#125;</code></pre><p>上面第 6-16 行定义的一个 C++ 结构体，第 18-24 行写了一个 BOOST_PYTHON_MODULE，用来导出 C++ 的结构体，以供 python 使用。</p><ul><li><code>BOOST_PYTHON_MODULE</code>里面传的为自定义的模块名。python 调用的 C++ 结构体的时候，需要导入该库名。</li><li><code>boost::python::class_&lt;StructionData&gt;(&quot;StructionData&quot;)</code>，前面部分说明导出的是结构体，后面括号里 <code>StructionData</code> 是自定义的对象名。</li><li>def 中第二个参数 <code>StructionData::hello</code> 为 C++ 结构体的函数名，第一个参数 <code>hello</code> 为导出的函数名，供 python 调用的。</li></ul><p>下面看 python 解释器运行上面的代码：</p><pre><code class="python">&gt;&gt;&gt; import Boost_Python_Sample&gt;&gt;&gt; Ptr = Boost_Python_Sample.StructionData&gt;&gt;&gt; Ptr.hello_p()hello, this is boost::python sample!&gt;&gt;&gt; Ptr.printmsg_p()print message done!</code></pre><h1 id="二、C- 数据类型的导出和调用"><a href="# 二、C- 数据类型的导出和调用" class="headerlink" title="二、C++ 数据类型的导出和调用"></a>二、C++ 数据类型的导出和调用 </h1><h2 id="2-1- 函数 Function"><a href="#2-1- 函数 Function" class="headerlink" title="2.1 函数 Function"></a>2.1 函数 Function</h2><p> 格式：<code>boost::python::def(&quot; 导出的 python 函数名 &quot;， c++ 函数名)</code></p><p>看一个例子</p><pre><code class="c++">void greet()&#123;    cout&lt;&lt; &quot;Hello world!&quot; &lt;&lt;endl;&#125;BOOST_PYTHON_MODULE(Python_Wrapper)&#123;    boost::python::def(&quot;greet&quot;, greet);&#125;//python 解释器运行&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; Python_Wrapper.greet()&#39;Hello world!&#39;</code></pre><h2 id="2-2- 类 class"><a href="#2-2- 类 class" class="headerlink" title="2.2 类 class"></a>2.2 类 class</h2><h3 id="2-2-1 无参构造"><a href="#2-2-1 无参构造" class="headerlink" title="2.2.1 无参构造"></a>2.2.1 无参构造 </h3><p> 格式：</p><pre><code>boost::python::class_&lt;T&gt;(&quot;TName&quot;)     .def(&quot;func1&quot;, &amp;T::func1)     .def(&quot;func2&quot;, &amp;T::func2); </code></pre><ul><li>T 是需要被导出的 C++ 类名</li><li>TName 是导出的自定义的类名</li></ul><p>看一个例子：</p><pre><code class="c++">class Person &#123;public:    void set(string name) &#123;        m_name = name;    &#125;    string get() &#123;        return m_name;    &#125;private:    string m_name;&#125;;BOOST_PYTHON_MODULE(Python_Wrapper)&#123;    boost::python::class_&lt;Person&gt;(&quot;Person&quot;)     .def(&quot;set&quot;, &amp;Person::set)     .def(&quot;get&quot;, &amp;Person::get); &#125;//python 解释器运行&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; msg = Python_Wrapper.Message()&gt;&gt;&gt; msg.Get()&#39;&#39;&gt;&gt;&gt; msg.Set(&#39;123&#39;)&gt;&gt;&gt; msg.Get()&#39;123&#39;</code></pre><h3 id="2-2-2- 有参构造"><a href="#2-2-2- 有参构造" class="headerlink" title="2.2.2 有参构造"></a>2.2.2 有参构造 </h3><p> 格式：<code>boost::python::class_&lt;T&gt;(&quot;TName&quot;, boost::python::init&lt;para&gt;())</code></p><pre><code class="c++">class Sum&#123;public:    Sum(std::string data) :m_data(data) &#123;&#125;    Sum(double a, double b) :m_a(a), m_b(b) &#123;&#125;    void Set(std::string data)    &#123;        m_data = data;    &#125;    std::string Get()    &#123;        return m_data;    &#125;    double Result()    &#123;        return m_a + m_b;    &#125;private:    std::string m_data;    double m_a;    double m_b;&#125;;BOOST_PYTHON_MODULE(Python_Wrapper)&#123;    boost::python::class_&lt;Sum&gt;(&quot;Sum&quot;, boost::python::init&lt;std::string&gt;())        .def(boost::python::init&lt;double, double&gt;())        .def(&quot;Set&quot;, &amp;Sum::Set)        .def(&quot;Get&quot;, &amp;Sum::Get)        .def(&quot;Result&quot;, &amp;Sum::Result);&#125;//python 解释器运行&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; s1 = Python_Wrapper.Sum(&quot;total&quot;)&gt;&gt;&gt; s1.Get()&#39;total&#39;&gt;&gt;&gt; s2 = Python_Wrapper.Sum(1,2)&gt;&gt;&gt; s2.Result()3.0</code></pre><h3 id="2-2-3- 成员属性"><a href="#2-2-3- 成员属性" class="headerlink" title="2.2.3 成员属性"></a>2.2.3 成员属性 </h3><p> 格式：<code>.def_readonly()/.def_readwrite()</code></p><pre><code class="c++">class User&#123;public:    User(std::string name) :m_name(name), m_number(-1) &#123;&#125;    std::string m_name;    int m_number;&#125;;BOOST_PYTHON_MODULE(Python_Wrapper)&#123;    boost::python::class_&lt;User&gt;(&quot;User&quot;, boost::python::init&lt;std::string&gt;())        .def_readonly(&quot;name&quot;, &amp;User::m_name)        .def_readwrite(&quot;number&quot;, &amp;User::m_number);&#125;//python 解释器运行&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; user = Python_Wrapper.User(&quot;Jason&quot;)&gt;&gt;&gt; user.name = &quot;Micky&quot;Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: can&#39;t set attribute&gt;&gt;&gt; user.number = 12345&gt;&gt;&gt; user.number12345</code></pre><h3 id="2-2-4- 增加类属性"><a href="#2-2-4- 增加类属性" class="headerlink" title="2.2.4 增加类属性"></a>2.2.4 增加类属性 </h3><p> 格式：<code>.add_property()</code></p><pre><code class="c++">class MessagePro&#123;public:    void Set(std::string msg)    &#123;        m_msg = msg;    &#125;    std::string Get()    &#123;        return m_msg;    &#125;private:    std::string m_msg;&#125;;BOOST_PYTHON_MODULE(boost_python)&#123;    boost::python::class_&lt;MessagePro&gt;(&quot;MessagePro&quot;)        .add_property(&quot;info&quot;, &amp;MessagePro::Get, &amp;MessagePro::Set);&#125;//python 解释器运行&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; msg = Python_Wrapper.MessagePro()&gt;&gt;&gt; msg.set()  // 报错&gt;&gt;&gt; msg.get()  // 报错&gt;&gt;&gt; msg.info&#39;&#39;&gt;&gt;&gt; msg.info = &#39;hello&#39;&gt;&gt;&gt; msg.info&#39;hello&#39;</code></pre><h3 id="2-2-5- 继承"><a href="#2-2-5- 继承" class="headerlink" title="2.2.5 继承"></a>2.2.5 继承 </h3><p> 格式：<code>boost::python::class_&lt;T, boost::python::bases&lt;TBase&gt;&gt;(&quot;TName&quot;)</code></p><p><strong>必须告知导出原 C++ 类的继承关系，不然导出后类之间就没有了继承关系</strong></p><p><strong>告知类的继承关系关系后：</strong></p><ul><li>继承类自动继承了基类的 Python 方法（即包装了的 c++ 成员函数）</li><li>即使是基类指针指向继承类对象，多态的函数也能够找到相应继承类的对应函数</li></ul><pre><code class="c++">class Base&#123;public:    virtual ~Base() &#123;&#125;;    virtual std::string Name()    &#123;        return &quot;Base&quot;;    &#125;&#125;;class Derived : public Base&#123;public:    std::string Name()    &#123;        return &quot;Derived&quot;;    &#125;&#125;;void BaseName(Base *base)&#123;    std::cout &lt;&lt; base-&gt;Name().c_str() &lt;&lt; std::endl;&#125;void DerivedName(Derived *derived)&#123;    std::cout &lt;&lt; derived-&gt;Name().c_str() &lt;&lt; std::endl;&#125;Base *factory()&#123;    return new Derived();&#125;BOOST_PYTHON_MODULE(boost_python)&#123;    //inherited    boost::python::class_&lt;Base&gt;(&quot;Base&quot;, boost::python::init&lt;&gt;())        .def(&quot;Name&quot;, &amp;Base::Name);    boost::python::class_&lt;Derived, boost::python::bases&lt;Base&gt;&gt;(&quot;Derived&quot;)        .def(&quot;Name&quot;, &amp;Derived::Name);    boost::python::def(&quot;BaseName&quot;, BaseName);    boost::python::def(&quot;DerivedName&quot;, DerivedName);    // 因为 factory 是生成一个新的 Direved 对象    //manage_new_object 告知 Python 生成一个指针指向一个新生成的 Python 对象，    boost::python::def(&quot;factory&quot;, factory, boost::python::return_value_policy&lt;boost::python::manage_new_object&gt;());&#125;//python&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; obj = Python_Wrapper.factory()&gt;&gt;&gt; obj.Name()&#39;Derived&#39;&gt;&gt;&gt; Python_Wrapper.BaseName(obj)Derived&gt;&gt;&gt; Python_Wrapper.DerivedName(obj)Derived&gt;&gt;&gt;&gt;&gt;&gt; objBase = Python_Wrapper.Base()&gt;&gt;&gt; objBase.Name()&#39;Base&#39;&gt;&gt;&gt; Python_Wrapper.BaseName(objBase)Base&gt;&gt;&gt; Python_Wrapper.DerivedName(objBase)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;Boost.Python.ArgumentError: Python argument types in    Python_Wrapper.DerivedName(Base)did not match C++ signature:</code></pre><h3 id="2-2-6- 其他"><a href="#2-2-6- 其他" class="headerlink" title="2.2.6 其他"></a>2.2.6 其他 </h3><p> 虚函数，操作符，重载等类的一些属性，参阅<a href="https://www.jianshu.com/p/bc0f18b60c89">C++ 和 Python 的混合编程 -C++ 数据类型的导出和调用 - 简书 (jianshu.com)</a></p><h2 id="2-3- 枚举 Enum"><a href="#2-3- 枚举 Enum" class="headerlink" title="2.3 枚举 Enum"></a>2.3 枚举 Enum</h2><p>格式：<code>boost::python::enum_&lt;T&gt;(&quot;TName&quot;)</code></p><pre><code class="c++">enum MessageType&#123;    MT_START = 1,    MT_PROCESS,    MT_DONE,    MT_EXCEPTION&#125;;BOOST_PYTHON_MODULE(Python_Wrapper)&#123;//enum    boost::python::enum_&lt;MessageType&gt;(&quot;MessageType&quot;)        .value(&quot;MT_START&quot;, MT_START)        .value(&quot;MT_PROCESS&quot;, MT_PROCESS)        .value(&quot;MT_DONE&quot;, MT_DONE)        .value(&quot;MT_EXCEPTION&quot;, MT_EXCEPTION);&#125;//python&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; Python_Wrapper.MessageType.MT_STARTPython_Wrapper.MessageType.MT_START&gt;&gt;&gt; int(Python_Wrapper.MessageType.MT_START)1&gt;&gt;&gt; int(Python_Wrapper.MessageType.MT_DONE)3</code></pre><h2 id="2-2- 常量 const"><a href="#2-2- 常量 const" class="headerlink" title="2.2 常量 const"></a>2.2 常量 const</h2><h3 id="2-2-1- 基本常量"><a href="#2-2-1- 基本常量" class="headerlink" title="2.2.1 基本常量"></a>2.2.1 基本常量 </h3><p> 格式：<code>boost::python::scope().attr</code></p><pre><code class="c++">//1. 在模块中加入常量属性BOOST_PYTHON_MODULE(Python_Wrapper)&#123;    //const    boost::python::scope().attr(&quot;yes&quot;) = 1;    boost::python::scope().attr(&quot;no&quot;) = 0;&#125;//python&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; Python_Wrapper.yes1&gt;&gt;&gt; Python_Wrapper.no0</code></pre><ul><li><p>boost::python::scope()用于得到 <strong> 当前的作用域，定义新的 scope 对象会改变当前的作用域</strong></p></li><li><p>使用参数来构造一个新的 scope 对象会将关联的全局 python 对象更改为参数所持有的对象 直到作用域对象的生存期结束, 关联的全局 python 对象才会恢复到作用域对象之前的对象。</p></li></ul><h3 id="2-2-2- 作用域"><a href="#2-2-2- 作用域" class="headerlink" title="2.2.2 作用域"></a>2.2.2 作用域</h3><pre><code class="c++">class Message&#123;public:    void Set(std::string msg)    &#123;        m_msg = msg;    &#125;    std::string Get()    &#123;        return m_msg;    &#125;private:    std::string m_msg;&#125;;//1. 在模块中加入常量属性BOOST_PYTHON_MODULE(Python_Wrapper)&#123;    //const    boost::python::scope().attr(&quot;yes&quot;) = 1;    boost::python::scope().attr(&quot;no&quot;) = 0;    boost::python::class_&lt;Message&gt;(&quot;Message&quot;)        .def(&quot;Set&quot;, &amp;Message::Set)        .def(&quot;Get&quot;, &amp;Message::Get); &#125;//python&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; Python_Wrapper.yes1&gt;&gt;&gt; Python_Wrapper.no0/////////////////////////////////////////////////////////2. 改变导出顺序，也没有问题，在模块中加入常量属性BOOST_PYTHON_MODULE(boost_python)&#123;    boost::python::class_&lt;Message&gt;(&quot;Message&quot;)        .def(&quot;Set&quot;, &amp;Message::Set)        .def(&quot;Get&quot;, &amp;Message::Get);     //const    boost::python::scope().attr(&quot;yes&quot;) = 1;    boost::python::scope().attr(&quot;no&quot;) = 0;&#125;//python&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; Python_Wrapper.yes1&gt;&gt;&gt; Python_Wrapper.no0////////////////////////////////////////////////////////3. 如果使用 boost::python::scope 对象，则改变了当前的作用域，yes 和 no 成了 message 类的属性BOOST_PYTHON_MODULE(boost_python)&#123;    //Change the current scope    boost::python::scope newScope =  boost::python::class_&lt;Message&gt;(&quot;Message&quot;)        .def(&quot;Set&quot;, &amp;Message::Set)        .def(&quot;Get&quot;, &amp;Message::Get);    //const Defined in the current scope（Message）    boost::python::scope().attr(&quot;yes&quot;) = 1;    boost::python::scope().attr(&quot;no&quot;) = 0;&#125;//python&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; Python_Wrapper.yesTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: module &#39;Python_Wrapper&#39; has no attribute &#39;yes&#39;&gt;&gt;&gt; Python_Wrapper.noTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: module &#39;Python_Wrapper&#39; has no attribute &#39;no&#39;&gt;&gt;&gt; msg = Python_Wrapper.Message()&gt;&gt;&gt; msg.yes1&gt;&gt;&gt; msg.no0//4. 使用 boost::python::scope 定义了新的域对象，改变了当前的作用域，这个对象出了作用域，则会恢复为之前的域对象BOOST_PYTHON_MODULE(Python_Wrapper)&#123;    //const    &#123;    boost::python::scope newScope =  boost::python::class_&lt;Message&gt;(&quot;Message&quot;)        .def(&quot;Set&quot;, &amp;Message::Set)        .def(&quot;Get&quot;, &amp;Message::Get);    boost::python::scope().attr(&quot;yes&quot;) = 1;    boost::python::scope().attr(&quot;no&quot;) = 0;    &#125;    boost::python::scope().attr(&quot;exist&quot;) = 1;    boost::python::scope().attr(&quot;none&quot;) = 0;&#125;//python&gt;&gt;&gt; import Python_Wrapper&gt;&gt;&gt; msg = Python_Wrapper.Message()&gt;&gt;&gt; msg.yes1&gt;&gt;&gt; msg.no0&gt;&gt;&gt; Python_Wrapper.exist1&gt;&gt;&gt; Python_Wrapper.none0</code></pre><p>上面介绍了如何将 C++ 代码导出为 python 解释器能够调用的对象。因此我们可以利用 Boost::Python 从 Python 调用 C ++ 代码。</p><h1 id="三、C- 执行 python"><a href="# 三、C- 执行 python" class="headerlink" title="三、C++ 执行 python"></a>三、C++ 执行 python</h1><p>这一部分内容介绍：C++ 调用执行 python 代码。</p><pre><code class="c++">bp::str code = &quot;def fact(n):\n\treturn 1 if n==1 else n*fact(n-1)&quot;)bp::object result = bp::exec(code)  </code></pre><blockquote><p>bp::exec 的作用就是执行 python 代码。</p></blockquote><h2 id="3-1-exec 函数"><a href="#3-1-exec 函数" class="headerlink" title="3.1 exec 函数"></a>3.1 exec 函数 </h2><p> 函数作用：用来执行一个字符串形式 python 语句，或者表达式，并返回得到的计算结果。</p><p>函数原型：</p><pre><code>boost::pythoin::api::object exec(boost::python::str string,                                 boost::python::api::object global=boost::python::api::object(),                                 boost::python::api::object local=boost::python::api::object())；</code></pre><p>参数：</p><ul><li>string：需要执行的语句或表达式字符串，如 result=2**10 #2^10</li><li>global：需要执行的字符串是放在哪个全局作用域中。</li><li>local：需要执行的字符串是放在哪个局部作用域中。</li><li>返回的值是 Boost::Python::api 中的 Object 对象。</li><li>可以使用 extract 来获得 C++ 类型的值。</li></ul><p>举个例子：</p><pre><code class="c++">//C++boost::python::object main_module = import(&quot;__main__&quot;);boost::python::object main_namespace = main_module.attr(&quot;__dict__&quot;);boost::python::object return_value = exec(&quot;result = 2**10&quot;, global = main_namespace,local = main_namespace);</code></pre><h2 id="3-2-eval 函数"><a href="#3-2-eval 函数" class="headerlink" title="3.2 eval 函数"></a>3.2 eval 函数 </h2><p> 函数作用：用来执行一个 python 求值的表达式的字符串， 并返回得到的计算结果。</p><p>原型：</p><pre><code class="c++">namespace bpa = boost::python::api;bpa::object bpa::eval(boost::python::str string,                       bpa::object global=bpa::object(), bpa::object local = bpa::object())</code></pre><p>参数：</p><ul><li>string：需要执行的表达式字符串，如 2**10 </li><li>global：需要执行的字符串是放在哪个全局作用域中。</li><li>local：需要执行的字符串是放在哪个局部作用域中。</li><li>返回的值是 Boost::Python::<a href="https://so.csdn.net/so/search?q=api&spm=1001.2101.3001.7020">api</a>中的 Object 对象。</li></ul><p>举个例子：</p><pre><code class="c++">//C++boost::python::object main_module = import(&quot;__main__&quot;);boost::python::object main_namespace = main_module.attr(&quot;__dict__&quot;);boost::python::object return_value = eval(&quot;2**10&quot;, main_namespace,main_namespace);</code></pre><h2 id="3-3-eval 与 exec 区别"><a href="#3-3-eval 与 exec 区别" class="headerlink" title="3.3 eval 与 exec 区别"></a>3.3 eval 与 exec 区别</h2><p>eval 与 exec 的调用形式相同，作用也基本相同，区别是：</p><ul><li><p>eval ：evaluate Python expression from str</p><p>用来直接运行一个表达式求得一个值，而不是运行一个语句，eval 需要有返回的值。</p></li><li><p>exec：execute python expression/statement from str</p><p>用来运行一个表达式或者运行一个语句，可以有返回值，也可以没有。</p></li></ul><h2 id="3-4-exec-file 函数"><a href="#3-4-exec-file 函数" class="headerlink" title="3.4 exec_file 函数"></a>3.4 exec_file 函数 </h2><p> 函数作用：执行 python 源文件 Execute python source code from file ‘filename’.</p><p>原型：</p><pre><code class="c++">namespace bpa=boost::python::api;bpa::object exec_file(boost::python::str filename,                       bpa::object global=bpa::object(), bpa::object local=pba::object())</code></pre><p>参数：</p><ul><li>filename：需要执行的路径和文件名。</li><li>global：需要执行的字符串是放在哪个全局作用域中。</li><li>local：需要执行的字符串是放在哪个局部作用域中。</li></ul><p>举个例子：</p><pre><code class="c++">//C++boost::python::object main_module = import(&quot;__main__&quot;);boost::python::object main_namespace = main_module.attr(&quot;__dict__&quot;);boost::python::object simple = exec_file(&quot;D:\\demoPython\\example.py&quot;, main_namespace,main_namespace);</code></pre>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 泛型编程与模板</title>
      <link href="/C-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%A8%A1%E6%9D%BF/"/>
      <url>/C-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>本阶段主要针对 C++<strong>泛型编程 </strong> 和<strong>STD</strong>技术做详细学习，探讨 C++ 更深层次的使用。</p><h1 id="一、- 模板"><a href="# 一、- 模板" class="headerlink" title="一、 模板"></a>一、 模板 </h1><p> 模板就是建立通用的模具，大大提高复用性。<strong>学习模板是为了会用别人提供的模板</strong>。</p><ul><li>C++ 另一种编程思想称为泛型编程，主要利用的技术就是模板</li><li>C++ 提高两种模板机制：函数模板和类模板</li></ul><h2 id="1-1- 函数模板"><a href="#1-1- 函数模板" class="headerlink" title="1.1 函数模板"></a>1.1 函数模板 </h2><h3 id="1-1-1- 函数模板定义"><a href="#1-1-1- 函数模板定义" class="headerlink" title="1.1.1 函数模板定义"></a>1.1.1 函数模板定义</h3><p> 函数模板：建立一个通用函数，其函数返回类型和形参类型可以不具体制定，用一个虚拟的类型来代表</p><p>语法：</p><pre><code class="c++">template&lt;typename T&gt;     // 注意这里没有分号；void func(T &amp;a)&#123;...&#125;     // 函数声明或定义</code></pre><p>解释：</p><ul><li>template — 声明创建模板</li><li>typename — 表明其后面的符号是一种数据类型，<strong>可以用 class 代替</strong></li><li>T — 通用的数据类型，名称可以替换，通常为大写字母</li></ul><pre><code class="c++">template&lt;typename T&gt;  // 声明一个模板，告诉编译器 T 为通用数据类型，不要报错void mySwap(T &amp;a, T &amp;b) &#123;    T temp = a;    a = b;    b = temp;&#125;int main() &#123;    float a = 1.1;    float b = 2.2;    mySwap(a, b);             // 第一种调用：自动类型推导    cout &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; b &lt;&lt; endl;    int c = 10;    int d = 20;    mySwap&lt;int&gt;(c, d);       // 第二种调用：显示指定类型    cout &lt;&lt; c &lt;&lt; endl;    cout &lt;&lt; d &lt;&lt; endl;    system(&quot;pause&quot;);&#125;</code></pre><p>总结：</p><ul><li>函数模板用关键字 template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的时为了提高函数复用性，将类型参数化。</li></ul><h3 id="1-1-2- 函数模板注意事项"><a href="#1-1-2- 函数模板注意事项" class="headerlink" title="1.1.2 函数模板注意事项"></a>1.1.2 函数模板注意事项 </h3><p> 注意事项：</p><ul><li><p>自动类型推导，必须推导出一致的数据类型 T，才可使用</p></li><li><p>模板必须要确定出 T 的数据类型，才可以使用</p><pre><code class="c++">template&lt;typename T&gt;    // 声明了 T, 紧接着的 test()函数却没有使用void test() &#123;    cout &lt;&lt; &quot;test()调用 &quot; &lt;&lt; endl;&#125;void mySwap(T &amp;a, T &amp;b)&#123;    // 这个会报错 T, 上面的 T 声明仅对 T 声明下面的第一个函数有效    cout &lt;&lt; &quot; 交换 &quot; &lt;&lt; endl;&#125;int main() &#123;    test();  // 这里调用就会报错    test&lt;int&gt;()  // 这随意指定一个 int，就没问题了    system(&quot;pause&quot;);&#125;</code></pre></li></ul><h3 id="1-1-3- 函数模板案例"><a href="#1-1-3- 函数模板案例" class="headerlink" title="1.1.3 函数模板案例"></a>1.1.3 函数模板案例</h3><p>  案例描述：</p><ul><li>利用函数模板封装一个排序的函数，可以对不同的数据类型数组进行排序</li><li>排序规则从大到小，排序算法为选择排序</li><li>分别利用 char 数组和 int 数组进行测试</li></ul><pre><code class="c++">template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b) &#123;    T temp = a;    a = b;    b = temp;&#125;template&lt;typename T&gt;  void mySort(T arr[], int len) &#123;    for (int i = 0; i &lt; len; ++i) &#123;        int max = i;        for (int j = i + 1; j &lt; len; ++j) &#123;            if (arr[max] &lt; arr[j]) &#123;                max = j;            &#125;        &#125;        if (max != i) &#123;            mySwap(arr[max], arr[i]);        &#125;    &#125;&#125;void test() &#123;    char cha[] = &quot;dhsjas&quot;;    //int cha[] = &#123; 3,4,2,5,1,6,8,7 &#125;;    int len = sizeof(cha) / sizeof(cha[0]);    mySort(cha, len);    for (int i = 0; i &lt; len; ++i) &#123;        cout &lt;&lt; cha[i] &lt;&lt; &quot; &quot;;    &#125;&#125;int main() &#123;    test();    system(&quot;pause&quot;);&#125;</code></pre><h3 id="1-1-4- 普通函数与函数模板的区别"><a href="#1-1-4- 普通函数与函数模板的区别" class="headerlink" title="1.1.4 普通函数与函数模板的区别"></a>1.1.4 普通函数与函数模板的区别 </h3><p> 普通函数与函数模板区别（<strong>主要是是否可以发生隐式类型转换</strong>）：</p><ul><li>普通函数调用时，可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><pre><code class="c++">int addtest1(int a, int b) &#123;    return a + b;&#125;template&lt;typename T&gt;T addtest2(T a, T b) &#123;    return a + b;&#125;int main() &#123;    int a = 10;    char c = &#39;c&#39;; //(int)c = 99    cout &lt;&lt; addtest1(a, c) &lt;&lt; endl;    // 自动类型推导    //cout &lt;&lt; addtest2(a, c) &lt;&lt; endl; 报错    // 显示指定类型    cout &lt;&lt; addtest2&lt;int&gt;(a, c) &lt;&lt; endl;    system(&quot;pause&quot;);&#125;</code></pre><h3 id="1-1-5- 普通函数与函数模板的调用规则"><a href="#1-1-5- 普通函数与函数模板的调用规则" class="headerlink" title="1.1.5 普通函数与函数模板的调用规则"></a>1.1.5 普通函数与函数模板的调用规则</h3><ul><li>如果函数模板和普通函数都可以实现，优先使用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ul><pre><code class="c++">int test1(int a, int b);template&lt;typename T&gt;void test1(T a, T b) &#123;    cout &lt;&lt; &quot; 调用模板函数 &quot; &lt;&lt; endl;&#125;int main() &#123;    int a = 10;    int b = 20;    // 报错，调用普通函数，然而普通函数只有声明没有实现    //test1(a, b);    // 通过空模板参数列表, 强制调用函数模板    test1&lt;&gt;(a, b) ;    // 函数模板可以产生更好的匹配，优先调用函数模板    char c1 = &#39;a&#39;;    char c2 = &#39;b&#39;;    test1(c1, c2);    system(&quot;pause&quot;);&#125;</code></pre><h3 id="1-1-6- 模板的局限性 - 具体化的模板"><a href="#1-1-6- 模板的局限性 - 具体化的模板" class="headerlink" title="1.1.6 模板的局限性 / 具体化的模板"></a>1.1.6 模板的局限性 / 具体化的模板 </h3><p> 有时候通用模板并不能解决所有问题，这时候可以利用具体化的模板，去解决自定义类型的通用化。</p><pre><code class="c++">class Person &#123;public:    Person(string name, int age) &#123;        this-&gt;m_name = name;        this-&gt;m_age = age;    &#125;    string m_name;    int m_age;&#125;;template&lt;typename T&gt;bool compare(T a, T b) &#123;    if (a == b) &#123;        return true;    &#125;    else &#123;        return false;    &#125;&#125;;// 具体化模板template&lt;&gt; bool compare(Person &amp;p1, Person &amp;p2) &#123;    if (p1.m_name == p2.m_name &amp;&amp; p1.m_age == p2.m_age) &#123;        return true;    &#125;    else &#123;        return false;    &#125;&#125;int main() &#123;    Person p1(&quot; 张三 &quot;, 25);    Person p2(&quot; 张三 &quot;, 21);    bool ret = compare(p1, p2);    system(&quot;pause&quot;);&#125;</code></pre><h2 id="1-2- 类模板"><a href="#1-2- 类模板" class="headerlink" title="1.2 类模板"></a>1.2 类模板 </h2><h3 id="1-2-1- 类模板语法"><a href="#1-2-1- 类模板语法" class="headerlink" title="1.2.1 类模板语法"></a>1.2.1 类模板语法</h3><p> 类模板作用：建立一个通用类，类中的成员、数据类型可以不具体制定，用一个虚函数类型来代表。</p><p>语法：</p><pre><code class="c++">template&lt;typename T&gt;class A&#123;...&#125;                   // 类的声明或定义</code></pre><p>尖括号 <code>&lt;&gt;</code> 里可以定义多个通用数据类型，以逗号隔开。</p><pre><code class="c++">template&lt;class NameType,class AgeType&gt;class Person &#123;public:    Person(NameType name, AgeType age) &#123;        this-&gt;m_name = name;        this-&gt;m_age = age;    &#125;    void show_Person() &#123;        cout &lt;&lt; this-&gt;m_name &lt;&lt; endl;        cout &lt;&lt; this-&gt;m_age &lt;&lt; endl;    &#125;    NameType m_name;    AgeType m_age;&#125;;void test() &#123;    Person&lt;string, int&gt; p1(&quot;Tom&quot;, 23);  //&lt;string，int&gt; 叫模板的参数列表，必须指定    p1.show_Person();&#125;int main() &#123;    test();    system(&quot;pause&quot;);&#125;</code></pre><h3 id="1-2-2- 类模板与函数模板区别"><a href="#1-2-2- 类模板与函数模板区别" class="headerlink" title="1.2.2 类模板与函数模板区别"></a>1.2.2 类模板与函数模板区别 </h3><p> 类模板与函数模板区别：</p><ul><li>类模板没有自动类型推导的使用方式。</li><li>类模板在模板参数列表中可以有默认参数。</li></ul><pre><code class="c++">template&lt;class NameType, class AgeType=int&gt;class Person &#123;public:    Person(NameType name, AgeType age) &#123;        this-&gt;m_name = name;        this-&gt;m_age = age;    &#125;    NameType m_name;    AgeType m_age;&#125;;// 类模板没有自动类型推导的使用方式void test1() &#123;    Person p1(&quot;Tom&quot;, 23);  // 报错，必须指定类型&#125;// 类模板在模板参数列表中可以有默认参数void test2() &#123;    Person&lt;string&gt; p2(&quot;Tomo&quot;, 22);  //template 中已经指定了第二个参数的默认类型&#125;</code></pre><h3 id="1-2-3- 类模板中的成员函数创建时机"><a href="#1-2-3- 类模板中的成员函数创建时机" class="headerlink" title="1.2.3 类模板中的成员函数创建时机"></a>1.2.3 类模板中的成员函数创建时机 </h3><p> 类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建。</li><li>类模板中的成员函数在调用时才创建。</li></ul><pre><code class="c++">class Person1 &#123;public:    void show1() &#123;        cout &lt;&lt; &quot;Person1 成员函数的调用 &quot; &lt;&lt; endl;    &#125;&#125;;class Person2 &#123;public:    void show2() &#123;        cout &lt;&lt; &quot;Person2 成员函数的调用 &quot; &lt;&lt; endl;    &#125;&#125;;template&lt;class T&gt; class Person &#123;public:    T obj;    // 类模板中的成员函数    void func1() &#123;        obj.show1();    &#125;    void func2() &#123;        obj.show2();    &#125;&#125;;void test() &#123;    Person&lt;Person1&gt; p;           p.func1();             // 这里并不会报错，调用 func1()只会创建 func1()    p.func2();             // 报错&#125;int main() &#123;    test();    system(&quot;pause&quot;);&#125;</code></pre><h3 id="1-2-4- 类模板对象做函数参数"><a href="#1-2-4- 类模板对象做函数参数" class="headerlink" title="1.2.4 类模板对象做函数参数"></a>1.2.4 类模板对象做函数参数 </h3><p> 一共有三种传入方式：</p><ol><li>指定传入的类型：直接显示对象的数据类型</li><li>参数模板化：将对象中的参数变为模板进行传递</li><li>整个类模板化：将这个对象类型模板化进行传递</li></ol><pre><code class="c++">template &lt;class T1,class T2&gt;class Person &#123;public:    Person(T1 name, T2 age) &#123;        this-&gt;m_name = name;        this-&gt;m_age = age;    &#125;    void show() &#123;        cout &lt;&lt; m_name &lt;&lt; endl;        cout &lt;&lt; m_age &lt;&lt; endl;    &#125;    T1 m_name;    T2 m_age;&#125;;// 指定传入的类型      void test1(Person&lt;string, int&gt;&amp;p) &#123;    p.show();&#125;// 参数模板化template&lt;class T1, class T2&gt;void test2(Person&lt;T1, T2&gt;&amp; p) &#123;    p.show();&#125;// 整个类模板化template&lt;class T&gt;void test3(T &amp;p) &#123;    p.show();    cout &lt;&lt; typeid(T).name() &lt;&lt; endl;  // 输出&#125;int main() &#123;    Person&lt;string, int&gt;p(&quot;Tom&quot;, 200);    test1(p);    Person&lt;string, int&gt;p2(&quot;Tomo&quot;, 20);    test2(p2);    Person&lt;string, int&gt;p3(&quot;July&quot;, 50);    test3(p3);    system(&quot;pause&quot;);&#125;</code></pre><blockquote><p>使用最广泛的是第一种：指定传入的类型。</p></blockquote><h3 id="1-2-5- 类模板与继承"><a href="#1-2-5- 类模板与继承" class="headerlink" title="1.2.5 类模板与继承"></a>1.2.5 类模板与继承 </h3><p> 当类模板碰到继承时，需要注意以下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定父类中 T 的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定父类中 T 的类型，子类也需要变为类模板</li></ul><pre><code class="c++">template &lt;class T&gt;class Base &#123;    T m;&#125;;// 在继承父类时，父类模板必须要指定类型class Son1 :public Base&lt;int&gt; &#123;...&#125;;// 也可以灵活指定，子类也需要变为类模板template&lt;class T1,class T2&gt;class Son2 :public Base&lt;T1&gt; &#123;  public:    T2 obj;    Son2() &#123;        cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;        cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;    &#125;&#125;;void test() &#123;    Son1 s1;    Son2&lt;int, char&gt; s2;&#125;int main() &#123;    test();    system(&quot;pause&quot;);&#125;</code></pre><h3 id="1-2-6- 类模板成员函数类外实现"><a href="#1-2-6- 类模板成员函数类外实现" class="headerlink" title="1.2.6 类模板成员函数类外实现"></a>1.2.6 类模板成员函数类外实现</h3><pre><code class="c++">template &lt;class T1, class T2&gt;class Person &#123;public:    Person(T1 name, T2 age);    void showPerson();    T1 m_name;    T2 m_age;&#125;;// 构造函数类外实现template&lt;class T1, class T2&gt;Person&lt;T1,T2&gt;::Person(T1 name, T2 age) &#123;    this-&gt;m_name = name;    this-&gt;m_age = age;&#125;// 成员函数类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123;    cout &lt;&lt; this-&gt;m_name &lt;&lt; endl;    cout &lt;&lt; this-&gt;m_age &lt;&lt; endl;&#125;</code></pre><h3 id="1-2-7- 类模板成员函数类外实现"><a href="#1-2-7- 类模板成员函数类外实现" class="headerlink" title="1.2.7 类模板成员函数类外实现"></a>1.2.7 类模板成员函数类外实现 </h3><p> 当我们写类模板时，成员函数的调用时机是在调用阶段，导致文件编写时链接不到</p><p>有两种解决方式：</p><ul><li>解决方式 1：直接包含.cpp 源文件</li><li>解决方式 2：将声明和实现写到同一个文件中，并更改后缀名为.hpp。hpp 是约定的名称，并不是强制</li></ul><h3 id="1-2-8- 类模板与友元"><a href="#1-2-8- 类模板与友元" class="headerlink" title="1.2.8 类模板与友元"></a>1.2.8 类模板与友元 </h3><p> 全局函数类内实现：直接在类内声明友元即可。</p><p>全局函数类外实现：需要提前让编译器知道全局函数的存在。</p><pre><code class="C++">template &lt;class T1, class T2&gt;class Person;// 类外实现template &lt;class T1, class T2&gt;void showPerson2(Person&lt;T1, T2&gt; p) &#123;    cout &lt;&lt; p.m_name &lt;&lt; endl;    cout &lt;&lt; p.m_age &lt;&lt; endl;&#125;template &lt;class T1, class T2&gt;class Person &#123;    // 全局函数在类内实现    friend void showPerson(Person&lt;T1, T2&gt; p) &#123;        cout &lt;&lt; p.m_name &lt;&lt; endl;        cout &lt;&lt; p.m_age &lt;&lt; endl;    &#125;;    // 全局函数类外实现    friend void showPerson2&lt;&gt;(Person&lt;T1, T2&gt; p);  // 实现的代码要写在该类的前面public:    Person(T1 name, T2 age) &#123;        this-&gt;m_name = name;        this-&gt;m_age = age;    &#125;;private:    T1 m_name;    T2 m_age;&#125;;void test() &#123;    Person&lt;string, int&gt; p1(&quot;Tom&quot;, 25);    showPerson(p1);   // 全局函数在类内实现    showPerson2(p1);  // 全局函数在类外实现&#125;int main() &#123;    test();    system(&quot;pause&quot;);&#125;</code></pre><p>一般建议全局函数模板类内实现，类外实现太复杂了。</p><h3 id="1-2-9- 类模板案例"><a href="#1-2-9- 类模板案例" class="headerlink" title="1.2.9 类模板案例"></a>1.2.9 类模板案例 </h3><p><strong> 实现一个通用的数组类</strong>，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及 operator= 防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p>首先定义一个数组模板类，文件命名为 Array.hpp：</p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;class Array &#123;public:    // 有参构造函数，用于初始化数组容量    Array(int capacity) &#123;        this-&gt;mSize = 0;        this-&gt;mCapacity = capacity;        this-&gt;mAddress = new T[this-&gt;mCapacity];    &#125;    // 拷贝构造函数    Array(const Array&amp; arr) &#123;        this-&gt;mCapacity = arr.mCapacity;        this-&gt;mSize = arr.mSize;        this-&gt;mAddress = new T[this-&gt;mCapacity];        for (int i = 0; i &lt; this-&gt;mSize; ++i) &#123;            this-&gt;mAddress[i] = arr.mAddress[i];        &#125;    &#125;    // 重载 = 操作符，深拷贝    Array&amp; operator=(const Array&amp; arr) &#123;        if (this-&gt;mAddress != NULL) &#123;            delete[] this-&gt;mAddress;            this-&gt;mSize = 0;            this-&gt;mCapacity = 0;        &#125;        this-&gt;mCapacity = arr.mCapacity;        this-&gt;mSize = arr.mSize;        this-&gt;mAddress = new T[this-&gt;mCapacity];        for (int i = 0; i &lt; this-&gt;mSize; ++i) &#123;            this-&gt;mAddress[i] = arr.mAddress[i];        &#125;        return *this;    &#125;    // 尾部插入数据    void Push_Back(const T&amp; val) &#123;        if (this-&gt;mCapacity == this-&gt;mSize) &#123;            return;        &#125;        this-&gt;mAddress[this-&gt;mSize] = val;        this-&gt;mSize++;    &#125;    // 从尾部删除数据    void Pop_Back() &#123;        if (this-&gt;mSize == 0) &#123;            return;        &#125;        this-&gt;mSize--;  // 逻辑删除，让用户访问不到    &#125;    T&amp; operator[](int index) &#123;        return this-&gt;mAddress[index];// 暂未考虑越界的问题    &#125;    int getCapacity() &#123;        return this-&gt;mCapacity;    &#125;    int getSize() &#123;        return this-&gt;mSize;    &#125;    ~Array() &#123;        if (this-&gt;mAddress != NULL) &#123;            delete[] this-&gt;mAddress;            this-&gt;mAddress = NULL;            this-&gt;mCapacity = 0;            this-&gt;mSize = 0;        &#125;    &#125;private:    T* mAddress;    // 指针指向堆区开辟的真实数组    int mCapacity;  // 数组容量    int mSize;      // 数组当前的大小&#125;;</code></pre><p>测试案例，命名为 ArrayTest.cpp：</p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;#include&quot;Array.hpp&quot;using namespace std;void printIntArray(Array&lt;int&gt;&amp; arr) &#123;    for (int i = 0; i &lt; arr.getSize(); ++i) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;// 测试 1void test1() &#123;    Array&lt;int&gt; arr1(6);    Array&lt;int&gt; arr3(100);    arr1 = arr3;    for (int i = 0; i &lt; 6; ++i) &#123;        arr1.Push_Back(i);    &#125;    printIntArray(arr1);    cout &lt;&lt; &quot;arr1 的大小：&quot; &lt;&lt; arr1.getSize() &lt;&lt; endl;    cout &lt;&lt; &quot;arr1 的容量：&quot; &lt;&lt; arr1.getCapacity() &lt;&lt; endl;    Array&lt;int&gt; arr2(arr1);    printIntArray(arr2);    cout &lt;&lt; &quot;arr2 的大小：&quot; &lt;&lt; arr2.getSize() &lt;&lt; endl;    cout &lt;&lt; &quot;arr2 的容量：&quot; &lt;&lt; arr2.getCapacity() &lt;&lt; endl;    arr2.Pop_Back();    printIntArray(arr2);    cout &lt;&lt; &quot;arr2 的大小：&quot; &lt;&lt; arr2.getSize() &lt;&lt; endl;    cout &lt;&lt; &quot;arr2 的容量：&quot; &lt;&lt; arr2.getCapacity() &lt;&lt; endl;&#125;// 测试自定义数据类型class Person &#123;public:    Person() &#123;&#125;;    Person(string name, int age) &#123;        this-&gt;m_name = name;        this-&gt;m_age = age;    &#125;    string m_name;    int m_age;&#125;;void printPersonArray(Array&lt;Person&gt;&amp; arr) &#123;    for (int i = 0; i &lt; arr.getSize(); ++i) &#123;        cout &lt;&lt; arr[i].m_name + &quot; &quot; &lt;&lt; arr[i].m_age &lt;&lt; endl;    &#125;    cout &lt;&lt; endl;&#125;// 测试自定义的数据类型void test2() &#123;    cout &lt;&lt; &quot;\n--------------test2------------&quot; &lt;&lt; endl;    Array&lt;Person&gt; arr(10);    Person p1(&quot; 孙悟空 &quot;, 999);    Person p2(&quot; 韩信 &quot;, 24);    Person p3(&quot; 妲己 &quot;, 23);    Person p4(&quot; 赵云 &quot;, 26);    Person p5(&quot; 鲁班 &quot;, 12);    arr.Push_Back(p1);    arr.Push_Back(p2);    arr.Push_Back(p3);    arr.Push_Back(p4);    arr.Push_Back(p5);    printPersonArray(arr);    cout &lt;&lt; &quot;arr 的大小：&quot; &lt;&lt; arr.getSize() &lt;&lt; endl;    cout &lt;&lt; &quot;arr 的容量：&quot; &lt;&lt; arr.getCapacity() &lt;&lt; endl;&#125;int main() &#123;    test1();    test2();    system(&quot;pause&quot;);&#125; </code></pre><h2 id="1-3- 写模板的坑"><a href="#1-3- 写模板的坑" class="headerlink" title="1.3 写模板的坑"></a>1.3 写模板的坑 </h2><p><strong> 推荐把模板的实现和声明都写在头文件！</strong>否则编译会报错。</p><p>还有一种方式，可以分离声明与实现：</p><p>h 头文件：</p><pre><code class="c++">template &lt;typename T&gt;T add(const T &amp;a, const T &amp;b);</code></pre><p>cpp 实现：</p><pre><code class="c++">#include &quot;add.h&quot;template &lt;typename T&gt;T add(const T &amp;a, const T &amp;b)&#123;    return a + b;&#125;template int add(const int &amp;a, const int &amp;b);</code></pre><p>最后一行要指定模板的实际类型。</p><h1 id="二、STL 初识"><a href="# 二、STL 初识" class="headerlink" title="二、STL 初识"></a>二、STL 初识</h1><h2 id="2-1-STL 的诞生"><a href="#2-1-STL 的诞生" class="headerlink" title="2.1 STL 的诞生"></a>2.1 STL 的诞生</h2><ul><li>长久以来，人们一直希望建立一种可以重复利用的东西</li><li>C++ 面向对象编程和泛型编程思想，目的就是复用性的提升</li><li>大多情况下，数据结构和算法都未有一套标准，导致被迫从事大量重复工作</li><li>为了建立数据结构和算法的一套标准，诞生了 STL(Standard Template Library, 标准模板库)</li></ul><h2 id="2-2-STL 的介绍"><a href="#2-2-STL 的介绍" class="headerlink" title="2.2 STL 的介绍"></a>2.2 STL 的介绍</h2><ul><li>STL 从广义上分为：<strong>容器 </strong>（container），<strong> 算法 </strong>（algorithm），<strong> 迭代器</strong>（iterator）</li><li><strong>容器 </strong> 和<strong>算法 </strong> 之间通过 <strong> 迭代器 </strong> 进行无缝链接</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h2 id="2-3-STL 六大组件"><a href="#2-3-STL 六大组件" class="headerlink" title="2.3 STL 六大组件"></a>2.3 STL 六大组件</h2><p>STL 大体分为六大组件，分别是容器，算法，迭代器，仿函数，适配器（配接器），空间配置器</p><ol><li>容器：各种数据结构，如 vector, list, deque, set, map 等，用来存放数据</li><li>算法：各种常用的算法，如 sort, find, copy, for_each 等。</li><li>迭代器：扮演了容器与算法之间的胶合剂</li><li>仿函数，行为类似函数，可作为算法的某种策略</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li><li>空间配置器：负责用来空间的配置与管理</li></ol><h2 id="2-4-STL 中的容器、算法、迭代器"><a href="#2-4-STL 中的容器、算法、迭代器" class="headerlink" title="2.4 STL 中的容器、算法、迭代器"></a>2.4 STL 中的容器、算法、迭代器</h2><blockquote><p>容器：置物之所也。</p></blockquote><p>STL 容器就是将运用最广泛的一些数据结构实现出来，常用的数据结构：数组，链表，树，栈，队列，集合，映射表等。</p><p>这些容器分为序列式容器和关联式容器两种：</p><ul><li>序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置。</li><li>关联式容器：二叉树结构，各元素之间没有严格的物理意义上的顺序关系。<strong>只能一步步偏移取值，不能跳转</strong>。</li></ul><blockquote><p>算法：问题值解法也。</p></blockquote><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法（Algorithms）。</p><p>算法分为：质变算法和非质变算法。</p><ul><li>质变算法：是指运算过程中，会更改区间元素的内容，例如拷贝，替换，删除等。</li><li>非质变算法：是指运算过程中，不会更改区间内的元素内容，例如查找，计数，遍历，寻找极值等等。</li></ul><blockquote><p>迭代器：容器和算法之间的粘合剂</p></blockquote><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器。</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针。</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持 ++，==，！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持 ++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持 ++，==，！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前向后操作</td><td>读写，支持 ++，–</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持 ++，–，[n]，-n，&lt;，&lt;=， &gt;，&gt;=</td></tr></tbody></table><p>常用的容器迭代器种类为 <strong> 双向迭代器 </strong> 和<strong>随机访问迭代器</strong></p><h2 id="2-5- 容器算法迭代器初识"><a href="#2-5- 容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h2><p>STL 中最常用的容器为 Vector，可以理解为数组。</p><h3 id="2-5-1-vector- 存放内置数据类型"><a href="#2-5-1-vector- 存放内置数据类型" class="headerlink" title="2.5.1 vector 存放内置数据类型"></a>2.5.1 vector 存放内置数据类型 </h3><p> 容器：<code>vector</code></p><p>算法：<code>for_each</code></p><p>迭代器：<code>vector&lt;int&gt;::interator</code></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;void Mprint(int val) &#123;    cout &lt;&lt; val &lt;&lt; endl;&#125;void test() &#123;    vector&lt;int&gt; v;        v.push_back(10);  // 插入数据    v.push_back(20);    v.push_back(30);    v.push_back(40);    // 通过迭代器访问容器中的数据    vector&lt;int&gt;::iterator itBegin = v.begin();  // 起始迭代器，指向容器的第一个元素    vector&lt;int&gt;::iterator itEnd = v.end();  // 起始迭代器，指向容器的最后一个元素的下一个位置    // 第一种遍历方式    while (itBegin != itEnd) &#123;        cout &lt;&lt; *itBegin &lt;&lt; endl;  // 迭代器是一个指针        itBegin++;    &#125;    // 第二种遍历方式    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123;        cout &lt;&lt; *it &lt;&lt; endl;    &#125;    // 第三种遍历方式，利用 STL 提供的遍历算法    for_each(v.begin(), v.end(), Mprint);&#125;int main() &#123;    test();    system(&quot;pause&quot;);&#125;</code></pre><h3 id="2-5-2-vector 存放自定义数据类型"><a href="#2-5-2-vector 存放自定义数据类型" class="headerlink" title="2.5.2 vector 存放自定义数据类型"></a>2.5.2 vector 存放自定义数据类型</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;class Person &#123;public:    Person(string name, int age) &#123;        this-&gt;m_name = name;        this-&gt;m_age = age;    &#125;    string m_name;    int m_age;&#125;;// 传入自定义的数据类型void test1() &#123;    vector&lt;Person&gt; v;    Person p1(&quot;Tom&quot;, 23);    Person p2(&quot;Jack&quot;, 18);    Person p3(&quot;Judy&quot;, 23);    Person p4(&quot;Mark&quot;, 23);    v.push_back(p1);    v.push_back(p2);    v.push_back(p3);    v.push_back(p4);    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123;        //cout &lt;&lt; (*it).m_name &lt;&lt; &quot; &quot; &lt;&lt; (*it).m_age &lt;&lt; endl;  // *it 是 Perosn 类型的数据        cout &lt;&lt; it-&gt;m_name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;m_age &lt;&lt; endl; // 推荐这种    &#125;&#125;// 传入自定义的数据类型的指针void test2() &#123;    vector&lt;Person*&gt; v;   //v 用来储存指针（指针指向 person 类型）    Person p1(&quot;Tom&quot;, 23);    Person p2(&quot;Jack&quot;, 18);    Person p3(&quot;Judy&quot;, 23);    Person p4(&quot;Mark&quot;, 23);    v.push_back(&amp;p1);    v.push_back(&amp;p2);    v.push_back(&amp;p3);    v.push_back(&amp;p4);    for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123;        cout &lt;&lt; (*it)-&gt;m_name &lt;&lt; &quot; &quot; &lt;&lt; (*it)-&gt;m_age &lt;&lt; endl;  // *it 是 Perosn 类型的数据        &#125;&#125;int main() &#123;    test1();    test2();    system(&quot;pause&quot;);&#125;</code></pre><h3 id="2-5-3-vector 容器嵌套容器"><a href="#2-5-3-vector 容器嵌套容器" class="headerlink" title="2.5.3 vector 容器嵌套容器"></a>2.5.3 vector 容器嵌套容器</h3><pre><code class="c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;void test1() &#123;    vector&lt;vector&lt;int&gt;&gt; v;    // 创建小容器    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    vector&lt;int&gt; v3;    // 向小容器添加数据    for (int i = 0; i &lt; 3; ++i) &#123;        v1.push_back(i + 1);        v2.push_back(i + 2);        v3.push_back(i + 3);    &#125;    // 将小容器插入到大容器中    v.push_back(v1);    v.push_back(v2);    v.push_back(v3);    // 通过大容器，把所有数据遍历一遍    for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123;        for (vector&lt;int&gt;::iterator jt = (*it).begin(); jt != (*it).end(); ++jt) &#123;            cout &lt;&lt; *jt &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;int main() &#123;    test1();    system(&quot;pause&quot;);&#125;</code></pre><h1 id="三、STL 常用容器"><a href="# 三、STL 常用容器" class="headerlink" title="三、STL 常用容器"></a>三、STL 常用容器 </h1><p>STL 中<code>list</code>、<code>vector</code>、<code>map</code> 是三个最常被使用的容器。</p><p>STL 中，所有容器拷贝均为 <strong> 深拷贝</strong>。没有浅拷贝的概念。</p><h2 id="3-1-string 容器"><a href="#3-1-string 容器" class="headerlink" title="3.1 string 容器"></a>3.1 string 容器 </h2><h3 id="3-1-1-string- 基本概念"><a href="#3-1-1-string- 基本概念" class="headerlink" title="3.1.1 string 基本概念"></a>3.1.1 string 基本概念</h3><p> 本质：string 是 C++ 风格的字符串，而 string 本质是一个类</p><p>string 和 char 区别：</p><ul><li>char * 是一个指针</li><li>string 是一个类，类内部封装了 <code>char*</code>，管理这个字符串，是一个<code>char*</code> 类型的容量</li></ul><p>特点：</p><ul><li>string 类内部封装了很多成员方法，如查找 find，拷贝 copy，删除 delete，替换 replace，插入 insert</li><li>string 管理 <code>char*</code> 所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</li></ul><h3 id="3-1-2-string- 构造函数"><a href="#3-1-2-string- 构造函数" class="headerlink" title="3.1.2 string 构造函数"></a>3.1.2 string 构造函数 </h3><p> 构造函数原型：</p><ul><li><code>string();</code>                                         // 创建一个空的字符串，例如 string str;</li><li><code>string(const char* s);</code>              // 使用字符串 s 初始化</li><li><code>string(const string&amp; str);</code>     // 使用一个 string 对象初始化另一个 string 对象</li><li><code>string(int n, char c);</code>             // 使用 n 个字符 c 初始化</li></ul><h3 id="3-1-3-string- 赋值操作"><a href="#3-1-3-string- 赋值操作" class="headerlink" title="3.1.3 string 赋值操作"></a>3.1.3 string 赋值操作</h3><p>string 赋值操作：即给 string 字符串进行赋值</p><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>              //char* 类型字符串，赋值给当前的字符串</li><li><code>string&amp; operator=(const string&amp; s);</code>         // 把字符串 s 赋值给当前的字符串</li><li><code>string&amp; operator=(char  s);</code>                          // 把字符赋值给当前的字符串</li><li><code>string&amp; assign(const char* s);</code>                    // 把字符串 s 赋值给当前的字符串</li><li><code>string&amp; assign(const char* s, int n);</code>     // 把字符串 s 的前 n 个字符赋值给当前的字符串</li><li><code>string&amp; assign(const string&amp; s);</code>               // 把字符串 s 赋值给当前的字符串</li><li><code>string&amp; assign(int n, char s);</code>                 // 用 n 个字符 s 赋值给当前的字符串</li></ul><h3 id="3-1-4-string- 字符串拼接"><a href="#3-1-4-string- 字符串拼接" class="headerlink" title="3.1.4 string 字符串拼接"></a>3.1.4 string 字符串拼接 </h3><p> 在字符串末尾拼接字符串</p><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>                   // 重载 += 操作符</li><li><code>string&amp; operator+=(const char c);</code>                         // 重载 += 操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>                // 重载 += 操作符</li><li><code>string&amp; append(const char *s);</code>                               // 把字符串 s 连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                 // 把字符串 s 的前 n 个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                           // 同 operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>// 字符串 s 中从 pos 开始的 n 个字符连接到字符串结尾</li><li><code>string&amp; append(int n, char c);</code>                                   // 在字符串结尾拼接 n 个 c</li></ul><pre><code class="c++">// 字符串拼接void test01()&#123;    string str1 = &quot; 我 &quot;;    // += 拼接    str1 += &quot; 爱玩游戏 &quot;;    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;    string str2 = &quot;LOL DNF&quot;;    str1 += str2;    cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;    string str3 = &quot;I&quot;;     // append 拼接    str3.append(&quot; love &quot;);    str3.append(&quot;game abcde&quot;, 4);    //append 指定位置拼接    str3.append(str2, 4, 3); // 从下标 4 位置开始 ，截取 3 个字符，拼接到字符串末尾    cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;&#125;</code></pre><h3 id="3-1-5-string- 查找和替换"><a href="#3-1-5-string- 查找和替换" class="headerlink" title="3.1.5 string 查找和替换"></a>3.1.5 string 查找和替换 </h3><p><strong> 功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              // 查找 str 第一次出现位置, 从 pos 开始查找</li><li><code>int find(const char* s, int pos = 0) const;</code>                     // 查找 s 第一次出现位置, 从 pos 开始查找</li><li><code>int find(const char* s, int pos, int n) const;</code>               // 从 pos 位置查找 s 的前 n 个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const;</code>                       // 查找字符 c 第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      // 查找 str 最后一次位置, 从 pos 开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              // 查找 s 最后一次出现位置, 从 pos 开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              // 从 pos 查找 s 的前 n 个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;</code>                      // 查找字符 c 最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code>       // 替换从 pos 开始 n 个字符为字符串 str</li><li><code>string&amp; replace(int pos, int n,const char* s);</code>                 // 替换从 pos 开始的 n 个字符为字符串 s</li></ul><pre><code class="c++">// 查找void test01()&#123;    string str1 = &quot;abcdefgde&quot;;    //find 找第一次出现的位置    int pos = str1.find(&quot;de&quot;);    if (pos == -1)&#123;        cout &lt;&lt; &quot; 未找到 &quot; &lt;&lt; endl;    &#125;    else&#123;        cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;    &#125;    //rfind 找最后一次出现的位置    pos = str1.rfind(&quot;de&quot;);    cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;&#125;// 替换void test02()&#123;    string str1 = &quot;abcdefgde&quot;;    str1.replace(1, 3, &quot;1111&quot;);    // 从位置 1 开始的共 3 个字符替换为 1111            cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;&#125;</code></pre><h3 id="3-1-6-string- 字符串比较"><a href="#3-1-6-string- 字符串比较" class="headerlink" title="3.1.6 string 字符串比较"></a>3.1.6 string 字符串比较 </h3><p><strong> 功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的 ASCII 码进行对比</li></ul><p>= 返回   0</p><p>&gt; 返回   1 </p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const;</code>  // 与字符串 s 比较</li><li><code>int compare(const char *s) const;</code>      // 与字符串 s 比较</li></ul><pre><code class="c++">void test01()&#123;    string s1 = &quot;hello&quot;;    string s2 = &quot;aello&quot;;    int ret = s1.compare(s2);    if (ret == 0) &#123;        cout &lt;&lt; &quot;s1 等于 s2&quot; &lt;&lt; endl;    &#125;    else if (ret &gt; 0)    &#123;        cout &lt;&lt; &quot;s1 大于 s2&quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;s1 小于 s2&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="3-1-7-string- 字符存取"><a href="#3-1-7-string- 字符存取" class="headerlink" title="3.1.7 string 字符存取"></a>3.1.7 string 字符存取</h3><p>string 中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n);</code>     // 通过 [] 方式取字符</li><li><code>char&amp; at(int n);</code>                    // 通过 at 方法获取字符</li></ul><pre><code class="c++">void test01()&#123;    string str = &quot;hello world&quot;;    // 获取字符    for (int i = 0; i &lt; str.size(); i++)    &#123;        cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for (int i = 0; i &lt; str.size(); i++)    &#123;        cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    // 字符修改    str[0] = &#39;x&#39;;    str.at(1) = &#39;x&#39;;    cout &lt;&lt; str &lt;&lt; endl;&#125;</code></pre><blockquote><p>[]：下标操作符 [] 在使用时不检查索引的有效性，如果下标超出字符的长度范围，会示导致未定义行为。</p><p>at：函数 at() 在使用时会检查下标是否有效。如果给定的下标超出字符的长度范围，系统会抛出 out_of_range 异常。</p></blockquote><h3 id="3-1-8-string- 插入和删除"><a href="#3-1-8-string- 插入和删除" class="headerlink" title="3.1.8 string 插入和删除"></a>3.1.8 string 插入和删除 </h3><p><strong> 功能描述：</strong></p><ul><li>对 string 字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);</code>                // 插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code>        // 插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                // 在指定位置插入 n 个字符 c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    // 删除从 Pos 开始的 n 个字符 </li></ul><pre><code class="c++">// 字符串插入和删除void test01()&#123;    string str = &quot;hello&quot;;    //insert 插入    str.insert(1, &quot;111&quot;);    cout &lt;&lt; str &lt;&lt; endl;    //    //erase 删除    str.erase(1, 3);  // 从 1 号位置开始 3 个字符， 第二个数字可以不写，意为删除从第 1 个到最后一个    cout &lt;&lt; str &lt;&lt; endl;&#125;</code></pre><h3 id="3-1-9-string- 子串"><a href="#3-1-9-string- 子串" class="headerlink" title="3.1.9 string 子串"></a>3.1.9 string 子串 </h3><p><strong> 功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   // 返回由 pos 开始的 n 个字符组成的字符串</li></ul><pre><code class="c++">void test01()&#123;    string str = &quot;abcdefg&quot;;    // 获取子串    string subStr = str.substr(1, 3);       // 若第二个数字可以不写，意为取从第 1 个到最后一个    cout &lt;&lt; &quot;subStr = &quot; &lt;&lt; subStr &lt;&lt; endl;    string email = &quot;hello@sina.com&quot;;    int pos = email.find(&quot;@&quot;);    string username = email.substr(0, pos);    cout &lt;&lt; &quot;username: &quot; &lt;&lt; username &lt;&lt; endl;&#125;</code></pre><h2 id="3-2-vector- 容器"><a href="#3-2-vector- 容器" class="headerlink" title="3.2 vector 容器"></a>3.2 vector 容器</h2><h3 id="3-2-1-vector 基本概念"><a href="#3-2-1-vector 基本概念" class="headerlink" title="3.2.1 vector 基本概念"></a>3.2.1 vector 基本概念</h3><p>vector 数据结构和数组非常相似，也称为单端数组。</p><p>vector 与普通数组区别：<strong>数组是静态空间，而 vector 可以动态扩展</strong>。数组 array 在定义时必须显式或隐式指定其 size；vector 则不用。</p><p>动态扩展：并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝至新空间，释放原空间。</p><p>vector 容器的迭代器是支持随机访问的迭代器。</p><h3 id="3-2-2-vector 构造函数"><a href="#3-2-2-vector 构造函数" class="headerlink" title="3.2.2 vector 构造函数"></a>3.2.2 vector 构造函数 </h3><p><strong> 函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v;</code>                            // 采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code>       // 将 v[begin(), end()]区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            // 构造函数将 n 个 elem 拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         // 拷贝构造函数。</li></ul><pre><code class="c++">#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    vector&lt;int&gt; v1; // 无参构造    for (int i = 0; i &lt; 10; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    vector&lt;int&gt; v2(v1.begin(), v1.end());  // 将 v1 的所有数据传给 v2    printVector(v2);    vector&lt;int&gt; v3(10, 100);   // 传入 10 个 100 给 V3    printVector(v3);    vector&lt;int&gt; v4(v3);  // 拷贝构造    printVector(v4);&#125;</code></pre><p><strong>vector 数组快速声明与初始化：</strong></p><pre><code class="c++">// 初始化数组长度vector&lt;int&gt; v1(10);// 初始化数组大小和值vector&lt;int&gt; v2(10, 100);// 直接赋值vector&lt;int&gt; v3 = &#123;1,2,3,4,5&#125;;// 使用数组初始化int arr[] = &#123;1,2,3,4&#125;;vector&lt;int&gt; v4(arr, arr+4);vector&lt;int&gt; v5(std::begin(arr), std::end(arr));</code></pre><h3 id="3-2-3-vector 赋值操作"><a href="#3-2-3-vector 赋值操作" class="headerlink" title="3.2.3 vector 赋值操作"></a>3.2.3 vector 赋值操作 </h3><p><strong> 函数原型：</strong></p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>// 重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>       // 将 [beg, end) 区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>        // 将 n 个 elem 拷贝赋值给本身。</li></ul><pre><code class="c++">#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123;    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01()&#123;    vector&lt;int&gt; v1;     for (int i = 0; i &lt; 10; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    vector&lt;int&gt;v2;    v2 = v1;                 // = 号赋值    printVector(v2);    vector&lt;int&gt;v3;    v3.assign(v1.begin(), v1.end());    //assign 赋值    printVector(v3);    vector&lt;int&gt;v4;    v4.assign(10, 100);      //assign 赋数值    printVector(v4);&#125;</code></pre><h3 id="3-2-4-vector 容量和大小"><a href="#3-2-4-vector 容量和大小" class="headerlink" title="3.2.4  vector 容量和大小"></a>3.2.4  vector 容量和大小 </h3><p><strong> 函数原型：</strong></p><ul><li><p><code>empty();</code>                            // 判断容器是否为空</p></li><li><p><code>capacity();</code>                      // 容器的 <strong> 容量</strong></p></li><li><p><code>size();</code>                              // 返回容器中 <strong> 元素的个数</strong></p></li><li><p><code>resize(int num);</code>             // 重新指定容器的长度为 num，若容器变长，则以默认值 0 填充新位置。</p><p>​                                                // 如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  // 重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。</p><p>​                                                  // 如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><pre><code class="c++">void test01()&#123;    vector&lt;int&gt; v1;    for (int i = 0; i &lt; 10; i++)    &#123;        v1.push_back(i);    &#125;    //printVector(v1);    //empty 使用    if (v1.empty())    &#123;        cout &lt;&lt; &quot;v1 为空 &quot; &lt;&lt; endl;    &#125;    else    &#123;        cout &lt;&lt; &quot;v1 不为空 &quot; &lt;&lt; endl;        cout &lt;&lt; &quot;v1 的容量 = &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;        cout &lt;&lt; &quot;v1 的大小 = &quot; &lt;&lt; v1.size() &lt;&lt; endl;    &#125;    //resize 重新指定大小为 15，用 10 补齐    v1.resize(15, 10);    //printVector(v1);    //resize 重新指定大小，超出 5 个元素部分删除    v1.resize(5);    //printVector(v1);&#125;</code></pre><h3 id="3-2-5-vector 插入和删除"><a href="#3-2-5-vector 插入和删除" class="headerlink" title="3.2.5 vector 插入和删除"></a>3.2.5 vector 插入和删除 </h3><p><strong> 函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         // 尾部插入元素 ele</li><li><code>pop_back();</code>                                                // 删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        // 迭代器指向位置 pos 插入元素 ele</li><li><code>insert(const_iterator pos, int count,ele);</code>// 迭代器指向位置 pos 插入 count 个元素 ele</li><li><code>erase(const_iterator pos);</code>                     // 删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>// 删除迭代器从 start 到 end 之间的元素</li><li><code>clear();</code>                                                        // 删除容器中所有元素</li></ul><pre><code class="c++">#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt; v1;    // 尾插    v1.push_back(10);    v1.push_back(20);    v1.push_back(30);    v1.push_back(40);    v1.push_back(50);    //printVector(v1);    // 尾删    v1.pop_back();    //printVector(v1);    // 插入    v1.insert(v1.begin(), 100);      //printVector(v1);               //100 10 20 30 40 50    v1.insert(v1.begin(), 2, 1000);    //printVector(v1);    // 删除    v1.erase(v1.begin());    printVector(v1);    // 清空    v1.erase(v1.begin(), v1.end());    v1.clear();    //printVector(v1);&#125;</code></pre><p>当 vector 容器为空时，必须采用 push_back()方法来插入元素。但如果 vector 容器初始化有值，可以用随机访问的方法重新赋值：</p><pre><code class="c++">void test() &#123;    vector&lt;int&gt; m(10,0);        // 初始化 m 容器为 10 个 0    // 修改元素    for (int i = 0; i &lt; 10; ++i) &#123;        m[i] = i;    &#125;    // 查看元素    for (int num : m) &#123;        cout &lt;&lt; num;    &#125;&#125;</code></pre><h3 id="3-2-6-vector 数据存取"><a href="#3-2-6-vector 数据存取" class="headerlink" title="3.2.6 vector 数据存取"></a>3.2.6 vector 数据存取 </h3><p><strong> 函数原型：</strong></p><ul><li><code>at(int idx);</code>     // 返回索引 idx 所指的数据</li><li><code>operator[idx];</code>       // 返回索引 idx 所指的数据</li><li><code>front();</code>            // 返回容器中第一个数据元素</li><li><code>back();</code>              // 返回容器中最后一个数据元素</li></ul><pre><code class="c++">#include &lt;vector&gt;void test01()&#123;    vector&lt;int&gt;v1;    for (int i = 0; i &lt; 10; i++)    &#123;        v1.push_back(i);    &#125;    for (int i = 0; i &lt; v1.size(); i++)    &#123;        cout &lt;&lt; v1[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for (int i = 0; i &lt; v1.size(); i++)    &#123;        cout &lt;&lt; v1.at(i) &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;v1 的第一个元素为： &quot; &lt;&lt; v1.front() &lt;&lt; endl;    cout &lt;&lt; &quot;v1 的最后一个元素为： &quot; &lt;&lt; v1.back() &lt;&lt; endl;&#125;</code></pre><h3 id="3-2-7-vector 互换容器"><a href="#3-2-7-vector 互换容器" class="headerlink" title="3.2.7 vector 互换容器"></a>3.2.7 vector 互换容器 </h3><p><strong> 函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将 vec 与本身的元素互换</li></ul><pre><code class="c++">void test01()&#123;    vector&lt;int&gt;v1;    for (int i = 0; i &lt; 10; i++)    &#123;        v1.push_back(i);    &#125;    printVector(v1);    vector&lt;int&gt;v2;    for (int i = 10; i &gt; 0; i--)    &#123;        v2.push_back(i);    &#125;    printVector(v2);    // 互换容器    cout &lt;&lt; &quot; 互换后 &quot; &lt;&lt; endl;    v1.swap(v2);    printVector(v1);    printVector(v2);&#125;</code></pre><p>当然 swap 函数更重要的作用是：<strong>收缩容量，节省空间</strong></p><pre><code class="c++">void test02()&#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt; 10000; i++) &#123;        v.push_back(i);    &#125;    cout &lt;&lt; &quot;v 的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;   // 输出 12138    cout &lt;&lt; &quot;v 的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;       // 输出 10000    v.resize(3);    cout &lt;&lt; &quot;v 的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;   // 输出 12138    cout &lt;&lt; &quot;v 的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;       // 输出 3    // 收缩容量（内存）    vector&lt;int&gt;(v).swap(v); //vector&lt;int&gt;(v)匿名对象    cout &lt;&lt; &quot;v 的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;   // 输出 3    cout &lt;&lt; &quot;v 的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;       // 输出 3&#125;</code></pre><h3 id="3-2-8-vector 预留空间"><a href="#3-2-8-vector 预留空间" class="headerlink" title="3.2.8 vector 预留空间"></a>3.2.8 vector 预留空间 </h3><p> 减少 vector 在动态扩展容量时的扩展次数。</p><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>// 容器预留 len 个元素长度，预留位置不初始化，元素不可访问。</li></ul><pre><code class="c++">void test01()&#123;    vector&lt;int&gt; v;    // 预留空间    v.reserve(100000);  // 加与不加这行，后面计算的 num 有差别    int num = 0;    int* p = NULL;    for (int i = 0; i &lt; 100000; i++) &#123;        v.push_back(i);        if (p != &amp;v[0]) &#123;            p = &amp;v[0];            num++;        &#125;    &#125;    cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;  // 输出：1&#125;</code></pre><h2 id="3-3-Deque 容器"><a href="#3-3-Deque 容器" class="headerlink" title="3.3 Deque 容器"></a>3.3 Deque 容器</h2><h3 id="3-3-1-deque 容器基本概念"><a href="#3-3-1-deque 容器基本概念" class="headerlink" title="3.3.1 deque 容器基本概念"></a>3.3.1 deque 容器基本概念</h3><p>deque（音 /dɛk/）容器是一种双端数组，可以对头部和尾部进行插入删除操作。</p><p>deque 与 vector 区别：</p><ul><li>vector 对于头部的插入和删除效率低下，数据量越大，效率越低</li><li>deque 相对而言，对头部的插入删除速度会比 vector 快</li><li>vector 访问元素时的速度会比 deque 快，这和内部实现有关。</li></ul><p>deque 内部工作原理：</p><p>deuqe 内部有个中控器，维护每段缓冲区中的内容，缓冲区存放真实数据。</p><p>中控器维护的是每个缓冲区的地址，使得使用 deque 时像一片连续的内存空间。</p><p>deque 容器的迭代器是支持随机访问的迭代器。</p><h3 id="3-3-2-deque 构造函数"><a href="#3-3-2-deque 构造函数" class="headerlink" title="3.3.2 deque 构造函数"></a>3.3.2 deque 构造函数 </h3><p><strong> 函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT;                        // 默认构造形式</li><li><code>deque(beg, end);</code>                  // 构造函数将 [beg, end) 区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    // 构造函数将 n 个 elem 拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   // 拷贝构造函数</li></ul><pre><code class="c++">void printDeque(const deque&lt;int&gt;&amp; d)&#123;    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;  // 注意这里的 const_iterator，只读迭代器        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test01() &#123;    deque&lt;int&gt; d1;     for (int i = 0; i &lt; 10; i++)    &#123;        d1.push_back(i);    &#125;    printDeque(d1);    deque&lt;int&gt; d2(d1.begin(), d1.end());    printDeque(d2);    deque&lt;int&gt;d3(10, 100);    printDeque(d3);    deque&lt;int&gt;d4 = d3;    printDeque(d4);&#125;</code></pre><p><strong>总结：</strong>deque 容器和 vector 容器的构造方式几乎一致，灵活使用即可</p><h3 id="3-3-3-deque 赋值操作"><a href="#3-3-3-deque 赋值操作" class="headerlink" title="3.3.3 deque 赋值操作"></a>3.3.3 deque 赋值操作 </h3><p><strong> 函数原型：</strong></p><ul><li><code>deque&amp; operator=(const deque &amp;deq);</code>         // 重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>                                           // 将 [beg, end) 区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>                                             // 将 n 个 elem 拷贝赋值给本身。</li></ul><pre><code class="c++">void test01()&#123;    deque&lt;int&gt; d1;    for (int i = 0; i &lt; 10; i++)    &#123;        d1.push_back(i);    &#125;    printDeque(d1);    deque&lt;int&gt;d2;    d2 = d1;                //= 号赋值    printDeque(d2);    deque&lt;int&gt;d3;    d3.assign(d1.begin(), d1.end());   //assign 赋值    printDeque(d3);    deque&lt;int&gt;d4;    d4.assign(10, 100);    printDeque(d4);&#125;</code></pre><h3 id="3-3-4-deque 大小操作"><a href="#3-3-4-deque 大小操作" class="headerlink" title="3.3.4 deque 大小操作"></a>3.3.4 deque 大小操作 </h3><p><strong> 函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                        // 判断容器是否为空</p></li><li><p><code>deque.size();</code>                          // 返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                // 重新指定容器的长度为 num, 若容器变长，则以默认值填充新位置。</p><p>​                                                      // 如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     // 重新指定容器的长度为 num, 若容器变长，则以 elem 值填充新位置。</p><p>​                                                        // 如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p>其用法与 vector 完全一样。</p><h3 id="3-3-5-deque- 插入和删除"><a href="#3-3-5-deque- 插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除 </h3><p><strong> 函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          // 在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        // 在容器头部插入一个数据</li><li><code>pop_back();</code>                   // 删除容器最后一个数据</li><li><code>pop_front();</code>                 // 删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         // 在 pos 位置插入一个 elem 元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     // 在 pos 位置插入 n 个 elem 数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    // 在 pos 位置插入 [beg,end) 区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           // 清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             // 删除 [beg,end) 区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    // 删除 pos 位置的数据，返回下一个数据的位置。</p></li></ul><p>用法类似 vector。比 vector 多的是可以进行头部插入和删除。</p><h3 id="3-3-6-deque- 数据存取"><a href="#3-3-6-deque- 数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取 </h3><p><strong> 函数原型：</strong></p><ul><li><code>at(int idx);</code>     // 返回索引 idx 所指的数据</li><li><code>operator[];</code>      // 返回索引 idx 所指的数据</li><li><code>front();</code>            // 返回容器中第一个数据元素</li><li><code>back();</code>              // 返回容器中最后一个数据元素</li></ul><p>其用法与 vector 完全一样。</p><h3 id="3-3-7-deque- 排序"><a href="#3-3-7-deque- 排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序 </h3><p><strong> 算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  // 对 beg 和 end 区间内元素进行排序</li></ul><pre><code class="c++">#include &lt;deque&gt;#include &lt;algorithm&gt;   // 标准算法库void test01()&#123;    deque&lt;int&gt; d;    d.push_back(10);    d.push_back(20);    d.push_front(100);    d.push_front(200);    printDeque(d);    // 排序    sort(d.begin(), d.end());    printDeque(d);&#125;</code></pre><p>vector 也支持用 sort 进行排序。总结一句话：只要是支持随机访问的迭代器容器都可以用 sort 进行排序。</p><h2 id="3-4- 案例 - 评委打分"><a href="#3-4- 案例 - 评委打分" class="headerlink" title="3.4 案例 - 评委打分"></a>3.4 案例 - 评委打分 </h2><h3 id="3-4-1- 案例描述"><a href="#3-4-1- 案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h3><p> 有 5 名选手，选手 ABCDE，10 个评委分别对每一位选手打分，去除最高分，去除评委中最低分，取平均分。</p><p>实现步骤：</p><ul><li>创建五名选手，放到 vector 容器中</li><li>遍历 vector 容器，取出来每一位选手，执行 for 循环，可以把 10 个评分打分存到 deque 容器中</li><li>sort 算法对 deque 容器中分数排序，去除最高分和最低分</li><li>deque 容器遍历一遍，累加总分</li><li>获取平均分</li></ul><h3 id="3-4-2- 代码实现"><a href="#3-4-2- 代码实现" class="headerlink" title="3.4.2 代码实现"></a>3.4.2 代码实现</h3><pre><code class="c++">#pragma once#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;#include&lt;vector&gt;#include&lt;algorithm&gt;#include &lt;deque&gt;class Person &#123;public:    Person(string name, int score) &#123;        this-&gt;m_Name = name;        this-&gt;m_score = score;    &#125;    string m_Name;    int m_score;&#125;;void creatPerson(vector&lt;Person&gt;&amp; v) &#123;    string seed = &quot;ABCDE&quot;;    for (int i = 0; i &lt; seed.size(); ++i) &#123;        string name = &quot; 选手 &quot; ;        name += +seed[i];        int score = 0;        Person p(name, score);        v.push_back(p);    &#125;&#125;void setScore(vector&lt;Person&gt;&amp; v) &#123;    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123;        deque&lt;int&gt; d;  // 用来存放 10 个分数        for (int i = 0; i &lt; 10; ++i) &#123;            int score = rand() % 40 + 61;            d.push_back(score);        &#125;        sort(d.begin(), d.end());        d.pop_back();        d.pop_front();        // 计算平均分        int sum = 0;        for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); ++dit) &#123;            sum += *dit;        &#125;        int avg = sum / d.size();        it-&gt;m_score = avg;    &#125;&#125;int main() &#123;    srand((unsigned int)time(NULL)); // 随机数种子    vector&lt;Person&gt; v;    creatPerson(v);    setScore(v);    for (vector&lt;Person&gt;::iterator it = v.begin();it!=v.end();++it) &#123;        cout &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;m_score &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h2 id="3-5-stack 容器"><a href="#3-5-stack 容器" class="headerlink" title="3.5 stack 容器"></a>3.5 stack 容器</h2><h3 id="3-5-1- 基本概念"><a href="#3-5-1- 基本概念" class="headerlink" title="3.5.1 基本概念"></a>3.5.1 基本概念</h3><p>stack（栈）容器是一种先进后出的数据结构容器，它只有一个出口。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220204205615728.png" alt=""></p><p>栈内元素只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为。</p><p>栈中进入数据称为—入栈<code>push</code></p><p>栈中弹出数据称为—出栈<code>pop</code></p><h3 id="3-5-2-stack 常用接口"><a href="#3-5-2-stack 常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口 </h3><p> 构造函数：</p><ul><li><code>stack&lt;T&gt; stk</code>                             // 采用模板类实现，stack 对象的默认构造形式</li><li><code>stack(const stack &amp;stk)</code>      // 拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk)</code>       // 重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>        // 向栈顶添加元素</li><li><code>pop();</code>                  // 从栈顶移除元素</li><li><code>top();</code>                  // 返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            // 判断栈是否为空</li><li><code>size();</code>              // 返回栈的大小</li></ul><h2 id="3-6-queue 容器"><a href="#3-6-queue 容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h2><h3 id="3-6-1- 基本概念"><a href="#3-6-1- 基本概念" class="headerlink" title="3.6.1 基本概念"></a>3.6.1 基本概念</h3><p>queue 是一种先进先出的数据结构，它有两个出口：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220204212753063.png" alt=""></p><p>队列容器允许从一端新增元素，从另一端移除元素。<strong>犹如人，嘴巴进，屁股出</strong>。</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为—入队<code>push</code></p><p>队列中出数据称为—出队<code>pop</code></p><h3 id="3-6-2- 常用接口"><a href="#3-6-2- 常用接口" class="headerlink" title="3.6.2 常用接口"></a>3.6.2 常用接口 </h3><p> 构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                  //queue 采用模板类实现，queue 对象默认构造形式</li><li><code>queue(const queue &amp;que);</code>           // 拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>       // 重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>               // 往队尾添加元素</li><li><code>pop();</code>                         // 从队头移除第一个元素</li><li><code>back();</code>                      // 返回最后一个元素</li><li><code>front();</code>                    // 返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>                     // 判断容器是否为空</li><li><code>size();</code>                      // 返回容器的大小</li></ul><h2 id="3-7-list 容器"><a href="#3-7-list 容器" class="headerlink" title="3.7 list 容器"></a>3.7 list 容器</h2><h3 id="3-7-1- 基本概念"><a href="#3-7-1- 基本概念" class="headerlink" title="3.7.1 基本概念"></a>3.7.1 基本概念</h3><p>list 容器的存储方式为链式存储。</p><p>链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的。</p><p>链表的组成：链表由一系列结点组成。</p><p>结点的组成：一个是存储数据元素的数据域，另一个是储存下一个结点地址的指针域。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220205215539070.png" style="zoom: 80%;" /><p>STL 中的链表是一个 <strong> 双向循环 </strong> 链表。</p><ul><li><strong>双向 </strong> 是指每一个结点有两个指针，一个指针 next 指向下一个结点的地址，一个指针 prev 指向上一个结点的地址；</li><li><strong>循环 </strong> 是指第一个结点 prev 指向最后一个结点的地址，最后一个结点 next 指向第一个结点的地址。</li></ul><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220205215848416.png" alt=""></p><p>由于链表的存储方式并不是连续的内存空间，因此链表 list 中的迭代器只支持前移和后移，属于 <strong> 双向迭代器</strong>。</p><p>list 的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list 的缺点：</p><ul><li>链表灵活，但是空间（指针域）和时间（遍历）额外耗费较大。</li></ul><p>List 有一个重要的性质，插入和删除操作都不会造成原有 list 迭代器的失效，这在 vector 是不成立的。</p><h3 id="3-7-2-list 构造函数"><a href="#3-7-2-list 构造函数" class="headerlink" title="3.7.2  list 构造函数"></a>3.7.2  list 构造函数 </h3><p> 函数原型：</p><ul><li><code>list&lt;T&gt; lst;</code>                                // list 采用采用模板类实现, 对象的默认构造形式：</li><li><code>list(beg,end);</code>                           // 构造函数将 [beg, end) 区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             // 构造函数将 n 个 elem 拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            // 拷贝构造函数。</li></ul><pre><code class="c++">#include&lt;list&gt;void printList(const list&lt;int&gt;&amp;L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); ++it) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test1() &#123;    // 创建 list 容器 --- 默认构造    list&lt;int&gt; L1;    L1.push_back(10);    L1.push_back(20);    L1.push_back(30);    L1.push_back(40);    printList(L1);    // 创建 list 容器 --- 区间方式构造    list&lt;int&gt; L2(L1.begin(),L1.end());    // 创建 list 容器 --- 拷贝构造    list&lt;int&gt; L3(L2);    // 创建 list 容器 ---n 个 elem    list&lt;int&gt; L4(10,100);    printList(L4);&#125;int main() &#123;    test1();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="3-7-3-list- 赋值和交换"><a href="#3-7-3-list- 赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换 </h3><p><strong> 函数原型：</strong></p><ul><li><code>assign(beg, end);</code>            // 将 [beg, end) 区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              // 将 n 个 elem 拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         // 重载等号操作符</li><li><code>swap(lst);</code>                         // 将 lst 与本身的元素互换。</li></ul><h3 id="3-7-4-list- 大小操作"><a href="#3-7-4-list- 大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作 </h3><p><strong> 函数原型：</strong></p><ul><li><p><code>size();</code>                              // 返回容器中元素的个数</p></li><li><p><code>empty();</code>                           // 判断容器是否为空</p></li><li><p><code>resize(num);</code>                   // 重新指定容器的长度为 num，若容器变长，则以默认值填充新位置。</p><p>​                                             // 如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem);</code>       // 重新指定容器的长度为 num，若容器变长，则以 elem 值填充新位置。变短则删除。</p></li></ul><h3 id="3-7-5-list- 插入和删除"><a href="#3-7-5-list- 插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除 </h3><p><strong> 函数原型：</strong></p><ul><li><code>push_back(elem);</code>                           // 在容器尾部加入一个元素</li><li><code>pop_back();</code>                                     // 删除容器中最后一个元素</li><li><code>push_front(elem);</code>                         // 在容器开头插入一个元素</li><li><code>pop_front();</code>                                    // 从容器开头移除第一个元素</li><li><code>insert(pos,elem);</code>                         // 在 pos 位置插 elem 元素的拷贝，返回新数据的位置。</li><li><code>insert(pos,n,elem);</code>                     // 在 pos 位置插入 n 个 elem 数据，无返回值。</li><li><code>insert(pos,beg,end);</code>                   // 在 pos 位置插入 [beg,end) 区间的数据，无返回值。</li><li><code>clear();</code>                                           // 移除容器的所有数据</li><li><code>erase(beg,end);</code>                            // 删除 [beg,end) 区间的数据，返回下一个数据的位置。</li><li><code>erase(pos);</code>                                    // 删除 pos 位置的数据，返回下一个数据的位置。</li><li><code>remove(elem);</code>                                // 删除容器中所有与 elem 值匹配的元素。</li></ul><h3 id="3-7-6-list- 数据存取"><a href="#3-7-6-list- 数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取 </h3><p><strong> 函数原型：</strong></p><ul><li><code>front();</code>        // 返回第一个元素。</li><li><code>back();</code>         // 返回最后一个元素。</li></ul><h3 id="3-7-7-list- 反转和排序"><a href="#3-7-7-list- 反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序 </h3><p><strong> 函数原型：</strong></p><ul><li><code>reverse();</code>   // 反转链表</li><li><code>sort();</code>        // 链表排序，升序</li></ul><pre><code class="c++">#include&lt;list&gt;void printList(const list&lt;int&gt;&amp;L) &#123;    for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); ++it) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;bool myCompare(int v1, int v2) &#123;    return v1 &gt; v2;&#125;void test1() &#123;    list&lt;int&gt; L1;    L1.push_back(20);    L1.push_back(10);    L1.push_back(40);    L1.push_back(30);    L1.sort();  // 默认升序排列    printList(L1);    L1.sort(myCompare);   // 降序排列    printList(L1);&#125;int main() &#123;    test1();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="3-7-8- 排序案例"><a href="#3-7-8- 排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h3><pre><code class="c++">#include&lt;list&gt;class Person &#123;public:    Person(string name, int age, int height) &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;        this-&gt;m_Height = height;    &#125;    string m_Name;    int m_Age;    int m_Height;&#125;;void printList(const list&lt;Person&gt;&amp;L) &#123;    for (list&lt;Person&gt;::const_iterator it = L.begin(); it != L.end(); ++it) &#123;        cout &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; &quot;;        cout &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; &quot;;        cout &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;&#125;bool sortRule(Person &amp;p1, Person &amp;p2) &#123;    if (p1.m_Age == p2.m_Age) &#123;        return p1.m_Height &gt; p2.m_Height;    &#125;    return p1.m_Age &lt; p2.m_Age;&#125;void test1() &#123;    list&lt;Person&gt; L1;    Person p1(&quot; 张飞 &quot;, 23, 178);    Person p2(&quot; 周瑜 &quot;, 28, 175);    Person p3(&quot; 孙权 &quot;, 12, 132);    Person p4(&quot; 曹操 &quot;, 34, 175);    Person p5(&quot; 关羽 &quot;, 25, 182);    Person p6(&quot; 刘备 &quot;, 28, 180);    L1.push_back(p1);    L1.push_back(p2);    L1.push_back(p3);    L1.push_back(p4);    L1.push_back(p5);    L1.push_back(p6);    printList(L1);    cout &lt;&lt; endl;    L1.sort(sortRule);    printList(L1);&#125;</code></pre><blockquote><p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序。</p><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂。</p></blockquote><h2 id="3-8-set-multiset 容器"><a href="#3-8-set-multiset 容器" class="headerlink" title="3.8 set/multiset 容器"></a>3.8 set/multiset 容器 </h2><h3 id="3-8-1- 基本概念"><a href="#3-8-1- 基本概念" class="headerlink" title="3.8.1 基本概念"></a>3.8.1 基本概念</h3><p> 集合容器，所有元素在插入时会自动被排序。set/multiset 属于 <strong> 关联式容器</strong>，底层结构用二叉树实现。</p><p>set 和 multiset 区别：</p><ul><li>set 不允许容器中有重复的元素，multiset 允许容器中有重复的元素</li><li>set 插入数据的同时会返回插入结果，表示插入是否成功；multiset 无返回值</li></ul><p>set 和 multiset 的头文件都是<code>#include&lt;set&gt;</code></p><p><strong>构造函数</strong></p><ul><li><code>set&lt;T&gt; st;</code>                        // 默认构造函数：</li><li><code>set(const set &amp;st);</code>       // 拷贝构造函数</li></ul><p><strong>赋值</strong></p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    // 重载等号操作符</li></ul><h3 id="3-8-2-set 大小和交换"><a href="#3-8-2-set 大小和交换" class="headerlink" title="3.8.2 set 大小和交换"></a>3.8.2 set 大小和交换 </h3><p><strong> 函数原型：</strong></p><ul><li><code>size();</code>          // 返回容器中元素的数目</li><li><code>empty();</code>        // 判断容器是否为空</li><li><code>swap(st);</code>      // 交换两个集合容器</li></ul><h3 id="3-8-3-set 插入和删除"><a href="#3-8-3-set 插入和删除" class="headerlink" title="3.8.3 set 插入和删除"></a>3.8.3 set 插入和删除 </h3><p><strong> 函数原型：</strong></p><ul><li><code>insert(elem);</code>           // 在容器中插入元素。</li><li><code>clear();</code>                    // 清除所有元素</li><li><code>erase(pos);</code>              // 删除 pos 迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    // 删除区间 [beg,end) 的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            // 删除容器中值为 elem 的元素。</li></ul><h3 id="3-8-5-set 查找和统计"><a href="#3-8-5-set 查找和统计" class="headerlink" title="3.8.5 set 查找和统计"></a>3.8.5 set 查找和统计 </h3><p><strong> 函数原型：</strong></p><ul><li><code>find(key);</code>                  // 查找 key 是否存在, 若存在，返回该键的元素的迭代器；若不存在，返回 set.end();</li><li><code>count(key);</code>                // 统计 key 的元素个数（整型 int）</li></ul><pre><code class="c++">#include&lt;set&gt;void test1() &#123;    set&lt;int&gt; s1;    s1.insert(20);    s1.insert(50);    s1.insert(10);    s1.insert(40);    s1.insert(30);    set&lt;int&gt;::iterator pos = s1.find(30);    if (pos != s1.end()) &#123;        cout &lt;&lt; &quot; 找到 &quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot; 没找到 &quot; &lt;&lt; endl;    &#125;    int num = s1.count(10);&#125;</code></pre><h3 id="3-8-6-set 返回值"><a href="#3-8-6-set 返回值" class="headerlink" title="3.8.6 set 返回值"></a>3.8.6 set 返回值</h3><p>set 插入数据的同时会返回插入结果，表示插入是否成功。返回值是一个 pair 类型的数据</p><pre><code class="c++">#include&lt;set&gt;void test1() &#123;    set&lt;int&gt; s1;    pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s1.insert(20);    if (ret.second) &#123;        cout &lt;&lt; &quot; 插入成功！&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot; 插入失败！&quot; &lt;&lt; endl;    &#125;    pair&lt;set&lt;int&gt;::iterator, bool&gt; ret2 = s1.insert(20);    if (ret2.second) &#123;        cout &lt;&lt; &quot; 插入成功！&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot; 插入失败！&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="3-8-7-pair 对组创建"><a href="#3-8-7-pair 对组创建" class="headerlink" title="3.8.7 pair 对组创建"></a>3.8.7 pair 对组创建 </h3><p> 成对出现的数据，利用对组可以返回两个数据。</p><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p (value1, value2);</code></li><li><code>pair&lt;type, type&gt; p = make_pair(value1, value2);</code></li></ul><pre><code class="c++">pair&lt;string, int&gt; p(&quot;Tom&quot;, 20);cout &lt;&lt; &quot; 姓名： &quot; &lt;&lt;  p.first &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.second &lt;&lt; endl;</code></pre><h3 id="3-8-8-set 容器排序"><a href="#3-8-8-set 容器排序" class="headerlink" title="3.8.8 set 容器排序"></a>3.8.8 set 容器排序 </h3><p> 学习目标：</p><ul><li>set 容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong>：内置的数据类型排序</p><pre><code class="c++">#include&lt;set&gt;class SortRule &#123;public:    bool operator()(int v1, int v2) const &#123;       // 这里加个 const，不然 vs2019 会报错        return v1 &gt; v2;    &#125;&#125;;void printSet(set&lt;int, SortRule&gt;&amp;s) &#123;    for (set&lt;int, SortRule&gt;::iterator it = s.begin(); it != s.end(); ++it) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void test1() &#123;    set&lt;int, SortRule&gt; s1;    s1.insert(20);    s1.insert(30);    s1.insert(10);    s1.insert(50);    s1.insert(40);    printSet(s1);&#125;</code></pre><p>示例二：自定义数据类型排序</p><pre><code class="c++">#include&lt;set&gt;class Person &#123;public:    Person(string name, int age, int height) &#123;        this-&gt;m_Name = name;        this-&gt;m_Age = age;        this-&gt;m_Height = height;    &#125;    string m_Name;    int m_Age;    int m_Height;&#125;;class SortRule &#123;public:    bool operator()(const Person&amp; p1, const Person&amp; p2) const&#123;        return p1.m_Age &gt; p2.m_Age;    &#125;&#125;;void printSet(set&lt;Person, SortRule&gt;&amp;s) &#123;    for (set&lt;Person, SortRule&gt;::iterator it = s.begin(); it != s.end(); ++it) &#123;        cout &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; &quot;;        cout &lt;&lt; it-&gt;m_Age &lt;&lt; &quot; &quot;;        cout &lt;&lt; it-&gt;m_Height &lt;&lt; endl;    &#125;&#125;void test1() &#123;    set&lt;Person, SortRule&gt; s1;    Person p1(&quot; 张飞 &quot;, 25, 180);    Person p2(&quot; 周瑜 &quot;, 26, 175);    Person p3(&quot; 刘备 &quot;, 28, 179);    Person p4(&quot; 孙权 &quot;, 16, 158);    Person p5(&quot; 关羽 &quot;, 27, 182);    s1.insert(p1);    s1.insert(p2);    s1.insert(p3);    s1.insert(p4);    s1.insert(p5);    printSet(s1);&#125;</code></pre><h2 id="3-9-map-multimap 容器"><a href="#3-9-map-multimap 容器" class="headerlink" title="3.9 map/multimap 容器"></a>3.9 map/multimap 容器</h2><h3 id="3-9-1-map 基本概念"><a href="#3-9-1-map 基本概念" class="headerlink" title="3.9.1 map 基本概念"></a>3.9.1 map 基本概念</h3><p>map/multimap 属于关联式容器，底层结构是用二叉树实现。</p><ul><li>map 中所有元素都是 pair</li><li>pair 中第一个元素为 key（键值），起索引作用，第二个元素为 value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p>优点：</p><ul><li>可以根据 key 值快速找到 value 值</li></ul><p>map/multimap 区别：</p><ul><li>map 不允许容器中有重复 key 值元素。</li><li>multimap 允许容器中有重复 key 值元素。</li></ul><h3 id="3-9-2-map 构造和赋值"><a href="#3-9-2-map 构造和赋值" class="headerlink" title="3.9.2  map 构造和赋值"></a>3.9.2  map 构造和赋值 </h3><p><strong> 函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map 默认构造函数: </li><li><code>map(const map &amp;mp);</code>             // 拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    // 重载等号操作符</li></ul><pre><code class="c++">#include&lt;map&gt;void printMap(map&lt;int, int&gt;&amp; m) &#123;    for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); ++it) &#123;        cout &lt;&lt; (*it).first &lt;&lt; &quot; &quot; &lt;&lt; (*it).second &lt;&lt; endl;    &#125;&#125;void test1() &#123;    // 默认构造    map&lt;int, int&gt;m;    m.insert(pair&lt;int,int&gt;(1, 10));    m.insert(pair&lt;int, int&gt;(4, 40));    m.insert(pair&lt;int, int&gt;(3, 30));    m.insert(pair&lt;int, int&gt;(2, 200));    printMap(m);    // 拷贝构造    map&lt;int, int&gt;m2(m);    printMap(m2);    // 赋值    map&lt;int, int&gt;m3 = m;    printMap(m3);    // 按照 key 取值    cout &lt;&lt; m[2] &lt;&lt; endl;      // 多层 map    map&lt;string, map&lt;int, int&gt;&gt; mm;    mm.insert(make_pair(&quot;No1&quot;, m));   //mm[&quot;No1&quot;]=m&#125;</code></pre><p>map 取值有三种：[]，find，at</p><ul><li><p>find 有就是有，没有就是没有，需要判断 find 的返回结果，才知道有没有。</p></li><li><p>[] 不管有没有，都是有。因为没有就是 0，字符串就是空。反正就是给它是初始值。如果原先不存在该 key，则插入，如果存在，则覆盖插入。</p></li><li><p>at 用于取值，但它是进行越界检测，这会损失效率。</p><p>相比于 find，能少敲键盘</p><p>相比于[]，更安全</p><p>性能会有损失</p><p>所以常用于待查找的 key 都应该存在的情况，如果查找的 key 不存在，则说明程序有问题了。</p></li></ul><blockquote><p>以上三种虽然都能达到取值的目的，但用法上的些微差别可能导致使用上的 bug，所以一般性的建议如下：</p><p>如果纯粹是查找取值，不要用 [] 操作符，因为它会自动创建不存在的元素 <br> 正因为上面的原因，[]仅用于非 const 的情形下。在 const map 下使用 [] 会导致编译期错误 <br> 如果不确定待查找的值是否存在，且不存在也是合理的，则使用 find，判断返回值是否是 end()<br>如果待查找的值肯定存在，如果不存在就是逻辑上的错误，则使用 at，处理 out_of_range 异常</p></blockquote><p><strong>所以，对 map 根据 key 取值，不要用[]！！！</strong></p><h3 id="3-9-3-map 大小和交换"><a href="#3-9-3-map 大小和交换" class="headerlink" title="3.9.3 map 大小和交换"></a>3.9.3 map 大小和交换 </h3><p> 函数原型：</p><ul><li><code>size();</code>          // 返回容器中元素的数目</li><li><code>empty();</code>        // 判断容器是否为空</li><li><code>swap(st);</code>      // 交换两个集合容器</li></ul><h3 id="3-9-4-map 插入和删除"><a href="#3-9-4-map 插入和删除" class="headerlink" title="3.9.4 map 插入和删除"></a>3.9.4 map 插入和删除 </h3><p><strong> 函数原型：</strong></p><ul><li><code>insert(elem);</code>           // 在容器中插入元素。</li><li><code>clear();</code>                    // 清除所有元素</li><li><code>erase(pos);</code>              // 删除 pos 迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    // 删除区间 [beg,end) 的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            // 删除容器中值为 key 的元素。</li></ul><h3 id="3-9-5-map 查找和统计"><a href="#3-9-5-map 查找和统计" class="headerlink" title="3.9.5 map 查找和统计"></a>3.9.5 map 查找和统计 </h3><p><strong> 函数原型：</strong></p><ul><li><code>find(key);</code>                  // 查找 key 是否存在，若存在，返回该键的元素的迭代器；若不存在，返回 map.end();</li><li><code>count(key);</code>                // 统计 key 的元素个数，返回 int 整型数据</li></ul><pre><code class="c++">#include&lt;map&gt;void test1() &#123;    map&lt;int, int&gt;m;    m.insert(make_pair(1, 10));    m.insert(make_pair(2, 20));    m.insert(make_pair(3, 30));    m.insert(make_pair(4, 40));    map&lt;int, int&gt;::iterator pos = m.find(2);    cout &lt;&lt; pos-&gt;second &lt;&lt; endl;&#125;</code></pre><h3 id="3-9-6-map 容器排序"><a href="#3-9-6-map 容器排序" class="headerlink" title="3.9.6 map 容器排序"></a>3.9.6 map 容器排序</h3><p>map 排序函数与 set 类似。</p><pre><code class="c++">class SortRule &#123;public:    bool operator()(int v1, int v2) const &#123;       // 这里加个 const，不然 vs2019 会报错        return v1 &gt; v2;    &#125;&#125;;void test1() &#123;    map&lt;int, int, SortRule&gt; m;    //SortRule 指明按照从大到小排列    m.insert(make_pair(1, 10));    m.insert(make_pair(2, 20));    m.insert(make_pair(3, 30));    m.insert(make_pair(4, 40));    m.insert(make_pair(5, 50));&#125;</code></pre><h2 id="3-10- 案例 - 员工分组"><a href="#3-10- 案例 - 员工分组" class="headerlink" title="3.10 案例 - 员工分组"></a>3.10 案例 - 员工分组</h2><h3 id="3-10-1- 案例描述"><a href="#3-10-1- 案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h3><ul><li>公司今天招聘了 10 个员工（ABCDEFGHIJ），10 名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li><li>随机给 10 名员工分配部门和工资</li><li>通过 multimap 进行信息的插入  key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h3 id="3-10-2- 代码实现"><a href="#3-10-2- 代码实现" class="headerlink" title="3.10.2 代码实现"></a>3.10.2 代码实现</h3><pre><code class="c++">#include&lt;vector&gt;#include&lt;map&gt;class Worker &#123;public:    string m_Name;    int m_Salary;&#125;;void createWorker(vector&lt;Worker&gt;&amp; v) &#123;    string nameseed = &quot;ABCDEFGH&quot;;    for (int i = 0; i &lt; nameseed.size(); ++i) &#123;        Worker worker;        worker.m_Name = &quot; 员工 &quot;;        worker.m_Name += nameseed[i];        worker.m_Salary = rand() % 10000 + 10000;        v.push_back(worker);    &#125;&#125;void setGroup(vector&lt;Worker&gt;&amp; v, multimap&lt;int, Worker&gt;&amp; m) &#123;    for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123;        int dpart = rand() % 3 + 1;        m.insert(pair&lt;int, Worker&gt;(dpart, *it));    &#125;&#125;void showWorkerByGroup(multimap&lt;int, Worker&gt;&amp; m) &#123;    for (int i = 1; i &lt; 4; ++i) &#123;        switch (i)        &#123;        case 1:            cout &lt;&lt; &quot; 策划部门员工：&quot; &lt;&lt; endl;            break;        case 2:            cout &lt;&lt; &quot; 美术部门员工：&quot; &lt;&lt; endl;            break;        case 3:            cout &lt;&lt; &quot; 研发部门员工：&quot; &lt;&lt; endl;            break;        default:            break;        &#125;        multimap&lt;int, Worker&gt;::iterator pos = m.find(i);        int num = m.count(i);        int index = 0;        for (; pos != m.end() &amp;&amp; index &lt; num; ++pos, index++) &#123;            cout &lt;&lt; pos-&gt;second.m_Name &lt;&lt; &quot; &quot; &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;        &#125;        cout &lt;&lt; endl;    &#125;&#125;void test1() &#123;    srand((unsigned int)time(NULL));    vector&lt;Worker&gt; vWorker;    createWorker(vWorker);    multimap&lt;int, Worker&gt;mWorker;    setGroup(vWorker, mWorker);    showWorkerByGroup(mWorker);    /*for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); ++it) &#123;        cout &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;    &#125;*/    &#125;</code></pre><h1 id="四、STL- 函数对象"><a href="# 四、STL- 函数对象" class="headerlink" title="四、STL- 函数对象"></a>四、STL- 函数对象 </h1><h2 id="4-1- 函数对象"><a href="#4-1- 函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h2><h3 id="4-1-1- 函数对象概念"><a href="#4-1-1- 函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h3><p> 概念：</p><ul><li>重载函数调用操作符的类，其对象常称为函数对象。</li><li>函数对象使用重载的 () 时，行为类似函数调用，也叫仿函数。</li></ul><p>本质：函数对象（仿函数）是一个类，不是一个函数。</p><h3 id="4-1-2- 函数对象使用"><a href="#4-1-2- 函数对象使用" class="headerlink" title="4.1.2 函数对象使用"></a>4.1.2 函数对象使用 </h3><p> 特点：</p><ul><li><p>函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值</p><pre><code class="c++">// 函数对象（仿函数）class MyAdd &#123;public:    int operator()(int v1, int v2) &#123;        return v1 + v2;    &#125;&#125;;void test1() &#123;    MyAdd add;    int ret = add(10, 20);  // 类对象的调用类似函数    cout &lt;&lt; ret &lt;&lt; endl;&#125;</code></pre></li><li><p>函数对象超出普通函数的概念，函数对象可以有自己的状态</p><pre><code class="c++">class MyPrint &#123;public:    MyPrint() &#123;        this-&gt;count = 0;    &#125;    void operator()(string test) &#123;        cout &lt;&lt; test &lt;&lt; endl;        this-&gt;count++;    &#125;    int count;&#125;;void test1() &#123;    MyPrint print;    print(&quot;hello world&quot;);    print(&quot;hello world&quot;);    print(&quot;hello world&quot;);    cout &lt;&lt; &quot;print 调用次数:&quot; &lt;&lt; print.count &lt;&lt; endl;&#125;</code></pre><blockquote><p>这里仿函数可以记录自己调用的次数</p></blockquote></li><li><p>函数对象可以作为参数传递</p><pre><code class="c++">class MyPrint &#123;public:    MyPrint() &#123;        this-&gt;count = 0;    &#125;    void operator()(string test) &#123;        cout &lt;&lt; test &lt;&lt; endl;        this-&gt;count++;    &#125;    int count;&#125;;void doPrint(MyPrint&amp; mp, string test) &#123;    mp(test);&#125;void test1() &#123;    MyPrint print;    doPrint(print, &quot;Hello C++&quot;);   //here&#125;</code></pre></li></ul><h2 id="4-2- 谓词 Pred"><a href="#4-2- 谓词 Pred" class="headerlink" title="4.2 谓词 Pred"></a>4.2 谓词 Pred</h2><p>返回 bool 类型的仿函数称为谓词:</p><ul><li>如果 operator()接受一个参数，那么就叫一元谓词</li><li>如果 operator()接受两个参数，那么就叫二元谓词</li></ul><pre><code class="c++">#include &lt;vector&gt;#include &lt;algorithm&gt;//1. 一元谓词struct GreaterFive&#123;    bool operator()(int val) &#123;        return val &gt; 5;    &#125;&#125;;void test01() &#123;    vector&lt;int&gt; v;    for (int i = 0; i &lt; 10; i++)    &#123;        v.push_back(i);    &#125;    // 利用 find_if 标准算法    vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());    if (it == v.end()) &#123;        cout &lt;&lt; &quot; 没找到!&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot; 找到:&quot; &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;// 二元谓词class MyCompare&#123;public:    bool operator()(int num1, int num2)    &#123;        return num1 &gt; num2;    &#125;&#125;;void test()&#123;    vector&lt;int&gt; v;    v.push_back(10);    v.push_back(20);    sort(v.begin(), v.end(), MyCompare);&#125;</code></pre><h2 id="4-3- 内建函数对象"><a href="#4-3- 内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h2><h3 id="4-3-1- 基本概念"><a href="#4-3-1- 基本概念" class="headerlink" title="4.3.1 基本概念"></a>4.3.1 基本概念</h3><p>STL 内建了一些函数对象，其中包括：</p><ul><li>算术仿函数</li><li>关系仿函数</li><li>逻辑仿函数</li></ul><p>用法：</p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件<code>#include&lt;functional&gt;</code></li></ul><h3 id="4-3-2- 算术仿函数"><a href="#4-3-2- 算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数 </h3><p><strong> 功能描述：</strong></p><ul><li>实现四则运算</li><li>其中 negate 是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                // 加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              // 减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    // 乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         // 除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         // 取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           // 取反仿函数</li></ul><pre><code class="c++">#include&lt;functional&gt;void test1() &#123;    negate&lt;int&gt; ne;               // 取反    cout &lt;&lt; ne(50) &lt;&lt; endl;    plus&lt;int&gt; p;                  // 加法    cout &lt;&lt; p(10, 20) &lt;&lt; endl;&#125;</code></pre><h3 id="4-3-3- 关系仿函数"><a href="#4-3-3- 关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数 </h3><p><strong> 功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    // 等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            // 不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      // 大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          // 大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           // 小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               // 小于等于</li></ul><pre><code class="c++">#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;functional&gt;void test1() &#123;    vector&lt;int&gt; v;    v.push_back(10);    v.push_back(30);    v.push_back(20);    sort(v.begin(), v.end(), greater&lt;int&gt;());    // 内建的 greater&lt;int&gt;()函数对象，改变默认的排序方式    for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123;        cout &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="4-3-4- 逻辑仿函数"><a href="#4-3-4- 逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数 </h3><p><strong> 功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              // 逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                // 逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              // 逻辑非</li></ul><pre><code class="c++">#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;functional&gt;void test1() &#123;    vector&lt;bool&gt; v;    v.push_back(true);    v.push_back(false);    v.push_back(true);    // 利用逻辑非，将容器 v 搬运到容器 v2 中，并执行取反操作    vector&lt;bool&gt; v2;    v2.resize(v.size());    transform(v.begin(), v.end(), v2.begin(), logical_not&lt;bool&gt;());    for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); ++it) &#123;        cout &lt;&lt; *it &lt;&lt; endl;    &#125;&#125;</code></pre><blockquote><p>此部分内容仅做了解即可，实际使用较少</p></blockquote><h1 id="五、STL 常用算法"><a href="# 五、STL 常用算法" class="headerlink" title="五、STL 常用算法"></a>五、STL 常用算法 </h1><p><strong> 概述</strong>:</p><ul><li><p>算法主要是由头文件 <code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code> 组成。</p></li><li><p><code>&lt;algorithm&gt;</code>是所有 STL 头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p></li><li><p><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</p></li><li><p><code>&lt;functional&gt;</code>定义了一些模板类, 用以声明函数对象。</p></li></ul><h2 id="5-1- 常用遍历算法"><a href="#5-1- 常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法 </h2><p><strong> 算法简介：</strong></p><ul><li><code>for_each</code>     // 遍历容器</li><li><code>transform</code>   // 搬运容器到另一个容器中</li></ul><p>这两个算法包含在 <code>&lt;algorithm&gt;</code> 中。</p><h3 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h3><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator_beg, iterator_end, _func);</code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><pre><code class="c++">#include&lt;algorithm&gt;#include&lt;vector&gt;// 普通函数void print1(int val) &#123;    cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;// 仿函数class print2 &#123;public:    void operator()(int val) &#123;        cout &lt;&lt; val &lt;&lt; &quot; &quot;;    &#125;&#125;;void test1() &#123;    vector&lt;int&gt; v;    v.push_back(10);    v.push_back(30);    v.push_back(20);    v.push_back(40);    for_each(v.begin(), v.end(), print1);  // 传入普通函数，遍历出每个元素     cout &lt;&lt; endl;    for_each(v.begin(), v.end(), print2());  // 传入仿函数()，遍历出每个元素&#125;</code></pre><h3 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h3><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator_beg1, iterator_end1, iterator_beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><pre><code class="c++">#include&lt;algorithm&gt;#include&lt;vector&gt;void print1(int val) &#123;    cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;int trans(int v) &#123;    return v;&#125;void test1() &#123;    vector&lt;int&gt; v;    v.push_back(10);    v.push_back(30);    v.push_back(20);    v.push_back(40);    vector&lt;int&gt; v2;    v2.resize(v.size());  // 先要开辟空间    transform(v.begin(), v.end(), v2.begin(), trans);    for_each(v2.begin(), v2.end(), print1);&#125;</code></pre><h2 id="5-2- 常用查找算法"><a href="#5-2- 常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法 </h2><p><strong> 算法简介：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li><li><p><code>find_if(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回 bool 类型的仿函数）</p></li><li><p><code>adjacent_find(iterator beg, iterator end);</code></p><p>// 查找相邻重复元素, 返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li><li><p><code>bool binary_search(iterator beg, iterator end, value);</code></p><p>// 查找指定的元素，查到 返回 true  否则 false</p><p>// 注意: 在 <strong> 无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li><li><p><code>count(iterator beg, iterator end, value);</code></p><p>// 统计元素出现次数，返回 int 类型数据</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li><li><p><code>count_if(iterator beg, iterator end, _Pred);</code></p><p>// 按条件统计元素出现次数，返回 int 类型数据</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p>一个 <code>find_if</code> 的例子：</p><pre><code class="c++">class Greater30 &#123;public:    bool operator()(int val) &#123;        return val &gt; 30;    &#125;&#125;;void test1() &#123;    vector&lt;int&gt; v;    v.push_back(10);    v.push_back(30);    v.push_back(20);    v.push_back(40);    vector&lt;int&gt;::iterator it=find_if(v.begin(), v.end(), Greater30());    if (it == v.end()) &#123;        cout &lt;&lt; &quot; 没找到 &quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot; 找到 &quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; *it &lt;&lt; endl;  // 输出 30，找到第一个满足条件的即停止查找&#125;</code></pre><h2 id="5-3- 常用排序算法"><a href="#5-3- 常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法 </h2><p><strong> 算法简介：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);</code></p><p>// 排序</p><p>//  beg    开始迭代器</p><p>//  end    结束迭代器</p><p>// _Pred  谓词</p></li><li><p><code>random_shuffle(iterator beg, iterator end);</code></p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是 <strong> 有序的</strong></p><p>// beg1   容器 1 开始迭代器<br>// end1   容器 1 结束迭代器<br>// beg2   容器 2 开始迭代器<br>// end2   容器 2 结束迭代器<br>// dest    目标容器开始迭代器</p></li><li><p><code>reverse(iterator beg, iterator end);</code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><h2 id="5-4- 常用拷贝和替换算法"><a href="#5-4- 常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法 </h2><p><strong> 算法简介：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg  开始迭代器</p><p>// end  结束迭代器</p><p>// dest 目标起始迭代器</p></li><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li><li><p><code>swap(container c1, container c2);</code></p><p>// 互换两个容器的元素</p><p>// c1 容器 1</p><p>// c2 容器 2</p></li></ul><h2 id="5-5- 常用算术生成算法"><a href="#5-5- 常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法 </h2><p><strong> 注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);</code></p><p>// 计算容器元素累计总和，返回总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li><li><p><code>fill(iterator beg, iterator end, value);</code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><h2 id="5-6- 常用集合算法"><a href="#5-6- 常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法 </h2><p><strong> 算法简介：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的交集</p><p>// <strong>注意: 两个集合必须是有序序列</strong></p><p>// beg1 容器 1 开始迭代器 <br>// end1 容器 1 结束迭代器<br>// beg2 容器 2 开始迭代器<br>// end2 容器 2 结束迭代器<br>// dest 目标容器开始迭代器，目标容器开辟空间需要从<strong> 两个容器中取小值</strong></p></li><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的并集</p><p>// <strong>注意: 两个集合必须是有序序列</strong></p><p>// beg1 容器 1 开始迭代器 <br>// end1 容器 1 结束迭代器<br>// beg2 容器 2 开始迭代器<br>// end2 容器 2 结束迭代器<br>// dest 目标容器开始迭代器，目标容器开辟空间需要<strong> 两个容器相加</strong></p></li><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的差集</p><p>// <strong>注意: 两个集合必须是有序序列</strong></p><p>// beg1 容器 1 开始迭代器 <br>// end1 容器 1 结束迭代器<br>// beg2 容器 2 开始迭代器<br>// end2 容器 2 结束迭代器<br>// dest 目标容器开始迭代器，目标容器开辟空间需要从<strong> 两个容器取较大值</strong></p></li></ul><h1 id="六、异常处理"><a href="# 六、异常处理" class="headerlink" title="六、异常处理"></a>六、异常处理</h1><p> 程序有时会遇到运行阶段错误，导致程序无法正常地运行下去，C++ 为此提供了异常处理工具。其基本思想是：函数 A 在执行过程中发现异常时可以不加处理，而只是”拋出一个异常”给 A 的调用者，函数 B 可以选择捕获 A 拋出的异常进行处理，也可以选择置之不理。如果置之不理，这个异常就会被拋给 B 的调用者，以此类推。如果一层层的函数都不处理异常，异常最终会被拋给最外层的 main 函数。main 函数应该处理异常。如果 main 函数也不处理异常，那么程序就会立即异常地中止。</p><h2 id="6-1- 基本的异常处理"><a href="#6-1- 基本的异常处理" class="headerlink" title="6.1 基本的异常处理"></a>6.1 基本的异常处理 </h2><p><strong>1、调用 std::abort() 函数</strong></p><pre><code class="c++">using namespace std;double cal(double a, double b) &#123;    if (a == -b) &#123;        cout &lt;&lt; &quot; 两数之和不可以等于 0&quot; &lt;&lt; endl;        abort();       // 直接调用    &#125;    else &#123;        return 1 / (a + b);    &#125;&#125;</code></pre><p>当运行到 abort()，程序会终止，避免崩溃。</p><p> <strong>2、返回错误码</strong></p><p>可以使用指针 / 引用参数来将值返回给调用程序，并使用函数的返回值来指出成功还是失败。</p><pre><code class="c++">bool cal(double a, double b, double * ans) &#123;    if (a == -b) &#123;        *ans = 0.0;        return false;    &#125;    else &#123;        *ans = 1 / (a + b);        return true;    &#125;&#125;void test1() &#123;    double x, y, ans;    cout &lt;&lt; &quot; 请输入 x，y 的值 &quot; &lt;&lt; endl;    cin &gt;&gt; x &gt;&gt; y;    if (cal(x, y, &amp;ans)) &#123;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;error code 1&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><h2 id="6-2- 异常机制"><a href="#6-2- 异常机制" class="headerlink" title="6.2 异常机制"></a>6.2 异常机制</h2><p>C++ 异常是对程序运行过程中发生异常情况的一种响应，对异常的处理分为 3 个组成部分：</p><ul><li>引发异常</li><li>使用处理程序捕获异常</li><li>使用 try 块</li></ul><p>C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p><p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：</p><p><strong>捕获异常</strong></p><pre><code class="c++">// 捕获异常try &#123;   // 保护代码&#125;catch(ExceptionName e1)&#123;   // 处理 ExceptionName 异常的代码&#125;catch(ExceptionName e2)&#123;   // 处理 ExceptionName 异常的代码&#125;</code></pre><p>如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p><pre><code class="c++">try &#123;&#125;catch (...)&#123;&#125;  // 捕获任何异常</code></pre><p><strong>抛出异常</strong></p><p>我们可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p><pre><code class="c++">double division(int a, int b)&#123;   if(b == 0)   &#123;      throw &quot;Division by zero condition!&quot;;  // 抛出异常   &#125;   return (a/b);&#125;</code></pre><h2 id="6-3- 案例"><a href="#6-3- 案例" class="headerlink" title="6.3 案例"></a>6.3 案例</h2><pre><code class="c++">#include &lt;iostream&gt;using namespace std;double division(int a, int b)&#123;   if(b == 0)   &#123;      throw &quot;Division by zero condition!&quot;;   &#125;   return (a/b);&#125;int main ()&#123;   int x = 50;   int y = 0;   double z = 0;   try &#123;     z = division(x, y);     cout &lt;&lt; z &lt;&lt; endl;   &#125;catch (const char* msg) &#123;     cerr &lt;&lt; msg &lt;&lt; endl;   &#125;   return 0;&#125;</code></pre><p>由于我们抛出了一个类型为字符串数组（”Division by zero condition!”）的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char* 接收。</p><h2 id="6-4- 异常类型"><a href="#6-4- 异常类型" class="headerlink" title="6.4 异常类型"></a>6.4 异常类型</h2><h3 id="6-4-1- 标准异常"><a href="#6-4-1- 标准异常" class="headerlink" title="6.4.1 标准异常"></a>6.4.1 标准异常</h3><p>C++ 提供了一系列标准的异常，定义在 <code>&lt;exception&gt;</code> 中。</p><p>我们可以在程序中使用这些标准的异常。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220210163206236.png" alt=""></p><table><thead><tr><th align="left">异常</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>std::exception</strong></td><td align="left">该异常是所有标准 C++ 异常的父类。</td></tr><tr><td align="left">std::bad_alloc</td><td align="left">该异常可以通过 <strong>new</strong> 抛出。</td></tr><tr><td align="left">std::bad_cast</td><td align="left">该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td></tr><tr><td align="left">std::bad_exception</td><td align="left">这在处理 C++ 程序中无法预期的异常时非常有用。</td></tr><tr><td align="left">std::bad_typeid</td><td align="left">该异常可以通过 <strong>typeid</strong> 抛出。</td></tr><tr><td align="left"><strong>std::logic_error</strong></td><td align="left">理论上可以通过读取代码来检测到的异常。</td></tr><tr><td align="left">std::domain_error</td><td align="left">当使用了一个无效的数学域时，会抛出该异常。</td></tr><tr><td align="left">std::invalid_argument</td><td align="left">当使用了无效的参数时，会抛出该异常。</td></tr><tr><td align="left">std::length_error</td><td align="left">当创建了太长的 std::string 时，会抛出该异常。</td></tr><tr><td align="left">std::out_of_range</td><td align="left">该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td></tr><tr><td align="left"><strong>std::runtime_error</strong></td><td align="left">理论上不可以通过读取代码来检测到的异常。</td></tr><tr><td align="left">std::overflow_error</td><td align="left">当发生数学上溢时，会抛出该异常。</td></tr><tr><td align="left">std::range_error</td><td align="left">当尝试存储超出范围的值时，会抛出该异常。</td></tr><tr><td align="left">std::underflow_error</td><td align="left">当发生数学下溢时，会抛出该异常。</td></tr></tbody></table><p>下面举一个 <code>std::bad_alloc</code> 例子：</p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int main()&#123;    try &#123;        char* p = new char[0x7fffffff];  // 无法分配这么多空间，会抛出异常    &#125;    catch (exception&amp; e) &#123;        cout &lt;&lt; e.what() &lt;&lt; endl;    &#125;    catch (bad_alloc&amp; e) &#123;        cout &lt;&lt; e.what() &lt;&lt; endl;    &#125;    return 0;&#125;// 第 8 行的 catch 捕获到了 bad allocation 输出，第二次 catch 为空（即使就是 bad_alloc 类型的异常）</code></pre><blockquote><p><strong>what()</strong> 是异常类提供的一个公共方法，将返回异常产生的原因</p><p>异常只捕获一次</p></blockquote><h3 id="6-4-2- 自定义异常"><a href="#6-4-2- 自定义异常" class="headerlink" title="6.4.2 自定义异常"></a>6.4.2 自定义异常 </h3><p> 可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;class MyException : public exception&#123;public:    const char* what() const throw ()    &#123;        return &quot;C++ Exception&quot;;    &#125;&#125;;int main()&#123;    try    &#123;        throw MyException();        cout &lt;&lt; &quot;look here&quot; &lt;&lt; endl;    &#125;    catch (MyException&amp; e)    &#123;        cout &lt;&lt; &quot;MyException caught&quot; &lt;&lt; endl;        cout &lt;&lt; e.what() &lt;&lt; endl;    &#125;    catch (exception&amp; e)    &#123;        // 其他的错误    &#125;&#125;/* 输出MyException caughtC++ Exception*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 入门学习笔记</title>
      <link href="/C-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/C-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、工具安装"><a href="# 一、工具安装" class="headerlink" title="一、工具安装"></a>一、工具安装 </h1><p>Microsoft Visual Studio（简称 VS）是美国<a href="https://baike.baidu.com/item/ 微软公司"> 微软公司 </a> 的<a href="https://baike.baidu.com/item/ 开发工具 /10464557">开发工具 </a> 包系列产品。VS 是一个基本 <a href="https://baike.baidu.com/item/ 完整 /32785"> 完整 </a> 的开发工具集，它包括了整个 <a href="https://baike.baidu.com/item/ 软件生命周期 /861455"> 软件生命周期 </a> 中所需要的大部分工具，如 <a href="https://baike.baidu.com/item/UML/446747">UML</a> 工具、代码 <a href="https://baike.baidu.com/item/ 管控 /24264804"> 管控 </a> 工具、<a href="https://baike.baidu.com/item/ 集成开发环境 /298524">集成开发环境 </a>(IDE) 等等。</p><p>社区免费版：<a href="https://visualstudio.microsoft.com/zh-hans/downloads/">https://visualstudio.microsoft.com/zh-hans/downloads/</a></p><p>【编辑器】：纯用来写代码的，如 vim</p><p>【编译器】：将源程序转化为二进制形式的目标程序的工具，如 GCC</p><p>【IDE】：集成了编辑器、编译器以及链接器等众多功能的一个集成开发环境。</p><h1 id="二、基础入门"><a href="# 二、基础入门" class="headerlink" title="二、基础入门"></a>二、基础入门 </h1><h2 id="2-1- 认识 C"><a href="#2-1- 认识 C" class="headerlink" title="2.1 认识 C++"></a>2.1 认识 C++</h2><h3 id="2-1-1- 注释"><a href="#2-1-1- 注释" class="headerlink" title="2.1.1 注释"></a>2.1.1 注释</h3><p> 单行注释：</p><pre><code class="c++">// 注释信息</code></pre><p>多行注释：</p><pre><code class="c++">/*多行注释 1多行注释 2*/</code></pre><h3 id="2-1-2- 变量与常量"><a href="#2-1-2- 变量与常量" class="headerlink" title="2.1.2 变量与常量"></a>2.1.2 变量与常量 </h3><p> 变量：给一段内存起名，方便我们管理内存。</p><pre><code class="c++">// 变量创建   数据类型 变量名 = 变量初始值;int a = 10;</code></pre><p>常量：用于记录程序中不可更改的数据。</p><p>C++ 中定义常量的两种方法：</p><ul><li><strong>宏常量</strong>：<code>#define 常量名 常量值</code> 。通常在文件开头定义。</li><li><strong>const 修饰的常量</strong>：<code>const 数据类型 常量名 = 常量值</code></li></ul><pre><code class="c++">#include&lt;iostream&gt;using namespace std;#define Day 7  // 宏常量int main()&#123;    const int a = 10;   //const 修饰的常量    cout&lt;&lt;Day&lt;&lt;endl;    cout&lt;&lt;a&lt;&lt;endl;    system(&quot;pause&quot;)    return 0;&#125;</code></pre><h3 id="2-1-3- 关键字"><a href="#2-1-3- 关键字" class="headerlink" title="2.1.3 关键字"></a>2.1.3 关键字 </h3><p> 作用：关键字是 C++ 中保留的单词（标识符），在 C++ 中拥有固定的，预设的含义。因此在定义变量 / 常量的时候，禁止使用关键字。</p><table><thead><tr><th>关键字</th><th>关键字</th><th>关键字</th><th>关键字</th><th>关键字</th></tr></thead><tbody><tr><td>asm</td><td>do</td><td>if</td><td>return</td><td>typedef</td></tr><tr><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typeid</td></tr><tr><td>bool</td><td>dynamic</td><td>int</td><td>signed</td><td>typename</td></tr><tr><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr><td>catch</td><td>explict</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td><td></td></tr></tbody></table><h3 id="2-1-4- 标识符命名规则"><a href="#2-1-4- 标识符命名规则" class="headerlink" title="2.1.4 标识符命名规则"></a>2.1.4 标识符命名规则 </h3><p> 作用：C++ 规定给标识符（变量，常量）命名时，有一套自己的规则</p><ul><li>标识符不能是关键字</li><li>标识符只能由字母，数字，下划线组成</li><li>第一个字符必须为字母或者下划线组成</li><li>标识符中字母区分大小写</li></ul><p>给标识符命名时，尽量做到见名知意，方便阅读。</p><h3 id="2-1-5-main- 函数"><a href="#2-1-5-main- 函数" class="headerlink" title="2.1.5 main 函数"></a>2.1.5 main 函数 </h3><p> 在 C++ 中，main 函数为必须的，C++ 程序自动从 main 函数开始执行。</p><h2 id="2-2- 数据类型"><a href="#2-2- 数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h2><p>C++ 在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存。</p><p>可以通过 <code>typeid(变量名).name()</code>查看数据类型。</p><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 <strong>内置</strong>C++ 数据类型：</p><table><thead><tr><th>类型</th><th>关键字</th><th>可加修饰符</th></tr></thead><tbody><tr><td>整型</td><td>int</td><td>signed、unsigned、short、long</td></tr><tr><td>单浮点型</td><td>float</td><td>/</td></tr><tr><td>双浮点型</td><td>double</td><td>long</td></tr><tr><td>字符型</td><td>char</td><td>signed、unsigned</td></tr><tr><td>布尔型</td><td>bool</td><td>/</td></tr><tr><td>无类型</td><td>void</td><td>/</td></tr><tr><td>宽字符型</td><td>wchar_t</td><td>/</td></tr></tbody></table><p>其实 wchar_t 是这样来的：</p><pre><code>typedef short int wchar_t;</code></pre><p>C++ 允许使用速记符号来声明 <strong> 无符号短整数 </strong> 或<strong>无符号长整数</strong>。可以不写 int，只写单词 <strong>unsigned、short</strong> 或 <strong>long</strong>，<strong>int</strong> 是隐含的。</p><ul><li>cout 输出时，默认只输出六位有效数字。可使用 cout.precision(10); 更改为 10 位有效数字。</li></ul><h3 id="2-2-1- 整型"><a href="#2-2-1- 整型" class="headerlink" title="2.2.1 整型"></a>2.2.1 整型 </h3><p> 作用：用于表示整数类型的数据。</p><p>整型类型：</p><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short(短整型)</td><td>2 byte(字节)</td><td>-2^15 – 2^15-1 （-32786–32767）</td></tr><tr><td>int(整型)</td><td>4 byte</td><td>-2^31 – 2^31-1</td></tr><tr><td>long(长整型)</td><td>4 byte (window/linux x32); 8 byte(linux x64)</td><td>-2^31 – 2^31-1</td></tr><tr><td>long long (长长整型)</td><td>8 byte</td><td>-2^63 – 2^63-1</td></tr><tr><td>signed int(有符号整型)</td><td>4 byte</td><td>-2^31 – 2^31-1</td></tr><tr><td>unsigned int(无符号整型)</td><td>4 byte</td><td>0 – 2^32-1</td></tr><tr><td>unsigned short（无符号短整型）</td><td>2 byte</td><td>0~65535</td></tr></tbody></table><p>数据类型存在的意义：给变量分配合适的内存空间，避免造成资源浪费。1byte 字节 =8bit 比特，二进制数系统中，每个 0 或 1 就是一个位(bit)</p><p><strong>MB 与 byte 换算：</strong></p><p>1MB = 1048576byte = 262144 int 类型数据</p><pre><code class="c++">// 一个内存溢出造成数据错误的例子：#include&lt;iostream&gt;using namespace std;#define Day 7int main() &#123;     short a = 33000;    cout &lt;&lt; a &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;// 输出 a 的结果：-32536</code></pre><blockquote><p>利用 sizeof 关键字可以统计数据类型所占的内存空间大小</p><p>语法：sizeof(数据类型) 或者 sizeof(变量名字)</p></blockquote><p>注意：<strong>将一个负数强制转成无符号数，并不是取绝对值的关系：</strong></p><pre><code class="c++">int main()&#123;    int a = -1;    cout &lt;&lt; (unsigned)a &lt;&lt; endl; // 输出 4294967295，即 2^32-1    int b = -10;    cout &lt;&lt; (unsigned)b &lt;&lt; endl;  // 输出 4294967286，即 2^32-10&#125;</code></pre><p><strong>int 类型数据取值范围为什么是 -2^31 – 2^31-1？</strong></p><p>举个例子：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220215174024345.png" style="zoom:80%;" /><p><code>2^(4*8-1)=2^31</code></p><p>因为 0 的源码是:</p><p> 00000000 00000000 00000000 00000000     占了一个位置，所以正整数范围是<code>0-2^31-1</code> 一共是 2^31 个数。</p><p><strong>题外话：</strong></p><p>在计算机中，负数的二进制是用其源码的补码储存的。正数是用其源码直接存储。</p><p>补码：反码加 1 称为补码。</p><p>反码：将二进制源码按位取反。</p><pre><code>111001   源码000110   反码000111   补码 </code></pre><h3 id="2-2-2- 浮点型"><a href="#2-2-2- 浮点型" class="headerlink" title="2.2.2 浮点型"></a>2.2.2 浮点型</h3><p> 作用：用于表示小数。</p><p>浮点型分为两种：</p><ol><li>单精度 float</li><li>双精度 double</li></ol><table><thead><tr><th>数据类型</th><th>占用空间</th><th>有效数字范围</th></tr></thead><tbody><tr><td>float</td><td>4 byte</td><td>7 位有效数字</td></tr><tr><td>double</td><td>8 byte</td><td>15-16 位有效数字</td></tr><tr><td>long double</td><td>16 byte</td><td>18-19 位有效数字</td></tr></tbody></table><pre><code class="c++">//...int main() &#123;    float a = 3.14f;    double b = 3.141592654;    cout &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; b &lt;&lt; endl;    // 科学计数法    float c = 2e5； // 2*10^5    system(&quot;pause&quot;);    return 0;&#125;/* 输出 3.14  3.14159 */</code></pre><p>默认情况下，输出一个小数，最多只能输出 6 位有效数字。</p><h3 id="2-2-3- 字符型"><a href="#2-2-3- 字符型" class="headerlink" title="2.2.3 字符型"></a>2.2.3 字符型 </h3><p> 作用：字符型变量用于显示单个字符</p><p>语法：<code>char ch = &#39;a&#39;</code></p><blockquote><p>在显示字符型变量时，用单引号括起来，不要用双引号。</p><p>单引号内只能有一个字符，不可以是字符串。</p></blockquote><p>C 和 C++ 中，字符型变量只占用 1 个字节</p><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>char</td><td>1byte</td><td>-2^7– 2^7-1</td></tr><tr><td>unsigned char</td><td>1byte</td><td>0–2^8-1</td></tr></tbody></table><p>字符型变量并不是把字符本身放到内存中存储，而是将其对应的 ASCII 编码放到存储单元。</p><pre><code class="c++">//...int main() &#123;    char ch = &#39;a&#39;;    char ch2 = &#39;A&#39;;    cout &lt;&lt; (int)ch &lt;&lt; endl;    // 输出 97    cout &lt;&lt; (int)ch2 &lt;&lt; endl;   // 输出 65    system(&quot;pause&quot;);    return 0;&#125;// 输出 97  65</code></pre><p>1MB = 1048576byte = 1048576 char 类型数据</p><h3 id="2-2-4- 布尔类型 bool"><a href="#2-2-4- 布尔类型 bool" class="headerlink" title="2.2.4 布尔类型 bool"></a>2.2.4 布尔类型 bool</h3><p>作用：布尔类型代表真或假</p><p>布尔类型只有两个值：</p><ul><li>true — 真（本质是 1）</li><li>false — 假 （本质是 0）</li></ul><p>布尔类似只占用 1 个字节。</p><h3 id="2-2-5- 转义字符"><a href="#2-2-5- 转义字符" class="headerlink" title="2.2.5 转义字符"></a>2.2.5 转义字符 </h3><p> 作用：用于表示一些不能显示出来的 ASCII 字符，如一些表示格式的字符。反斜杠 \</p><p>现阶段我们常用的转义字符<code>\n \\ \t</code>。</p><h3 id="2-2-6- 字符串"><a href="#2-2-6- 字符串" class="headerlink" title="2.2.6 字符串"></a>2.2.6 字符串 </h3><p> 作用：用于表示一串字符</p><p>两种风格：</p><ol><li><p>C 风格字符串：<code>char 变量名[] = &quot;abcd&quot;</code></p><pre><code class="c++">char ch[] = &#123; &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39;&#125;;   // 必须加结尾符 \0cout &lt;&lt; ch &lt;&lt; endl;                // 输出 abc，为字符串数组,char ch2[] = &quot;abc&quot;;cout &lt;&lt; ch2 &lt;&lt; endl;       // 输出 abc</code></pre></li><li><p>C++ 风格字符串：<code>string 变量名 = “abcd”</code></p></li></ol><p>如果要使用 C++ 风格字符串，需要加头文件: <code>#include&lt;string&gt;</code></p><p>在 C++ 中，字符串类型本质是一个容器类。</p><p>字符串以 <code>\0</code> 字符结尾。</p><pre><code class="c++">int main()&#123;    char c[] = &#123; &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;\0&#39;&#125;;    cout &lt;&lt; strlen(c) &lt;&lt; endl;  // 输出 4    cout &lt;&lt; sizeof(c) &lt;&lt; endl;  // 输出 5    string a = &quot;abcd&quot;;    cout &lt;&lt; sizeof(a) &lt;&lt; endl;  // 输出 28，字符串 a 本质是一个类    cout &lt;&lt; a.length() &lt;&lt; endl;  // 输出 4&#125;</code></pre><p>为了节省内存和方便，定义字符串的时候，可以采用这种方法：</p><pre><code class="c++">char ch2[] = &quot;abcd&quot;;cout &lt;&lt; sizeof(ch2) &lt;&lt; endl;  // 输出 5</code></pre><p>相比 <code>string a = &quot;abcd&quot;;</code> 节省了空间，不过 string 提供很多方法可供使用，后面容器部分会有详细介绍。这里先介绍 C 风格字符串的方法：</p><p><strong>C 风格字符串的方法：</strong></p><table><thead><tr><th align="left">函数</th><th align="left">目的</th></tr></thead><tbody><tr><td align="left">strcpy(s1, s2);</td><td align="left">复制字符串 s2 到字符串 s1</td></tr><tr><td align="left">strcat(s1, s2);</td><td align="left">连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 <strong>+</strong> 号</td></tr><tr><td align="left">strlen(s1);</td><td align="left">返回字符串 s1 的长度。</td></tr><tr><td align="left">strcmp(s1, s2);</td><td align="left">如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td></tr><tr><td align="left">strchr(s1, ch);</td><td align="left">返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td align="left">strstr(s1, s2);</td><td align="left">返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><h3 id="2-2-7- 进制"><a href="#2-2-7- 进制" class="headerlink" title="2.2.7 进制"></a>2.2.7 进制</h3><table><thead><tr><th>进制</th><th>标识符</th><th>示例</th></tr></thead><tbody><tr><td>二进制（0 和 1 组成）</td><td>0b 或者 0B</td><td>0b101=5(十进制)</td></tr><tr><td>八进制（0-7 组成）</td><td>0</td><td>0555=365(十进制)</td></tr><tr><td>十六进制（0-9，A-F 组成）</td><td>0x 或者 0X</td><td>0x10F=271(十进制)</td></tr></tbody></table><p>转换成十进制的换算方法：</p><p><code>0555 = 5*8^2 + 5*8^1 + 5*8^0 = 365</code></p><p><code>0x10F = 1*16^2 + 0*16^1 + 15*16^0 = 271</code>    注意：F 代表 15， A 代表 10</p><p>总结 ：第 <strong>i</strong> 位数乘以 <strong> 进制的 (i-1) 次方 </strong> + 第<strong>i-1</strong> 位数乘以 <strong> 进制的 (i-1-1) 次方 </strong> + … + 第 1 位数乘以进制的(1-1) 次方。</p><hr><p><strong>利用计算机程序进行进制转换：</strong></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;bitset&gt;int main()&#123;    int a = 60;    cout &lt;&lt; (bitset&lt;10&gt;)a &lt;&lt; endl;  // 二进制需要用到 bitset 库， 这里的 10 是输出二进制的位数，输出 10 位二进制数    cout &lt;&lt; oct &lt;&lt; a &lt;&lt; endl;       // 八进制输出    cout &lt;&lt; hex &lt;&lt; a &lt;&lt; endl;       // 十六进制输出&#125;/*0000111100743c*/</code></pre><h3 id="2-2-8-auto 关键字"><a href="#2-2-8-auto 关键字" class="headerlink" title="2.2.8 auto 关键字"></a>2.2.8 auto 关键字</h3><p>C++11 引入了 auto 和 decltype 关键字实现类型推导，通过这两个关键字不仅能方便地获取复杂的类型，而且还能简化书写，提高编码效率。</p><pre><code>auto x = 5;                      // OK: x 是 int 类型auto pi = new auto(1);           // OK: pi 被推导为 int*const auto *v = &amp;x, u = 6;       // OK: v 是 const int* 类型，u 是 const int 类型static auto y = 0.0;             // OK: y 是 double 类型auto int r;                      // error: auto 不再表示存储类型指示符auto s;                          // error: auto 无法推导出 s 的类型</code></pre><p>auto 并不能代表一个实际的类型声明，只是一个类型声明的“占位符”。使用 auto 声明的变量必须马上初始化，以让编译器推断出它的实际类型，并在编译时将 auto 占位符替换为真正的类型。</p><p><strong>但是 auto 使用是有限制的：</strong></p><ul><li><p>auto 变量必须在定义时初始化，这类似于 const 关键字。</p></li><li><p>定义在一个 auto 序列的变量必须始终推导成同一类型。</p><pre><code>auto a4 = 10, a5 = 20, a6 = 30;   //a4 a5 a6 必须为同一类型</code></pre></li><li><p>如果初始化表达式是引用，则去除引用语义。</p><pre><code>int a = 10;int &amp;b = a;auto c = b;//c 的类型为 int 而非 int&amp;（去除引用）auto &amp;d = b;// 此时 c 的类型才为 int&amp;</code></pre></li><li><p>如果初始化表达式为 const 或 volatile（或者两者兼有），则除去 const/volatile 语义。</p><pre><code>const int a1 = 10;auto  b1= a1; //b1 的类型为 int 而非 const int（去除 const）const auto c1 = a1;// 此时 c1 的类型为 const intb1 = 100;// 合法c1 = 100;// 非法</code></pre></li><li><p>如果 auto 关键字带上 &amp; 号，则不去除 const 语意。</p><pre><code>const int a2 = 10;auto &amp;b2 = a2;// 因为 auto 带上 &amp;，故不去除 const，b2 类型为 const intb2 = 10; // 非法</code></pre></li><li><p>初始化表达式为数组时，auto 关键字推导类型为指针。</p><pre><code>int a3[3] = &#123; 1, 2, 3 &#125;;auto b3 = a3;</code></pre></li><li><p>若表达式为数组且 auto 带上 &amp;，则推导类型为数组类型。</p><pre><code>int a7[3] = &#123; 1, 2, 3 &#125;;auto &amp; b7 = a7;</code></pre></li><li><p>函数或者模板参数不能被声明为 auto</p><pre><code>void func(auto a)&#123;&#125;  // 错误</code></pre></li><li><p>时刻要注意 auto 并不是一个真正的类型。<br>auto 仅仅是一个占位符，它并不是一个真正的类型，不能使用一些以类型为操作数的操作符，如 sizeof 或者 typeid。</p></li></ul><h3 id="2-2-9- 数据类型转换"><a href="#2-2-9- 数据类型转换" class="headerlink" title="2.2.9 数据类型转换"></a>2.2.9 数据类型转换 </h3><p><strong> 字符串转整型</strong>：比如将“123” 转成 123   –&gt;  <code>std::stoi(str) = intStr</code></p><p>字符串转单精度：比如将“123.22” 转成 123.22   –&gt;    <code>std::stof(str) = floatStr</code></p><p>字符串转双精度：比如将“123.22121” 转成 123.22121   –&gt;    <code>std::stod(str) = doubleStr</code></p><p>数值转字符串：比如将 123.11 转成字符串“123.11”   –&gt;   <code>std::to_string(int) = str</code></p><h2 id="2-3- 算术运算"><a href="#2-3- 算术运算" class="headerlink" title="2.3 算术运算"></a>2.3 算术运算 </h2><h3 id="2-3-1- 输入与输出"><a href="#2-3-1- 输入与输出" class="headerlink" title="2.3.1 输入与输出"></a>2.3.1 输入与输出</h3><p> 关键字：<code>cin</code>输入    <code>cout</code>输出</p><pre><code class="c++">//...int main() &#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p>计算机怎么知道你终端输入是否完成呢？</p><p><strong>cin 以空格为结束符</strong></p><p><strong>cin.getline()</strong> 以换行符（回车键）为结束，但它不保存换行符，在存储字符串时，它用空字符代替换行符（存储换行符为空字符）</p><p><strong>cin.get()</strong> 以换行符（回车键）为结束，它读取到换行符的前一个字符，此时换行符仍在输入队列中。</p><pre><code class="c++">cin.get(name, mSize)  // 读取输入保存 mSize 个字符到 name 中cin.get(diss, mSize)  // 第二次调用 cin.get 时首先就看到换行符，故它什么都读取不到就结束了</code></pre><p>cin.get()有另一种变体来处理换行符：</p><pre><code class="c++">cin.get(name, mSize)  cin.get()     //  读取下一个字符，包括换行符，可以有返回值cin.get(diss, mSize) </code></pre><ul><li>cout 默认输出六位有效数字，可使用 cout.precision(10); 更改为 10 位。</li></ul><h3 id="2-3-2- 算术运算符"><a href="#2-3-2- 算术运算符" class="headerlink" title="2.3.2 算术运算符"></a>2.3.2 算术运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">把两个操作数相加</td><td align="left">10 + 20 将得到 30</td></tr><tr><td align="left">-</td><td align="left">从第一个操作数中减去第二个操作数</td><td align="left">10 - 20  将得到 -10</td></tr><tr><td align="left">*</td><td align="left">把两个操作数相乘</td><td align="left">10 * 20  将得到 200</td></tr><tr><td align="left">/</td><td align="left">除数</td><td align="left">10 / 20.0 将得到 0.5</td></tr><tr><td align="left">%</td><td align="left">取模运算符，整除后的余数</td><td align="left">10 % 20 将得到 10</td></tr><tr><td align="left">++</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html">自增运算符</a>，整数值增加 1</td><td align="left">10++ 将得到 11</td></tr><tr><td align="left">–</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html">自减运算符</a>，整数值减少 1</td><td align="left">10– 将得到 9</td></tr></tbody></table><h3 id="2-3-3- 关系运算符"><a href="#2-3-3- 关系运算符" class="headerlink" title="2.3.3 关系运算符"></a>2.3.3 关系运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">称为逻辑与运算符。如果两个操作数都 true，则条件为 true。</td></tr><tr><td align="left">||</td><td align="left">称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。</td></tr><tr><td align="left">!</td><td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。</td></tr></tbody></table><h3 id="2-3-4- 位运算符"><a href="#2-3-4- 位运算符" class="headerlink" title="2.3.4 位运算符"></a>2.3.4 位运算符 </h3><p> 位运算符作用于位，并逐位执行操作。对两个数的二进制数的每一位进行位运算。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与操作，按二进制位进行”与”运算。运算规则：<br /><code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td><td align="left">二进制(100&amp; 001) 将得到 000</td></tr><tr><td align="left">|</td><td align="left">按位或运算符，按二进制位进行”或”运算。运算规则：<br />`0</td><td align="left">0=0;    0</td></tr><tr><td align="left">^</td><td align="left">异或运算符，按二进制位进行”异或”运算，相同得 0。运算规则：<br /><code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td><td align="left">二进制(100 ^ 001) 将得到 101</td></tr><tr><td align="left">~</td><td align="left">取反运算符，按二进制位进行”取反”运算。运算规则：<br /><code>~1=0;    ~0=1;</code></td><td align="left">二进制(~000100) 将得到 111011</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补 0）。</td><td align="left">二进制 000101&lt;&lt; 2 将得到 010100</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补 0，负数左补 1，右边丢弃。</td><td align="left">二进制 000101 &gt;&gt; 2 将得到 000001</td></tr></tbody></table><p><strong>位运算的作用：</strong></p><ul><li><p><strong>&amp; 按位与</strong></p><ul><li><p>快速清零</p><pre><code class="c++">int a=0x0011;a&amp;=0;        //a = 0x0011 &amp; 0x0000 = 0x0000</code></pre></li><li><p>判断奇偶</p><p>奇数的二进制末尾一定是 1；偶数的二进制末尾一定是 0。</p><pre><code class="c++">int a = 2;int b = 3;a = a&amp;1;   //a 结果为 0，偶数为 0b = b&amp;1;   //b 结果为 1，奇数为 1</code></pre></li></ul></li><li><p><strong>| 按位或</strong></p><ul><li><p>设定指定位的数据</p><pre><code>int a=0x0001;int b=0x0010;int c=a|b;  //c: 0x0011</code></pre></li></ul></li><li><p><strong>^ 按位异或</strong></p><ul><li><p>交换数值</p><pre><code class="c++">int main()&#123;    int a = 32;    int b = 34;    a = a ^ b;    b = b ^ a;    a = a ^ b;    cout &lt;&lt; a &lt;&lt; endl;  // a:34    cout &lt;&lt; b &lt;&lt; endl;  // b:32&#125;</code></pre></li></ul></li><li><p><strong>&lt;&lt; 和 &gt;&gt; 左移和右移</strong></p><ul><li><p><code>m &lt;&lt; n</code> 等于<code>m*2^n</code>。</p><pre><code class="c++">int main()&#123;    int m = 32;    int n = 3;    if (m &lt;&lt; n == m * pow(2, n)) &#123;        cout &lt;&lt; &quot;True&quot; &lt;&lt; endl;    &#125;&#125;// 输出 True</code></pre></li><li><p><code>m &gt;&gt; n</code> 等于<code>floor(m/(2^n))</code>。</p><p>当 m 为负数，情况就不一样了</p><pre><code class="c++">int main()&#123;    int m = -31;    int n = 3;    int c = m &gt;&gt; n;    cout &lt;&lt; c &lt;&lt; endl;    // 输出 -4    double d = m / pow(2, n);       cout &lt;&lt; d &lt;&lt; endl;    // 输出 -3.875  floor(-3.875) = -4&#125;</code></pre></li></ul></li></ul><h3 id="2-3-5- 赋值运算符"><a href="#2-3-5- 赋值运算符" class="headerlink" title="2.3.5 赋值运算符"></a>2.3.5 赋值运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td></tr><tr><td align="left">+=</td><td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td></tr><tr><td align="left">-=</td><td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td></tr><tr><td align="left">*=</td><td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td></tr><tr><td align="left">/=</td><td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td></tr><tr><td align="left">%=</td><td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td></tr><tr><td align="left">&lt;&lt;=</td><td align="left">左移且赋值运算符</td></tr><tr><td align="left">&gt;&gt;=</td><td align="left">右移且赋值运算符</td></tr><tr><td align="left">&amp;=</td><td align="left">按位与且赋值运算符</td></tr><tr><td align="left">^=</td><td align="left">按位异或且赋值运算符</td></tr><tr><td align="left">|=</td><td align="left">按位或且赋值运算符</td></tr></tbody></table><h3 id="2-3-6- 杂项运算符"><a href="#2-3-6- 杂项运算符" class="headerlink" title="2.3.6 杂项运算符"></a>2.3.6 杂项运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">sizeof</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-sizeof-operator.html">sizeof 运算符 </a> 返回变量所占空间的大小。例如，sizeof(a) 将返回 4，其中 a 是整数 int。</td></tr><tr><td align="left">Condition ? X : Y</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-conditional-operator.html">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td></tr><tr><td align="left">,</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-comma-operator.html">逗号运算符 </a> 会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td></tr><tr><td align="left">.（点）和 -&gt;（箭头）</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-member-operators.html">成员运算符 </a> 用于引用类、结构和共用体的成员。</td></tr><tr><td align="left">Cast</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-casting-operators.html">强制转换运算符 </a> 把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td></tr><tr><td align="left">&amp;</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 &amp;</a> 返回变量的地址。例如 &a; 将给出变量的实际地址。</td></tr><tr><td align="left">*</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td></tr></tbody></table><h3 id="2-3-7- 类型转换"><a href="#2-3-7- 类型转换" class="headerlink" title="2.3.7 类型转换"></a>2.3.7 类型转换 </h3><p> 在 C++ 中，表达式中包含不同的数据类型，C++ 将对其值进行转换。</p><pre><code class="c++">int main()&#123;    int a = 10;    double b = 10.0;    if (a == b) &#123;        cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;    &#125;&#125;</code></pre><p>上述结果会输出：true</p><p>这里的等于判断，只会判断数值是否相等。不判断数据类型。</p><h2 id="2-4- 程序流结构"><a href="#2-4- 程序流结构" class="headerlink" title="2.4 程序流结构"></a>2.4 程序流结构</h2><p>C/C++ 支持最基本的三种程序运行结构，顺序结构；选择结构；循环结构。</p><ul><li>顺序结构：程序按照顺序执行，不发生跳转</li><li>选择结构：依据条件是否满足，有选择的执行相应功能</li><li>循环结构：依据条件是否满足，循环多次执行某段代码</li></ul><h3 id="2-4-1- 选择结构"><a href="#2-4-1- 选择结构" class="headerlink" title="2.4.1 选择结构"></a>2.4.1 选择结构</h3><ul><li><p>if 语句</p><ul><li><p>单行格式 if 语句</p><pre><code class="c++">if (条件)&#123;   // 满足条件代码块&#125;;</code></pre></li><li><p>多行格式 if 语句</p><pre><code class="c++">if (条件)&#123;   // 满足条件代码块&#125;else&#123;   // 不满足条件代码块&#125;</code></pre></li><li><p>多条件的 if 语句</p><pre><code class="c++">if (条件)&#123;   // 满足条件代码块&#125;else if (条件)&#123;   // 不满足条件代码块&#125;else &#123;   // 不满足条件代码块&#125;</code></pre></li></ul></li><li><p>三目运算符</p><p>语法：<code>表达式 1？表达式 2：表达式 3</code> 。解释：如果表达式 1 为真，则执行表达式 2，否则执行表达式 3</p></li><li><p>switch 语句</p><pre><code class="c++">switch(表达式)&#123;  case 结果 1：执行语句 1；break;  case 结果 2：执行语句 2；break;  case 结果 3：执行语句 3；break;  default: 执行语句 3；break;&#125;</code></pre></li></ul><h2 id="2-5- 循环结构"><a href="#2-5- 循环结构" class="headerlink" title="2.5 循环结构"></a>2.5 循环结构 </h2><p> 作用：满足条件，反复执行某段代码。</p><h3 id="2-5-1-while 循环"><a href="#2-5-1-while 循环" class="headerlink" title="2.5.1 while 循环"></a>2.5.1 while 循环</h3><pre><code class="c++">while(条件)&#123;   // 满足条件执行&#125;</code></pre><p>一个猜数字的例子：</p><pre><code class="c++">int main() &#123;    srand((unsigned int)time(NULL));  // 随机种子，避免每次都是一样的随机数    int a = rand() % 100; // 随机生成 0-99 的随机数;    int var;    while (1) &#123;        cin &gt;&gt; var;        if (var &gt; a) &#123;            cout &lt;&lt; &quot; 猜测过大 &quot; &lt;&lt; endl;        &#125;        else if (var &lt; a) &#123;            cout &lt;&lt; &quot; 猜测过小 &quot; &lt;&lt; endl;        &#125;        else &#123;            cout &lt;&lt; &quot; 恭喜猜对了 &quot; &lt;&lt; endl;            break;  // 可以利用 break 关键字退出循环        &#125;    &#125;    system(&quot;pause&quot;);&#125;</code></pre><h3 id="2-5-2-do-while- 循环"><a href="#2-5-2-do-while- 循环" class="headerlink" title="2.5.2 do while 循环"></a>2.5.2 do while 循环</h3><pre><code class="c++">do &#123;   // 执行一次&#125;while (条件)；</code></pre><p>案例—水仙花数：</p><p>水仙花数是指一个 3 位数，它的每个位的数字的 3 次之幂之和等于它本身</p><p>例如：1^3 + 5^3 + 3^3 = 153</p><p>利用 do while 循环，求出所有 3 位数中的水仙花数。</p><pre><code class="c++">int main() &#123;    int A = 100;    int a, b, c;    do&#123;        a = A / 100;        b = (A - a * 100) / 10;        c = (A - a * 100 - b * 10);        if (a*a*a + b*b*b + c*c*c == A) &#123;            cout &lt;&lt; A &lt;&lt; endl;        &#125;        A++;    &#125; while (A &lt; 1000);    system(&quot;pause&quot;);&#125;// 输出 153 370 371 407</code></pre><blockquote><p>注意：C++ 中不能用 ^ 表示幂指数，^ 是位异或的意思。</p></blockquote><h3 id="2-5-3-for- 循环"><a href="#2-5-3-for- 循环" class="headerlink" title="2.5.3 for 循环"></a>2.5.3 for 循环 </h3><p> 作用：满足循环条件，执行循环语句。</p><p>语法：<code>for(起始表达式；条件表达式；末尾循环体)&#123; 循环语句 &#125;</code></p><pre><code class="c++">for(int i=0; i&lt;10; i++)&#123;   cout &lt;&lt; i &lt;&lt;endl;&#125;</code></pre><p><strong>在 C++ 中，for 循环有了一个新用法</strong>：<code>for(接受数据的变量名：容器)&#123;&#125;</code></p><pre><code class="c++">int arr[] = &#123;0,1,2,3,4,5&#125;;for (int n : arr) &#123;    cout &lt;&lt; n &lt;&lt; &quot; &quot;;         // 输出 1 2 3 4 5 6&#125;cout &lt;&lt; endl;</code></pre><h3 id="2-5-4- 嵌套循环"><a href="#2-5-4- 嵌套循环" class="headerlink" title="2.5.4 嵌套循环"></a>2.5.4 嵌套循环</h3><pre><code class="C++">int main() &#123;    for (int i = 0; i &lt; 10; i++) &#123;        for (int j = 0; j &lt; 10; j++) &#123;            cout &lt;&lt; &quot;* &quot;;        &#125;        cout &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);&#125;</code></pre><h2 id="2-6- 跳转语句"><a href="#2-6- 跳转语句" class="headerlink" title="2.6 跳转语句"></a>2.6 跳转语句 </h2><h3 id="2-6-1-break- 语句"><a href="#2-6-1-break- 语句" class="headerlink" title="2.6.1 break 语句"></a>2.6.1 break 语句</h3><p> 作用：用于跳出选择结构或者循环结构。一碰到 break 关键词就 <strong> 跳出当前循环</strong>。</p><p>break 使用时机：</p><ul><li>出现 switch 条件语句中，作用是终止 case 并跳出 switch</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul><h3 id="2-6-2-continue- 语句"><a href="#2-6-2-continue- 语句" class="headerlink" title="2.6.2 continue 语句"></a>2.6.2 continue 语句 </h3><p> 作用：在循环语句中，跳出本次循环中余下未执行的语句，<strong>继续执行下一次循环</strong>。</p><pre><code class="c++">int main() &#123;    for (int i = 0; i &lt; 10; i++) &#123;        if (i % 2 == 0) &#123;            continue;  // 可以筛选条件，执行到此后面的 cout i 就不再执行        &#125;        cout &lt;&lt; i &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);&#125;// 输出 1 3 5 7 9</code></pre><h3 id="2-6-3-goto- 语句"><a href="#2-6-3-goto- 语句" class="headerlink" title="2.6.3 goto 语句"></a>2.6.3 goto 语句 </h3><p> 作用：可以无条件跳转语句。如果标记名词存在，执行到 goto 语句时，会跳转到标记位置。</p><p>语法：<code>goto 标记</code></p><pre><code class="c++">int main() &#123;    cout &lt;&lt; &quot;1. XXXXX&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;2. XXXXX&quot; &lt;&lt; endl;    goto FLAG;    cout &lt;&lt; &quot;3. XXXXX&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;4. XXXXX&quot; &lt;&lt; endl;    FLAG:    cout &lt;&lt; &quot;5. XXXXX&quot; &lt;&lt; endl;    system(&quot;pause&quot;);&#125;/* 输出1. XXXXX2. XXXXX5. XXXXX*/</code></pre><h2 id="2-7- 数组"><a href="#2-7- 数组" class="headerlink" title="2.7 数组"></a>2.7 数组 </h2><p> 所谓数组，就是几个集合，里面存放了相同类型的数据类型。</p><ul><li>数组中每一个数据元素都是相同的数据类型</li><li>数组是由连续的内存位置组成</li></ul><h3 id="2-7-1- 创建数组"><a href="#2-7-1- 创建数组" class="headerlink" title="2.7.1 创建数组"></a>2.7.1 创建数组</h3><pre><code class="c++">// 第一种定义方式int arr[3];  // 声明数组arr[0] = 1;  // 赋值arr[1] = 2;arr[2] = 3;// 第二种定义方式int arr2[5] = &#123; 1,2,3 &#125;;for (int i = 0; i &lt; 5; i++) &#123;     cout &lt;&lt; arr2[i] &lt;&lt; endl;&#125;/* 输出 1 2 3 0 0 */ // 第三种定义方式int arr3[] = &#123; 1,2,3,4 &#125;;</code></pre><h3 id="2-7-2- 一维数组"><a href="#2-7-2- 一维数组" class="headerlink" title="2.7.2 一维数组"></a>2.7.2 一维数组 </h3><p> 一维数组名称的用途：</p><ul><li><p>获取数组的长度</p></li><li><p>获取数组在内存中的首地址</p></li></ul><pre><code class="c++">int arr[] = &#123; 1,2,3,4 &#125;;cout &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; endl;   // 输出数组长度cout &lt;&lt; arr &lt;&lt; endl;  // 输出数组的首地址cout &lt;&lt; &amp;arr[0] &lt;&lt; endl;  // 输出数组第一个元素的地址</code></pre><blockquote><p>&amp; 是取址符</p></blockquote><p><strong>练习案例 - 小猪称体重</strong>： 在一个数组中记录了五只小猪的体重，找出并打印最重的小猪的体重。</p><pre><code class="c++">int main() &#123;    int pigs[] = &#123;250,380,129,566,412&#125;;    int max = pigs[0];  // 假设第一个值最大    for (int i = 1; i &lt; (sizeof(pigs) / sizeof(pigs[0])); i++) &#123;        if (pigs[i]&gt;max) &#123;            max = pigs[i];        // 逐一比较，更新最大值        &#125;    &#125;    cout &lt;&lt;&quot; 最大的数值为：&quot; &lt;&lt; max &lt;&lt; endl;    system(&quot;pause&quot;);&#125;</code></pre><p><strong>练习案例 - 元素逆置</strong>：将一个数组里的元素逆置，并输出逆置后的结果。</p><pre><code class="c++">int main() &#123;    int a[] = &#123;1,2,3,4,5,6&#125;;    int start = 0;    int end = sizeof(a) / sizeof(a[0]) -1;    int temp;    while(start &lt; end)&#123;            temp = a[start];            a[start] = a[end];            a[end] = temp;            start++;            end--;        &#125;    for (int i = 0; i &lt; sizeof(a) / sizeof(a[0]); i++) &#123;        cout &lt;&lt; a[i]&lt;&lt;endl;    &#125;    system(&quot;pause&quot;);&#125;</code></pre><h3 id="2-7-3- 冒泡排序"><a href="#2-7-3- 冒泡排序" class="headerlink" title="2.7.3 冒泡排序"></a>2.7.3 冒泡排序 </h3><p> 冒泡排序算法是最常用的算法，对数组内元素进行排序</p><ol><li>比较相邻元素，如果第一个比第二个大，就交换它们两个</li><li>对每一对相邻的元素做同样的工作，执行完毕后，找到第一个最大值。</li><li>重复以上的步骤，每次比较次数减一，直到不需要比较。</li></ol><pre><code class="c++">int main() &#123;    int a[] = &#123;4,2,8,0,5,7,1,3,9&#125;;    int len = sizeof(a) / sizeof(a[0]);    int temp;    // 排序轮数    for (int i = 0; i &lt; len-1; i++) &#123;        // 每轮对比次数        for (int j = 0; j &lt; len-i-1; j++) &#123;            if (a[j] &gt; a[j+1]) &#123;                temp = a[j+1];                a[j+1] = a[j];                a[j] = temp;            &#125;        &#125;    &#125;    for (int i = 0; i &lt; len; i++) &#123;        cout &lt;&lt; a[i] &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);&#125;</code></pre><h3 id="2-7-4- 二维数组"><a href="#2-7-4- 二维数组" class="headerlink" title="2.7.4 二维数组"></a>2.7.4 二维数组 </h3><p> 二维数组定义的四种方式：</p><ul><li><code>数据类型 数组名[行数][列数];</code></li><li><code>数据类型 数组名[行数][列数] = &#123;&#123; 数据 1, 数据 2&#125;,&#123; 数据 3, 数据 4&#125;&#125;;</code></li><li><code>数据类型 数组名[行数][列数] = &#123; 数据 1, 数据 2, 数据 3, 数据 4&#125;;</code></li><li><code>数据类型 数组名[][列数] = &#123; 数据 1, 数据 2, 数据 3, 数据 4&#125;;</code></li></ul><blockquote><p>建议采用第二种，更加直观。</p></blockquote><pre><code class="c++">int arr[2][3] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125; &#125;;cout &lt;&lt; sizeof(arr) &lt;&lt; endl;   // 输出数组所占内存空间大小cout &lt;&lt; sizeof(arr[0]) &lt;&lt; endl;   // 输出数组第一行所占内存空间大小int row = sizeof(arr)/sizeof(arr[0]);             // 行数int col = sizeof(arr[0])/sizeof(arr[0][0]);       // 列数cout &lt;&lt; arr &lt;&lt; endl;  // 输出数组的首地址cout &lt;&lt; &amp;arr[0][0] &lt;&lt; endl;  // 输出数组第一个元素的地址cout &lt;&lt; arr[0]&lt;&lt; endl;  // 输出数组第一行的首地址cout &lt;&lt; arr[1]&lt;&lt; endl;  // 输出数组第二行的首地址</code></pre><h2 id="2-8- 函数"><a href="#2-8- 函数" class="headerlink" title="2.8 函数"></a>2.8 函数 </h2><h3 id="2-8-1- 函数概述"><a href="#2-8-1- 函数概述" class="headerlink" title="2.8.1 函数概述"></a>2.8.1 函数概述</h3><p> 作用：将一段经常使用的代码封装起来，减少代码重复</p><p>函数的定义一般主要由 5 个步骤：</p><ol><li>返回值类型</li><li>函数名</li><li>参数列表</li><li>函数体语句</li><li>return 表达式</li></ol><pre><code class="c++">/*返回值类型 函数名（参数列表）&#123;    // 函数体语句;    return 表达式&#125;*/void swap(int a, int b) &#123;      // 这里 a,b 均为形参    int temp;    temp = b;    b = a;    a = temp;&#125;int main() &#123;    int a = 10;    int b = 20;                   swap(a, b);   // 这里 a,b 均为实参    cout &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; b &lt;&lt; endl;    return 0;  // 可省略    system(&quot;pause&quot;);&#125;// 输出 a,b 为 10,20</code></pre><blockquote><p>如果函数不需要返回值，声明函数的时候可以写<strong>void</strong>。</p><p>当我们在做值传递的时候，函数的形参发生改变，不会影响实参。</p></blockquote><h3 id="2-8-2- 函数的声明"><a href="#2-8-2- 函数的声明" class="headerlink" title="2.8.2 函数的声明"></a>2.8.2 函数的声明 </h3><p> 由于 C++ 编译器的特点，main 函数一定要位于其调用其他函数的后面。在实际使用过程中，会常将定义的函数在开头做一个声明，从而不用将函数体定义在 main 函数的前面。</p><pre><code class="c++">int get_max(int a, int b);  // 函数的声明，提前告诉编译器有这个函数int main() &#123;    int a = 10;    int b = 25;    cout &lt;&lt; get_max(a, b) &lt;&lt; endl;    return 0;  // 可省略    system(&quot;pause&quot;);&#125;// 函数的定义int get_max(int a, int b) &#123;         return a &gt; b ? a : b;&#125;</code></pre><blockquote><p>函数可以声明写多次，定义只能写一次。</p></blockquote><h3 id="2-8-3- 函数的分文件编写"><a href="#2-8-3- 函数的分文件编写" class="headerlink" title="2.8.3 函数的分文件编写"></a>2.8.3 函数的分文件编写 </h3><p> 作用：让代码结构更加清晰。</p><p>函数分文件编写一般有四个步骤：</p><ol><li>创建后缀名为.h 的头文件</li><li>创建后缀名为.cpp 的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义，并链接头文件 <code>#include &quot; 头文件名 &quot;</code></li></ol><h3 id="2-8-4- 静态变量"><a href="#2-8-4- 静态变量" class="headerlink" title="2.8.4 静态变量"></a>2.8.4 静态变量 </h3><p> 静态变量：加关键词 <code>static</code> 的变量。三个特点：</p><ul><li>作用范围：只本文件中可访问，对其他文件是隐藏的</li><li>创建与释放：程序开始时分配空间，结束时释放空间，数据存放于内存的全局区中</li><li>初始化默认为 0，使用时也可对其重新赋值</li></ul><h2 id="2-9- 指针"><a href="#2-9- 指针" class="headerlink" title="2.9 指针"></a>2.9 指针 </h2><p> 指针的作用：可以通过指针间接访问内存。</p><ul><li>内存编号是从 0 开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><h3 id="2-9-1- 指针变量的定义和使用"><a href="#2-9-1- 指针变量的定义和使用" class="headerlink" title="2.9.1 指针变量的定义和使用"></a>2.9.1 指针变量的定义和使用 </h3><p> 指针变量定义的语法：<code>数据类型 * 变量名</code></p><pre><code class="c++">int main() &#123;    int a = 10;    int* p;   // 定义一个指针 p    p = &amp;a;   // 将变量 a 的地址赋值给 p，&amp; 是取址符    int b = *p;  // 指针前加 * 代表解引用，找到指针指向内存的数据    return 0;  // 可省略    system(&quot;pause&quot;);&#125;</code></pre><p><strong>指针所占的内存空间：32 位系统—4byte，64 位系统—8byte，无论什么数据类型的指针。</strong></p><h3 id="2-9-2- 空指针与野指针"><a href="#2-9-2- 空指针与野指针" class="headerlink" title="2.9.2 空指针与野指针"></a>2.9.2 空指针与野指针 </h3><p> 空指针：指针变量指向内存中编号为 0 的空间</p><ul><li><p>用途：初始化指针变量</p></li><li><p>注意：空指针指向的内存是不可以访问的</p></li></ul><p>野指针：指针变量指向非法的内存空间</p><pre><code class="c++">int* p = NULL; // 初始化指针为空int* p1 = (int*)0x11001  // 指针指向了无访问权限的地址，野指针</code></pre><blockquote><p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p></blockquote><h3 id="2-9-3-const 修饰指针"><a href="#2-9-3-const 修饰指针" class="headerlink" title="2.9.3 const 修饰指针"></a>2.9.3 const 修饰指针</h3><p>const 修饰指针有三种情况：</p><ol><li><p>const 修饰指针 — 常量指针：指针的指向可以改，但是指针指向的值不可以改</p><pre><code class="c++">int a=10;int b=20;const int* p = &amp;a;   // 常量指针*p = 20;  // 错误操作，指针指向的值不可更改p = &amp;b;   // 允许操作，指针指向可以改</code></pre><p>可以记忆为“常量的指针”，常量即值不可以修改。</p></li><li><p>const 修饰常量 — 指针常量：指针的指向不可以改，但是指针指向的值可以改</p><pre><code class="c++">int a=10;int b=20;int* const p = &amp;a;   // 指针常量*p = 20;  // 允许操作，指针指向的值可改p = &amp;b;   // 错误操作，指针指向不可以改</code></pre><p>可以记忆为“指针是常量”，指针为常量即指针指向不可以改。</p></li><li><p>const 既修饰指针，又修饰常量：指针的指向不可以改，指针指向的值也不可改</p><pre><code class="c++">int a=10;int b=20;const int* const p = &amp;a;  //*p = 20;  // 错误操作，指针指向的值不可改p = &amp;b;   // 错误操作，指针指向不可改</code></pre></li></ol><h3 id="2-9-4- 指针和数组"><a href="#2-9-4- 指针和数组" class="headerlink" title="2.9.4 指针和数组"></a>2.9.4 指针和数组 </h3><p> 作用：利用指针访问数组中的元素</p><pre><code class="c++">int main() &#123;    int arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;    int* p = arr;            // 赋值数组首地址给指针 p    cout &lt;&lt; *p &lt;&lt; endl;      // 获取首地址（第一个元素）的值    p++;                     // 指针右偏移四个字节    cout &lt;&lt; *p &lt;&lt; endl;      // 获取第二个元素的值    system(&quot;pause&quot;);&#125;</code></pre><h3 id="2-9-5- 指针和函数"><a href="#2-9-5- 指针和函数" class="headerlink" title="2.9.5 指针和函数"></a>2.9.5 指针和函数 </h3><p> 作用：利用指针作函数参数，可以修改实参的值</p><pre><code class="c++">void swap(int* p1, int* p2) &#123;    int temp = *p1;    *p1 = *p2;    *p2 = temp;&#125;int main() &#123;    int a = 1;    int b = 2;    swap(&amp;a, &amp;b);  // 地址传递    cout &lt;&lt; a &lt;&lt; endl;  // 输出 a 为 2    cout &lt;&lt; b &lt;&lt; endl;  // 输出 b 为 1    system(&quot;pause&quot;);&#125;</code></pre><p>地址传递可以改变实参的值。</p><blockquote><p>如果想改变实参的值，就用地址传递；如果不想改变实参，就用值传递。</p></blockquote><h3 id="2-9-6- 指针，数组和函数"><a href="#2-9-6- 指针，数组和函数" class="headerlink" title="2.9.6 指针，数组和函数"></a>2.9.6 指针，数组和函数 </h3><p> 封装一个函数，利用冒泡排序，实现对整型数组的升序排列。</p><pre><code class="C++">void bubbleSort(int* arr, int len) &#123;    for (int i = 0; i &lt; len - 1; i++) &#123;        for (int j = 0; j &lt; len - i - 1; j++) &#123;            if (arr[j + 1] &lt; arr[j]) &#123;                int temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            &#125;                   &#125;    &#125;&#125;int main() &#123;    int arr[] = &#123; 4,3,6,9,1,2,10,8,7,5 &#125;;    int len = sizeof(arr) / sizeof(arr[0]);    bubbleSort(arr, len);    for (int i = 0; i &lt; len; i++) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    system(&quot;pause&quot;);&#125;</code></pre><h2 id="2-10- 结构体"><a href="#2-10- 结构体" class="headerlink" title="2.10 结构体"></a>2.10 结构体 </h2><h3 id="2-10-1- 基本概念"><a href="#2-10-1- 基本概念" class="headerlink" title="2.10.1 基本概念"></a>2.10.1 基本概念</h3><p> 结构体属于用户自定义的数据类型，允许用户储存不同的数据类型。</p><p>语法：<code>struct 结构体名 &#123; 结构体成员列表 &#125;;</code></p><p>通过结构体创建变量的方式有三种：</p><ul><li>struct 结构体名，变量名</li><li>struct 结构体名 变量名 = {成员 1 值，成员 2 值…}</li><li>定义结构体时顺便创建变量</li></ul><pre><code class="c++">struct student &#123;    string name;    int age;    int scores;&#125;s3;                   // 第三种方式：定义结构体时顺便创建变量int main() &#123;    // 第一种方式    struct student s1;      //struct 关键词可以省略    s1.name = &quot;zs&quot;;    s1.age = 25;    s1.scores = 80;    // 第二种方式    struct student s2 = &#123;&quot;ls&quot;, 27, 90&#125;;              s3.name = &quot;we&quot;;    s3.age = 20;    s3.scores = 52;    cout &lt;&lt; s1.name &lt;&lt; endl;   // 通过. 点来访问成员    cout &lt;&lt; s2.name &lt;&lt; endl;    cout &lt;&lt; s3.name &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="2-10-2- 结构体数组"><a href="#2-10-2- 结构体数组" class="headerlink" title="2.10.2 结构体数组"></a>2.10.2 结构体数组 </h3><p> 作用：将自定义的结构体放入到数组中方便维护</p><p>语法：<code>struct 结构体名 数组名[] = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;</code></p><pre><code class="c++">struct student &#123;    string name;    int age;    int scores;&#125;;int main() &#123;    struct student s1[] = &#123;        &#123;&quot;zs&quot;, 19, 68&#125;,        &#123;&quot;li&quot;, 25, 70&#125;,        &#123;&quot;dw&quot;, 26, 85&#125;,    &#125;;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="2-10-3- 结构体指针"><a href="#2-10-3- 结构体指针" class="headerlink" title="2.10.3 结构体指针"></a>2.10.3 结构体指针 </h3><p> 作用：通过指针访问结构体中的成员</p><ul><li>利用操作符 <code>-&gt;</code> 可以通过结构体指针访问结构体属性。</li></ul><pre><code class="c++">struct student &#123;    string name;    int age;    int scores;&#125;;int main() &#123;    struct student s1 = &#123; &quot;zs&quot;, 19, 68 &#125;;    student * p = &amp;s1;  // 创建结构体指针并赋值    cout &lt;&lt; p-&gt;name &lt;&lt; endl; // 访问属性    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="2-10-4- 结构体嵌套"><a href="#2-10-4- 结构体嵌套" class="headerlink" title="2.10.4 结构体嵌套"></a>2.10.4 结构体嵌套 </h3><p> 在结构体中可以定义另一个结构体作为成员，用来解决实际问题。</p><pre><code class="c++">struct student &#123;    string name;    int age;    int scores;&#125;;struct teacher&#123;    string name;    int age;    string course;    struct student stu;  // 嵌套一个 student 结构体&#125;;int main() &#123;    teacher t1;    t1.name = &quot;wteacher&quot;;    t1.age = 45;    t1.course = &quot;mathematics&quot;;    t1.stu.name = &quot;zs&quot;;    t1.stu.age = 25;    t1.stu.scores = 80;    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="2-10-5- 结构体做函数参数"><a href="#2-10-5- 结构体做函数参数" class="headerlink" title="2.10.5 结构体做函数参数"></a>2.10.5 结构体做函数参数 </h3><p> 作用：将结构体作为参数向函数中传递</p><p>传递方式有两种：</p><ul><li>值传递</li><li>地址传递</li></ul><pre><code class="c++">struct student &#123;    string name;    int age;    int scores;&#125;;// 值传递void printstudent1(struct student s) &#123;    s.age = 80;    cout &lt;&lt; s.name &lt;&lt;&quot; &quot;;    cout &lt;&lt; s.age &lt;&lt; &quot; &quot;;    cout &lt;&lt; s.scores &lt;&lt;endl;&#125;;// 地址传递void printstudent2(struct student* s) &#123;    s-&gt;age = 100;    cout &lt;&lt; s-&gt;name &lt;&lt; &quot; &quot;;    cout &lt;&lt; s-&gt;age &lt;&lt; &quot; &quot;;    cout &lt;&lt; s-&gt;scores &lt;&lt; endl;&#125;;int main() &#123;    student s1 = &#123; &quot;zs&quot;, 19, 68 &#125;;    printstudent1(s1);          // 输出 &quot;zs&quot;, 80, 68     cout &lt;&lt; s1.name &lt;&lt; &quot; &quot;;    cout &lt;&lt; s1.age &lt;&lt; &quot; &quot;;    cout &lt;&lt; s1.scores &lt;&lt; endl;   // 输出 &quot;zs&quot;, 19, 68   不改变原来的值    printstudent2(&amp;s1);          // 输出 &quot;zs&quot;, 100, 68     cout &lt;&lt; s1.name &lt;&lt; &quot; &quot;;    cout &lt;&lt; s1.age &lt;&lt; &quot; &quot;;    cout &lt;&lt; s1.scores &lt;&lt; endl;   // 输出 &quot;zs&quot;, 100, 68 改变原来的值    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="2-10-6- 结构体中 const 使用场景"><a href="#2-10-6- 结构体中 const 使用场景" class="headerlink" title="2.10.6 结构体中 const 使用场景"></a>2.10.6 结构体中 const 使用场景 </h3><p> 在实际使用场景中，若使用值传递，相当于又要拷贝一份数据给函数，会显著增加内存资源损耗。使用地址传递就不会存在这个问题，一个指针只占四个字节，会极大的节省空间，但是地址传递在新的函数中处理数据时，会改变原来数据，这时候就可以使用 const 修饰，避免数据篡改。</p><pre><code class="c++">void printstudent1(const struct student* s) &#123;   // 传地址时加 const 限制    s-&gt;age = 100;   // 此修改行为不允许    cout &lt;&lt; s-&gt;name &lt;&lt; &quot; &quot;;    cout &lt;&lt; s-&gt;age &lt;&lt; &quot; &quot;;    cout &lt;&lt; s-&gt;scores &lt;&lt; endl;&#125;;int main() &#123;    student s1 = &#123; &quot;zs&quot;, 19, 68 &#125;;    printstudent1(&amp;s1);    system(&quot;pause&quot;);    return 0;&#125;</code></pre><h3 id="2-10-6- 案例"><a href="#2-10-6- 案例" class="headerlink" title="2.10.6 案例"></a>2.10.6 案例 </h3><p> 案例描述：设计一个英雄的结构体，包括成员姓名，性别；创建结构体数组，数组中存放 5 名英雄。</p><p>通过冒泡排序算法，将数组中的英雄按照年龄进行升序排列，最终打印排序后的结果。</p><pre><code class="c++">struct Hero &#123;    string name;    int age;    string sex;&#125;;void bubblesort(struct Hero sanguo[],int len) &#123;    for (int i = 0; i &lt; len-1; i++) &#123;        for (int j = 0; j &lt; len-1-i; j++) &#123;            if (sanguo[j].age &gt; sanguo[j + 1].age) &#123;                struct Hero temp = sanguo[j];                sanguo[j] = sanguo[j + 1];                sanguo[j + 1] = temp;            &#125;        &#125;    &#125;&#125;int main() &#123;    Hero sanguo[] = &#123;        &#123;&quot; 刘备 &quot;,23,&quot; 男 &quot;&#125;,        &#123;&quot; 关羽 &quot;,22,&quot; 男 &quot;&#125;,        &#123;&quot; 张飞 &quot;,20,&quot; 男 &quot;&#125;,        &#123;&quot; 赵云 &quot;,21,&quot; 男 &quot;&#125;,        &#123;&quot; 貂蝉 &quot;,19,&quot; 女 &quot;&#125;,    &#125;;    int len = sizeof(sanguo) / sizeof(sanguo[0]);    bubblesort(sanguo, len);    for (int i = 0; i &lt; len - 1; i++) &#123;        cout &lt;&lt; sanguo[i].name &lt;&lt; &quot; &quot;;        cout &lt;&lt; sanguo[i].age &lt;&lt; &quot; &quot;;        cout &lt;&lt; sanguo[i].sex &lt;&lt; endl;    &#125;       system(&quot;pause&quot;);    return 0;&#125;</code></pre><ul><li>结构体变量作函数参数时，函数内的操作不会改变结构体的值，结构体的各成员作为实参传递给了函数的形参，实际操作的是形参，不会影响实参；</li></ul><ul><li><strong>结构体数组作为函数参数时，实际上是将结构体数组的第一个数组成员的地址传递给了形参，用对应的指针或者直接用结构体数组的名称作为实参效果是一样的，操作都直接对结构体数组进行，可以改变其值。</strong></li></ul><h2 id="2-11- 枚举类型"><a href="#2-11- 枚举类型" class="headerlink" title="2.11 枚举类型"></a>2.11 枚举类型 </h2><p> 枚举类型 (enumeration) 是 C++ 中的一种派生 <strong> 数据类型</strong>，它是由用户定义的若干枚举常量的集合。</p><h3 id="2-11-1- 定义枚举类型"><a href="#2-11-1- 定义枚举类型" class="headerlink" title="2.11.1 定义枚举类型"></a>2.11.1 定义枚举类型</h3><pre><code class="c++">enum 数据类型名 &#123; 枚举常量表 &#125;;# 举例enum Week &#123;Mon, Tus, Wed, Thus, Fri, Sat, Sun&#125;</code></pre><blockquote><p>语句将创建一个名为 Week 的数据类型—枚举类型（与整型，浮点型等类似）。</p><p>枚举常量表——由枚举常量构成，以标识符形式表示的整型量，而不能是整型、字符型等文字常量。</p><p>枚举常量代表该枚举类型的变量可能取的值，默认情况下，编译系统为每个枚举常量指定一个整数值，从 0 开始，依次加 1；也可自行指定。</p><p>若自行指定，而指定值之后的枚举常量按依次加 1 的原则取值。 各枚举常量的值可以重复，枚举标识符不能重复。</p></blockquote><pre><code class="c++">enum letter_set &#123;&#39;a&#39;,&#39;d&#39;,&#39;F&#39;,&#39;s&#39;,&#39;T&#39;&#125;;                // 非法enum year_set&#123;2000,2001,2002,2003,2004,2005&#125;;         // 非法enum fruit_set &#123;apple, orange, banana=1, peach, grape&#125;   // 合法# apple=1, orange=2, banana=1, peach=2, grape=3</code></pre><h3 id="2-11-2- 定义枚举变量"><a href="#2-11-2- 定义枚举变量" class="headerlink" title="2.11.2 定义枚举变量"></a>2.11.2 定义枚举变量 </h3><p> 定义枚举数据类型后，可以接着使用枚举类型指定枚举变量。</p><pre><code class="c++">// 定义枚举类型enum Week &#123;Mon, Tus, Wed, Thus, Fri, Sat, Sun&#125;;// 定义枚举变量 w1 和 w2, 并赋值 w2Week w1, w2 = Tus;</code></pre><p>也可以：类型与变量同时定义（甚至类型名可省）</p><pre><code>enum &#123;Mon, Tus, Wed, Thus, Fri, Sat, Sun&#125; w1, w2;</code></pre><blockquote><p>枚举变量的值只能取：枚举常量表中所列的标识符。虽然枚举常量表中的标识符中的背后代表的是枚举常量，但是枚举变量的值不能取整型常量值，如 1,2 等。</p><p>枚举变量占用内存的大小与整型数相同。不管枚举类型有多少枚举量，枚举数都占 4 bytes.</p><p>枚举变量只能参与 <strong> 赋值 </strong> 和<strong>关系运算 </strong> 以及 <strong> 输出操作</strong>，其中参与运算时用其本身的整数值。</p></blockquote><p>允许的赋值操作如下：</p><pre><code class="c++">enum &#123;Mon, Tus, Wed, Thus, Fri, Sat, Sun&#125; w1, w2;w1 = Fri;w2 = w1;int i = w2;int j = Sun;</code></pre><p>非法操作：</p><pre><code class="c++">enum &#123;Mon, Tus, Wed, Thus, Fri, Sat, Sun&#125; w1, w2;w1 = 1;              // 非法w2 = FFF;            // 非法</code></pre><h3 id="2-11-3- 关系运算"><a href="#2-11-3- 关系运算" class="headerlink" title="2.11.3 关系运算"></a>2.11.3 关系运算 </h3><p> 可以使用整数值而不是符号名称来测试枚举变量。还可以使用关系运算符来比较两个枚举变量</p><pre><code class="c++">enum &#123; Mon, Tus, Wed, Thus, Fri, Sat, Sun &#125; w1 = Mon, w2 = Fri;if (w1 == Mon) &#123;   cout &lt;&lt; &quot;w1 的枚举变量名是 Mon&quot; &lt;&lt; endl;&#125;if (w1 == 0) &#123;    cout &lt;&lt; &quot;w1 的枚举常量是 0&quot; &lt;&lt; endl;&#125;if (w2 &gt; w1) &#123;    cout &lt;&lt; &quot;w2 的枚举常量大于 w2&quot; &lt;&lt; endl;&#125;</code></pre><h3 id="2-11-4- 枚举类"><a href="#2-11-4- 枚举类" class="headerlink" title="2.11.4 枚举类"></a>2.11.4 枚举类</h3><p>C++11 中新增了枚举类，也称作【限定作用域的枚举类】。关键字为：<code>enum class</code></p><blockquote><p>enum 现在被称为【不限范围】的枚举型别。</p><p>enum class 是【限定作用域】枚举型别，他们仅在枚举型别内可见，且只能通过强制转换转换为其他型别。</p><p>两种枚举都支持底层型别指定，enum class 默认是 int，enum 没有默认底层型别。enum 可以前置声明，但仅在指定默认底层型别的情况下才能前置声明。</p></blockquote><p>枚举类的基本用法和枚举数一致。</p><p>枚举类优势：</p><ul><li><p>降低命名空间污染</p><pre><code class="C++">// 枚举数enum Week&#123; Mon, Tus, Wed, Thus, Fri, Sat, Sun &#125; w1 = Mon, w2 = Fri;int Mon = 100;   // 错误// 枚举类enum class Month &#123; Jan, Feb, Mar, Apr, May &#125; m1 = Month::Jan, m2;m2 = Month::May;int Jan = 100;   // 允许</code></pre></li><li><p>避免发生隐式转换</p><pre><code class="c++">// 枚举数enum Week&#123; Mon, Tus, Wed, Thus, Fri, Sat, Sun &#125; w1 = Mon;if (w1 &lt; 7) &#123;&#125;// 枚举类enum class Month &#123; Jan, Feb, Mar, Apr, May &#125; m1 = Month::Jan;if (m1 &lt; 7) &#123;&#125;   // 不允许</code></pre><p>限定作用域的枚举型别不允许发生任何隐式转换。如果非要转换，按就只能使用 static_cast 进行强制转换。</p></li></ul><ul><li><p>可以前置声明</p><pre><code class="c++">enum Color;          // 非法enum class Color;    // 合法</code></pre></li></ul><h1 id="三、实战 1- 通讯录管理系统"><a href="# 三、实战 1- 通讯录管理系统" class="headerlink" title="三、实战 1- 通讯录管理系统"></a>三、实战 1- 通讯录管理系统 </h1><p> 通讯录是一个可以记录亲人，好友信息的工具。系统中需要实现的功能如下：</p><ul><li>添加联系人：向通讯录中添加新人，信息包括（姓名，性别，年龄，联系电话，家庭住址），最多记录 100 人</li><li>显示联系人：显示通讯录总所有联系人的信息</li><li>删除联系人：按照姓名进行删除指定联系人</li><li>查找联系人：按照姓名进行查找指定联系人</li><li>修改联系人：按照姓名重新修改指定联系人</li><li>清空联系人：清空通讯录中所有信息</li><li>退出通讯录：退出当前使用的通讯录</li></ul><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;#define MAX 1000void showMenu() &#123;    cout &lt;&lt; &quot;**************************&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****  1. 添加联系人  *****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****  2. 显示联系人  *****  &quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****  3. 删除联系人  *****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****  4. 查找联系人  *****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****  5. 修改联系人  *****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****  6. 清空联系人  *****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;*****  0. 退出通讯录  *****&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;**************************&quot; &lt;&lt; endl;&#125;struct member &#123;    string name;    int sex;  //1 为男 2 为女    int age;    string tel;    string addr;&#125;;struct addressbooks &#123;    struct member memberarr[MAX];  // 通讯录名单    int size;                      // 人数&#125;;void addperson(addressbooks * abs) &#123;    if (abs-&gt;size == MAX) &#123;        cout &lt;&lt; &quot; 联系人已满，请删除不必要的人员再添加 &quot; &lt;&lt; endl;        return;    &#125;    else &#123;        string name;        int sex=0;  //1 为男 2 为女        int age=0;        string tel;        string addr;        cout &lt;&lt; &quot; 请输入姓名：&quot; &lt;&lt; endl;        cin &gt;&gt; name;        abs-&gt;memberarr[abs-&gt;size].name = name;        cout &lt;&lt; &quot; 请输入性别：&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;1  ---  男 &quot; &lt;&lt; endl;        cout &lt;&lt; &quot;2  ---  女 &quot; &lt;&lt; endl;        while (true) &#123;            cin &gt;&gt; sex;            if (sex == 1 || sex == 2) &#123;                abs-&gt;memberarr[abs-&gt;size].sex = sex;                break;            &#125;            cout &lt;&lt; &quot; 输入有误，请重新输入！&quot; &lt;&lt; endl;        &#125;        cout &lt;&lt; &quot; 请输入年龄：&quot; &lt;&lt; endl;        cin &gt;&gt; age;        abs-&gt;memberarr[abs-&gt;size].age = age;        cout &lt;&lt; &quot; 请输入电话：&quot; &lt;&lt; endl;        cin &gt;&gt; tel;        abs-&gt;memberarr[abs-&gt;size].tel = tel;        cout &lt;&lt; &quot; 请输入地址：&quot; &lt;&lt; endl;        cin &gt;&gt; addr;        abs-&gt;memberarr[abs-&gt;size].addr = addr;        abs-&gt;size++;        cout &lt;&lt; &quot; 添加成功 &quot; &lt;&lt; endl;        system(&quot;pause&quot;);        system(&quot;cls&quot;);    &#125;&#125;void showperson(addressbooks * abs) &#123;    if (abs-&gt;size == 0) &#123;        cout &lt;&lt; &quot; 通讯录为空 &quot; &lt;&lt; endl;    &#125;    else &#123;        for (int i = 0; i &lt; abs-&gt;size; i++) &#123;            cout &lt;&lt; &quot; 姓名: &quot; &lt;&lt; abs-&gt;memberarr[i].name;            cout &lt;&lt; &quot;\t 性别: &quot; &lt;&lt; (abs-&gt;memberarr[i].sex==1?&quot; 男 &quot;:&quot; 女 &quot;);            cout &lt;&lt; &quot;\t 年龄: &quot; &lt;&lt; abs-&gt;memberarr[i].age;            cout &lt;&lt; &quot;\t 电话: &quot; &lt;&lt; abs-&gt;memberarr[i].tel;            cout &lt;&lt; &quot;\t 地址: &quot; &lt;&lt; abs-&gt;memberarr[i].addr &lt;&lt; endl;        &#125;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;int isExist(addressbooks* abs, string name) &#123;    for (int i = 0; i &lt; abs-&gt;size; i++) &#123;        if (abs-&gt;memberarr[i].name == name) &#123;            return i;        &#125;    &#125;    return -1;&#125;void delperson(addressbooks* abs) &#123;    cout &lt;&lt; &quot; 请输入删除的联系人：&quot; &lt;&lt; endl;    string name;    cin &gt;&gt; name;    int ret = isExist(abs,name);    if (ret != -1) &#123;        for (int i = ret; i &lt; abs-&gt;size; i++) &#123;            abs-&gt;memberarr[i] = abs-&gt;memberarr[i + 1];        &#125;        abs-&gt;size--;        cout &lt;&lt; &quot; 删除成功 &quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot; 查无此人 &quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);    &#125;void findperson(addressbooks* abs) &#123;    cout &lt;&lt; &quot; 请输入查找的联系人：&quot; &lt;&lt; endl;    string name;    cin &gt;&gt; name;    int ret= isExist(abs, name);    if (ret != -1) &#123;        cout &lt;&lt; &quot; 姓名: &quot; &lt;&lt; abs-&gt;memberarr[ret].name &lt;&lt; &quot;\t&quot;;        cout &lt;&lt; &quot; 性别: &quot; &lt;&lt; (abs-&gt;memberarr[ret].sex == 1 ? &quot; 男 &quot; : &quot; 女 &quot;) &lt;&lt; &quot;\t&quot;;        cout &lt;&lt; &quot; 年龄: &quot; &lt;&lt; abs-&gt;memberarr[ret].age &lt;&lt; &quot;\t&quot;;        cout &lt;&lt; &quot; 电话: &quot; &lt;&lt; abs-&gt;memberarr[ret].tel &lt;&lt; &quot;\t&quot;;        cout &lt;&lt; &quot; 地址: &quot; &lt;&lt; abs-&gt;memberarr[ret].addr &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot; 查无此人 &quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;void modifyperson(addressbooks* abs) &#123;    cout &lt;&lt; &quot; 请输入修改的联系人：&quot; &lt;&lt; endl;    string name;    cin &gt;&gt; name;    int ret = isExist(abs, name);    if (ret != -1) &#123;        cout &lt;&lt; &quot; 请输入姓名：&quot; &lt;&lt; endl;        cin &gt;&gt; name;        abs-&gt;memberarr[ret].name = name;        cout &lt;&lt; &quot; 请输入性别：&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;1  ---  男 &quot; &lt;&lt; endl;        cout &lt;&lt; &quot;2  ---  女 &quot; &lt;&lt; endl;        while (true) &#123;            int sex = 0;            cin &gt;&gt; sex;            if (sex == 1 || sex == 2) &#123;                abs-&gt;memberarr[abs-&gt;size].sex = sex;                break;            &#125;            cout &lt;&lt; &quot; 输入有误，请重新输入！&quot; &lt;&lt; endl;        &#125;        int age = 0;        cout &lt;&lt; &quot; 请输入年龄：&quot; &lt;&lt; endl;        cin &gt;&gt; age;        abs-&gt;memberarr[ret].age = age;        cout &lt;&lt; &quot; 请输入电话：&quot; &lt;&lt; endl;        string tel;        cin &gt;&gt; tel;        abs-&gt;memberarr[ret].tel = tel;        cout &lt;&lt; &quot; 请输入地址：&quot; &lt;&lt; endl;        string addr;        cin &gt;&gt; addr;        abs-&gt;memberarr[ret].addr = addr;        cout &lt;&lt; &quot; 修改成功 &quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot; 查无此人 &quot; &lt;&lt; endl;    &#125;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;void cleanperson(addressbooks* abs) &#123;    abs-&gt;size = 0;    cout&lt;&lt;&quot; 联系人已全部清空 &quot; &lt;&lt; endl;    system(&quot;pause&quot;);    system(&quot;cls&quot;);&#125;int main() &#123;    int select = 0;    addressbooks abs;    abs.size = 0;    while (true) &#123;        showMenu();        cin &gt;&gt; select;        switch (select)        &#123;        case 1:            addperson(&amp;abs);            break;        case 2:            showperson(&amp;abs);            break;        case 3:            delperson(&amp;abs);            break;        case 4:            findperson(&amp;abs);            break;        case 5:            modifyperson(&amp;abs);            break;        case 6:            cleanperson(&amp;abs);            break;        case 0:            cout &lt;&lt; &quot; 欢迎下次使用 &quot; &lt;&lt; endl;            system(&quot;pause&quot;);            return 0 ;            break;        default:            break;        &#125;            &#125;    &#125;</code></pre><h1 id="四、C- 核心编程"><a href="# 四、C- 核心编程" class="headerlink" title="四、C++ 核心编程"></a>四、C++ 核心编程 </h1><p> 本阶段主要针对 C++<strong>面向对象编程 </strong> 技术做详细讲解，探讨 C++ 中的核心和精髓。</p><h2 id="4-1- 内存分区模型"><a href="#4-1- 内存分区模型" class="headerlink" title="4.1 内存分区模型"></a>4.1 内存分区模型</h2><p>C++ 程序在执行时，将内存大方向划分为 4 个区域</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li><li>堆区：由程序员分配和释放，若程序员不释放，程序结束时，由操作系统回收。</li></ul><p>内存四区的意义：</p><p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程。</p><p>—————–程序运行前————–</p><p>在程序编译后，生成 exe 可执行程序，未执行该程序前分为两个区域：</p><ol><li>代码区：存放 CPU 执行的机器指令；代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份即可；代码区是只读的，防止程序意外的修改了它的指令。</li><li>全局区：<strong>全局变量 </strong> 和<strong>静态变量 </strong> 存放于此；全局区还包含了 <strong> 常量 </strong> 区，字符串常量和其他常量也存放于此；该区域的数据在程序结束后由操作系统释放。</li></ol><pre><code class="c++">int g_a = 10;   // 全局变量const int c_g_a = 10; //const 修饰的全局变量int main()&#123;    int a = 10;   // 局部变量    static int s_a = 10; // 静态变量，在普通变量前加 static，属于静态变量    string str_a = &quot;hello word&quot;;    // 字符串常量    const int c_a = 10;    //const 修饰的局部变量    system(&quot;pause&quot;);&#125;</code></pre><p>—————–程序运行中————–</p><p>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。注意：不要返回局部变量的地址。</p><p>堆区：由程序员分配释放，若程序员不释放，程序结束时由操作系统回收。在 C++ 中，主要利用 new 关键字在堆区开辟内存。</p><pre><code class="c++">int* func() &#123;    int* p = new int(10);   //new 创建的数据，返回指针    return p;&#125;int main()&#123;    int* p = func();    cout &lt;&lt; *p &lt;&lt; endl;    cout &lt;&lt; *p &lt;&lt; endl;    system(&quot;pause&quot;);&#125;</code></pre><h2 id="4-2-new 操作符"><a href="#4-2-new 操作符" class="headerlink" title="4.2 new 操作符"></a>4.2 new 操作符</h2><p>C++ 中利用 new 操作符在堆区开辟数据.</p><p>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete</p><p>语法：<code>new 数据类型</code></p><p>利用 new 创建的数据，会返回该数据对应的类型的指针。</p><pre><code class="c++">int* func() &#123;    int* arr = new int[10];   // 创建一个数组，返回首地址    arr[0] = 0;    return arr;&#125;int main()&#123;    int* p = func();    cout &lt;&lt; *p &lt;&lt; endl;    cout &lt;&lt; *p &lt;&lt; endl;    delete[] p;  // 释放数组时，要加[]    system(&quot;pause&quot;);&#125;</code></pre><h2 id="4-3- 引用"><a href="#4-3- 引用" class="headerlink" title="4.3 引用"></a>4.3 引用 </h2><p> 作用：给变量起别名</p><p>语法：<code>数据类型 &amp; 别名 = 原名</code></p><pre><code class="c++">int main()&#123;    int a = 10;    int&amp; b = a;    cout &lt;&lt; a &lt;&lt; endl;  // 输出 10    cout &lt;&lt; b &lt;&lt; endl;  // 输出 10    b = 100;    cout &lt;&lt; a &lt;&lt; endl;  // 输出 100    cout &lt;&lt; b &lt;&lt; endl;  // 输出 100    system(&quot;pause&quot;);&#125;</code></pre><blockquote><p>注意事项：引用必须初始化，且在初始化后不可更改。</p></blockquote><h3 id="4-3-1- 引用作函数实参"><a href="#4-3-1- 引用作函数实参" class="headerlink" title="4.3.1 引用作函数实参"></a>4.3.1 引用作函数实参 </h3><p> 作用：函数传参时，可以利用引用让形参修饰实参</p><p>优点：可以简化指针修改实参</p><pre><code class="c++">void swap(int &amp;a,int &amp;b)&#123;    int temp = a;    a = b;    b = temp;&#125;int main()&#123;    int a = 10;    int b = 20;    swap(a, b);     // 引用传递，形参也会修饰实参的    cout &lt;&lt; a &lt;&lt; endl;    // 输出 20    cout &lt;&lt; b &lt;&lt; endl;    // 输出 10    system(&quot;pause&quot;);&#125;</code></pre><blockquote><p>总结：通过引用参数产生的效果同按照地址是一样的，引用的语法更加清楚简单。</p></blockquote><h3 id="4-3-2- 引用作函数的返回值"><a href="#4-3-2- 引用作函数的返回值" class="headerlink" title="4.3.2 引用作函数的返回值"></a>4.3.2 引用作函数的返回值 </h3><p> 作用：引用是可以作为函数的返回值存在的。注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><pre><code class="c++">int&amp; test() &#123;    static int a = 10;    return a;   // 返回静态变量的引用&#125;int main()&#123;    int&amp; ref = test();       cout &lt;&lt; ref &lt;&lt; endl;    cout &lt;&lt; ref &lt;&lt; endl;    // 如果函数作左值，必须返回函数的引用    test() = 1000;      cout &lt;&lt; ref &lt;&lt; endl;    cout &lt;&lt; ref &lt;&lt; endl;    system(&quot;pause&quot;);&#125;</code></pre><h3 id="4-3-3- 引用的本质"><a href="#4-3-3- 引用的本质" class="headerlink" title="4.3.3 引用的本质"></a>4.3.3 引用的本质 </h3><p> 本质：引用的本质在 C++ 内部实现的一个指针常量</p><pre><code class="c++">void func(int&amp; ref) &#123;    ref = 50;   //ref 是引用，转换为 *ref = 50&#125;int main() &#123;    int a = 10;    int&amp; ref = a;  // 自动转换为 int* const ref=&amp;a; 指针常量时指针指向不可改，也说明为什么引用不可更改    ref = 100; // 内部发现 ref 是引用，自动帮我们转换为 *ref=100;    func(a); &#125;</code></pre><blockquote><p>C++ 推荐使用引用技术，因为语法方便，引用本质是指针常量，但所有的指针操作编译器都帮我们做了。</p></blockquote><h3 id="4-3-4- 常量引用"><a href="#4-3-4- 常量引用" class="headerlink" title="4.3.4 常量引用"></a>4.3.4 常量引用 </h3><p> 作用：常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加 const 修饰形参，防止形参改变实参</p><pre><code class="c++">void func(const int&amp; v) &#123;    v = 50;   // 常量引用不可赋值，报错    cout &lt;&lt; v &lt;&lt; endl;&#125;int main() &#123;    //int&amp; ref = 10;  // 报错。常量引用，引用必须引一块合法的内存空间    const int&amp; ref = 10;     // int temp=10; const int&amp; ref = temp;  // 实际是这样的    //ref = 20; 加入 const 之后变为只读，不可以修改    // 函数中利用常量引用防止误操作修改实参    int a = 20;    func(a);    system(&quot;pause&quot;); &#125;</code></pre><h2 id="4-4- 函数的提高"><a href="#4-4- 函数的提高" class="headerlink" title="4.4 函数的提高"></a>4.4 函数的提高 </h2><h3 id="4-4-1- 函数默认值"><a href="#4-4-1- 函数默认值" class="headerlink" title="4.4.1 函数默认值"></a>4.4.1 函数默认值</h3><p> 在 C++ 中，函数的形参列表中的形参是可以有默认值的</p><p>语法：<code>返回值类型 函数名 （参数 = 默认值）｛｝</code></p><pre><code class="c++">// 定义函数时，可以设置初始默认值int func(int a, int b = 20,int c = 30) &#123;    return (a + b + c);&#125;int main() &#123;    cout &lt;&lt; func(10) &lt;&lt; endl;      cout &lt;&lt; func(10, 40) &lt;&lt; endl;      // 如果有传参，就用传的参数，若无，就用默认的值    cout &lt;&lt; func(10, 40, 50)&lt;&lt; endl;    //cout &lt;&lt; func(, , 50)&lt;&lt; endl;        // 非法调用，不能只默认前两个，改第三个    system(&quot;pause&quot;); &#125;</code></pre><p>定义函数时，如果某个位置已经有了默认值，那么从这个位置往后，从左到右都必须有默认值。</p><p>函数声明和函数定义，二者只能有一种默认参数，不能函数声明和函数定义都写默认参数。</p><pre><code class="c++">int func(int a, int b = 30,int c = 0)        // 函数声明int func(int a, int b = 30,int c = 0) &#123;     // 函数定义    return (a + b + c);&#125;// 以上的默认值写法是错的，不能同时存在</code></pre><h3 id="4-4-2- 函数占位参数"><a href="#4-4-2- 函数占位参数" class="headerlink" title="4.4.2 函数占位参数"></a>4.4.2 函数占位参数</h3><p>C++ 中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p>语法：<code>返回值类型 函数名 （数据类型）｛｝</code></p><pre><code class="c++">void func(int a, int,int) &#123;        cout &lt;&lt; &quot;this is a test&quot; &lt;&lt; endl;&#125;int main() &#123;    func(10, 10, 10);    system(&quot;pause&quot;); &#125;</code></pre><h3 id="4-4-3- 函数重载"><a href="#4-4-3- 函数重载" class="headerlink" title="4.4.3 函数重载"></a>4.4.3 函数重载 </h3><p> 作用：函数名可以相同，提高复用性</p><p>函数重载满足条件：</p><ol><li>同一个作用域下</li><li>函数名相同</li><li>函数参数 <strong> 类型不同 </strong> 或者 <strong> 个数不同 </strong> 或者 <strong> 顺序不同</strong></li></ol><pre><code class="c++">void func() &#123;        cout &lt;&lt; &quot;func()的调用 &quot; &lt;&lt; endl;&#125;void func(int a) &#123;    cout &lt;&lt; &quot;func(int a)的调用 &quot; &lt;&lt; endl;&#125;int main() &#123;    func();        // 输出：func()的调用    func(10);      // 输出：func(int a)的调用    system(&quot;pause&quot;); &#125;</code></pre><blockquote><p>函数的返回值不可以作为函数重载的条件</p><p>函数参数引用可以作为函数重载的条件</p><p>使用函数重载时，尽量不要写默认参数</p></blockquote><pre><code class="c++">void func(int&amp; a) &#123;    cout &lt;&lt; &quot;func1 的调用 &quot; &lt;&lt; endl;&#125;void func(const int &amp;a) &#123;    cout &lt;&lt; &quot;func2 的调用 &quot; &lt;&lt; endl;&#125;int main() &#123;    int a = 10;    func(a);                // 输出：func1 的调用    const int b = 10;    func(b);               // 输出：func2 的调用    system(&quot;pause&quot;); &#125;</code></pre><h2 id="4-5- 类和对象"><a href="#4-5- 类和对象" class="headerlink" title="4.5 类和对象"></a>4.5 类和对象</h2><p>C++ 面向对象的三大特性：封装，继承，多态。</p><p>C++ 认为万事万物都皆为对象，对象上有其属性和行为</p><h3 id="4-5-1- 封装"><a href="#4-5-1- 封装" class="headerlink" title="4.5.1 封装"></a>4.5.1 封装 </h3><p> 封装是 C++ 面向对象三大特性之一</p><p>封装的意义一：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p>语法：<code>class 类名 &#123; 访问权限：属性 / 行为 &#125;；</code></p><p>一个圆类：</p><pre><code class="c++">const double PI = 3.14;class Circle &#123;public:              // 访问权限：公共权限    int m_r;    double calcul_perimeter() &#123;        return 2 * PI * m_r;    &#125;&#125;;int main() &#123;    Circle C1;   // 通过圆类，创建具体的圆（对象），实例化    C1.m_r = 10;   // 给属性赋值    cout &lt;&lt; C1.calcul_perimeter() &lt;&lt; endl;  // 输出：62.8    system(&quot;pause&quot;); &#125;</code></pre><p>类中的属性和行为，我们统一称为成员。</p><p>属性：成员属性、成员变量</p><p>行为：成员函数、成员方法</p><p>封装的意义二：</p><ul><li>类在设计时，可以把属性和行为放在不同的权限下，加以控制</li><li>访问权限有三种<ol><li>public 公共权限：类内可以访问，类外可以访问                           </li><li>protected 保护权限：类内可以访问，类外不可以访问                  </li><li>private 私有权限：类内可以访问，类外不可以访问</li></ol></li></ul><pre><code class="c++">class Person &#123;public:                 string m_name;protected:    string m_car;private:    int m_password = 1001;public:    void get_info() &#123;        //m_name = &quot;liu wen&quot;;        m_car = &quot;BWM&quot;;        m_password = 123456;        cout &lt;&lt; m_name &lt;&lt; endl;        cout &lt;&lt; m_car &lt;&lt; endl;        cout &lt;&lt; m_password &lt;&lt; endl;    &#125;&#125;;int main() &#123;    Person p1;      p1.m_name = &quot;li qiang&quot;;    p1.get_info();             // 输出：li qiang   BWM   123456    system(&quot;pause&quot;); &#125;</code></pre><p> struct 和 class 区别：</p><p>在 C++ 中，struct 和 class 唯一的区别就在于默认的访问权限不同。</p><p>区别：</p><ul><li>struct 默认权限为公共 public</li><li>class 默认权限为私有 private</li></ul><p>成员属性设为私有</p><ul><li>将所有成员属性设为私有，可以自己控制读写权限</li><li>对于写权限，我们可以检测数据的有效性</li></ul><p>举一个例子：</p><pre><code class="c++">class Person &#123;public:                 void setname(string name) &#123;        m_name = name;    &#125;    string getname() &#123;        return m_name;    &#125;    string getcar() &#123;        string m_car = &quot;BWM&quot;;  // 初始化        return m_car;    &#125;    void setpassword(int password) &#123;        m_password = password;    &#125;private:    string m_name;       string m_car;       int m_password;  &#125;;int main() &#123;    Person p1;      p1.setname(&quot;li qiang&quot;);           // 可写    cout &lt;&lt; p1.getname() &lt;&lt; endl;     // 可读    cout &lt;&lt; p1.getcar() &lt;&lt; endl;     // 只读    p1.setpassword(456789);            // 只写    system(&quot;pause&quot;); &#125;</code></pre><p>一个正方体的例子：</p><pre><code class="c++">class Cube &#123;public:                 void setL(int L) &#123;        m_L = L;    &#125;    double getL() &#123;        return m_L;    &#125;    void setW(int W) &#123;        m_W = W;    &#125;    double getW() &#123;        return m_W;    &#125;    void setH(int H) &#123;        m_H = H;    &#125;    double getH() &#123;        return m_H;    &#125;    bool isSame(Cube&amp; c) &#123;        if (m_L == c.getL() &amp;&amp; m_W == c.getW() &amp;&amp; m_H == c.getH()) &#123;            return true;        &#125;        return false;    &#125;private:    double m_L;       double m_W;    double m_H;&#125;;bool isSame(Cube&amp; c1, Cube&amp; c2) &#123;    if (c1.getL() == c2.getL() &amp;&amp; c1.getW() == c2.getW() &amp;&amp; c1.getH() == c2.getH()) &#123;        return true;    &#125;    return false;&#125;int main() &#123;    Cube C1;    C1.setL(100);    C1.setH(100);    C1.setW(100);    Cube C2;    C2.setL(100);    C2.setH(100);    C2.setW(100);    // 成员函数判断    bool tag = C1.isSame(C2);    if (tag) &#123;        cout &lt;&lt; &quot;C1 和 C2 是相同的 &quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;C1 和 C2 是不同的 &quot; &lt;&lt; endl;    &#125;    // 全局函数判断    isSame(C1, C2);    system(&quot;pause&quot;); &#125;</code></pre><h3 id="4-5-2- 对象的初始化和清理"><a href="#4-5-2- 对象的初始化和清理" class="headerlink" title="4.5.2 对象的初始化和清理"></a>4.5.2 对象的初始化和清理 </h3><h4 id="4-5-2-1- 构造函数和析构函数"><a href="#4-5-2-1- 构造函数和析构函数" class="headerlink" title="4.5.2.1 构造函数和析构函数"></a>4.5.2.1 构造函数和析构函数</h4><p> 对象的初始化和清理也是两个非常重要的安全问题</p><p>一个对象或者变量没有初始状态，对其使用后果是未知的</p><p>同样使用完一个对象或者变量，没有及时清理，也会造成一定的安全问题</p><p>C++ 利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现。</p><ul><li>构造函数：主要作用在于创建对象时为对象成员属性赋值，构造函数由编译器自动调用，无须手动调用。<strong>在创建对象时调用</strong>。</li><li>析构函数：主要作用在于对象销毁系统自动调用，执行一些清理工作。<strong>在销毁对象前调用</strong>。</li></ul><p>构造函数语法：<code>类名 （）&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写 void</li><li>构造函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时会自动调用构造，无须手动调用而且只会调用一次</li></ol><p>析构函数语法：<code>~ 类名（）&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写 void</li><li>析构函数名称与类名相同，在名称前加上符号~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在调用对象时会自动调用析构，无须手动调用而且只会调用一次</li></ol><pre><code class="c++">class Person &#123;public:    //Person 类的构造函数    Person() &#123;        cout &lt;&lt; &quot;Person 构造函数的调用 &quot; &lt;&lt; endl;    &#125;    //Person 类的析构函数    ~Person() &#123;        cout &lt;&lt; &quot;Person 析构函数的调用 &quot; &lt;&lt; endl;    &#125;&#125;;void test() &#123;    Person p;   // 在栈上的数据，函数执行完会被自动释放&#125;int main() &#123;    test();   // 构造，析构函数均会被调用    Person p1;   // 这里不会析构，p1 执行完没被释放，按 enter 后才被释放，调用析构    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-2-2- 构造函数的分类及调用"><a href="#4-5-2-2- 构造函数的分类及调用" class="headerlink" title="4.5.2.2 构造函数的分类及调用"></a>4.5.2.2 构造函数的分类及调用 </h4><p> 两种分类方式：</p><ul><li>按参数分：有参构造和无参构造</li><li>按类型分：普通构造和拷贝构造</li></ul><p>三种调用方式：括号法   显示法   隐式转换法</p><pre><code class="c++">class Person &#123;public:    //Person 类的构造函数    Person() &#123;        cout &lt;&lt; &quot; 默认构造函数的调用 &quot; &lt;&lt; endl;    &#125;    //Person 类的构造函数的重载 --- 有参构造    Person(int a) &#123;        age = a;        cout &lt;&lt; &quot; 有参构造函数的调用 &quot; &lt;&lt; endl;    &#125;    //Person 类的构造函数的重载 --- 拷贝构造    Person(const Person &amp;p) &#123;        age = p.age;        cout &lt;&lt; &quot; 拷贝构造函数的调用 &quot; &lt;&lt; endl;    &#125;    //Person 类的析构函数    ~Person() &#123;        cout &lt;&lt; &quot;Person 析构函数的调用 &quot; &lt;&lt; endl;    &#125;    int age;    int name;&#125;;int main() &#123;    // 括号调用法    Person p1;          // 无参构造调用，注意：无参构造调用不能写括号 p1()    //Person p4(); 这种写法会让编译器认为这是函数声明    Person p2(10);      // 有参构造调用    Person p3(p2);      // 拷贝参构造调用    // 显示法    Person p1;    Person p2 = Person(10); //Person(10); 匿名对象，执行完系统会立即回收    Person p3 = Person(p2);    // 隐式转换法    Person p2 = 10;      // 相当于 Person p2(10)    Person p3 = p2;      // 拷贝构造    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-2-3- 拷贝构造函数调用时机"><a href="#4-5-2-3- 拷贝构造函数调用时机" class="headerlink" title="4.5.2.3 拷贝构造函数调用时机"></a>4.5.2.3 拷贝构造函数调用时机</h4><p>C++ 中拷贝构造函数调用时机通常有三种情况：</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回给局部对象</li></ul><pre><code class="c++">class Person &#123;public:    Person() &#123;        cout &lt;&lt; &quot; 默认构造函数的调用 &quot; &lt;&lt; endl;    &#125;    //Person 类的构造函数的重载 --- 拷贝构造    Person(int a) &#123;        age = a;        cout&lt;&lt; &quot; 有参构造函数的调用 &quot; &lt;&lt; endl;    &#125;    Person(const Person &amp;p) &#123;        age = p.age;        cout &lt;&lt; &quot; 拷贝构造函数的调用 &quot; &lt;&lt; endl;    &#125;    //Person 类的析构函数    ~Person() &#123;        cout &lt;&lt; &quot;Person 析构函数的调用 &quot; &lt;&lt; endl;    &#125;    int age;    int name;&#125;;//1、使用一个已经创建完毕的对象来初始化一个新对象void test1() &#123;    Person p1(20);    Person p2(p1);    cout &lt;&lt; p2.age &lt;&lt; endl;&#125;//2、值传递的方式给函数参数传值void doWork2(Person p) &#123;&#125;void test2() &#123;    Person p1;    doWork2(p1);&#125;//3、以值方式返回给局部对象Person doWork3() &#123;    Person p1;    cout &lt;&lt; (int*)&amp;p1 &lt;&lt; endl;    return p1;&#125;void test3() &#123;    Person p = doWork3();    cout &lt;&lt; (int*)&amp;p &lt;&lt; endl;&#125;int main() &#123;    test1();    cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;    test2();    cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;    test3();    cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-2-4- 构造函数调用规则"><a href="#4-5-2-4- 构造函数调用规则" class="headerlink" title="4.5.2.4 构造函数调用规则"></a>4.5.2.4 构造函数调用规则 </h4><p> 默认情况下，C++ 编译器至少给一个类添加 3 个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性进行值拷贝</li></ol><p>构造函数的调用规则如下：</p><ul><li>如果用户定义有参构造函数，C++ 不再提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，C++ 不会再提供其他构造函数。</li><li><strong>总的来说，必须写拷贝构造函数，有它就行。</strong></li></ul><h4 id="4-5-2-5- 深浅拷贝"><a href="#4-5-2-5- 深浅拷贝" class="headerlink" title="4.5.2.5 深浅拷贝"></a>4.5.2.5 深浅拷贝 </h4><p> 浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p>默认采用类的拷贝构造函数—浅拷贝：</p><pre><code class="c++">class Person &#123;public:    Person() &#123;        cout &lt;&lt; &quot; 默认构造函数的调用 &quot; &lt;&lt; endl;    &#125;    Person(int a,int b) &#123;        age = a;        height = new int(b);        cout&lt;&lt; &quot; 有参构造函数的调用 &quot; &lt;&lt; endl;    &#125;    // 析构函数，将堆区开辟的数据做释放操作    ~Person() &#123;        if (height != NULL) &#123;            delete height;            height = NULL;        &#125;        cout &lt;&lt; &quot;Person 析构函数的调用 &quot; &lt;&lt; endl;    &#125;    int age;    int *height;&#125;;void test1() &#123;    Person p1(18,160);    cout &lt;&lt; p1.age &lt;&lt; endl;    cout &lt;&lt; *p1.height &lt;&lt; endl;    Person p2(p1);         // 默认浅拷贝    cout &lt;&lt; p2.age &lt;&lt; endl;    cout &lt;&lt; *p2.height &lt;&lt; endl;&#125;int main() &#123;    test1();   // 浅拷贝带来的问题是内存的重复释放，造成程序异常终止    system(&quot;pause&quot;); &#125;</code></pre><p>自己写类的拷贝构造函数—深拷贝：</p><pre><code class="c++">class Person &#123;public:    Person() &#123;        cout &lt;&lt; &quot; 默认构造函数的调用 &quot; &lt;&lt; endl;    &#125;    Person(int a,int b) &#123;        age = a;        height = new int(b);         cout&lt;&lt; &quot; 有参构造函数的调用 &quot; &lt;&lt; endl;    &#125;    // 自己写拷贝构造函数    Person(const Person&amp; p) &#123;        age = p.age;        //height = p.height; 编译器默认写法        height = new int(*p.height);  // 深拷贝    &#125;    // 析构函数，将堆区开辟的数据做释放操作    ~Person() &#123;        if (height != NULL) &#123;            delete height;            height = NULL;        &#125;        cout &lt;&lt; &quot;Person 析构函数的调用 &quot; &lt;&lt; endl;    &#125;    int age;    int *height;&#125;;void test1() &#123;...&#125;int main() &#123;...&#125;</code></pre><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="4-5-2-6- 初始化列表"><a href="#4-5-2-6- 初始化列表" class="headerlink" title="4.5.2.6 初始化列表"></a>4.5.2.6 初始化列表 </h4><p> 作用：c++ 提供了初始化列表语法，用来初始化属性</p><p>语法：<code>构造函数（）：属性 1（值 1），属性 2（值 2）&#123;&#125;</code></p><pre><code class="c++">class Person &#123;public:    Person() : A(0), B(0), C(1)&#123;   // 初始化默认属性        cout &lt;&lt; &quot; 构造函数的调用 &quot; &lt;&lt; endl;        cout &lt;&lt; A &lt;&lt; endl;        cout &lt;&lt; B &lt;&lt; endl;        cout &lt;&lt; C &lt;&lt; endl;    &#125;    Person(int a, int b, int c) : A(a), B(b), C(c)&#123;   // 通过传参初始化属性        cout &lt;&lt; &quot; 构造函数的调用 &quot; &lt;&lt; endl;        cout &lt;&lt; A &lt;&lt; endl;        cout &lt;&lt; B &lt;&lt; endl;        cout &lt;&lt; C &lt;&lt; endl;    &#125;    ~Person() &#123;        cout &lt;&lt; &quot; 析构函数的调用 &quot; &lt;&lt; endl;    &#125;private:    int A;    int B;    int C;&#125;;int main() &#123;    Person p(10,20,30);    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-2-7- 类对象作为类成员"><a href="#4-5-2-7- 类对象作为类成员" class="headerlink" title="4.5.2.7 类对象作为类成员"></a>4.5.2.7 类对象作为类成员 </h4><p>C++ 类中的成员可以是另一个类的对象，我们称为该成员为<strong> 对象成员</strong></p><pre><code class="c++">class Phone &#123;public:    string phone_name;    Phone(string pname) &#123;        phone_name = pname;    &#125;        ~Phone() &#123;        cout &lt;&lt; &quot;Phone 析构函数的调用 &quot; &lt;&lt; endl;    &#125;&#125;;class Person &#123;public:    Person(int a,string b) : m_id(a), m_phone(b)    &#123;        cout &lt;&lt; m_id &lt;&lt; endl;        cout &lt;&lt; m_phone.phone_name &lt;&lt; endl;    &#125;    ~Person() &#123;        cout &lt;&lt; &quot;Person 析构函数的调用 &quot; &lt;&lt; endl;    &#125;private:    int m_id;    Phone m_phone;   // 对象成员&#125;;int main() &#123;    Person p(111, &quot;iphone13&quot;);    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-2-8- 静态成员"><a href="#4-5-2-8- 静态成员" class="headerlink" title="4.5.2.8 静态成员"></a>4.5.2.8 静态成员 </h4><p> 静态成员就是在成员变量和成员函数前加上关键字 static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>只能访问静态成员变量</li></ul></li></ul><pre><code class="c++">class Person &#123;public:    static void func()&#123;        cout &lt;&lt; &quot; 静态成员函数的调用 &quot; &lt;&lt; endl;        cout &lt;&lt; m_A &lt;&lt; endl;        //cout &lt;&lt; m_B &lt;&lt; endl;           不能访问 m_B, 静态成员函数只能访问静态成员变量    &#125;    static int m_A;  // 类内声明    int m_B;&#125;;int Person::m_A = 0;  // 类外初始化int main() &#123;    // 通过对象访问    Person p;    p.func();    // 通过类名访问    Person::func();    system(&quot;pause&quot;); &#125;</code></pre><p>static 在 C++ 中的作用：</p><ul><li>在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。</li><li>static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。</li><li>static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。</li><li>不想被释放的时候，可以使用 static 修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。</li><li>考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。</li></ul><p>引用：<a href="https://www.runoob.com/w3cnote/cpp-static-usage.html">C/C++ 中 static 的用法全局变量与局部变量 | 菜鸟教程 (runoob.com)</a></p><h4 id="4-5-2-9-const 成员"><a href="#4-5-2-9-const 成员" class="headerlink" title="4.5.2.9 const 成员"></a>4.5.2.9 const 成员</h4><p><strong>const 对象只能调用 const 成员函数；非 const 对象是可以调用 const 成员函数的。</strong></p><h3 id="4-5-3-C- 对象模型和 this 指针"><a href="#4-5-3-C- 对象模型和 this 指针" class="headerlink" title="4.5.3 C++ 对象模型和 this 指针"></a>4.5.3 C++ 对象模型和 this 指针 </h3><h4 id="4-5-3-1- 成员变量和成员函数分开储存"><a href="#4-5-3-1- 成员变量和成员函数分开储存" class="headerlink" title="4.5.3.1 成员变量和成员函数分开储存"></a>4.5.3.1 成员变量和成员函数分开储存</h4><p> 在 C++ 中，类内的成员变量和成员函数分开储存</p><p>只有非静态成员变量才属于类的对象</p><p>首先举一个简单例子：一个空类占的内存空间</p><pre><code class="c++">class Person &#123;&#125;;void test1() &#123;    Person p1;    cout &lt;&lt; sizeof(p1) &lt;&lt; endl;  // 输出结果 1，C++ 编译器会给每个空对象分配 1 字节空间，是为了区分空对象占内存的位置&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><p>非空类占的内存空间：非静态成员变量才属于类的对象，按 <strong> 成员变量计算内存空间</strong>；静态变量不属于，不计算内存。</p><pre><code class="c++">class Person &#123;public:    void func() &#123;                   // 成员函数分开储存        cout &lt;&lt; m_A &lt;&lt; endl;    &#125;    int m_A;               // 计算成员变量 内存空间 4    static int m_B;        // 不计算&#125;;void test1() &#123;    Person p1;    cout &lt;&lt; sizeof(p1) &lt;&lt; endl;    // 输出结果 4&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-3-2-this- 指针"><a href="#4-5-3-2-this- 指针" class="headerlink" title="4.5.3.2 this 指针"></a>4.5.3.2 this 指针 </h4><p> 每一个非静态成员函数只会诞生一份函数实例，也就是多个同类的对象会共用一块代码，那么这一块代码是如何区分每个对象调用自己的呢？</p><p>C++ 通过提供特殊的对象指针，this 指针，解决上述问题，this 指针指向被调用的成员函数所属的对象</p><p>this 指针是隐含每一个非静态成员函数内的一种指针</p><p>this 指针不需要定义，直接使用即可</p><p>this 指针的用途：</p><ul><li>当形参和成员变量同名时，可以用 this 指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用 return *this</li></ul><pre><code class="c++">class Person &#123;public:    Person(int age) &#123;        this-&gt;age = age;   // 形参 age 和成员变量 age 同名    &#125;    Person&amp; addAge(Person &amp;p) &#123;        this-&gt;age += p.age;        return *this;            // 可以链式调用    &#125;    int age;&#125;;void test1() &#123;    Person p1(18);    cout &lt;&lt; p1.age &lt;&lt; endl;&#125;void test2() &#123;    Person p1(10);    Person p2(10);    p2.addAge(p1).addAge(p1).addAge(p1);    cout &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123;    test1();    test2();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-3-3- 空指针访问成员函数"><a href="#4-5-3-3- 空指针访问成员函数" class="headerlink" title="4.5.3.3 空指针访问成员函数"></a>4.5.3.3 空指针访问成员函数</h4><p>C++ 中空指针也是可以调用成员函数的，但是也要注意有没有用到 this 指针</p><p>如果用到 this 指针，需要加以判断保证代码的健壮性</p><pre><code class="c++">class Person &#123;public:    void func() &#123;        cout &lt;&lt; &quot; 调用成员函数 &quot; &lt;&lt; endl;    &#125;    void getAge() &#123;        cout &lt;&lt; age &lt;&lt; endl;  // 等同于 this-&gt;age，传入的指针为 NULL    &#125;    void getName() &#123;        if (this == NULL) &#123;         // 加个判断，避免传入空指针            return;        &#125;        cout &lt;&lt; name &lt;&lt; endl;    &#125;    int age;    string name;&#125;;void test1() &#123;    Person* p = NULL;    p-&gt;func();    //p-&gt;getAge(); 报错    p-&gt;getName();&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-3-4-const 修饰成员函数"><a href="#4-5-3-4-const 修饰成员函数" class="headerlink" title="4.5.3.4 const 修饰成员函数"></a>4.5.3.4 const 修饰成员函数 </h4><p> 常函数：</p><ul><li>成员函数后加 const 后我们称之为这个函数为常函数</li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字 mutable 后，在常函数中依然可以修改</li></ul><p>常对象：</p><ul><li>声明对象前加 const 称该对象为常对象</li><li>常对象只能调用常函数</li></ul><pre><code class="c++">class Person &#123;public:    // 在成员函数后面加 const，称为常函数，修饰的是 this 指向，让指针指向的值不可以修改    void getAge() const&#123;        //this-&gt;age = 100; // 报错        this-&gt;name = &quot;ssss&quot;;   //name 是 mutable 属性，可以修改    &#125;    void func1() &#123;        this = NULL;     // 报错，this 本质是指针常量，不可以修改指针的指向    &#125;    void func2() &#123;        age = 100;    &#125;    int age;    mutable string name;  // 特殊变量，即使在常函数中，也可以修改这个值&#125;;void test1() &#123;    const Person p;   // 常对象    p.age = 100;     // 报错，也不可修改    p.name = &quot;sd&quot;;   // 可以修改    // 常对象只能调用常函数    p.getAge();    p.func2();   // 报错&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><h3 id="4-5-4- 友元"><a href="#4-5-4- 友元" class="headerlink" title="4.5.4 友元"></a>4.5.4 友元 </h3><p> 在程序里，有的私有属性也想让一些类外特殊的一些函数或者类进行访问，就需要用到 <strong> 友元 </strong> 的技术</p><p>友元的目的就是让一个函数或者类，访问另一个类中私有属性。一个类中可以有多个友元。</p><p>友元的关键字为<code>friend</code></p><p>友元的三种实现：</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><p><strong>全局函数做友元：</strong></p><pre><code class="c++">class Building &#123;    friend void Goodgay(Building&amp; b); // 声明该函数为 Building 类的友元, 可以访问 Building 的私有属性public:    Building() &#123;        m_sittingroom = &quot; 客厅 &quot;;        m_bedgroom = &quot; 卧室 &quot;;    &#125;    string m_sittingroom;private:    string m_bedgroom;&#125;;void Goodgay(Building &amp;b) &#123;    cout &lt;&lt; b.m_sittingroom &lt;&lt; endl;    cout &lt;&lt; b.m_bedgroom &lt;&lt; endl;     // 访问 Building 类的私有属性&#125;void test1() &#123;    Building b1;    Goodgay(b1);&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><p><strong>类做友元</strong>：</p><pre><code class="c++">class Building &#123;    friend class Goodgay;  // 友元可以访问 Building 的私有成员public:    Building();    string m_sittingroom;private:    string m_bedroom;&#125;;class Goodgay &#123;public:    Goodgay();    void visit();    Building *b;&#125;;// 类外写成员函数Building::Building() &#123;    m_sittingroom = &quot; 客厅 &quot;;    m_bedroom = &quot; 卧室 &quot;;&#125;Goodgay::Goodgay()&#123;    b = new Building;&#125;void Goodgay::visit() &#123;    cout &lt;&lt; b-&gt;m_sittingroom &lt;&lt; endl;    cout &lt;&lt; b-&gt;m_bedroom &lt;&lt; endl;&#125;void test1() &#123;    Goodgay gg;    gg.visit();&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><p><strong>成员函数做友元</strong>：</p><pre><code class="c++">class Building;class Goodgay &#123;public:    Goodgay();    void visit();    Building *b;&#125;;class Building &#123;    friend void Goodgay::visit();  // 成员函数做友元public:    Building();    string m_sittingroom;private:    string m_bedroom;&#125;;// 类外写成员函数Building::Building() &#123;    m_sittingroom = &quot; 客厅 &quot;;    m_bedroom = &quot; 卧室 &quot;;&#125;Goodgay::Goodgay()&#123;    b = new Building;&#125;void Goodgay::visit() &#123;    cout &lt;&lt; b-&gt;m_sittingroom &lt;&lt; endl;    cout &lt;&lt; b-&gt;m_bedroom &lt;&lt; endl;          // 可以访问私有属性&#125;void test1() &#123;    Goodgay gg;    gg.visit();&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><blockquote><p>注意 Building 类必须写在 Goodgay 类后面</p></blockquote><p>关于友元，有两点需要说明：</p><ul><li><strong>友元的关系是单向 </strong> 的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。</li><li><strong>友元的关系不能传递</strong>。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。</li></ul><p>以上的例子中，都是使用 A 类中的成员函数作为 B 类的友元，因此 A 可以访问 B 类的私有属性。其实加友元关键字后，该函数可以变成全局函数，这个全局函数写在类内（声明和实现都写在类内）。可以在其他地方直接调用（无需写作用域）。</p><pre><code class="c++">class Person &#123;    // 全局函数在类内实现, 加 friend 关键字    friend void showPerson(Person &amp;p) &#123;        cout &lt;&lt; p.m_name &lt;&lt; endl;        cout &lt;&lt; p.m_age &lt;&lt; endl;    &#125;;public:    Person(string name, int age) &#123;        this-&gt;m_name = name;        this-&gt;m_age = age;    &#125;;private:    string m_name;    int m_age;&#125;;void test() &#123;    Person p1(&quot;Tom&quot;, 25);    showPerson(p1);     // 这是一个全局函数&#125;int main() &#123;    test();    system(&quot;pause&quot;);&#125;</code></pre><h3 id="4-5-5- 运算符重载"><a href="#4-5-5- 运算符重载" class="headerlink" title="4.5.5 运算符重载"></a>4.5.5 运算符重载 </h3><p> 运算符重载的概念：对已有的运算符进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-5-1- 加号运算符重载"><a href="#4-5-5-1- 加号运算符重载" class="headerlink" title="4.5.5.1 加号运算符重载"></a>4.5.5.1 加号运算符重载 </h4><p> 作用：实现两个自定义数据类型相加的运算。对于编译器内置的数据类型（如整型，浮点型），编译器知道如何进行加减乘除，但是对于自定义的数据类型，就不管用了。</p><p><strong>成员函数实现 + 号重载</strong></p><pre><code class="c++">class Person &#123;public:    // 成员函数实现 + 号重载    Person operator+(Person&amp; p) &#123;        Person temp;        temp.m_A = this-&gt;m_A + p.m_A;        temp.m_B = this-&gt;m_B + p.m_B;        return temp;    &#125;    int m_A ;    int m_B ;&#125;;void test1() &#123;    Person p1;    p1.m_A = 10;    p1.m_B = 20;    Person p2;    p2.m_A = 100;    p2.m_B = 200;    Person p3 = p1 + p2;    //Person 类型的数据进行加号运算    cout &lt;&lt; p3.m_A &lt;&lt; endl;    cout &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><p><strong>全局函数实现 + 号重载</strong></p><pre><code class="c++">class Person &#123;...&#125;;// 全局函数重载 + 号运算符Person operator+(Person&amp; p1, Person&amp; p2) &#123;    Person temp;    temp.m_A =p1.m_A + p2.m_A;    temp.m_B = p1.m_B + p2.m_B;    return temp;&#125;</code></pre><p>运算符重载，也可以发生函数重载</p><pre><code class="c++">class Person &#123;...&#125;;Person operator+(Person&amp; p1, Person&amp; p2) &#123;    Person temp;    temp.m_A =p1.m_A + p2.m_A;    temp.m_B = p1.m_B + p2.m_B;    return temp;&#125;Person operator+(Person&amp; p1, int a) &#123;    Person temp;    temp.m_A = p1.m_A + a;    temp.m_B = p1.m_B + a;    return temp;&#125;void test1() &#123;    Person p1；    Person p2;    Person p3 = p1 + p2;    //Person 类型的数据进行加号运算    Person p4 = p1 + 10;    //Person 类型的数据与整型数据进行加号运算&#125;</code></pre><h4 id="4-5-5-2- 左移运算符重载"><a href="#4-5-5-2- 左移运算符重载" class="headerlink" title="4.5.5.2 左移运算符重载"></a>4.5.5.2 左移运算符重载</h4><pre><code class="c++">class Person &#123;public:    int m_A = 10 ;    int m_B = 20 ;&#125;;// 全局函数重载 &lt;&lt; 号运算符ostream &amp; operator&lt;&lt;(ostream &amp;out,Person &amp;p) &#123;    out &lt;&lt; p.m_A &lt;&lt; endl;    out &lt;&lt; p.m_B &lt;&lt; endl;    return out;&#125;void test1() &#123;    Person p1;    cout &lt;&lt; p1 &lt;&lt; endl;   // 重载过的 &lt;&lt; 运算符，可以直接输出 Person 类型的数据    cout &lt;&lt; p1.m_A;  // 原有的 int 类型数据也可以照样输出&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><blockquote><p>左移运算符只能在全局函数中重载。成员函数中达不到这个效果。</p></blockquote><h4 id="4-5-5-3- 递增运算符重载"><a href="#4-5-5-3- 递增运算符重载" class="headerlink" title="4.5.5.3 递增运算符重载"></a>4.5.5.3 递增运算符重载</h4><pre><code class="c++">class Myinteger &#123;    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Myinteger a);public:    Myinteger() &#123;        m_num = 0;    &#125;    // 重载 ++ 运算符，前置 ++    Myinteger&amp; operator++() &#123;        m_num++;        return *this;    &#125;    // 重载 ++ 运算符，后置 ++    Myinteger operator++(int) &#123;     //int 是占位参数，区分前置和后置递增        Myinteger temp = *this;        m_num++;        return temp;   // 返回值，不能返回引用，temp 是一个局部（临时）变量    &#125;private:    int m_num ;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, Myinteger a) &#123;    out &lt;&lt; a.m_num;    return out;&#125;void test1() &#123;    Myinteger m;    cout &lt;&lt; ++m &lt;&lt; endl;  // 结果 1    cout &lt;&lt; m &lt;&lt; endl;    // 结果 1    Myinteger n;    cout &lt;&lt; n++ &lt;&lt;endl;  // 结果 0    cout &lt;&lt; n &lt;&lt; endl;   // 结果 1&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><blockquote><p>重载后置 ++ 时，也可以将 temp 开辟在堆区，就可以返回引用了。</p></blockquote><h4 id="4-5-5-4- 赋值运算符重载"><a href="#4-5-5-4- 赋值运算符重载" class="headerlink" title="4.5.5.4 赋值运算符重载"></a>4.5.5.4 赋值运算符重载</h4><p>C++ 编译器至少给一个类添加 4 个函数</p><ol><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=，对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题。</p><pre><code class="c++">class Person &#123;public:    Person(int age) &#123;        m_A = new int(age);  // 指针 m_A 指向堆区开辟的内存，内存存放 age 的值    &#125;    ~Person() &#123;        if (m_A != NULL) &#123;            delete m_A;            m_A = NULL;        &#125;    &#125;    // 重载赋值运算符    Person &amp;operator=(Person &amp;p) &#123;        //m_A = p.m_A; 编译器提供的浅拷贝        if (m_A != NULL) &#123;   // 先判断是否有属性在堆区，先释放干净，再深拷贝            delete m_A;            m_A = NULL;        &#125;        m_A = new int(*p.m_A);   // 深拷贝        return *this;    &#125;    int* m_A;&#125;;void test1() &#123;    Person p1(20);    Person p2(18);    Person p3(30);    p2 = p1;     // 采用自写的赋值深拷贝    p3 = p2 = p1;  // 链式赋值，这就需要重载赋值时 return 本身    cout &lt;&lt; *p1.m_A &lt;&lt; endl;    cout &lt;&lt; *p2.m_A &lt;&lt; endl;    cout &lt;&lt; *p3.m_A &lt;&lt; endl;&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-5-5- 关系运算符重载"><a href="#4-5-5-5- 关系运算符重载" class="headerlink" title="4.5.5.5 关系运算符重载"></a>4.5.5.5 关系运算符重载 </h4><p> 作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p><pre><code class="c++">class Person &#123;public:    Person(string a, int b) &#123;        m_Name = a;        m_Age = b;    &#125;    bool operator==(Person&amp; p) &#123;        if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123;            return true;        &#125;        else &#123;            return false;        &#125;    &#125;    string m_Name;    int m_Age;&#125;;void test1() &#123;    Person p1(&quot;Tom&quot;, 25);    Person p2(&quot;Tom&quot;, 25);    if (p1 == p2) &#123;        cout &lt;&lt; &quot;the same&quot; &lt;&lt; endl;    &#125;    else &#123;        cout &lt;&lt; &quot;the different&quot; &lt;&lt; endl;    &#125;&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-5-6- 函数调用运算符重载"><a href="#4-5-5-6- 函数调用运算符重载" class="headerlink" title="4.5.5.6 函数调用运算符重载"></a>4.5.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符（）也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><pre><code class="c++">void func()&#123;&#125;func()  //func 是函数名，（）是函数调用的意思</code></pre><p>下面就是重载函数调用符括号（）:</p><pre><code class="c++">class Myprint &#123;public:    void operator()(string test) &#123;        cout &lt;&lt; test &lt;&lt; endl;    &#125;&#125;;class Myadd &#123;public:    int operator()(int a, int b) &#123;        return a + b;    &#125;&#125;;void test1() &#123;    Myprint myprint;    myprint(&quot;hello world&quot;);    Myadd add;    cout &lt;&lt; add(10, 20) &lt;&lt; endl;    cout &lt;&lt; Myadd()(20, 30) &lt;&lt; endl;  // 匿名函数对象&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><h3 id="4-5-6- 继承"><a href="#4-5-6- 继承" class="headerlink" title="4.5.6 继承"></a>4.5.6 继承 </h3><p> 继承的面向对象的三大特性之一。</p><p>有些类与类之间存在特殊的关系，下级别的成员除了拥有上一级的共性，还有自己的特性。这个时候我们就可以考虑利用继承的技术，减少重复代码。</p><h4 id="4-5-6-1- 继承基本语法"><a href="#4-5-6-1- 继承基本语法" class="headerlink" title="4.5.6.1 继承基本语法"></a>4.5.6.1 继承基本语法 </h4><p> 语法：<code>class 子类名：继承方式 父类｛｝</code></p><p>子类也叫派生类；父类也叫基类</p><pre><code class="c++">// 定义父类class BasePage &#123;public:    void header() &#123;        cout &lt;&lt; &quot; 首页、公开课、登陆、注册……(公共头部)&quot; &lt;&lt; endl;    &#125;    void footer() &#123;        cout &lt;&lt; &quot; 帮助中心、交流合作、站内地图……(公共底部)&quot; &lt;&lt; endl;    &#125;private:    int date;&#125;;// 子类：Java 页面，继承 BasePage 类的属性class Java : public BasePage&#123;public:    void content() &#123;        cout &lt;&lt; &quot;JAVA 学科视频 &quot; &lt;&lt; endl;    &#125;&#125;;// 子类：CPP 页面，继承 BasePage 类的属性class CPP : public BasePage &#123;public:    void content() &#123;        cout &lt;&lt; &quot;CPP 学科视频 &quot; &lt;&lt; endl;    &#125;&#125;;void test1() &#123;    Java java;    java.header();    java.footer();    java.content();    CPP cpp;    cpp.header();    cpp.footer();    cpp.content();&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-6-2- 继承方式"><a href="#4-5-6-2- 继承方式" class="headerlink" title="4.5.6.2 继承方式"></a>4.5.6.2 继承方式 </h4><p> 继承方式一共有三种：默认为，私有继承（private）。</p><ul><li>公共继承（public）</li><li>保护继承（protected）</li><li>私有继承（private）</li></ul><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220119164227608.png" alt="继承方式"></p><blockquote><p>基类的私有属性永远都无法通过继承访问。</p><p>只能采用 friend 友元技术访问。</p></blockquote><h4 id="4-5-6-3- 继承中的对象模型"><a href="#4-5-6-3- 继承中的对象模型" class="headerlink" title="4.5.6.3 继承中的对象模型"></a>4.5.6.3 继承中的对象模型 </h4><p> 从父类继承过来的成员，哪些成员继承到子类中了？</p><p>其实，父类中所有的非静态成员属性都会被子类继承下去，只是父类中的私有属性被编译器隐藏了，不可访问，但是确实继承下去了。</p><pre><code class="c++">class BasePage &#123;public:    int a;protected:    int b;private:    int c;&#125;;class Son :public BasePage &#123;public:    int d;&#125;;void test1() &#123;    Son s1;    cout &lt;&lt; sizeof(s1) &lt;&lt; endl;  // 输出 16 （4*4）&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-6-4- 继承中构造和析构顺序"><a href="#4-5-6-4- 继承中构造和析构顺序" class="headerlink" title="4.5.6.4 继承中构造和析构顺序"></a>4.5.6.4 继承中构造和析构顺序 </h4><p> 子类继承父类后，当创建子类对象，也会调用父类的构造函数。那么父类和子类的构造和析构顺序是谁先谁后？</p><pre><code class="c++">class BasePage &#123;public:    BasePage() &#123;        cout &lt;&lt; &quot; 父类构造函数 &quot; &lt;&lt; endl;    &#125;    ~BasePage() &#123;        cout &lt;&lt; &quot; 父类析构函数 &quot; &lt;&lt; endl;    &#125;&#125;;class Son :public BasePage &#123;public:    Son() &#123;        cout &lt;&lt; &quot; 子类构造函数 &quot; &lt;&lt; endl;    &#125;    ~Son() &#123;        cout &lt;&lt; &quot; 子类析造函数 &quot; &lt;&lt; endl;    &#125;&#125;;void test1() &#123;    Son s1;            &#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;/* 输出：父类构造函数子类构造函数子类析造函数父类析构函数*/</code></pre><h4 id="4-5-6-5- 继承中同名成员处理方式"><a href="#4-5-6-5- 继承中同名成员处理方式" class="headerlink" title="4.5.6.5 继承中同名成员处理方式"></a>4.5.6.5 继承中同名成员处理方式 </h4><p><strong> 继承中允许子类和父类有同名成员，不会覆盖</strong>。当子类与父类出现同名的成员，如何通过子类对象，访问到子类或者父类中同名的数据呢？</p><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加作用域</li></ul><pre><code class="c++">class BasePage &#123;public:    void func() &#123;        cout &lt;&lt; &quot; 父类函数的调用 &quot; &lt;&lt; endl;    &#125;    int m_A = 100;    int m_B = 200;&#125;;class Son :public BasePage &#123;public:    void func() &#123;        cout &lt;&lt; &quot; 子类函数的调用 &quot; &lt;&lt; endl;    &#125;    int m_A = 10;&#125;;void test1() &#123;    Son s1;    cout &lt;&lt; s1.m_A &lt;&lt; endl;              // 输出子类中自有的数据    cout &lt;&lt; s1.BasePage::m_A &lt;&lt; endl;    // 输出父类中同名的数据    cout &lt;&lt; s1.m_B &lt;&lt; endl;    s1.func();                     // 输出子类中自有的函数    s1.BasePage::func();           // 输出父类中同名的函数    &#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问父类中同名函数。</li></ol><h4 id="4-5-6-6- 继承同名静态成员处理方式"><a href="#4-5-6-6- 继承同名静态成员处理方式" class="headerlink" title="4.5.6.6 继承同名静态成员处理方式"></a>4.5.6.6 继承同名静态成员处理方式 </h4><p> 问题：继承中同名的静态成员在子类对象如何进行访问</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加作用域</li></ul><pre><code class="c++">class BasePage &#123;public:    static void func() &#123;        cout &lt;&lt; &quot; 父类函数的调用 &quot; &lt;&lt; endl;    &#125;    static int m_A;    int m_B = 200;&#125;;int BasePage::m_A = 100;class Son :public BasePage &#123;public:    static void func() &#123;        cout &lt;&lt; &quot; 子类函数的调用 &quot; &lt;&lt; endl;    &#125;    static int m_A;&#125;;int Son::m_A = 10;void test1() &#123;    Son s1;    // 通过对象访问    cout &lt;&lt; s1.m_A &lt;&lt; endl;              // 输出子类中自有的数据    cout &lt;&lt; s1.BasePage::m_A &lt;&lt; endl;    // 输出父类中同名的数据    cout &lt;&lt; s1.m_B &lt;&lt; endl;    // 通过类名访问    cout &lt;&lt; Son::m_A &lt;&lt; endl;            // 访问子类自己的属性    cout &lt;&lt; Son::BasePage::m_A &lt;&lt; endl;  // 访问子类的父类属性&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-6-7- 多继承语法"><a href="#4-5-6-7- 多继承语法" class="headerlink" title="4.5.6.7 多继承语法"></a>4.5.6.7 多继承语法</h4><p>C++ 允许一个类继承多个类。一个类继承了多个父类，称为多继承。</p><p>语法：<code>class 子类 ：继承方式 父类 1，继承方式 父类 2&#123;&#125;</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><blockquote><p>C++ 实际开发中不建议用多继承</p></blockquote><pre><code class="c++">class Base1 &#123;public:    void func() &#123;        cout &lt;&lt; &quot; 父类 1 函数的调用 &quot; &lt;&lt; endl;    &#125;    int m_A = 100;    int m_B = 200;&#125;;class Base2 &#123;public:     void func() &#123;        cout &lt;&lt; &quot; 父类 2 函数的调用 &quot; &lt;&lt; endl;    &#125;    int m_A = 10;    int m_B = 20;    int m_C = 30;&#125;;class Son :public Base1,public Base2 &#123;public:    void func() &#123;        cout &lt;&lt; &quot; 子类函数的调用 &quot; &lt;&lt; endl;    &#125;    int m_A = 1;    int m_D = 2;&#125;;void test1() &#123;    Son s1;    cout &lt;&lt; s1.m_A &lt;&lt; endl;    cout &lt;&lt; s1.Base1::m_A &lt;&lt; endl;    cout &lt;&lt; s1.Base2::m_A &lt;&lt; endl;    cout &lt;&lt; s1.Base1::m_B &lt;&lt; endl;    cout &lt;&lt; s1.m_C &lt;&lt; endl;&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-6-8- 菱形继承"><a href="#4-5-6-8- 菱形继承" class="headerlink" title="4.5.6.8 菱形继承"></a>4.5.6.8 菱形继承 </h4><p> 菱形继承（钻石）概念：</p><ol><li>两个派生类（B，C）继承同一个基类（A）</li><li>又有某个类（D）同时继承两个派生类</li></ol><p>菱形继承的问题：D 类同时通过从 B/C 类继承了 A 的数据，也就是 D 类有两份 A 的数据，其实我们只需要一份就可以。</p><p>这就需要用到虚继承了，关键字 <code>virtual</code>，解决内存浪费的问题。</p><pre><code class="c++">class Animal &#123;public:    int m_A;&#125;;class Yang: virtual public Animal &#123;&#125;;class Tuo: virtual public Animal &#123;&#125;;class Son :public Yang,public Tuo &#123;&#125;;void test1() &#123;    Son s1;    s1.Yang::m_A = 100;    s1.Tuo::m_A = 10;    cout &lt;&lt; s1.Yang::m_A &lt;&lt; endl;  // 输出 10    cout &lt;&lt; s1.Tuo::m_A &lt;&lt; endl;   // 输出 10    cout &lt;&lt; s1.m_A &lt;&lt; endl;       // 输出 10&#125;int main() &#123;    test1();    system(&quot;pause&quot;); &#125;</code></pre><p>若上述两个类 <code>Yang</code> 和<code>Tuo</code>在继承 <code>Animal</code> 时不加 <code>virtual</code> 关键字，<code>Son</code>类就会继承两份 <code>m_A</code>，且不可用<code>s1.m_A</code> 访问到 m_A 数据。</p><p><strong>函数在基类中被声明为 <code>virtual</code> 后，它在派生类中将自动成为虚方法。此时我们在派生类中将此方法声明不声明为 <code>virtual</code> 都没关系了，但是最好是声明出来好标记哪些方法是虚的。</strong></p><h4 id="4-5-6-9- 链式继承"><a href="#4-5-6-9- 链式继承" class="headerlink" title="4.5.6.9 链式继承"></a>4.5.6.9 链式继承 </h4><p> 链式继承：C 继承自 B，B 继承自 A…</p><pre><code class="c++">class Father &#123;public:    void printA() &#123;        cout &lt;&lt; &quot; 父类中的方法 &quot; &lt;&lt; endl;    &#125;&#125;;class Son:public Father&#123;public:    void printB() &#123;        cout &lt;&lt; &quot; 子类中的方法 &quot; &lt;&lt; endl;    &#125;&#125;;class GrandSon:public Son &#123;public:    void printC() &#123;        cout &lt;&lt; &quot; 孙类中的方法 &quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    GrandSon gs;    gs.printA();    // 输出“父类中的方法”    system(&quot;pause&quot;);&#125;</code></pre><h3 id="4-5-7- 多态"><a href="#4-5-7- 多态" class="headerlink" title="4.5.7 多态"></a>4.5.7 多态 </h3><h4 id="4-5-7-1- 多态的基本概念"><a href="#4-5-7-1- 多态的基本概念" class="headerlink" title="4.5.7.1 多态的基本概念"></a>4.5.7.1 多态的基本概念</h4><p> 多态是 C++ 面向对象三大特性之一，多态分为两类：</p><ul><li>静态多态：函数重载和运算符重载属于静态，复用函数名</li><li>动态多态：派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定—编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定—运行阶段确定函数地址</li></ul><p><strong>静态多态：</strong></p><pre><code class="c++">class Animal &#123;public:    void speak() &#123;        cout &lt;&lt; &quot; 动物在说话 &quot; &lt;&lt; endl;    &#125;&#125;;class Cat:public Animal &#123;public:    void speak() &#123;        cout &lt;&lt; &quot; 小猫在说话 &quot; &lt;&lt; endl;    &#125;&#125;;// 地址早绑定，在编译阶段就确定函数的地址，传的是 animal 对象void doSpeak(Animal &amp;animal) &#123;    animal.speak();    &#125;int main() &#123;    Cat cat;    doSpeak(cat);  // 输出动物说话    system(&quot;pause&quot;); &#125;</code></pre><p><strong>动态多态：</strong></p><p>动态多态满足条件：</p><ul><li><p><strong>得有继承关系</strong></p></li><li><p><strong>子类要重写父类中的虚函数</strong></p><blockquote><p>重写：函数返回值，函数名称，参数列表完全相同</p><p>子类重写时，也可以是虚函数</p></blockquote></li></ul><pre><code class="c++">class Animal &#123;public:        virtual void speak() &#123;                  // 虚函数        cout &lt;&lt; &quot; 动物在说话 &quot; &lt;&lt; endl;    &#125;&#125;;class Cat:public Animal &#123;public:    void speak() &#123;                         // 普通成员函数        cout &lt;&lt; &quot; 小猫在说话 &quot; &lt;&lt; endl;    &#125;&#125;;void doSpeak(Animal &amp;animal) &#123;    animal.speak();       //animal 的 speak 函数定义为虚函数，地址晚绑定&#125;int main() &#123;    Cat cat;    doSpeak(cat);  // 输出小猫说话    Animal animal;    animal.speak(&quot;woo&quot;);   // 父类虚函数也可以直接调用    system(&quot;pause&quot;); &#125;</code></pre><p>动态多态的使用：</p><ul><li><strong>父类的指针或者引用，执行子类对象 </strong>。如上例中，doSpeak() 传入的父类的引用，然后调用的时候，传的是子类对象。</li></ul><p>再举一个链式继承中多态的例子：</p><pre><code class="c++">class Father &#123;public:    virtual void print() &#123;cout &lt;&lt; &quot; 父类中的方法 &quot; &lt;&lt; endl;&#125;&#125;;class Son:public Father&#123;public:    virtual void print() &#123;cout &lt;&lt; &quot; 子类中的方法 &quot; &lt;&lt; endl;&#125;&#125;;class GrandSon:public Son &#123;public:    virtual void print() &#123;cout &lt;&lt; &quot; 孙类中的方法 &quot; &lt;&lt; endl;&#125;&#125;;int main() &#123;    Son son;    Father *fa=&amp;son;    fa-&gt;print();    GrandSon gs;    Father* faa = &amp;gs;    faa-&gt;print();    system(&quot;pause&quot;);&#125;</code></pre><h4 id="4-5-7-2- 多态案例"><a href="#4-5-7-2- 多态案例" class="headerlink" title="4.5.7.2 多态案例"></a>4.5.7.2 多态案例 </h4><p> 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ol><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ol><pre><code class="c++">//--------- 普通类实现 -----------------class Calculator &#123;public:    int getResult(string oper) &#123;        if (oper == &quot;+&quot;) &#123;            return m_num1 + m_num2;        &#125;        else if (oper == &quot;-&quot;) &#123;            return m_num1 - m_num2;        &#125;        else if (oper == &quot;*&quot;) &#123;            return m_num1 * m_num2;        &#125;        // 这个函数里，如果想扩展新功能（如加入开方运算），需要修改源码        // 在真实开发环境中，提倡开闭原则        // 开闭原则：对扩展进行开发，对修改进行关闭    &#125;    int m_num1;    int m_num2;&#125;;void test() &#123;    Calculator cal;    cal.m_num1 = 10;    cal.m_num2 = 5;    cout &lt;&lt; cal.getResult(&quot;*&quot;) &lt;&lt; endl;&#125;//---------- 利用多态实现 ----------------class AbstractCalculator &#123;public:    virtual int getResult() &#123;        return 0;    &#125;    void doOther() &#123;        cout &lt;&lt; &quot;some free&quot; &lt;&lt; endl;    &#125;    int m_A;    // 这两个必须是 public, 否则子类对象不可访问    int m_B;  &#125;;class AddCalculator:public AbstractCalculator &#123;public:    int getResult() &#123;        return m_A + m_B;    &#125;&#125;;class SubCalculator :public AbstractCalculator &#123;public:    int getResult() &#123;        return m_A - m_B;    &#125;&#125;;class MultiCalculator:public AbstractCalculator &#123;public:    int getResult() &#123;        return m_A * m_B;    &#125;&#125;;void test2() &#123;    // 多态的使用条件：父类指针或者引用指向子类对象    AbstractCalculator* abs = new AddCalculator;   // 多态的调用    abs-&gt;m_A = 10;    abs-&gt;m_B = 5;    cout &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;    delete abs;    abs = new SubCalculator;    abs-&gt;m_A = 20;    abs-&gt;m_B = 10;    cout &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;&#125;// 多态好处：组织结构清晰，可读性强，对于前期和后期扩展以及维护性高int main() &#123;    //test();    test2();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-7-3- 纯虚函数和抽象类"><a href="#4-5-7-3- 纯虚函数和抽象类" class="headerlink" title="4.5.7.3 纯虚函数和抽象类"></a>4.5.7.3 纯虚函数和抽象类 </h4><p> 在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容。抽象类是类族的公共接口。</p><p>因此可以将虚函数改为纯虚函数</p><p>纯虚函数语法：<code>virtual 返回类型 函数名（参数列表）= 0；</code></p><blockquote><p>这样不是纯虚函数：<code>virtual 返回类型 函数名（参数列表）&#123;return 0;&#125;</code></p></blockquote><p>当类中有了纯虚函数，这个类就称为抽象类。只要有一个纯虚函数就行，就是抽象类，就满足抽象类的特点。</p><p><strong>抽象类特点：</strong></p><ul><li><p><strong>无法实例化对象</strong></p></li><li><p><strong>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</strong></p></li></ul><pre><code class="c++">//Base 为抽象类class Base &#123;public:    virtual void func() = 0;  // 纯虚函数    void doOther() &#123;        cout &lt;&lt; &quot;free&quot; &lt;&lt; endl;    &#125;&#125;;class Son :public Base &#123;public:    void func() &#123;                                // 重写父类中的抽象类        cout &lt;&lt; &quot; 子类函数的调用 &quot; &lt;&lt; endl;    &#125;&#125;;void test() &#123;    //Base b1; 无法实例化，因为 Base 是抽象类    Base* base = new Son;  // 父类指针或者引用指向子类对象    base-&gt;func();&#125;int main() &#123;    test();    system(&quot;pause&quot;); &#125;</code></pre><blockquote><p>在父类中写纯虚函数，就是为了在子类中重写这个函数。</p></blockquote><h4 id="4-5-7-4- 多态案例"><a href="#4-5-7-4- 多态案例" class="headerlink" title="4.5.7.4 多态案例"></a>4.5.7.4 多态案例 </h4><p> 案例描述：制作饮品的大致流程为：煮水—冲泡—倒入杯中—加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p>咖啡制作：煮水—冲泡咖啡—倒入杯中—加糖和牛奶</p><p>茶水制作：煮水—冲泡茶叶—倒入杯中—加柠檬</p><pre><code class="c++">class AbstractDrinking &#123;public:    virtual void Boil() = 0;  // 煮水    virtual void Brew() = 0;  // 冲泡    virtual void PourInCup() = 0;  // 倒入杯中    virtual void PutSomething() = 0;  // 加入辅料    void makeDrinking() &#123;        Boil();         Brew();         PourInCup();         PutSomething() ;    &#125;&#125;;class MakeCoffee :public AbstractDrinking &#123;public:    void Boil() &#123;        cout &lt;&lt; &quot; 煮纯净水 &quot; &lt;&lt; endl;    &#125;    void Brew() &#123;        cout &lt;&lt; &quot; 冲泡咖啡 &quot; &lt;&lt; endl;    &#125;    void PourInCup() &#123;        cout &lt;&lt; &quot; 将咖啡水倒入杯中 &quot; &lt;&lt; endl;    &#125;    void PutSomething() &#123;        cout &lt;&lt; &quot; 加糖和牛奶 &quot; &lt;&lt; endl;    &#125;&#125;;class MakeTea :public AbstractDrinking &#123;public:    void Boil() &#123;        cout &lt;&lt; &quot; 煮山泉水 &quot; &lt;&lt; endl;    &#125;    void Brew() &#123;        cout &lt;&lt; &quot; 冲泡茶叶 &quot; &lt;&lt; endl;    &#125;    void PourInCup() &#123;        cout &lt;&lt; &quot; 将茶水水倒入杯中 &quot; &lt;&lt; endl;    &#125;    void PutSomething() &#123;        cout &lt;&lt; &quot; 加柠檬 &quot; &lt;&lt; endl;    &#125;&#125;;void test() &#123;    AbstractDrinking* abs = new MakeCoffee;    abs-&gt;makeDrinking();    delete abs;    cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;    abs = new MakeTea;    abs-&gt;makeDrinking();&#125;int main() &#123;    test();    system(&quot;pause&quot;); &#125;</code></pre><h4 id="4-5-7-5- 虚析构和纯虚析构"><a href="#4-5-7-5- 虚析构和纯虚析构" class="headerlink" title="4.5.7.5 虚析构和纯虚析构"></a>4.5.7.5 虚析构和纯虚析构 </h4><p> 多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：<code>virtual ~ 类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><ul><li><code>virtual ~ 类名()=0</code>  在类中定义纯虚析构</li><li><code>类名::~ 类名()&#123;&#125;</code> 在全局中定义具体的实现 </li></ul><pre><code class="c++">class Animal &#123;public:    Animal() &#123;        cout &lt;&lt; &quot; 父类的构造函数的调用 &quot; &lt;&lt; endl;    &#125;    // 利用虚析构可以解决 父类指针释放子类对象不干净的问题    virtual ~Animal() &#123;        cout &lt;&lt; &quot; 父类的析构函数的调用 &quot; &lt;&lt; endl;    &#125;    virtual void Speak() = 0;&#125;;class Cat: public Animal &#123;public:    Cat(string name) &#123;        cout &lt;&lt; &quot; 子类构造函数的调用 &quot; &lt;&lt; endl;        m_Name = new string(name);             // 堆区开辟内存    &#125;    ~Cat() &#123;        if (m_Name != NULL) &#123;            delete m_Name;            m_Name = NULL;            cout &lt;&lt; &quot; 子类析构函数的调用 &quot; &lt;&lt; endl;        &#125;    &#125;    void Speak() &#123;        cout &lt;&lt; *m_Name &lt;&lt; &quot; 小猫在说话 &quot; &lt;&lt; endl;    &#125;    string* m_Name;&#125;;void test() &#123;    Animal* animal = new Cat(&quot;Tom&quot;);   // 子类 Cat 开辟在堆区    animal-&gt;Speak();      delete animal;  // 释放父类指针，父类含有虚析构，就可以走子类的析构&#125;int main() &#123;    test();    system(&quot;pause&quot;); &#125;</code></pre><p>总结：</p><ol><li>虚析构或纯虚构就是用来解决通过父类指针释放子类对象</li><li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构。</li><li>拥有纯虚析构函数的类也属于抽象类</li></ol><h2 id="4-6- 结构体与类"><a href="#4-6- 结构体与类" class="headerlink" title="4.6 结构体与类"></a>4.6 结构体与类 </h2><p> 在<code>C++</code>中，<strong>结构体 </strong> 和<strong>类 </strong> 它们都是有构造函数、析构函数和成员函数的，他们两者的根本区别就是：</p><ul><li><p>结构体中访问控制默认是 <code>public</code> 的</p></li><li><p>而类中默认的访问控制是 <code>private</code> 的。</p></li></ul><p>示例一：</p><pre><code class="c++">struct Mt &#123;    int A ;    int B ;    int get_a() &#123;        return A;    &#125;&#125;;struct Mm :public Mt &#123;int C = 5;&#125;;int main() &#123;    Mm mm;    mm.A = 10;    cout &lt;&lt; mm.A &lt;&lt; endl;       cout &lt;&lt; mm.C &lt;&lt; endl; &#125;</code></pre><blockquote><p>结构体成员函数也用 <strong> 点.</strong> 获取。</p></blockquote><p>示例二：</p><pre><code class="c++">class Mt &#123;    int A ;    int B ;    int get_a() &#123;        return A;    &#125;&#125;;struct Mm :public Mt &#123;int C = 5;&#125;;int main() &#123;    Mm mm;    mm.A = 10;   // 报错，无法访问，Mm 无法继承 Mt 的私有属性（默认私有）&#125;</code></pre><blockquote><p>类和结构体无明显区别，大多数情况下可以看成是一种东西。除了上述提到的默认访问控制问题。</p></blockquote><h2 id="4-7- 文件操作"><a href="#4-7- 文件操作" class="headerlink" title="4.7 文件操作"></a>4.7 文件操作 </h2><p> 通过文件操作将数据持久化</p><p>C++ 中对文件操作需要包含头文件<code>&lt;fstream&gt;</code></p><p>文件类型分为两种：</p><ol><li>文本文件  — 文件以文本 ASCII 码形式存储在计算机中</li><li>二进制文件 — 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类：</p><ol><li>ofstream：写操作，将 <strong> 程序 </strong> 数据输出到文件中</li><li>ifstream：读操作，将文件中数据输入到 <strong> 程序 </strong> 中</li><li>fstream：读写操作</li></ol><h3 id="4-7-1- 文本文件"><a href="#4-7-1- 文本文件" class="headerlink" title="4.7.1 文本文件"></a>4.7.1 文本文件</h3><h4 id="4-7-1-1- 写文件"><a href="#4-7-1-1- 写文件" class="headerlink" title="4.7.1.1 写文件"></a>4.7.1.1 写文件</h4><ol><li>包含头文件 <code>#&lt;fstream&gt;</code></li><li>创建流对象  <code>ofstream ofs;</code></li><li>打开文件  <code>ofs.open(&#39;file_path&#39;, open_mode);</code></li><li>写数据  <code>ofs&lt;&lt;&#39;write txt&#39;;</code></li><li>关闭文件  <code>ofs.close();</code></li></ol><p>文件打开方式 open_mode:</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p>注意：文件打开方式可以配合使用，利用 | 操作符</p><p>如：<code>ios::binary | ios::out</code></p><pre><code class="c++"># include&lt;iostream&gt;# include&lt;string&gt;using namespace std;# include&lt;fstream&gt;void main()&#123;    ofstream ofs;    ofs.open(&quot;test.txt&quot;, ios::out);    ofs &lt;&lt; &quot;xxxxxxx&quot; &lt;&lt; endl;    ofs &lt;&lt; &quot;yyyyyyy&quot; &lt;&lt; endl;    ofs.close();&#125;</code></pre><h4 id="4-7-1-2- 读文件"><a href="#4-7-1-2- 读文件" class="headerlink" title="4.7.1.2 读文件"></a>4.7.1.2 读文件 </h4><p> 读文件步骤如下：</p><ol><li>包含头文件 <code>#&lt;fstream&gt;</code></li><li>创建流对象  <code>ifstream ifs;</code></li><li>打开文件并判断文件是否打开成功 <code>ifs.open(&#39;file_path&#39;, open_mode);</code></li><li>读数据</li><li>关闭文件   <code>ofs.close();</code></li></ol><pre><code class="c++"># include&lt;iostream&gt;# include&lt;string&gt;using namespace std;# include&lt;fstream&gt;void main() &#123;    ifstream ifs;    ifs.open(&quot;test.txt&quot;, ios::in);    if (ifs.is_open()) &#123;        // 读数据        /* 方法 1        char buf[1024] = &#123; 0 &#125;;    // 初始化一个数组        while (ifs &gt;&gt; buf) &#123;            cout &lt;&lt; buf &lt;&lt; endl;        &#125;        */        /* 方法 2        char buf2[1024] = &#123; 0 &#125;;    // 初始化一个数组        while (ifs.getline(buf2, sizeof(buf2))) &#123;            cout &lt;&lt; buf2 &lt;&lt; endl;        &#125;;        */        // 方法 3        string buf3;        while (getline(ifs, buf3)) &#123;            cout &lt;&lt; buf3 &lt;&lt; endl;        &#125;        /* 方法 4        char buf4;        while ((buf4 = ifs.get()) != EOF)&#123;            cout &lt;&lt; buf4 &lt;&lt; endl;&#125;        */        ifs.close();    &#125;    else &#123;        cout &lt;&lt; &quot; 文件打开失败 &quot; &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="4-7-2- 二进制文件"><a href="#4-7-2- 二进制文件" class="headerlink" title="4.7.2 二进制文件"></a>4.7.2 二进制文件 </h3><p> 以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ios::binary</p><h4 id="4-7-2-1- 写文件"><a href="#4-7-2-1- 写文件" class="headerlink" title="4.7.2.1 写文件"></a>4.7.2.1 写文件 </h4><p> 二进制方式写文件主要利用流对象调用成员函数 write</p><p>函数原型：<code>ostream&amp; write(const char* buffer, int len);</code></p><p>参数解释：字符型指针 buffer 指向内存中一段存储空间，len 是读写的字节数</p><h4 id="4-7-2-2- 读文件"><a href="#4-7-2-2- 读文件" class="headerlink" title="4.7.2.2 读文件"></a>4.7.2.2 读文件 </h4><p> 二进制方式读文件主要利用流对象调用成员函数 read</p><p>函数原型：<code>istream&amp; read(char* buffer, int len);</code></p><p>参数解释：字符型指针 buffer 指向内存中一段存储空间，len 是读写的字节数</p><pre><code class="c++"># include&lt;iostream&gt;# include&lt;string&gt;using namespace std;# include&lt;fstream&gt;class Person &#123;public:    char m_name[64];    int age;&#125;;// 二进制文件的写入void write() &#123;    ofstream ofs(&quot;person.txt&quot;, ios::binary | ios::out);;    Person p = &#123; &quot; 张三 &quot;, 18 &#125;;    ofs.write((const char*)&amp;p, sizeof(Person));        //(const char*)强制转换成字符常量指针    ofs.close();&#125;// 二进制文件的读取void read() &#123;    ifstream ifs(&quot;person.txt&quot;, ios::binary | ios::in);    if (ifs.is_open()) &#123;        Person p;        ifs.read((char*)&amp;p, sizeof(Person));        cout &lt;&lt; p.m_name &lt;&lt; endl;        cout &lt;&lt; p.age &lt;&lt; endl;        ifs.close();    &#125;&#125;int main() &#123;    write();    read();&#125;</code></pre><h1 id="五、实战 2- 职工管理系统"><a href="# 五、实战 2- 职工管理系统" class="headerlink" title="五、实战 2- 职工管理系统"></a>五、实战 2- 职工管理系统 </h1><p> 需求：职工管理系统可以用来管理公司内鄋员工的信息</p><p>本案例主要利用 C++ 来实现一个基于多态的职工管理系统</p><p>公司中职工分为三种，普通员工、经理、老板。显示信息时，需要显示职工编号，职工姓名、职工岗位、以及职责</p><p>普通员工职责：完成经理交给的任务</p><p>经理职责：完成老板交给的任务，并下发任务给员工</p><p>老板职责：管理公司所有事务</p><p>管理系统中需要实现的功能如下：</p><ul><li>退出管理程序：退出当前管理系统</li><li>增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号，姓名、部门编号</li><li>显示职工信息：显示公司内部所有职工的信息</li><li>删除离职员工：按照编号删除指定的职工</li><li>修改职工信息：按照编号修改职工个人信息</li><li>查找职工信息：按照编号或者姓名进行查找相关的人员信息</li><li>按照编号排序：按照职工编号，进行排序，排序规则由用户指定</li><li>清空所有文档：清空文件中所有职工信息（清空前需要再次确认，防止误删）</li></ul>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell 编程</title>
      <link href="/shell%E7%BC%96%E7%A8%8B/"/>
      <url>/shell%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、shell 编程概述"><a href="# 一、shell 编程概述" class="headerlink" title="一、shell 编程概述"></a>一、shell 编程概述 </h1><p> 在 Linux 下有一门脚本语言叫做：<strong>Shell 脚本</strong>，这个脚本语言可以帮助我们简化很多工作，例如编写自定义命令等，所以还是很有必要学习它的基本用法的。</p><p>本质上讲，shell 是 linux 命令集的概称，是属于命令行的人机界面。shell 里语句可以直接是 linux 命令的执行。</p><p><strong>shell</strong>分为几个版本，Bourne Shell， C Shell，Bash (Bourne Again Shell)，Korn Shell，Z Shell 等版本。</p><p>常用的 shell 主要有两种：Bash 和 C Shell，特点如下：</p><ul><li>Bash 是 GNU 项目的一部分，是最广泛使用的 Shell 之一。<ul><li>完全兼容 Bourne Shell，并扩展了大量功能，如命令行编辑、命令补全、历史记录等。</li><li>支持函数定义、数组操作、关联数组（从版本 4 开始）等高级特性。</li><li>非常适合脚本编写和日常使用，是 Linux 系统默认的 Shell。</li><li>在 linux 中，默认的环境配置文件路径在~/.bashrc，用户在登录后，默认执行该配置。</li></ul></li><li>C Shell 提供一种更接近于 C 语言语法的脚本环境。<ul><li>支持命令历史记录、别名、文件名补全等功能，提高了交互效率。</li><li>提供了一些类似于 C 语言的控制结构（如 <code>if</code>、<code>switch</code>），便于熟悉 C 的开发者使用。</li><li>不适合复杂的脚本编程，因为它的变量处理不如 Bash 灵活。</li><li>在 linux 中，默认的环境配置文件路径在~/.cshrc，用户在登录后，默认执行该配置。</li></ul></li></ul><h1 id="二、开始 Bshell"><a href="# 二、开始 Bshell" class="headerlink" title="二、开始 Bshell"></a>二、开始 Bshell</h1><p>shell 语言是 linux 命令集的概称，shell 可以通过其条件语句和循环语句等，把一系列 Linux 命令结合在一起，形成一个相当于面向过程的程序。</p><p>同时，在语法上，shell 语言格式与其他编程需要有相当大的不同。这个做一个简单的总结：</p><ul><li>用 # 进行单行注释，也可多行注释，多行注释请百度，一般用的少</li><li>用空格分割命令，空格不能随便用</li><li>用换行分割语句，分号也可用来分割语句。语句可以是一个命令，也可以是一个关键词。</li><li>对缩进没有要求，但是尽可能好看点，便于阅读</li></ul><p>一个简单的 <code>hello.sh</code> 脚本像下面这样：</p><pre><code class="shell">#!/bin/bash                     # 标识该 Shell 脚本由哪个 Shell 解释echo &quot;Hello World!&quot;             # 打印输出字符 Hello World!</code></pre><p><strong>运行 shell 脚本</strong>：在 CMD 命令行下，<code>sh hello.sh</code> 即可，也可 <code>./hello.sh</code> 运行</p><p><strong>后台运行</strong>：<code>sh hello.sh &amp;</code>  ，若退出终端的运行就会挂掉。</p><p><strong>后台挂起运行</strong>：<code>nohup sh hello.sh &amp;</code>，hohup 的作用是：用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</p><p>Shell 的编写流程：</p><ol><li>编写 Shell 脚本</li><li>赋予可执行权限(一般可以忽略)</li><li>执行，调试</li></ol><h2 id="2-1-shell 关键字"><a href="#2-1-shell 关键字" class="headerlink" title="2.1 shell 关键字"></a>2.1 shell 关键字 </h2><p> 所有的 linux 命令都可以在 shell 脚本里直接使用，比如：</p><pre><code class="sh">#!/bin/bashinput=`ls ./teat/*`  #`` 是反引号，通常位于 esc 键下面，用于执行 linux 的 ls 命令并返回结果</code></pre><p>除此之外，bshell 还有以下关键字用于脚本编写。</p><h3 id="2-1-1- 基本关键字"><a href="#2-1-1- 基本关键字" class="headerlink" title="2.1.1 基本关键字"></a>2.1.1 基本关键字 </h3><p> 基本常用的关键字如下：</p><ol><li>echo：打印文字到屏幕</li><li>exec：执行另一个 Shell 脚本</li><li>read：读标准输入</li><li>expr：对整数型变量进行算术运算</li><li>test：用于测试变量是否相等、 是否为空、文件类型等</li><li>exit：退出</li></ol><p>看个例子，新建文件 test.sh，写入：</p><pre><code class="shell">#!/bin/bash echo &quot;Hello Shell&quot;       # 打印输出字符串 Hello Shell# 读入变量（从屏幕输入）read VARecho &quot;VAR is $VAR&quot;     # 计算变量expr $VAR - 5       #算术运算，并返回值# 测试字符串test &quot;Hello&quot;=&quot;HelloWorld&quot;# 测试整数test $VAR -eq 10# 测试目录test -d ./Android# 执行其他 Shell 脚本exec ./othershell.sh# 退出exit</code></pre><blockquote><p>$ 符号是对变量取值</p></blockquote><h3 id="2-1-1- 各种重要符号"><a href="#2-1-1- 各种重要符号" class="headerlink" title="2.1.1 各种重要符号"></a>2.1.1 各种重要符号</h3><ul><li><p><code>$ 变量名</code>：对变量取值</p></li><li><p><code>$&#123; 变量名 &#125;</code>：对变量取值，花括号的作用仅仅是精确界定变量名称的范围。</p></li><li><p><code>$(命令或函数名)</code>：执行命令或函数，并返回执行结果。与反引号  ` 命令或函数名 `  作用一致</p></li><li><p>引号：见 2.2.1 章节</p></li><li><p><code>$[1+2]</code> 与<code>$((2+1))</code>：进行整数运算，注意这里可以没有空格</p></li><li><p>[]：判断符号，用于条件测试，见 2.5 章节</p></li><li><p>(())：整型的计算</p></li><li><p>[[]]：双方括号为字符串比较提供高级功能，模式匹配。常见用法见 2.4.2</p><p>[[是 bash 程序语言的关键字。</p></li><li><p>；分号或换行，一个 / 一句命令的结束</p></li></ul><hr><p><strong>()与 {} 的区别</strong></p><p>相同点：</p><ul><li>()和 {} 都是把一串的命令放在括号里面，如果命令在一行，则命令之间用 ; 隔开</li></ul><p>不同点：</p><ul><li><p>()只是把一串命令重新开一个子 shell 进行执行，不影响当前 shell 环境；{}对一串命令在当前 shell 执行, 影响当前 shell 环境</p></li><li><p>()最后一个命令不用分号，{}最后一个命令要用分号</p></li><li><p>()里的第一个命令和左边括号不必有空格，{}的第一个命令和左括号之间必要要有一个空格</p></li><li><p>()和 {} 中括号里面的某个命令的重定向只影响改名了，但括号外的重定向则影响到括号里的所有命令</p></li></ul><hr><p><strong>== 与 = 的区别</strong></p><ul><li>== 可用于判断变量是否相等，= 除了可用于判断变量是否相等外，还可以表示赋值。</li><li>= 与 == 在 [] 中表示判断 (字符串比较) 时是等价的</li><li>在 (()) 中 = 表示赋值， == 表示判断(整数比较)，它们不等价</li></ul><hr><p><strong>$()的补充用法</strong></p><ul><li>${var:-word}：若 var 为空或未设置，返回默认值但是并不把默认值赋值给该变量，若 var 不为空，则不替换，var 的值不变</li><li>${var:=word}：若 var 为空或未设置，把默认值赋值给该变量。若 var 设置了，则不替换，var 的值不变</li><li>${var:+word}：若 var 不为空时，返回默认值，并且也不重新赋值</li></ul><h2 id="2-2- 字符串"><a href="#2-2- 字符串" class="headerlink" title="2.2 字符串"></a>2.2 字符串</h2><p>shell 就两种数据类型，字符型和数组。数字（整型）也可以看作是一种字符串。</p><p><strong>在 Shell 中所有的变量默认都是字符串型。字符串可以用单引号，也可以用双引号，也可以不用引号。</strong></p><blockquote><p>字符串赋值时，变量名和等号之间 <strong> 不能有空格</strong></p><p>取值时，只要在变量名前面加美元符号 <strong>$</strong> 即可，也可使用 ${变量名}</p></blockquote><h3 id="2-2-1- 引号"><a href="#2-2-1- 引号" class="headerlink" title="2.2.1 引号"></a>2.2.1 引号</h3><ul><li><p>单引号</p><pre><code>str=&#39;this is a string&#39;</code></pre><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul></li><li><p>双引号</p><pre><code>name=&quot;Jack&quot;str=&quot;my name is $name&quot;</code></pre><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul></li><li><p>不加引号</p><pre><code>path=/home/qiang/file=$path/xor.txt</code></pre><p>不加引号特点：</p><ul><li>只能是连续字符串，不能有空格</li><li>可以有变量</li><li>可以出现转义字符</li></ul></li></ul><p>这里补充一个符号：<strong>尖角号 `</strong>（或叫反引号）</p><p>这个符号通常位于键盘 Esc 键的下方。当用尖角号括起来一个 shell 命令时，代表执行这个命令，并将执行的结果返回给赋给的变量。</p><h3 id="2-2-2- 字符串方法"><a href="#2-2-2- 字符串方法" class="headerlink" title="2.2.2 字符串方法"></a>2.2.2 字符串方法</h3><ul><li><p>获取子串长度：<code>$&#123;#str&#125;</code>，获取 str 变量的字符串长度</p></li><li><p>提取子串（切片）：<code>$&#123;str:1:4&#125;</code>，从第 2 个字符开始，截取 4 个字符</p><p><code>$&#123;str:2&#125;</code>，从第 3 个字符开始，截取后面所有字符</p><p><code>$&#123;str:2:-1&#125;</code>，从左往右第 3 位开始截取，从右往左截取到第一位</p></li><li><p>查找子串：</p><pre><code>expr index &quot;$str&quot; xy    #查找字符 x 或 y 的位置(哪个字母先出现就计算哪个)</code></pre></li><li><p>拼接字符串：”hello, “$name” !”，直接写在一块就行。</p></li><li><p>匹配删除：</p><p><code>$&#123;str#*chr&#125;</code>：表示删除从左到右第一个遇到的字符 chr 及其左侧的字符<br><code>$&#123;str##*chr&#125;</code>：表示删除从左到右最后一个遇到的字符 chr 及其左侧的字符（贪婪模式）<br><code>$&#123;str%chr*</code> ：表示删除从右向左第一个遇到的字符 chr 及其右侧的字符<br><code>$&#123;str%%chr*&#125;</code> ：表示删除从右到左最后一个遇到的字符 chr 及其右侧的字符（贪婪模式）</p></li></ul><h2 id="2-3-shell 变量类型"><a href="#2-3-shell 变量类型" class="headerlink" title="2.3 shell 变量类型"></a>2.3 shell 变量类型</h2><p>Shell 变量分为 3 种：</p><ol><li><strong>用户自定义变量</strong><ul><li>等号前后不要有空格：<code>NUM=10</code></li><li>一般变量名用大写：<code>M=1</code></li></ul></li><li><strong>预定义变量</strong></li><li><strong>环境变量</strong></li></ol><h3 id="2-3-1- 自定义变量"><a href="#2-3-1- 自定义变量" class="headerlink" title="2.3.1 自定义变量"></a>2.3.1 自定义变量 </h3><p> 这种变量 <strong> 只支持字符串类型</strong>，不支持其他字符，浮点等类型，常见有这 3 个前缀：</p><ul><li><code>unset</code>：删除变量</li><li><code>readonly</code>：标记只读变量</li><li><code>export</code>：指定全局变量</li></ul><p>一个例子：</p><pre><code class="shell">#!/bin/bash # 定义普通变量CITY=SHENZHEN              #将字符串 SHENZHEN 赋给变量 CITY # 定义全局变量export NAME=cdeveloper     # 定义只读变量readonly AGE=21# 打印变量的值echo $CITYecho $NAMEecho $AGE# 删除 CITY 变量unset CITY</code></pre><h3 id="2-3-2- 预定义变量"><a href="#2-3-2- 预定义变量" class="headerlink" title="2.3.2 预定义变量"></a>2.3.2 预定义变量 </h3><p><strong> 预定义变量常用来获取命令行的输入</strong>，有下面这些：</p><ol><li><code>$0</code> ：脚本文件名</li><li><code>$1-9</code>：第 1-9 个命令行参数名</li><li><code>$#</code>：命令行参数个数</li><li><code>$@</code> ：所有命令行参数</li><li><code>$*</code> ：所有命令行参数</li><li><code>$?</code> ：前一个命令的退出状态，<strong>可用于获取函数返回值</strong></li><li><code>$$</code> ：执行的进程 ID</li></ol><p>在运行 shell 脚本的时候，可以外部传参，供脚本内部使用：</p><pre><code>sh test.sh param1 parma2 parma3     #运行 test.sh 脚本并传入三个参数 param1 parma2 parma3</code></pre><p>这时候这 7 个预定义变量的作用就容易出来了。</p><p>一个例子执行<code>sh.test.sh x y z</code>：</p><pre><code>#!/bin/bashecho $0         #输出 test.shecho $1         #输出 xecho $2         #输出 yecho $3         #输出 zecho $#         #输出 3echo $@         #输出 x y zecho $*         #输出 x y zecho $?         #输出 0echo $$         #输出 184715</code></pre><h3 id="2-3-3- 环境变量"><a href="#2-3-3- 环境变量" class="headerlink" title="2.3.3 环境变量"></a>2.3.3 环境变量 </h3><p> 环境变量默认就存在，常用的有下面这几个：</p><ol><li><code>HOME</code>：代表用户主目录</li><li><code>PATH</code>：代表系统环境变量 PATH</li><li><code>TERM</code>：代表当前终端</li><li><code>UID</code>：代表当前用户 ID</li><li><code>PWD</code>：代表当前工作目录，绝对路径</li></ol><p>看一个例子：</p><pre><code class="sh">#!/bin/bashecho &quot;print env&quot;echo $HOME    #输出 /home/originecho $PATH    #输出 /home/orange/anaconda2/bin: 后面还有很多echo $TERM    #输出 xtermecho $PWD     #输出 /home/origin/testecho $UID     #输出 1674</code></pre><h2 id="2-4-shell 运算符"><a href="#2-4-shell 运算符" class="headerlink" title="2.4 shell 运算符"></a>2.4 shell 运算符</h2><h3 id="2-4-1- 算术运算"><a href="#2-4-1- 算术运算" class="headerlink" title="2.4.1 算术运算"></a>2.4.1 算术运算</h3><p><strong>shell 的算术运算只支持整型数字运算（包括正负整型），不支持浮点数。在算术运算时，非数字的单字符或字符串都被 shell 当作 0。</strong></p><p>由于 Shell 中所有的变量默认都是字符串型，故在运算时，不同于常规运算方法。</p><p>常用的四种运算格式（都是计算 m+1）:</p><ul><li><code>m=$[m + 1]</code>    #空格可有可无</li><li><code>m=expr $m + 1</code>    #中间必须有空格</li><li><code>let m=m+1</code>    #除了 <code>let</code> 后面有空格，计算中必定不能存在空格，只能赋值，不能直接输出</li><li><code>m=$((m + 1))</code>   #空格可有可无</li></ul><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220307194350402.png" style="zoom: 67%;" /><p>另外：还支持自增 ++ 和自减–。</p><p><strong>小数（浮点数）运算</strong></p><ul><li><p><code>bc</code>是 <code>Linux</code> 下的计算机工具模块，<code>bc</code>支持 <code> 交互式 </code> 和<code>非交互式 </code> 两种计算，在进行计算的时候，可以使用 <code>scale=n</code> 来指定小数点的位数，还支持比较操操作符<code>&gt;、&gt;=、&lt;、&lt;=、==、!=</code>。</p></li><li><p><code>交互式</code>：打开 <code>bc</code> 计算机，进行使用。</p></li><li><p><code>非交互式</code>：通过脚本命令执行，不需要打开计算机。</p></li><li><p>在使用 <code>bc</code> 命令时如果报错 <code>bc: command not found</code>，说明没有安装此工具模块，需要进行安装:</p></li></ul><pre><code class="sh">#!/bin/bashecho &quot;scale=2;10/3&quot; | bcresult=`echo &quot;scale=2;10/3&quot; | bc`echo $result</code></pre><ul><li>scale=2 是保留两位有效小数，计算 10/3 的值</li></ul><h3 id="2-4-2- 逻辑运算符"><a href="#2-4-2- 逻辑运算符" class="headerlink" title="2.4.2 逻辑运算符"></a>2.4.2 逻辑运算符</h3><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220307195033890.png" style="zoom: 67%;" /><h3 id="2-4-3- 布尔运算符"><a href="#2-4-3- 布尔运算符" class="headerlink" title="2.4.3 布尔运算符"></a>2.4.3 布尔运算符</h3><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220307195130426.png" style="zoom:67%;" /><h2 id="2-5- 条件测试"><a href="#2-5- 条件测试" class="headerlink" title="2.5 条件测试"></a>2.5 条件测试 </h2><p>shell 条件测试一共就三种：<strong> 文件测试 </strong>，<strong> 数值比较 </strong>，<strong> 字符串比较</strong></p><p>条件测试分为三种用法，但作用是一样的：</p><ul><li>test 条件表达式</li><li>[条件表达式]               注意 <code>[</code> 后要加空格，<code>]</code>前也有空格</li><li>[[条件表达式]]</li></ul><p>推荐使用第二种。</p><p>值得注意的是：<strong>对于条件测试，其中的条件表达式 condition 为真返回 0，假返回 1。这与其他语言不同！</strong></p><p>在 shell 中，命令语句执行完，<strong>其退出状态码，0（成功）表示真，非 0（失败）表示假</strong></p><p><strong>但是用 if [] 的判断条件 if [ 1]时，任何数字都返回真。</strong></p><h3 id="2-5-1- 文件测试"><a href="#2-5-1- 文件测试" class="headerlink" title="2.5.1 文件测试"></a>2.5.1 文件测试</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220307195210982.png" alt=""></p><p>用法示例：</p><pre><code class="shell">[! -d /home/test] &amp;&amp; makdir /home/test     #目录不存在就创建[-d /home/test] || makdir /home/test     #目录存在就不创建test -d /home/testecho $?0                     #在 shell 中，为真的退出状态码为 0，为假时状态码为 1</code></pre><h3 id="2-5-2- 数值比较"><a href="#2-5-2- 数值比较" class="headerlink" title="2.5.2 数值比较"></a>2.5.2 数值比较 </h3><p> 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220307195248494.png" alt=""></p><p>用法示例：</p><pre><code class="shell">disk_use=`df -Th`|grep &#39;/$&#39;|awk &#39;&#123;print $(NF-1)&#125;&#39;|awk -F &quot;%&quot; &#39;&#123;print $1&#125;&#39;  #磁盘利用率user=Aliceif [$disk_use -ge 90]; then   echo &quot;`data +%F-%H` disk: $&#123;disk_use&#125;%&quot;|mail -s &quot;disk war...&quot; $userfi</code></pre><p>数值比较还支持 C 语言风格：如 <code>((1&lt;10))，((1&lt;=10))</code> 这种，这里不多做介绍。</p><h3 id="2-5-3- 字符串比较"><a href="#2-5-3- 字符串比较" class="headerlink" title="2.5.3 字符串比较"></a>2.5.3 字符串比较 </h3><p><strong> 字符串变量要使用双引号引起来</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220307195333214.png" alt=""></p><p>用法示例：</p><pre><code class="shell">[aaa = abb];echo $?            #输出 1   1 为假[&quot;aaa&quot; = &quot;aaa&quot;];echo $?        #输出 0   0 为真str=asdstr2=abc[&quot;$str&quot; = &quot;$str2&quot;];echo $?     #输出 1    </code></pre><h2 id="2-6-shell 语句"><a href="#2-6-shell 语句" class="headerlink" title="2.6 shell 语句"></a>2.6 shell 语句 </h2><h3 id="2-6-1-if 语句"><a href="#2-6-1-if 语句" class="headerlink" title="2.6.1 if 语句"></a>2.6.1 if 语句</h3><p> 格式：</p><pre><code>if 条件测试 1then   执行语句 1elif 条件测试 2then   执行语句 2   else   执行语句 2fi  </code></pre><p>用法示例：</p><pre><code class="shell">#!/bin/bash VAR=10if [$VAR -eq 10]    #if test $VAR -eq 10then    echo &quot;true&quot;else    echo &quot;false&quot;fi</code></pre><h3 id="2-6-2-case 语句"><a href="#2-6-2-case 语句" class="headerlink" title="2.6.2 case 语句"></a>2.6.2 case 语句 </h3><p> 格式：</p><pre><code class="shell">case 变量 in    值 1)      执行语句 1      ;;    值 2)      执行语句 2      ;;    *)      执行语句 3      ;;esac    </code></pre><h3 id="2-6-3-for 语句"><a href="#2-6-3-for 语句" class="headerlink" title="2.6.3 for 语句"></a>2.6.3 for 语句 </h3><p> 格式：</p><pre><code class="sh">for ((i = 1; i &lt;= 3; i++))do    echo $idonefor j in 1 2 3do    echo $jdonefor j in &#123;0..100&#125;    #输出 0-100do    echo $jdoneworkspace=&quot;/home/user1/project&quot;input=`ls ./teat/*.gg`for ff in $inputdo    out=&quot;$workspace/$input&quot;    echo $outdone</code></pre><h3 id="2-6-4-while 语句"><a href="#2-6-4-while 语句" class="headerlink" title="2.6.4 while 语句"></a>2.6.4 while 语句 </h3><p> 格式：</p><pre><code class="sh">while 条件测试       #条件为真，执行do    执行语句  done</code></pre><h3 id="2-6-5-until 语句"><a href="#2-6-5-until 语句" class="headerlink" title="2.6.5 until 语句"></a>2.6.5 until 语句 </h3><p> 格式：</p><pre><code class="sh">until 条件测试       #条件为假，执行do      echo $i    i=$[$i + 1]done</code></pre><h3 id="2-6-6-break"><a href="#2-6-6-break" class="headerlink" title="2.6.6 break"></a>2.6.6 break</h3><p>Shell 中的 <code>break</code> 用法与高级语言相同，都是 <strong> 跳出循环</strong>，来看个例子：</p><pre><code class="sh">for VAR in 1 2 3do    if [$VAR -eq 2]    then        break    fi    echo $VARdone</code></pre><h3 id="2-6-7-continue"><a href="#2-6-7-continue" class="headerlink" title="2.6.7 continue"></a>2.6.7 continue</h3><p><code>continue</code> 用来 <strong> 跳过本次循环</strong>，进入下一次循环</p><pre><code class="shell">for VAR in 1 2 3do    if [$VAR -eq 2]    then        continue        fi    echo $VARdone</code></pre><h2 id="2-7-shell 数组"><a href="#2-7-shell 数组" class="headerlink" title="2.7 shell 数组"></a>2.7 shell 数组</h2><p>shell 就两种数据类型，字符型和数组。字符串之前已经介绍了，这里介绍数组。</p><p>数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小。</p><h3 id="2-7-1- 数组定义"><a href="#2-7-1- 数组定义" class="headerlink" title="2.7.1 数组定义"></a>2.7.1 数组定义</h3><pre><code class="shell"># 第一种arr=(v1 v2 v3 v4 v5)    #v 可以是字符串或者数字，不必类型相同#第二种arr1=(xxxyyyzzz)#数组的遍历for case in $&#123;arr1[*]&#125;do  echo $casedone#单独赋值arr[1]=10#第三种: 用字符串实现同样的功能arr2=&quot;xxxyyyzzz&quot;#字符串的遍历for item in $arr2do    echo $itemdone</code></pre><blockquote><p>一对括号 (…) 表示的是数组，数组元素用空格符号分隔开</p><p>数组和字符串循环取值的方式不同，注意区分</p></blockquote><h3 id="2-7-2- 读取与赋值"><a href="#2-7-2- 读取与赋值" class="headerlink" title="2.7.2 读取与赋值"></a>2.7.2 读取与赋值</h3><ul><li>读取数组：<ul><li>读取整个数组：<code>$&#123;arr[@]&#125;</code>   或者   <code>$&#123;arr[*]&#125;</code></li><li>按索引读取：<code>$&#123;arr[index]&#125;</code>，索引从 0 开始</li></ul></li><li>读取长度：<code>$&#123;#arr[@]&#125;</code>   或者   <code>$&#123;#arr[*]&#125;</code></li><li>赋值：<code>arr[1]=100</code></li><li>删除：<code>unset arr[1]</code>  或 <code>unset arr</code></li><li>替换：<code>$&#123;a[@或 *] / 查找字符 / 替换字符 &#125;</code> ，该操作不会改变原来的数组内容</li></ul><p>一个常用的例子：</p><pre><code class="shell">caselist=($(ls /home/template_dir | grep -v &#39;xor&#39;))for case in $&#123;caselist[*]&#125;do  echo $casedone</code></pre><h2 id="2-8-shell 函数"><a href="#2-8-shell 函数" class="headerlink" title="2.8 shell 函数"></a>2.8 shell 函数 </h2><p><strong>shell 函数中，默认均为全局变量</strong>，如想用局部变量加<code>local</code> 关键字</p><h3 id="2-8-1- 函数定义与调用"><a href="#2-8-1- 函数定义与调用" class="headerlink" title="2.8.1 函数定义与调用"></a>2.8.1 函数定义与调用 </h3><p> 格式 1：</p><pre><code class="shell">function fun1()&#123;         #如果写了 function 关键字，（）可以省略   echo $1       #返回方式 1   echo $2   return 0      #返回方式 2&#125;#1 直接函数名调用, 并传参fun1 10 20#2 间接调用F=`fun1 100 200`echo $F</code></pre><p>格式 2：</p><pre><code class="shell">fun2()&#123;  echo &quot;fun2 call&quot;  &#125;#3 直接函数名调用，不带参数方式fun2</code></pre><p>Shell 函数返回值，常用的两种方式：return、echo。二者是有差别的</p><ul><li>return：只能用来返回整数值（0-255），一般是用来表示函数执行成功与否的，0 表示成功，其他值表示失败。</li><li>echo：标准输出返回，可以返回任何类型的数据。</li></ul><h3 id="2-8-2- 获取函数返回值"><a href="#2-8-2- 获取函数返回值" class="headerlink" title="2.8.2 获取函数返回值"></a>2.8.2 获取函数返回值</h3><ul><li><p>函数用 echo 输出返回：直接函数名调用</p></li><li><p>函数用 return 输出返回：<code>$?</code> 接收，<code>$?</code>要紧跟在函数调用处的后面</p></li></ul><p>先举个例子：</p><pre><code class="shell">fun2()&#123;  echo &quot;fun2 call&quot;  return 100&#125;fun2        # 输出 echo 的内容：  fun2 callecho $?      #输出 return 的内容：100echo $?      #输出函数退出码：0</code></pre><p>还有 2 种：</p><ul><li>函数名当命令执行：`fun2` (尖角号)    或者   $(fun2)</li><li>传参输出返回：$(fun2  “/temp”)</li></ul><p>再举个例子：</p><pre><code class="shell">fun3()&#123;  echo &quot;fun3 call&quot;&#125;echo `fun3`      #输出打印 fun3 callecho $(fun3)     #输出打印 fun3 callre=$(fun3) echo $&#123;re&#125;       #输出打印 fun3 call</code></pre><h3 id="2-8-3- 高级收参"><a href="#2-8-3- 高级收参" class="headerlink" title="2.8.3 高级收参"></a>2.8.3 高级收参</h3><p>$@ 可以接收所有参数，以数组的方式。</p><pre><code class="shell">function getsum()&#123;    local sum=0    for n in $@    do         ((sum+=n))    done    echo $sum    return 0&#125;total=$(getsum 10 20 55 15)echo $total</code></pre><h2 id="2-9-shell 重定向"><a href="#2-9-shell 重定向" class="headerlink" title="2.9 shell 重定向"></a>2.9 shell 重定向 </h2><h3 id="2-9-1- 输出重定向"><a href="#2-9-1- 输出重定向" class="headerlink" title="2.9.1 输出重定向"></a>2.9.1 输出重定向</h3><p> 命令的结果不再输出到显示器上，而是输出到指定的文件里。</p><ul><li><strong>命令输出重定向</strong></li></ul><p>格式：</p><pre><code>command &gt; file       #覆盖写入到文件command &gt;&gt; file      #追加写入到文件 </code></pre><p> 用法示例：</p><pre><code class="shell">echo &quot;hello world!&quot; &gt; data.txtls -l &gt;&gt; data.txt</code></pre><ul><li><strong>cat 输出重定向 </strong>：<strong> 用于多行文本写入</strong></li></ul><p>用法示例：</p><pre><code class="shell">cat &gt; file &lt;&lt; EOFexport ORACLE_SID=yqpt export PATH=\$PATH:\$ORACLE_HOME/bin  EOF</code></pre><p>作用：将两个 EOF 之间的内容输出写到 data.txt 文件里。</p><ol><li>EOF 只是一个标识符，也可使用其他字符代替</li><li>多行文本如有 $ 等特殊字符时，须利用转义字符 \</li></ol><h3 id="2-9-2- 输入重定向"><a href="#2-9-2- 输入重定向" class="headerlink" title="2.9.2 输入重定向"></a>2.9.2 输入重定向 </h3><p> 使用文件作为命令的输入。</p><pre><code>command &lt; file       #将 file 文件中的内容作为 command 的输入command &lt;&lt; END       #从标准输入（键盘）中读取数据，直到遇见分界符 END 才停止 </code></pre><p> 高级用法（代码输入重定向）示例：</p><pre><code class="shell">#!/bin/bashsum=0while read n; do    ((sum += n))done &lt; nums.txt      #输入重定向echo &quot;sum=$sum&quot;</code></pre><h2 id="2-10-shell 调试"><a href="#2-10-shell 调试" class="headerlink" title="2.10 shell 调试"></a>2.10 shell 调试 </h2><p><strong> 检查是否有语法错误：</strong></p><pre><code>sh -n script_name.sh</code></pre><p><strong>执行并逐步调试 shell 脚本：</strong></p><pre><code>sh -x script_name.sh</code></pre><p><strong>带有 <code>+</code> 表示的是 <code>Shell</code> 调试器的输出 </strong>，<strong> 不带 <code>+</code> 表示我们程序的输出</strong>。</p><h1 id="三、开始 Cshell"><a href="# 三、开始 Cshell" class="headerlink" title="三、开始 Cshell"></a>三、开始 Cshell</h1><h2 id="1- 变量声明"><a href="#1- 变量声明" class="headerlink" title="1. 变量声明"></a>1. 变量声明</h2><pre><code class="sh">#!/bin/csh#使用 set 声明变量set enc = &quot;this is a test!&quot;set ax = 10echo $encecho $ax</code></pre><h2 id="2- 数组与循环"><a href="#2- 数组与循环" class="headerlink" title="2. 数组与循环"></a>2. 数组与循环</h2><pre><code class="sh">#!/bin/cshset myarr = (&quot;aa&quot; &quot;bb&quot; &quot;cc&quot;)echo $myarr[1]  #index 从 1 开始echo $#myarr    #输出元素个数foreach el ($&#123;myarr&#125;)    set out = $elend</code></pre><h2 id="3- 环境配置与别名声明"><a href="#3- 环境配置与别名声明" class="headerlink" title="3. 环境配置与别名声明"></a>3. 环境配置与别名声明 </h2><p> 一般 csh 的默认配置文件为：~/.cshrc，可以在里面配置一些环境。</p><pre><code class="sh">setenv PATH /home/user1/install/   #配置环境变量alias .. &quot;cd ..&quot;    #别名（快捷命令）alias python &quot;/home/user1/install/python3.10&quot;</code></pre><h2 id="4- 逻辑判断与循环语句"><a href="#4- 逻辑判断与循环语句" class="headerlink" title="4. 逻辑判断与循环语句"></a>4. 逻辑判断与循环语句</h2><h3 id="4-1-if- 判断"><a href="#4-1-if- 判断" class="headerlink" title="4.1 if 判断"></a>4.1 if 判断</h3><pre><code class="sh">#!/bin/cshset num = 5if ($num == 1) then    echo &quot;Number is 1&quot;else if ($num == 2) then    echo &quot;Number is 2&quot;else if ($num == 3) then    echo &quot;Number is 3&quot;else    echo &quot;Number is not 1, 2, or 3&quot;endif</code></pre><h3 id="4-2- 循环语句"><a href="#4-2- 循环语句" class="headerlink" title="4.2 循环语句"></a>4.2 循环语句</h3><pre><code class="sh">#!/bin/csh# foreachset myarr = (&quot;aa&quot; &quot;bb&quot; &quot;cc&quot;)foreach el ($&#123;myarr&#125;)    set out = $elend#whileset sum = 0set i = 1while ($i &lt;= 5)    set sum = `expr $sum + $i`    set i = `expr $i + 1`endecho &quot;Sum is $sum&quot;#switchswitch ($sum)  case 1:     # commands    breaksw  case 2:      #commands  default:    breakswendsw</code></pre><h2 id="5- 数据重定向"><a href="#5- 数据重定向" class="headerlink" title="5. 数据重定向"></a>5. 数据重定向</h2><pre><code class="sh">#!/bin/csh#单行重定向echo &quot;this is a test&quot; &gt; tt.log#多行重定向set words = (&quot;test1&quot; &quot;test2&quot; &quot;test3&quot;)cat &gt; tt.log &lt;&lt; ENDthis is a $words[1]this is a $words[2]this is a $words[3]END</code></pre><h2 id="6- 数学计算"><a href="#6- 数学计算" class="headerlink" title="6. 数学计算"></a>6. 数学计算</h2><pre><code class="sh">#!/bin/cshset a = 10set b = 20#第一种，exprset sum = `expr $a + $b`set product = `expr $a \* $b`#第二种，@@ sum = $a + $bproduct =  $a * $becho $sumecho $product# 小数计算set result = `echo &quot;scale=2;10/3&quot; | bc`echo $result</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 版本控制工具</title>
      <link href="/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
      <url>/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>关于 GitHub 访问巨慢或者打不开的解决方案：<a href="https://nyakohub.github.io/technology/how-to-access-github-stably.html">如何稳定访问 github (nyakohub.github.io)</a></p><p>推荐上文的第四种方案 –&gt; <a href="https://github.com/dotnetcore/FastGithub">dotnetcore/FastGithub: github 加速神器，解决 github 打不开、用户头像无法加载、releases 无法上传下载、git-clone、git-pull、git-push 失败等问题</a></p><hr><p>正文开始介绍 Git 版本控制工具。</p><h1 id="1、基本知识点"><a href="#1、基本知识点" class="headerlink" title="1、基本知识点"></a>1、基本知识点 </h1><p> 首先你要知道 Git 的工作流程：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220305113602583.png" alt=""></p><p>Git 仓库一共分为 4 个区：<strong>工作区；暂存区；本地仓库，远程仓库</strong>。前三个区都是在你电脑本地的，远程仓库我们一般在 GitHub 托管平台上。</p><p>首先我们看看一个 Git 仓库文件夹目录：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220305130607994.png" alt=""></p><ul><li>workspace/  就是 <strong> 工作区</strong></li><li>.git/index/     就是 <strong> 暂存区</strong>，暂存区只是一个简单的索引文件而已，包含的是文件的目录树。索引指向的是.git/objects 下的文件。 </li><li>.git/                就是 <strong> 本地仓库</strong></li></ul><h1 id="2、创建 GitHub 账号"><a href="#2、创建 GitHub 账号" class="headerlink" title="2、创建 GitHub 账号"></a>2、创建 GitHub 账号</h1><ol><li><p>登录 GitHub 官网：<a href="https://github.com/">GitHub</a>，Sign up 注册；Sign in 登录。</p></li><li><p>新建仓库 New repository，取好名字。</p></li><li><p>复制 SSH key 到 GitHub，将~/.ssh/id_rsa.pub 中的内容复制到 GitHub—Setting—SSH and GPG keys—new SSH key 里面即可。</p><pre><code># 在 cmd 中执行以下命令创建 SSH key：$ ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;# 或者$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></pre><p>完毕后，本地电脑就会新建~/.ssh/id_rsa.pub 和 id_rsa 文件。</p></li></ol><p>此时基本工作已经完毕。本地就可以和远程 GitHub 进行通信了！</p><blockquote><p>id_rsa 和 id_rsa.pub 这两个文件，分别对应私钥和公钥</p></blockquote><p>如有需要，本地存在多个 SSH keys，可参照 <a href="https://jqiange.github.io/Hexo 博客迁移与多平台使用 /">Hexo 博客迁移与多平台使用 | jqiange</a>   第 2.3 章节处理</p><h1 id="3、本地实战"><a href="#3、本地实战" class="headerlink" title="3、本地实战"></a>3、本地实战 </h1><p> 开始之前，要安装好 Git 管理工具：</p><ul><li>Windows 下安装：<a href="https://gitforwindows.org/">Git for Windows</a></li><li>Linux 安装：<code>apt-get install git</code></li></ul><h2 id="3-1- 从本地到远程"><a href="#3-1- 从本地到远程" class="headerlink" title="3.1 从本地到远程"></a>3.1 从本地到远程 </h2><h3 id="3-1-1- 初始化"><a href="#3-1-1- 初始化" class="headerlink" title="3.1.1 初始化"></a>3.1.1 初始化</h3><p> 首先选一个工作目录，如 D/test/，将其变成 git 本地仓库。</p><p>右键，Git Bash Here，执行命令：<code>git init</code> 则创建隐藏文件<code>.git</code>，暂存区和本地仓库就这个文件夹里面。</p><p><code>.git</code>里文件如下：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201028211359921.png" alt=""></p><h3 id="3-1-2- 设置签名"><a href="#3-1-2- 设置签名" class="headerlink" title="3.1.2 设置签名"></a>3.1.2 设置签名 </h3><p> 用以区分不同开发人员身份。用以告诉 git 是谁提交的代码。</p><p>一般采用第二种。</p><p>（1）本地库级别设置签名命令：</p><p><code>git config user.name zs</code></p><p><code>git config user.email zs@qq.com</code></p><p>信息保存位置：./.git/config 文件(系统用户名文件里)</p><p>（2）一般直接设置系统级别的签名：</p><p>系统用户级别设置签名方式：</p><p><code>git config --global user.name zs</code></p><p><code>git config --global user.email zs@qq.com</code></p><p>信息保存位置：./.gitconfig 文件</p><h3 id="3-1-3- 添加和查看远程仓库"><a href="#3-1-3- 添加和查看远程仓库" class="headerlink" title="3.1.3 添加和查看远程仓库"></a>3.1.3 添加和查看远程仓库 </h3><p> 添加远程仓库：</p><ul><li><code>git remote add origin 远程仓库地址.git</code>     这里 origin 是给远程仓库取的别名</li></ul><p>修改远程仓库：</p><ul><li><code>git remote set-url origin  新仓库地址</code> 可修改远程仓库地址</li></ul><p>显示远程仓库</p><ul><li><p><code>git remote</code>可显示远程仓库的别名</p></li><li><p><code>git remote -v</code>可显示远程仓库的地址</p></li></ul><h3 id="3-1-4- 保存并上传文件"><a href="#3-1-4- 保存并上传文件" class="headerlink" title="3.1.4 保存并上传文件"></a>3.1.4 保存并上传文件</h3><ol><li><p>上传到暂存区</p><p><code>git add 文件名</code></p><p><code>git add --all</code>上传所有未提交文件</p></li><li><p>提交到本地仓库</p><p><code>git commit -m &quot; 第一次代码提交 &quot;</code></p><p>-m 后面加提交说明文字。</p></li><li><p>推送到远程仓库</p><p><code>git push -u 仓库别名 分支</code></p><p>如：<code>git push -u origin master</code></p><p>把当前分支 master 推送到远程 master 分支，-u 会把本地 master 分支和远程 master 分支关联起来。下一次再提交的话就可以省略 -u。</p></li></ol><p>切换到分支 zs：<code>git checkout zs</code></p><p>推送分支：<code>git push -u origin zs</code></p><h3 id="3-1-5- 忽略文件"><a href="#3-1-5- 忽略文件" class="headerlink" title="3.1.5 忽略文件"></a>3.1.5 忽略文件 </h3><p> 文件夹里有些文件不需要上传到 GitHub，可使用命令：</p><p><code>touch .gitignore</code>生成忽略文件，并将其打开，写入忽略文件的格式，如<code>*.doc</code>，即为不上传后缀为.doc 的文件到 GitHub。</p><h3 id="3-1-6- 状态查看"><a href="#3-1-6- 状态查看" class="headerlink" title="3.1.6 状态查看"></a>3.1.6 状态查看</h3><p><code>git status</code>   查看哪些文件未传</p><p><code>git log</code>         查看提交日志</p><h3 id="3-1-7- 本地误删恢复"><a href="#3-1-7- 本地误删恢复" class="headerlink" title="3.1.7 本地误删恢复"></a>3.1.7 本地误删恢复</h3><blockquote><p>只有被 commit 后的文件才能被恢复，若文件只是 add 到暂存区，则不能恢复。</p></blockquote><p><code>git status</code>可以看到哪些文件被误删</p><p>依次执行：</p><pre><code>git reset HEAD filename git checkout filename </code></pre><p>这里举一个 <strong> 例子</strong>：文件 1 被 add 和 commit；文件 1 在工作区被修改为文件 2，文件 2 只是被 add，忘记 commit 了，然后文件 2 被修改为文件 3，此时又觉得文件 3 写了一半觉得不好，想回退到文件 2，于是执行 git reset –head HEAD，则工作区代码直接回退到文件 1（因为本地仓库只记住了代码 1 的样子，回到当前代码，就是代码 1 了），代码 2 就永久消失了。</p><h3 id="3-1-8- 分支管理"><a href="#3-1-8- 分支管理" class="headerlink" title="3.1.8 分支管理"></a>3.1.8 分支管理 </h3><p> 每个开发者都可以有一个分支。通常还有 div 分支以及 master 分支。git 所有分支之间彼此互不干扰，各自完成各自的工作和内容。可以在分支使用完后 <strong> 合并到总分支(原分支)</strong> 上，安全、便捷、不影响其他分支工作。</p><p>从项目创建之初，有且唯一的分支就是主分支，主分支被叫做<code>master</code>。</p><p><code>git branch</code>                   查看当前分支</p><p><code>git branch zs</code>             创建 zs 分支</p><p><code>git checkout zs</code>         切换分支</p><p><code>git branch -d zs</code>       删除分支</p><p><code>git checkout -b zs</code>   创建的同时切换分支</p><p><code>git merge zs</code>    合并 zs 分支，在 master 分支上执行</p><p><code>git branch -a</code>查看远程分支</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200518211946104.png" alt=""></p><h2 id="3-2- 从远程到本地"><a href="#3-2- 从远程到本地" class="headerlink" title="3.2 从远程到本地"></a>3.2 从远程到本地 </h2><p> 当从远程仓库拉取最新的代码到本地时，使用</p><pre><code>git pull或git pull origin master</code></pre><blockquote><p>如果本地代码为最新，上述命令就没有作用，远程代码不会替换掉本地的。</p><p>只有远程是最新的时候，才会 pull 成功。</p></blockquote><p>以上是本地仓库与远程仓库发生的互动。</p><p>但若本地不是仓库，只是个普通文件夹时，可以使用 git clone 获取到远程资源：</p><p><code>git clone git@github.com:xxxx.git</code></p><p>完成之后，就将整个仓库克隆下来了，文件名就是仓库名，同时我们可以发现，克隆下来的文件就变成仓库了，包含.git 文件夹，git 命令也有反应。</p><h2 id="3-3- 冲突"><a href="#3-3- 冲突" class="headerlink" title="3.3 冲突"></a>3.3 冲突 </h2><p> 有时候，我们会遇到 <code>git push</code> 或者<code>git pull</code> 发生 conflict 的情况，一般来讲可能有以下几种原因：</p><h3 id="3-3-1-git-push- 发生冲突"><a href="#3-3-1-git-push- 发生冲突" class="headerlink" title="3.3.1 git push 发生冲突"></a>3.3.1 git push 发生冲突 </h3><p> 一般来讲，发生这种现象的原因是：</p><ul><li>我们本地版本是旧版本 v0，在没有拉取最新版本 v1 的情况下，我们在旧版本 V0 直接改动进行 push v1’，这时 v1 就和 v1’发生冲突；或者我们在改动本地之前拉取了最新版本 v1，然后别人又 push 了新版本 v2，等我们改动后进行 push v2’的时候，这时 v2 就和 v2’发生冲突；</li></ul><p><strong>解决方案</strong>：</p><pre><code>git push origin master# conflict...errorgit pull --rebasegit push origin master</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220305164424111.png" alt=""></p><ul><li>还有一种情况是：V1 和 V1’改动的是同一处，这时候 git pull –rebase 会失败，因为 Git 肯定不知道到底要保存谁的。这时候就需要手动解决。</li></ul><p><strong>解决方案</strong>：依次执行</p><ol><li><p>打开本地文件，选择我们要保留的代码，然后再把 <code>&gt;&gt;&gt;&gt;&gt;, ======, &lt;&lt;&lt;&lt;&lt;&lt;</code> 这些提示行给去掉。（git pull –rebase 后才有<code>&gt;&gt;&gt;&gt;===</code>）</p></li><li><p>执行以下命令</p><pre><code>git add --agit commit -m &#39;resolve conflict&#39;git rebase --continuegit push origin master</code></pre></li></ol><h3 id="3-3-2-git-pull- 发生冲突"><a href="#3-3-2-git-pull- 发生冲突" class="headerlink" title="3.3.2 git pull 发生冲突"></a>3.3.2 git pull 发生冲突 </h3><p> 这种情况一般发生在本地版本较新时，而我们又想放弃本地所有改动（不管有没 add 或 commit），用远程文件强行覆盖。</p><pre><code>git fetch --allgit reset --hard origin/master</code></pre><p>一般来讲，我们常见的是选择版本回退的方法。参照 3.1.7 版本回退。</p><h3 id="3-3-3-git-push- 冲突案例演示"><a href="#3-3-3-git-push- 冲突案例演示" class="headerlink" title="3.3.3 git push 冲突案例演示"></a>3.3.3 git push 冲突案例演示</h3><ol><li><p>本地文件 test.txt</p><pre><code>print(&#39;basev0&#39;)</code></pre><p>Push 后，远程仓库：</p><pre><code>print(&#39;basev0&#39;)</code></pre></li><li><p>直接在 GitHub 仓库修改远程文件并保存</p><pre><code>print(&#39;remotev1&#39;)</code></pre></li><li><p>修改本地文件</p><pre><code>print(&#39;localv1-&#39;)</code></pre><p>Push，发生冲突。</p><p>执行 <code>git pull --rebase</code> ，失败。接下来最好是 <strong> 手动解决冲突</strong>：</p></li></ol><ol start="4"><li><p>手动解决冲突</p><p>此时本地打开该冲突的文件，内容为：</p><pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADprint(&#39;remotev1&#39;)=======print(&#39;localv1-&#39;)&gt;&gt;&gt;&gt;&gt;&gt;&gt; dc10440 (localv1-)</code></pre><p>手动合并的方法很简单，就是我们选择我们要保留的代码，然后再把 <code>&gt;&gt;&gt;&gt;&gt;, ======, &lt;&lt;&lt;&lt;&lt;&lt;</code> 这些提示行给去掉。最后重新 add 和 commit。</p><p>假设我们保留这个：</p><pre><code>print(&#39;localv1-&#39;)</code></pre><p>再执行：</p><p><code>git add --a</code></p><p><code>git commit -m &#39;resolve conflict&#39;</code></p><p><code>git rebase --continue</code></p><p><code>git push origin master</code></p></li></ol><p>即可大功告成！</p><h2 id="3-4- 版本回退"><a href="#3-4- 版本回退" class="headerlink" title="3.4 版本回退"></a>3.4 版本回退</h2><p>Git 提供了两种版本回退命令：</p><ul><li>git reset ：如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法。</li><li>git revert：如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。</li></ul><blockquote><p>只能回退到 commit 过的版本</p></blockquote><h3 id="3-4-1-git-reset"><a href="#3-4-1-git-reset" class="headerlink" title="3.4.1 git reset"></a>3.4.1 git reset</h3><p>当前版本往上回退一个版本：<code>git reset --hard HEAD^</code></p><p>回退 n 个版本：<code>git reset --hard HEAD~n</code></p><p>通过 id 回退：<code>git reset --hard commit_id</code></p><p>回退之后又想恢复到最新版本：<code>git reflog</code>查看每一次记录，通过 id 回退。</p><p><code>git reflog --date=iso</code>查看每次 commit 记录并显示时间。</p><hr><p><strong>git 中的 HEAD 理解</strong>：HEAD 代表当前指针的意思，它是 git 内部用来追踪位置的，形象的记忆就是：你在哪，HEAD 就指向哪。</p><p>上面加 <code>--hard</code> 的意思是：同时恢复到暂存区和工作区（工作区的新文件会被旧文件替代）；</p><p>加不加 <code>--head</code> 的区别：不加<code>--head</code>，在恢复的时候只恢复到暂存区。</p><p><code>--soft</code> 和 <code>--hard</code>的区别：<code>--hard</code>会清空工作目录和暂存区的改动，而 <code>--soft</code>则会保留工作目录的内容，并把因为保留工作目录内容所带来的新的文件差异放进暂存区。</p><p><strong>正式的流程如下：</strong></p><pre><code>git reflog                      #查看 commit 记录，找到想要回退到的 commit idgit reset --hard commit_id      #回退本地仓库git push origin master -f       #强制 push 到远程 </code></pre><p> 如果 git push 不加 -f，会显示 current branch is behind，导致失败。所以需要 -f 强制 push。</p><p>但是，如果远程仓库是【protected】，则可能会 not allowed force push。</p><p>这时候可以到项目的 Settings 页面下找到 Protected Branches，有如下两种解决方法</p><ol><li>可以直接点该分支旁的 Unprotect 按钮，解除保护，但是这种方法不推荐</li><li>第二种方法是在 Allowed to push 下选择允许那些角色或具体那些用户可以提交，在这里可以选择你自己</li></ol><h3 id="3-4-2-git-revert"><a href="#3-4-2-git-revert" class="headerlink" title="3.4.2 git revert"></a>3.4.2 git revert</h3><p><strong>正式的流程如下：</strong></p><pre><code>git reflog                      #查看 commit 记录，找到想要回退到的 commit idgit revert -n commit_id         #反做版本号为 commit_id 的版本 </code></pre><p> 这里可能会出现冲突，那么需要手动修改冲突的文件。冲突解决后，接着：</p><pre><code>git add yyygit commit -m &#39;revert xxx&#39;git push origin master</code></pre><p>即可。</p><h2 id="3-5- 指定 commit 进行 push"><a href="#3-5- 指定 commit 进行 push" class="headerlink" title="3.5 指定 commit 进行 push"></a>3.5 指定 commit 进行 push</h2><p>有时候，我们会需要将某个特定的 commit，将其 push 到其他分支，这时候就需要用到 <code>git cherry-pick</code> 命令：</p><pre><code class="shell">git log -3 --graph master   # 查看当前分支下的提交记录，-3 是看前 3 条git checkout 2022.05        # 切换到 2022.05 分支git branch                  # 查看当前所处分支git cherry-pick commit_id   # 指定的 commit_id 就被合并到 2022.05 分支git pull --rebase           # 解决冲突git push origin 2022.05     # push 到 2022.05 branch</code></pre><h1 id="4、深入阅读"><a href="#4、深入阅读" class="headerlink" title="4、深入阅读"></a>4、深入阅读 </h1><p><a href="https://www.lzane.com/tech/git-internal/"> 这才是真正的 Git——Git 内部原理 - LZANE | 李泽帆（靓仔）</a></p><p><a href="https://git-scm.com/book/zh/v2">Git - Book (git-scm.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客迁移与多平台使用</title>
      <link href="/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%9A%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/"/>
      <url>/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%9A%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们 <strong> 换电脑 </strong> 或者需要 <strong> 多台电脑维护</strong> GitPages 博客时，可以采用以下方案执行。</p></blockquote><h1 id="一、在旧电脑上的操作"><a href="# 一、在旧电脑上的操作" class="headerlink" title="一、在旧电脑上的操作"></a>一、在旧电脑上的操作</h1><h2 id="1-1- 准备工作"><a href="#1-1- 准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h2><p>1、在 GitHub 仓库上新建一个仓库 XXSS，用来放置博客文件目录 Hexo/ 下所有文件</p><p>2、配置 SSH Key：将本机的 id_rsa.pub 文件内容复制到 GitHub 上相应位置</p><p>3、将博客文件目录 Hexo/ 变成 Git 仓库并 push，cmd 执行</p><pre><code>git initgit remote add origin git@github.com:XXSS.gitgit add --allgit commit -m &#39;save file to GitHub&#39;git push origin master</code></pre><p>以上就完成了。</p><h1 id="二、在新电脑上的操作"><a href="# 二、在新电脑上的操作" class="headerlink" title="二、在新电脑上的操作"></a>二、在新电脑上的操作</h1><h2 id="2-1- 安装工具"><a href="#2-1- 安装工具" class="headerlink" title="2.1 安装工具"></a>2.1 安装工具</h2><p>1、安装 git for windows</p><p>2、安装 node.js</p><p>3、配置 SSH Key：将本机的 id_rsa.pub 文件内容复制到 GitHub 上相应位置</p><ul><li><p><strong>注意在生成 SSH key 的时候，一定要先确认下本机是否已存在</strong>，避免覆盖。如本地需多个 key（对应不同域名网站）, 参照 2.3 章节处理</p></li><li><p>验证是否配置成功：<code>ssh -T git@github.com  -i  ~/.ssh/id_rsa</code> 出现…successfully authenticated…即可</p></li></ul><p>4、安装 hexo：在 cmd 执行 <code>npm i -g hexo</code></p><p>5、创建博客目录：如 Hexo/，以后这里就是博客的工作目录</p><ul><li>初始化：在博客工作目录下，右键 Git Bash 中执行 <code>hexo init</code></li></ul><p>5、配置</p><pre><code>$ git config --global user.name &quot;liuxianan&quot;        // 你的 github 用户名，非昵称$ git config --global user.email  &quot;xxx@qq.com&quot;     // 填写你的 github 注册邮箱</code></pre><blockquote><p>注意：此时博客文件夹并不是一个 git 仓库。</p></blockquote><p>以上新电脑上的基本配置已经做完了。</p><h2 id="2-2- 导入更换文件"><a href="#2-2- 导入更换文件" class="headerlink" title="2.2 导入更换文件"></a>2.2 导入更换文件 </h2><h3 id="2-2-1- 更新文件"><a href="#2-2-1- 更新文件" class="headerlink" title="2.2.1 更新文件"></a>2.2.1 更新文件</h3><p> 在旧电脑上时，我们已经将所有的博客目录下的文件上传到 XXSS 仓库里了，接下来就要用远程文件更新本地的文件。</p><p>目前我们的博客目录 Hexo/ 只是一个普通文件夹，下面需要将其变成 git 本地仓库：</p><p>执行如下命令：</p><pre><code>git initgit remote add origin git@github.com:XXSS.git       // 添加目标远程仓库git pull origin master                              // 拉取文件</code></pre><p>  这时，如果显示：Permission denied….fatal: Could not read from remote repository. 按照 2.3 章节处理。</p><p>由于我们是准备强制覆盖本地文件的，可以使用：</p><pre><code>git fetch --allgit reset --hard origin/master</code></pre><blockquote><p>git fetch 从远程下载最新的，而不尝试合并或 rebase 任何东西。</p><p>git reset 将主分支重置为您刚刚获取的内容，–hard 选项更改工作树中的所有文件以匹配 origin/master 中的文件。</p></blockquote><p>这时候我们可以检查是否全部更新完毕。</p><h3 id="2-2-2- 善后工作"><a href="#2-2-2- 善后工作" class="headerlink" title="2.2.2 善后工作"></a>2.2.2 善后工作 </h3><p> 我们可以执行 <code>hexo s -g</code> 进行本地预览，发现可能还有问题，需要进一步处理。</p><p>执行 <code>npm install</code>，(由于仓库有一个.gitignore 文件，里面默认是忽略掉 node_modules 文件夹的，也就是说仓库的 hexo 分支并没有存储该目录[也不需要]，所以需要 install 下)。</p><p>这时候基本可以本地预览了，但是可能会报错，如： Error: Cannot find module ‘object-assign’</p><p>本着缺啥补啥的原则，直接安装它：<code>npm i object-assign</code></p><p>至此，所有工作基本已经做完。</p><h3 id="2-2-3- 图床"><a href="#2-2-3- 图床" class="headerlink" title="2.2.3 图床"></a>2.2.3 图床</h3><p>Typora 新版本已经支持图床，在偏好设置里面：上传服务选择 PicGo(app)。这样就不用本地存储图片，可以更好的管理图片了。</p><p>配置 PicGo:</p><ul><li><p>下载并安装：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here">PicGo is Here | PicGo</a> 这里我安装的是 2.3.1 版本</p></li><li><p>购买 OSS，这里我买的是阿里云 OSS，获取其 AccessKey ID 和 AccessKey Secret：</p></li></ul><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20250228004025160.png" style="zoom:33%;" /><ul><li><p>配置 PicGo：将 AccessKey ID 和 AccessKey Secret 分别填入 KeyId 和 KeySecret；BucKet 和存储区域也是自己创建和选择的，这里我之前是 image–1 和 oss-cn-shenzhen</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20250228004236420.png" style="zoom:33%;" /></li><li><p>配置 Typora：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20250228004634395.png" style="zoom:33%;" /></li></ul><p>当我们点击【验证图片上传选项】，会自动测试上传，并给出测试结果。</p><p>注意：不要勾选【为相对路径加上./】</p><h2 id="2-3- 处理多个本地 Key"><a href="#2-3- 处理多个本地 Key" class="headerlink" title="2.3 处理多个本地 Key"></a>2.3 处理多个本地 Key</h2><p>一般情况下，我们本地只需要一个 Key 就行。但是有时候，我们的机器上会有很多的 Git Host，比如公司 GitLab、我们自己的 GitHub，我们需要用不同的 key 来区分。于是我们在生成 Key 的时候，可以命名不同的名字加以区分。</p><p>如默认的  <code>id_rsa.pub</code>和 <code>id_rsa</code>；还可以命名其他名字：<code>id_rsa_mee.pub</code> 和<code>id_rsa_mee</code></p><p>为了让不同的 Host 区分使用不同的 SSH Key，需要做点额外配置（否则会 Permission denied）：</p><p>在 ~/.ssh/ 密钥同级目录下，新建文件名为 config，写入：</p><pre><code># 1 github setting Host github.com                      HostName github.com                  #ip 也可User xxx                             #这里写 git config user.nameIdentityFile ~/.ssh/id_rsa# 2 gitlab settingHost gitlab.com                       HostName gitlab.comUser qiangjiangIdentityFile ~/.ssh/id_rsa_mee</code></pre><ul><li><p><code>Host</code> ： 相当于一个别名，这里可以使用任意字段或通配符。访问 ssh 的时候如果服务器地址能匹配上这里 Host 指定的值</p></li><li><p><code>HostName</code> ：真正连接的服务器地址</p></li><li><p><code>User</code>：自定义的用户名</p></li><li><p><code>PreferredAuthentications</code> 指定优先使用哪种方式验证，支持密码和秘钥验证方式，默认可以不写</p><ul><li>publickey, password, keyboard-interactive，支持这三种</li></ul></li><li><p><code>IdentityFile</code>：指定本次连接使用的密钥文件</p></li></ul><p>配置完保存即可。</p><h1 id="三、再回顾 -Hexo"><a href="# 三、再回顾 -Hexo" class="headerlink" title="三、再回顾 Hexo"></a>三、再回顾 Hexo</h1><h2 id="3-1- 目录回顾"><a href="#3-1- 目录回顾" class="headerlink" title="3.1 目录回顾"></a>3.1 目录回顾 </h2><p><code>hexo/source</code>：放的是我写的全部 md 文章和素材，其中里面<code>_post</code> 是全部的文章 md 格式的，<code>about</code>是主页文章，<code>asset</code>是图片</p><blockquote><p>这个里面的东西超级重要！！！</p></blockquote><p><code>hexo/scaffolds</code>：放的是文章模板，<code>hexo n &#39; 文章标题 &#39;</code>生成的文章就是基于这里面的模板生成的，可以自定义修改</p><p><code>hexo/public</code>：存放的是通过 <code>hexo/source/_post</code> 里面的文章生成的 html 页面 , 这些文件将来是要提交到 github 去的，部署完后可以清理</p><p>其他的目录都是些基础配置。参考本站【使用 Hexo+Github 搭建个人免费博客 1.1 节】</p><h2 id="3-2- 命令回顾"><a href="#3-2- 命令回顾" class="headerlink" title="3.2 命令回顾"></a>3.2 命令回顾</h2><pre><code>hexo n &quot; 创建文章 &quot;hexo s -g  # 本地生成静态网页预览，检查用hexo d -g  # 部署上传到 githubhexo clean  #清除本地的 public 文件夹和缓存 db.json</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python 中的基础知识与重难点汇总</title>
      <link href="/python%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E9%87%8D%E9%9A%BE%E7%82%B9%E6%B1%87%E6%80%BB/"/>
      <url>/python%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E9%87%8D%E9%9A%BE%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="一、计算机编程语言"><a href="# 一、计算机编程语言" class="headerlink" title="一、计算机编程语言"></a>一、计算机编程语言 </h1><h2 id="1-1- 编程语言"><a href="#1-1- 编程语言" class="headerlink" title="1.1 编程语言"></a>1.1 编程语言</h2><p> 编程语言有‘高低’之分，分为：<strong>机器语言、汇编语言、高级语言。</strong></p><p><strong>机器语言：</strong>计算机直接能够接受和应用的语言，由二进制代码组成的 <strong> 机器指令 </strong> 的集合。</p><p><strong>汇编语言：</strong>是一种面向计算机硬件的低级语言，也称 <strong> 符号语言 </strong>，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。汇编语言写出源程序，在用<strong> 汇编编译器 </strong> 将其编译为机器指令，由计算机最终执行。</p><p><strong>高级语言：</strong>高级语言是一种指令集的体系，使用一般人易于接受的文字来表示，是高度封装了的编程语言。</p><h2 id="1-2- 高级语言特性"><a href="#1-2- 高级语言特性" class="headerlink" title="1.2 高级语言特性"></a>1.2 高级语言特性 </h2><h3 id="1-2-1- 编译型与解释型语言"><a href="#1-2-1- 编译型与解释型语言" class="headerlink" title="1.2.1 编译型与解释型语言"></a>1.2.1 编译型与解释型语言</h3><p> 高级语言有 C 系列（C、C++，C#），java，python，Go，PHP，VB，JavaScript，Rust，R 等。</p><p>按照执行的方式的不同，高级语言可被分为：</p><ul><li><strong>编译型语言 </strong>：源程序的每一条语句都经过<strong> 编译器 </strong> 编译成机器语言，并保存成二进制文件，这样运行时计算机可以直接以机器语言来运行此程序，速度很快。<ul><li>如：C、C++</li></ul></li><li><strong>解释型语言 </strong>：只在执行程序时，才一条一条的由<strong> 解释器 </strong> 解释成机器语言给计算机来执行，所以运行速度是不如编译后的程序运行的快的。<ul><li>如：java、python</li></ul></li></ul><h3 id="1-2-2- 动态语言和静态语言"><a href="#1-2-2- 动态语言和静态语言" class="headerlink" title="1.2.2 动态语言和静态语言"></a>1.2.2 动态语言和静态语言 </h3><p><strong> 动态类型语言：</strong>在用动态类型的语言编程时，永远也 <strong> 不用给任何变量指定数据类型 </strong>，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来，即在<strong> 运行期间才去做数据类型检查 </strong> 的语言。比如：Python，Ruby，JavaScript。</p><p><strong>静态类型语言：</strong>写程序时要 <strong> 声明所有变量的数据类型 </strong>，它的数据类型是在<strong> 编译其间检查的</strong>。比如：C/C++，C#、Java 等。</p><h3 id="1-2-3- 强类型和弱类型语言"><a href="#1-2-3- 强类型和弱类型语言" class="headerlink" title="1.2.3 强类型和弱类型语言"></a>1.2.3 强类型和弱类型语言 </h3><p><strong> 强类型定义语言：</strong>一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。不支持隐式转换。如：Python，Java，C++ 等。</p><p><strong>弱类型定义语言：</strong>类型不严格区分，一般是只要大小放得下，就可以转化。支持隐式转换。如：JavaScript、PHP 等。</p><p>举例说明：</p><pre><code class="python">//python 程序a=1+&#39;1&#39;print(a)// 结果输出：TypeError: unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</code></pre><hr><pre><code class="javascript">#JavaScript 程序var a=1+&#39;1&#39;console.log(a,typeof(a))# 结果输出：11 string  </code></pre><p>以上就是强类型语言和弱类型语言的区别。</p><h2 id="1-3-Python 与 Java 的执行原理"><a href="#1-3-Python 与 Java 的执行原理" class="headerlink" title="1.3 Python 与 Java 的执行原理"></a>1.3 Python 与 Java 的执行原理</h2><p>Python 和 Java 同属于解释型语言，都是先编译成中间状态的字节码，最后一行行解释执行。但是还是有差异的。具体请看下面两张图：</p><p><strong>（1）Python 的执行方式</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201118200325365.png" alt=""></p><ul><li>python 解释器首先会对整个.py 代码进行词法和语法分析，若发现错误，则停止运行抛出错误；若无错误，接下来编译器会将整个.py 代码译为二进制的字节码（放在与 python 代码的同级目录 <code>__pycache__</code> 文件夹里），接下来字节码由 PVM 执行，<strong>逐行解释 </strong> 执行字节码，变为机器码，与硬件交互执行。</li><li>注意：如果代码 A 被执行过，其对应的字节码（.pyc）也存在，下次再执行时，若代码 A 没被修改（以时间戳的一致性判断），则会跳过编译步骤，直接运行其字节码，以提高效率。</li></ul><p><strong>（2）Java 的执行方式</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201118200649238.png" alt=""></p><ul><li>java 编译器首先会对整个.java 代码进行词法，语法和语义分析，无误后，编译器将整个.java 代码译为二进制的字节码。接下来 JVM 会对字节码进行分析，将所有热点代码交给 JIT 一次性全部编译成机器码，非热点码则逐条解释，逐条执行。</li><li>注意：<strong>“热点代码”有两类：A、被多次调用的函数（方法）。B、被多次执行的循环体。</strong></li></ul><h2 id="1-4-Python 解释器"><a href="#1-4-Python 解释器" class="headerlink" title="1.4 Python 解释器"></a>1.4 Python 解释器</h2><ul><li><p>CPython：官方版本的解释器：CPython。这个解释器是用 C 语言开发的，所以叫 CPython。在命令行下运行 python 就是启动 CPython 解释器。CPython 是使用最广且被的 Python 解释器。</p></li><li><p>IPython：IPython 是基于 CPython 之上的一个交互式解释器，也就是说，IPython 只是在交互方式上有所增强，但是执行 Python 代码的功能和 CPython 是完全一样的。CPython 用 &gt;&gt;&gt; 作为提示符，而 IPython 用 In [序号]: 作为提示符。</p></li><li><p>PyPy：PyPy 是另一个 Python 解释器，它的目标是执行速度。PyPy 采用 JIT 技术，对 Python 代码进行动态编译（注意不是解释），所以可以显著提高 Python 代码的执行速度。<br>绝大部分 Python 代码都可以在 PyPy 下运行，但是 PyPy 和 CPython 有一些是不同的，这就导致相同的 Python 代码在两种解释器下执行可能会有不同的结果。如果你的代码要放到 PyPy 下执行，就需要了解 PyPy 和 CPython 的不同点。</p></li><li><p>Jython：Jython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。</p></li><li><p>IronPython：IronPython 和 Jython 类似，只不过 IronPython 是运行在微软.Net 平台上的 Python 解释器，可以直接把 Python 代码编译成.Net 的字节码。</p></li></ul><p>在这些 Python 解释器中，使用广泛的是 CPython。</p><h2 id="1-5-GIL 锁"><a href="#1-5-GIL 锁" class="headerlink" title="1.5 GIL 锁"></a>1.5 GIL 锁 </h2><p> 我们常说 Python 的执行效率比较慢，没法进行多线程任务，其实这不是 Python 的特性，而是其解释器 CPython 带来的。</p><p><strong>CPython（Python 解释器）限制了同一时间内，一个进程里只能有一个线程运行。它阻止了 多个线程同时执行 Python 字节码，这就是 GIL 锁（全局解释器锁）。</strong></p><p>Python 最初的设计理念在于，<strong>为了解决多线程之间数据完整性和状态同步的问题，设计为在任意时刻只有一个线程在解释器中运行。</strong>而当执行多线程程序时，由 GIL 来控制同一时刻只有一个线程能够运行。即 Python 中的多线程是表面多线程，也可以理解为‘假’多线程，不是真正的多线程。</p><p>为什么要这样做呢？举个例子，比如用 python 计算：n=n+1。这个操作被分成了四步：</p><ul><li>加载全局变量 n</li><li>加载常数 1</li><li>进行二进制加法运算</li><li>将运算结果存入变量 n</li></ul><p>以上的过程是非原子操作的，根据前面的线程释放 GIL 锁原则，线程 a 执行这四步的过程中，有可能会让出 GIL。如果这样，n=n+1 的运算过程就被打乱了。</p><p>这就是为什么我们说 GIL 是粗粒度的，它只保证了一定程度的安全。如果要做到线程的绝对安全，是不是所有的非 IO 操作，我们都需要自己再加一把锁呢？答案是否定的。在 python 中，有些操作是是原子级的，它本身就是一个字节码，GIL 无法在执行过程中释放。对于这种原子级的方法操作，我们无需担心它的安全。比如 sort 方法，[1,4,2].sort()，翻译成字节码就是 CALL METHOD 0。只有一行，无法再分，所以它是线程安全的。</p><p>同一时刻只有一个线程能够运行，那么是怎么执行多线程程序的呢？其实原理很简单：解释器的 <strong> 分时复用 </strong>。即多个线程的代码，<strong> 轮流 </strong> 被解释器 <strong> 执行 </strong>，只不过切换的很频繁很快，给人一种多线程“同时”在执行的错觉。聊的学术化一点，其实就是“<strong> 并发</strong>”。</p><p><strong>“并发”和“并行”：</strong></p><ul><li>并发：不同的代码块交替执行</li><li>并行：不同的代码块同时执行</li></ul><p><strong>GIL 锁最终是保证 Python 解释器中原子操作的线程安全</strong>。</p><p><strong>GIL 是怎么起作用的：</strong></p><ul><li>由于 GIL 的机制，单核 CPU 在同一时刻只有一个线程在运行，当线程遇到 IO（读写）操作或 Timer  Tick 到期，释放 GIL 锁。其他的两个线程去竞争这把锁，得到锁之后，才开始运行。</li><li>线程释放 GIL 锁有两种情况，一是遇到 IO 操作，二是 Time Tick 到期（执行完 100 个字节码指令或者 15ms）。IO 操作很好理解，比如发出一个 http 请求，等待响应。而 Time Tick 规定了线程的最长执行时间，超过时间后自动释放 GIL 锁。</li></ul><p>在多核 CPU 下，由于 GIL 锁的全局特性，无法发挥多核的特性，GIL 锁会使得多线程任务的效率大大降低。线程 1（Thread1）在 CPU1 上运行，线程 2（Thread2）在 CPU2 上运行。GIL 是全局的，CPU2 上的 Thread2 需要等待 CPU1 上的 Thread1 让出 GIL 锁，才有可能执行。如果在多次竞争中，Thread1 都胜出，Thread2 没有得到 GIL 锁，意味着 CPU2 一直是闲置的，无法发挥多核的优势。为了避免同一线程霸占 CPU，在 python3.x 中，线程会自动的调整自己的优先级，使得多线程任务执行效率更高。</p><p><strong>GIL 的优缺点：</strong></p><ul><li><p>GIL 的优点是显而易见的，GIL 可以保证我们在多线程编程时，无需考虑多线程之间数据完整性和状态同步的问题。</p></li><li><p>GIL 缺点是：我们的多线程程序执行起来是“并发”，而不是“并行”。因此执行效率会很低，会不如单线程的执行效率。</p></li></ul><p><strong>原子操作：</strong></p><ul><li>原子操作就是不会因为进程并发或者线程并发而导致被中断的操作。<strong>原子操作 </strong> 的特点就是 <strong> 要么一次全部执行，要么全不执行</strong>。不存在执行了一半而被中断的情况。</li></ul><p>最初是为了利用多核，Python 开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。后来发现这种‘加锁’是低效的。但 <strong> 当大家试图去拆分和去除 GIL 的时候，发现大量库代码开发者已经重度依赖 GIL 而非常难以去除了</strong>。</p><p><strong>在 Python 编程中，如果想利用计算机的多核提高程序执行效率，用多进程代替多线程。</strong></p><p>使用多进程的好处：完全并行，无 GIL 的限制，可充分利用多 cpu 多核的环境。</p><p>虽说一般使用多进程对电脑系统资源占用比较多，但是在类 unix 系统中，创建线程的开销并不比进程小，因此在并发操作时，多线程的效率还是受到了很大制约的。所以后来人们发现通过 yield 来中断代码片段的执行，同时交出了 cpu 的使用权，于是协程的概念产生了。</p><h2 id="1-6-Python 内存管理与垃圾回收机制"><a href="#1-6-Python 内存管理与垃圾回收机制" class="headerlink" title="1.6 Python 内存管理与垃圾回收机制"></a>1.6 Python 内存管理与垃圾回收机制</h2><p>Python 程序在运行时，需要在内存中开辟出一块空间，用于存放运行时产生的临时变量，计算完成后，再将结果输出到永久性存储器中。但是当数据量过大，或者内存空间管理不善，就很容易出现内存溢出的情况，程序可能会被操作系统终止。</p><p>而对于服务器这种用于永不中断的系统来说，内存管理就显得更为重要了，不然很容易引发内存泄漏。</p><p>那么对于不会再用到的内存空间，Python 主要是通过三种机制来管理的。</p><p><strong>以引用计数为主，分代回收为辅。</strong></p><p><strong>（1）引用计数</strong></p><p>引用计数法的原理是每个对象维护一个<strong>ob_ref</strong>，用来记录当前对象被引用的次数，也就是来追踪到底有多少引用指向了这个对象。当引用计数为 0 时，该内存将会被 Python 虚拟机销毁。</p><p>但发生以下几种情况时，<strong>引用计数 +1：</strong></p><ul><li><strong>对象被创建 / 引用</strong>，如<code>a=1,b=a</code>，此时 a 的引用计数为 2。</li><li><strong>对象被传参到函数中</strong>，如<code>def funX(a):</code>，此时 a 的引用计数再加 1。</li><li><strong>对象作为元素，存储在容器中</strong>，如<code>L=[a,&#39;name&#39;,1,&#39;23&#39;]</code>，此时 a 的引用计数再加 1。</li></ul><p>发生以下几种情况时，<strong>引用计数 -1：</strong></p><ul><li>对象的别名被显式销毁，如<code>del a</code>。</li><li>对象的别名被赋予新的对象，如<code>a=24</code></li><li>对象离开它的作用域，例如 func 函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）</li><li>将该对象从容器中删除时，或者容器被销毁时。</li></ul><p><strong>引用计数的优点：</strong></p><ol><li>高效</li><li>实时性</li><li>对象有确定的生命周期</li><li>易于实现</li></ol><p><strong>引用计数的缺点：</strong></p><ol><li>维护引用计数消耗资源，维护引用计数的次数和引用赋值成正比</li><li>无法解决循环引用的问题。A 和 B 相互引用，而再没有外部引用 A 与 B 中的任何一个，它们的引用计数都为 1，但显然应该被回收。</li></ol><p>为了解决这两个致命缺点，Python 又引入了以下两种 GC 机制：标记 - 清除和分代回收。</p><p><strong>（2）标记清除</strong></p><p>【标记清除（Mark—Sweep）】算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。主要解决的是循环引用的问题。</p><p>它分为两个阶段：标记活动对象——回收非活动对象。</p><p>如何判断非活动对象：</p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。</p><p>下面举个例子：</p><p>把小黑圈视为全局变量，也就是把它作为 root object，从小黑圈出发，对象 1 可直达，那么它将被标记，对象 2、3 可间接到达也会被标记，而 4 和 5 不可达。那么 1、2、3 就是活动对象，4 和 5 是非活动对象会被 GC 回收。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201119225602393.png" alt=""></p><p>标记清除算法作为 Python 的辅助垃圾收集技术主要处理的是一些 <strong> 容器对象</strong>。比如：列表，字典，集合等，而字符串、数值对象是不可能造成循环引用问题。</p><p>其实，Python 使用的是一种不同的链表来持续追踪活跃的对象。而不将其称之为“活跃列表”，Python 的内部 C 代码将其称为零代 (Generation Zero)。每次当<strong> 你创建一个对象或其他什么值的时候，Python 会将其加入零代链表</strong>。</p><p><strong>Python 会循环遍历零代列表上的每个对象，检查列表中每个互相引用的对象，根据规则减掉其引用计数。</strong></p><p>通过识别内部引用，Python 能够减少许多零代链表对象的引用计数。</p><p>而零代链表中剩下的活跃的对象则被移动到一个新的链表：一代链表。</p><p>接下来介绍分代回收机制。</p><p><strong>（3）分代回收</strong></p><p>Python 中, 引入了分代收集，总共三个”代”。Python 中，一个代就是一个链表,，所有属于同一”代”的内存块都链接在同一个链表中。</p><p>Python 程序运行时，会自动分配一块内存，随着程序的运行，变量的增多，一旦超过设定的阈值，就会在零代链表中触发垃圾回收机制，有效引用计数为 0 的，执行回收，有效引用计数大于 0 的，便会依次从上一代挪到下一代。而每一代启动自动垃圾回收的阈值，则是可以单独指定的。当垃圾回收器中新增对象减去删除对象达到相应的阈值时，就会对这一代对象启动垃圾回收。</p><p>你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。</p><p>总的来说：分代回收是一种以空间换时间的操作方式，Python 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python 将内存分为了 3“代”，分别为年轻代（第 0 代）、中年代（第 1 代）、老年代（第 2 代），他们对应的是 3 个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为 Python 的辅助垃圾收集技术处理那些容器对象。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 入门</title>
      <link href="/javascript%E5%85%A5%E9%97%A8/"/>
      <url>/javascript%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>仍杂持续学习中，内容可能有点杂乱，后期会整理……</p><h1 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h1><h2 id="1-1-js 的引入"><a href="#1-1-js 的引入" class="headerlink" title="1.1 js 的引入"></a>1.1 js 的引入</h2><ul><li>页面内嵌：<code>&lt;script&gt; code &lt;/script&gt;</code>也就是直接在页面写</li><li>外部引入：<code>&lt;script src=&#39; 需引入的 js 代码文件位置及名称 &#39;&gt; code &lt;/script&gt;</code>，也就是引入外部的 js 文件</li></ul><pre><code class="html">……&lt;body&gt;    &lt;script type=&#39;text/javascript&#39;&gt;   // 告诉浏览器 script 标签里的文本属于 javascript 语言        var a=100,            _b=10,            $c=1; // 变量的定义 (变量的只有这三种命名规则) 及赋值        document.write(a, _b, $c) // 打印（输出）到页面    &lt;/script&gt;&lt;/body&gt;……</code></pre><p>以上代码中变量的命名需遵循一定的规则，以字母，下划线或 $ 符开头。</p><h2 id="1-2- 数据类型"><a href="#1-2- 数据类型" class="headerlink" title="1.2 数据类型"></a>1.2 数据类型 </h2><h3 id="1-2-1- 堆和栈"><a href="#1-2-1- 堆和栈" class="headerlink" title="1.2.1 堆和栈"></a>1.2.1 堆和栈</h3><p> 介绍数据类型前，需要介绍两个名词：<strong>堆 heap 和栈 stack</strong>。</p><p>任何程序在运行时都要在内存中开辟空间，堆和栈就是跟内存相关的名词。</p><p><strong>堆 </strong> 是动态分配内存，内存大小不一，也不会自动释放。可以简单理解为一块区域。</p><p><strong>栈 </strong> 是自动分配相对固定大小的内存空间，并由系统自动释放。可以理解为客栈（固定的房间）。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201216191817451.png" style="zoom:67%;" /><h3 id="1-2-2- 原始值与引用值"><a href="#1-2-2- 原始值与引用值" class="headerlink" title="1.2.2 原始值与引用值"></a>1.2.2 原始值与引用值</h3><ul><li><p>原始值（放在栈 stack 里面）：</p></li><li><p><code>number, Boolean, String, undefined, null</code>一共 5 种。</p></li><li><p>引用值（放在堆 heap 里面）：</p><ul><li><p>Array 数组</p><pre><code class="javascript">var a=[1,2,3,4]</code></pre></li><li><p>Object 对象</p><pre><code class="javascript">var obj=&#123;    name:&#39;zs&#39;,    age:18,    sex:&#39;male&#39;&#125;</code></pre></li><li><p>function 函数</p><pre><code class="javascript">function test() &#123;            // 函数名必须遵循小驼峰原则    // 函数内容;    return;     // 函数必须有返回，return 可以省略（返回空）&#125;</code></pre></li><li><p>date 日期</p><pre><code class="javascript">var date = Date.now()</code></pre></li><li><p>RegExp 正则</p></li></ul></li></ul><h3 id="两类错误"><a href="# 两类错误" class="headerlink" title="两类错误"></a><strong>两类错误</strong></h3><ul><li>低级错误：比如冒号写成了中文冒号，会引发该代码块不会执行，因为 js 编译时会先大致扫描整个代码块，检查语法错误。注意，这不会影响另一个 js 代码块。</li><li>逻辑错误：比如变量未经定义便使用，代码会运行，到错误处再报错。</li></ul><h2 id="1-3- 运算符"><a href="#1-3- 运算符" class="headerlink" title="1.3 运算符"></a>1.3 运算符</h2><p>js 中的运算符与其他编程语言大致一样，这里只做简单介绍。</p><h3 id="1-3-1- 自增 - 或自减）"><a href="#1-3-1- 自增 - 或自减）" class="headerlink" title="1.3.1 自增(或自减）"></a>1.3.1 自增(或自减）</h3><ul><li><p>a++：</p><ul><li><pre><code class="javascript">var a=10;document.write(a++);   // 先执行本条语句打印 a，再 ++// 输出打印为 10</code></pre></li></ul></li><li><p>++a：</p><ul><li><pre><code class="javascript">var a=10;document.write(++a);      // 先 ++ 计算 a 再执行本条语句// 输出打印为 11</code></pre></li></ul></li></ul><h3 id="1-3-2- 逻辑运算符"><a href="#1-3-2- 逻辑运算符" class="headerlink" title="1.3.2 逻辑运算符"></a>1.3.2 逻辑运算符</h3><ul><li><p><code>A &amp;&amp; B</code>：“并且”的意思。若 A、B 均为真，就取值 B；若 A、B 中至少一个为假，则取值 0</p><ul><li><pre><code class="javascript">2&gt;1 &amp;&amp; documnet.write(&#39; 通过 &#39;)  // 打印输出‘通过’，这里运算符按顺序执行</code></pre></li></ul></li><li><p><code>A||B</code>：“或”的意思碰到真就返回。若 A 为真，返回 A，若 A 为假，B 为真，就返回 B，若 A、B 均为假，也返回 B。</p></li><li><p><code>！A</code>与<code>！！A</code>：非运算符，取反，结果为布尔值，双感叹号意思是取反再取反。</p><pre><code class="javascript">&gt;&gt;&gt;!1false&gt;&gt;&gt;!0true&gt;&gt;&gt;![]false&gt;&gt;&gt;!!1true</code></pre></li></ul><h2 id="1-4- 条件语句"><a href="#1-4- 条件语句" class="headerlink" title="1.4 条件语句"></a>1.4 条件语句</h2><ul><li><p><code>if</code>语句</p><pre><code class="javascript">if (条件判断)&#123;  当条件满足时，执行里面的语句&#125;else if (条件判断)&#123;  当条件满足时，执行里面的语句&#125;else&#123; 当上述条件都不满足时，执行里面的语句 &#125;</code></pre></li><li><p><code>for</code>循环</p><pre><code class="javascript">for (var i=0;i&lt;10;i++)&#123;    ……；&#125;</code></pre></li></ul><ul><li><p><code>while/do while</code>：用法与 C++ 一样</p></li><li><p><code>switch case</code>：条件判断语句</p><pre><code class="javascript">switch(参数)&#123;       case 条件 1：      // 判断参数是否等于满足条件 1          执行语句;            break;       case 条件 2：      // 判断参数是否等于满足条件 2            执行语句;            break;&#125;-------------------------------------------------------------------var date=window.prompt(&#39;input&#39;)switch(date)&#123;    case &#39;monday&#39;:console.log(&#39;working&#39;);        break;    case &#39;tuesday&#39;:console.log(&#39;working&#39;);        break;    case &#39;wendesday&#39;:console.log(&#39;working&#39;);         break;&#125;</code></pre><p>注意：switch 找到满足条件的语句后，后面的语句虽然不判断，但是也会执行出来，加个 break，就可以终止 switch case 语句。</p></li></ul><h2 id="1-5- 类型查询与转换"><a href="#1-5- 类型查询与转换" class="headerlink" title="1.5 类型查询与转换"></a>1.5 类型查询与转换</h2><ul><li><p>类型查询：<code>typeof(obj)</code>，js 中有六种数据类型：<code>number/srting/boolean/undefined/object/function</code></p><p>  注意：typeof(null)为 object。</p></li><li><p>类型转换</p><ul><li><p>显式转换</p><p><code>Number(a)</code>将 a 转换成数字</p><p><code>parseInt(string,radix)</code>：parse 是转化，Int 是整型，radix 是进制，取值 2-36。</p><p>parseFloat(string)</p><p>a.toString(radix)：转换成字符串，可以指定进制。</p><p>String(a)：字符串转换</p></li><li><p>隐式转换：在需要时自动转换</p><p>自动转换：</p><ul><li><pre><code class="javascript">// 这里随便举个例子var a=&#39;1&#39;*123   // 数字乘字符串会自动转换成数值类型，加减乘除除了加，都有这个性质-------------------------------------------------var a=&#39;1&#39;var b=+a  //+ 号可将字符类型转换成数字类型</code></pre></li></ul></li></ul></li></ul><ul><li><p>等于判断</p><p>  <code>===</code>：三个等于号，绝对等于</p><p>  <code>！==</code>：绝对不等于</p></li></ul><h1 id="2、函数"><a href="#2、函数" class="headerlink" title="2、函数"></a>2、函数 </h1><h2 id="2-1- 函数的定义"><a href="#2-1- 函数的定义" class="headerlink" title="2.1 函数的定义"></a>2.1 函数的定义</h2><p> 函数作用：实现高内聚，低耦合，减少重复。</p><pre><code class="javascript">function 函数名() &#123;            // 函数名必须遵循小驼峰原则    // 函数内容;    return;     // 函数必须有返回，return 可以省略（返回空）&#125;-------------------------------------------------------------var test = function 函数名() &#123;         // 函数表达式, 这种写法没必要    函数内容;&#125;-------------------------------------------------------------var test = function(a,b) &#123;            // 匿名函数表达式, 还可以指定形参    函数内容;&#125;test(1,2);   // 函数的调用, 实参可以多于形参，不会报错// 另外，这里藏着一个 aguments(数组类型), 装着传入的实参[1,2], 可以调用// 如 document.write(aguments)</code></pre><p>另外，这里藏着一个<code>aguments</code>(数组类型)，装着传入的实参[1,2]，可以调用，如 document.write(aguments)。</p><p>举例：</p><pre><code class="javascript">function sum(a,b) &#123;            a=2;            arguments[0]=3            document.write(a)        &#125;sum(100,200)// 输出打印为 3</code></pre><p>形参长度：<code>函数名.length</code></p><h2 id="2-2- 作用域"><a href="#2-2- 作用域" class="headerlink" title="2.2 作用域"></a>2.2 作用域</h2><ul><li><p>与 python 类似，分全局变量和局部变量</p></li><li><p>js 运行三部曲：语法分析（通篇扫面，检查语法错误）——&gt; 预编译——&gt; 解释执行（边解释边执行，解释一行执行一行）、</p></li></ul><h3 id="2-2-1- 语法分析"><a href="#2-2-1- 语法分析" class="headerlink" title="2.2.1 语法分析"></a>2.2.1 语法分析 </h3><p> 变量和函数声明的顺序问题：</p><p><strong>函数声明，不管写在那里，都会被整体提到逻辑的最前面。</strong></p><p><strong>变量的声明也会提升（赋值不会）</strong></p><pre><code class="javascript">  test();  function test()&#123;      console.log(&#39;a&#39;);  &#125;  // 以上也是可以执行，先调用函数，再定义它  ----------------------------------------------------------  console.log(a);  var a=123;  // 只会输出 undefined, 变量 a 声明了，但不会被赋值输出</code></pre><p>imply global 暗示全局变量：即任何变量，若变量未经声明就赋值，则此变量就为全局对象（就是 window 所有）</p><p>一切声明的全局变量，全是 window 的属性，可以通过 <code>window. 变量名</code> 来访问</p><h3 id="2-2-2- 预编译"><a href="#2-2-2- 预编译" class="headerlink" title="2.2.2 预编译"></a>2.2.2 预编译 </h3><p> 预编译发生在函数执行前的一刻。</p><p>当函数执行时，会创建一个称为 <strong> 执行期上下文 </strong> 的内部对象。</p><p>一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文被销毁。</p><p>查找变量：从作用域链的顶端依次向下查找。</p><p><strong>（1）函数预编译过程</strong></p><ul><li>创建 AO 对象（Activation Object），识别函数的作用域，函数产生的执行空间</li><li>找形参和变量 <strong> 声明</strong>，将变量和形参作为 AO 属性名，值为 undefined</li><li>将实参值和形参统一（把实参值传到形参里）</li><li>在函数体里面找函数声明，值赋予函数体。（先看自己的 AO，再看全局的 GO）</li></ul><pre><code class="javascript">// 这里举个例子function fn(a) &#123;            console.log(a);            var a=123;            function a() &#123;&#125;            console.log(a);            var b=function () &#123;&#125;            console.log(b);            function d() &#123;&#125;            &#125;fn(1);// 输出结果为：ƒunction a()123ƒunction b()</code></pre><p>以上执行的优先顺序理解：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201111220731524.png" style="zoom:120%;" /><p><strong>（2）全局的预编译</strong></p><ul><li><p>生成一个 GO 对象 Global Object（window 就是 GO）</p></li><li><p>找形参和变量声明，将变量和形参作为 GO 属性名，值为 undefined</p></li><li><p>在函数体里面找函数声明，值赋予函数体。</p><ul><li>先生成 GO 还是 AO？想执行全局，先生成 GO，在执行函数前一刻生成 AO。若有几层嵌套关系，近的优先，从近到远的，有 AO 就看 AO，AO 没有才看 GO。</li></ul></li><li><p>[[scope]]：每个 javascript 函数都是一个对象， 对象中有些属性我们可以访问，但有些不可以，这些属性仅供 javascript 弓擎存取，[[scope]]就是其中一 个。[[scopel]指的就是我们所说的作用域, 其中存储了运行期上下文的集合。<br>作用域链： [[scopel]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。</p></li></ul><p>举个例子：</p><p>  <img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201216201800380.png" alt=""></p><p>  a 函数被定义是，发生如下过程：</p><p>  <img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201112215403316.png" alt=""></p><p>  定义的函数 a 被执行时，发生如下过程：</p><p>  <img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201112215211763.png" alt=""></p><p>  b 函数被创建时，发生如下过程：（继承了 a 函数的作用域）</p><p>  <img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201112220454635.png" alt=""></p><p>  b 函数被执行时，发生如下过程：（创建的自己的 AO）</p><p>  <img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201112220802498.png" alt=""></p><h2 id="2-3- 立即执行函数"><a href="#2-3- 立即执行函数" class="headerlink" title="2.3 立即执行函数"></a>2.3 立即执行函数 </h2><p> 执行完不再另外调用时，立即被销毁，目的时为了避免占用空间。</p><pre><code class="javascript">var num = (function (a,b,c)&#123;    return a+b+c;&#125;(1,3,4));// 还有第二种写法：不过 w3c 建议采用第一种(function ()&#123;&#125;)();   // 这两种函数的 名都没有写的必要</code></pre><p>只有表达式才能被执行符号执行，执行符号就是括号  。</p><pre><code class="javascript">function test()&#123;console.log(&#39;a&#39;);&#125;();  // 这样会报错，函数的声明不能执行--------------------------------------------------function test()&#123;console.log(&#39;a&#39;);&#125;;test()；                 //test()就是执行表达式 test 的意思，故不会报错---------------------------------------------------// 以下这两种写法也不会报错var num=function ()&#123;console.log(&#39;a&#39;);&#125;();+ function test()&#123;console.log(&#39;a&#39;);&#125;();    // 加号将其变成了表达式</code></pre><h1 id="3、对象"><a href="#3、对象" class="headerlink" title="3、对象"></a>3、对象 </h1><h2 id="3-1- 创建对象"><a href="#3-1- 创建对象" class="headerlink" title="3.1 创建对象"></a>3.1 创建对象</h2><p> 创建对象有三种方法：</p><ul><li>字面量</li><li>构造函数<ul><li>系统自带，new Object();Array();Number();Boolean();String();Date()</li><li>自定义</li></ul></li><li>Object.create(原型)方法</li></ul><pre><code class="javascript">var MrJiang=&#123;              // 字面量创建对象            name:&#39;MrJiang&#39;,            age:18,            sex:&#39;male&#39;,            health:100,            smoke:function () &#123;                console.log(&quot;I&#39;m smoking!&quot;);                this.health--;       // 这里的 this 代表的是 MrJiang 对象            &#125;,        &#125;;----------------------------------------// 也可这样创建对象, 与上无区别var obj = new Object();    // 有 new 就是构造对象obj.name=&#39;MrJinag&#39;;obj.sex=&#39;male&#39;;</code></pre><h2 id="3-2- 增删改查"><a href="#3-2- 增删改查" class="headerlink" title="3.2 增删改查"></a>3.2 增删改查 </h2><p> 获取属性：</p><p>在浏览器里的控制台 console 面板运行：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201114171046778.png" alt=""></p><p>增加属性：（当然在代码也也可以增加属性）</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201114171211389.png" alt=""></p><p>删除：<code>delete MrJiang.name</code></p><h2 id="3-3- 函数生成对象（构造函数）"><a href="#3-3- 函数生成对象（构造函数）" class="headerlink" title="3.3 函数生成对象（构造函数）"></a>3.3 函数生成对象（构造函数）</h2><pre><code class="javascript">function Car() &#123;            this.name=&#39;BWM&#39;;            this.height=&#39;1400&#39;;            this.health=100;            this.run=function() &#123;                this.health--;            &#125;;        &#125;var car = new Car();      // 通过函数生成一个对象var car2 = new Car();car2.name=&#39;Tesla&#39;;-------------------------------------------------------function Student(name,age,sex) &#123;            // 这里隐藏个这个 var this=&#123;&#125;;            this.name = name;            this.age = age;            this.sex = sex;            this.grade=2017;            // 隐式的 return this;        &#125;;var zs = new Student(&#39;zs&#39;,18,&#39;male&#39;);      -------------------------------------------------------function Student(name,age,sex) &#123;            // 这里隐藏个这个 var this=&#123;&#125;;            this.name = name;            this.age = age;            this.sex = sex;            this.grade=2017;            return 123;        // 这个就是来搞破坏了, 这个‘return 原始值’是无效的，‘retuen 对象’是可以的（数组，函数都行）        &#125;;var zs = new Student(&#39;zs&#39;,18,&#39;male&#39;);   // 一定要这个 new</code></pre><p>有了 new，函数就产生了构造函数的功能。原始值是没有属性和方法的，只有个 length。只有引用值有。</p><p>构造函数与普通函数的区别：①定义上没有很大区别，构造函数一般首字母大写，创造实例时用 new。②this 指向不同，构造函数的 this 指向实例对象</p><p><strong>因为在 ES6 之前 JS 并没有引入类的概念 所以用构造函数代表类</strong>。</p><p><strong>原始值的属性：</strong></p><pre><code class="javascript">var num = 4;num.len=3;console.log(num.len)   // 输出 undefined，但不报错</code></pre><p>以上执行结果的原因是，系统碰到 num.len=3，知道这是不被允许的，于是就自动补充：<code>new Number(4).len = 3;  delete;</code>给你创建，但创建完就立马删除了，故不对 num.len=3 报错；<br>后面碰到 console.log 输出 num.len，系统又会自动补充<code>new Number(4).len</code>，这个就没被定义，所以输出 undefined。</p><h2 id="3-4- 包装类"><a href="#3-4- 包装类" class="headerlink" title="3.4 包装类"></a>3.4 包装类</h2><pre><code class="javascript">// 将原始值变成对象，这就是包装类var num =new Number(123);var str=new String(&#39;123&#39;);var bol=new Boolean(&#39;true&#39;);</code></pre><p>原始值类型的，通过包装类可以变得有属性。</p><p>一个特例：</p><pre><code class="javascript">var str=&#39;abcd&#39;;str.length=2;    console.log(str.length)  // 结果为 4</code></pre><p>以上运行解释：碰到 <code>str.length=2</code>，自动隐式的创建<code>new String(&#39;abcd&#39;).length=2;</code>，然后立马<code>delete;</code>，然后<code>str.length</code> 取的是对象类型的字符串的属性。</p><p>记住这个：字符串只有一个不可更改的属性 length（字符串还有其他方法的）。赋其他任何属性都不行。</p><h2 id="3-5- 继承模式"><a href="#3-5- 继承模式" class="headerlink" title="3.5 继承模式"></a>3.5 继承模式</h2><ul><li>原型链继承</li><li>借用构造函数继承<ul><li>不能继承借用构造函数的原型</li><li>每次构造函数都要多走一个函数</li></ul></li><li>共享原型<ul><li>不能随便改动子类的原型</li></ul></li><li>圣杯模式</li></ul><h3 id="3-5-1- 原型"><a href="#3-5-1- 原型" class="headerlink" title="3.5.1 原型"></a>3.5.1 原型</h3><p>1、定义：原型是 function 对象的一 个属性（出生即隐式存在），它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。</p><p>2、利用原型特点和概念，可以提取共有属性。</p><p>3、对象如何查看原型一 &gt; 隐式属性<code>_ proto_</code></p><p>4、对象如何查看对象的构造函数一 &gt; <code>constructor</code></p><pre><code class="javascript">Person.prototype.LastName=&#39;Deng&#39;;  // 这里的 prototype 就是原型Person.prototype.say=function () &#123;       console.log(&#39;hehe&#39;);        &#125;;function Person()&#123;       &#125;var person=new Person();   // 虽然函数 Person 什么都没有，但继承了 Person.prototype 的属性console.log(person.LastName)// 输出为‘Deng’---------------------------------------------------function Person()&#123;          this.LastName=&#39;Ji&#39;;     // 在函数中添加这一句，其他不变       &#125;console.log(person.LastName)// 输出为‘Ji’, 自己有就不继承了</code></pre><p>更改原型的指向：在使用 new 将函数 Person()变对象时，默认在函数加了一行代码：<code>var this=&#123;__proto__:Person.prototype&#125;</code>声明的原型的指向。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201115131012309.png" alt=""></p><p>既然这样，那么原型的指向便可以更改：</p><pre><code class="javascript">Person.prototype.LastName = &#39;Deng&#39;;function Person()&#123;    &#125;var ch = &#123;    LastName:&#39;sunny&#39;,        &#125;;var pon = new Person();pon.__proto__ = ch;            // 更改 pon 的原型console.log(pon.LastName)// 输出：sunny</code></pre><h3 id="3-5-2- 原型链"><a href="#3-5-2- 原型链" class="headerlink" title="3.5.2 原型链"></a>3.5.2 原型链</h3><pre><code class="javascript">// 以下就是原型链：Grand.prototype.LastName=&#39;Deng&#39;;function Grand()&#123;&#125;;var grand=new Grand();Father.prototype=grand;function Father()&#123;    this.name=&#39;Xuming&#39;;&#125;var father=new Father();Son.prototype=father;function Son()&#123;    this.hobbit=&#39;smoke&#39;;&#125;var son=new Son();--------------------------------// 控制台里&gt;&gt;&gt;son.lastName&#39;Deng&#39;&gt;&gt;&gt;son.name&#39;Xuming&#39;&gt;&gt;&gt;son.hobbit&#39;smoke&#39;//son 继承了祖先所有的属性</code></pre><p>原型链会过多的继承不该继承的属性。</p><h3 id="3-5-3- 原型创建对象"><a href="#3-5-3- 原型创建对象" class="headerlink" title="3.5.3 原型创建对象"></a>3.5.3 原型创建对象</h3><pre><code class="javascript">Person.prototype.LastName = &#39;Deng&#39;;function Person()&#123;&#125;var pon = Object.create(Person.prototype);</code></pre><h3 id="3-5-4-call-apply"><a href="#3-5-4-call-apply" class="headerlink" title="3.5.4 call/apply"></a>3.5.4 call/apply</h3><p>（1）call</p><p>作用：改变 this 的指向。</p><pre><code class="javascript">function Person(name,age)&#123;    this.name=name;    this.age=age;&#125;var pers=new Person(&#39;deng&#39;,100);var obj=&#123;&#125;;Person.call();   // 等同于 Person() 执行的意思----------------------------------------// 它更大的用处是：Person.call(obj,&#39;cheng&#39;,200);   // 它改变了 Person 函数中的 this 指向，相当于在函数中添加了 this==obj</code></pre><p>此时 obj 就变成了：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201115155551827.png" alt=""></p><p>通过 call 方法，就可以让 obj 借用函数的属性。</p><p>原型链会将长辈的所有特点都会继承过来，有时我们不需要其中的东西，利用上面学的 call 方法可以实现这一点。</p><p>下例就是一个实际应用：</p><pre><code class="javascript">function Person(name,age,sex,health)&#123;    this.name=name;    this.age=age;    this.sex=sex;    this.health=health&#125;function Student(name,age,sex,tel,grade)&#123;    Person.call(this,name,age,sex);   // 调用 Person 函数里的属性    this.tel=tel;    this.grade=grade;&#125;var student=new Student(&#39;sunny&#39;,&#39;123&#39;,&#39;male&#39;,139,2017);</code></pre><p>（2）apply</p><p>与 call 的区别是：call 需要把实参按照形参的个数传进去</p><p>apply 需要传一个 arguments。</p><pre><code class="javascript">……Person.apply(this,[name,age,sex]); // 括起来……</code></pre><h3 id="3-5-5- 共享原型与圣杯模式"><a href="#3-5-5- 共享原型与圣杯模式" class="headerlink" title="3.5.5 共享原型与圣杯模式"></a>3.5.5 共享原型与圣杯模式</h3><pre><code class="javascript">Father.prototype.LastName=&#39;Deng&#39;;function Father()&#123;&#125;var father=new Father();function Son()&#123;&#125;Son.prototype=Father.prototype;   // 只继承 Father 的原型var son=new Son();</code></pre><p>进一步地：</p><pre><code class="javascript">Father.prototype.LastName=&#39;Deng&#39;;function Father()&#123;&#125;function Son()&#123;&#125;function inherit(Target,Origin)&#123;    Target.prototype=Origin.prototype;&#125;inherit(Son,Father);var son=new Son(); ----------------------------------------------------// 以上有个缺点，如添加Son.prototype.sex=&#39;male&#39;;// 则这也改变了 Father 的 sex, 显然不合理//Son.prototype 和 Father.prototype 指向了同一个空间</code></pre><p>共享原型：改变子对象的原型会改变父对象的原型</p><p>圣杯模式：还是共享原型，不过需要一点小技巧。</p><pre><code class="javascript">Father.prototype.LastName=&#39;Deng&#39;;function Father()&#123;&#125;function Son()&#123;&#125;function inherit(Target,Origin)&#123;    function F()&#123;&#125;;    F.prototype=Origin.prototype;    Target.prototype=new F();    Target.prototype.constuctor=Target;&#125;inherit(Son,Father);son.prototype.sex=&#39;male&#39;;var son=new Son(); var father=new Father();// 这样就不影响了</code></pre><h2 id="3-6- 命名空间"><a href="#3-6- 命名空间" class="headerlink" title="3.6 命名空间"></a>3.6 命名空间 </h2><p> 一个网页文件往往是团队合作的结果，经常嵌入多个 js 文件，有时为了实现某个类似的功能，不同的程序员可能写了相似的功能，用了一样的变量命名或者一样的标签名，这时把多个人的工作整合到一起，就会出现冲突的问题。</p><p>这是就出现了命名空间，将变量全放在命名空间里。</p><pre><code class="javascript">// 定义一个命名空间（以创建对象的形式）var org=&#123;    department1:&#123;        jicheng:&#123;            name:&#39;abc&#39;,            age:123        &#125;,        xuming:&#123;            name:&#39;sxc&#39;,            age:23        &#125;    &#125;,    department2:&#123;        zs:&#123;&#125;,        ls:&#123;&#125;      &#125;&#125;// 调用变量var jicheng=org.department1.jicheng;jicheng.name</code></pre><p>以上是老的解决办法。</p><p>现在采用新的方法：使用闭包实现</p><pre><code class="javascript">var name=&#39;dcf&#39;var init=(function()&#123;         // 立即执行函数    var name=&#39;abc&#39;;    function callName()&#123;        console.log(name);    &#125;    return function()&#123;        callName();    &#125;&#125;())var initDeng=(function()&#123;    var name=&#39;Deng&#39;;    function callName()&#123;        console.log(name);    &#125;    return function()&#123;        callName();    &#125;&#125;())init()initDeng()// 以上就不会污染 name 这个变量了</code></pre><h2 id="3-7- 访问属性名"><a href="#3-7- 访问属性名" class="headerlink" title="3.7 访问属性名"></a>3.7 访问属性名</h2><pre><code class="javascript">var obj=&#123;    name:&#39;qwe&#39;&#125;// 访问属性obj.name// 实际上，obj.name 等价于 obj[&#39;name&#39;], 真正执行的是 obj[&#39;name&#39;]obj[&#39;name&#39;]  // 也可以访问属性</code></pre><p>再看个例子：通过拼接的属性访问</p><pre><code class="javascript">var deng=&#123;    wife1:&#123;name:&#39;xiaoliu&#39;&#125;,    wife2:&#123;name:&#39;xiaozhang&#39;&#125;,    wife3:&#123;name:&#39;xiaomeng&#39;&#125;,    callWife:function(num)&#123;        return this[&#39;wife&#39;+num];    &#125;&#125;deng.callWife(2) // 打印出 Object &#123;name:&#39;xiaozhang&#39;&#125;</code></pre><h2 id="3-8- 对象枚举"><a href="#3-8- 对象枚举" class="headerlink" title="3.8 对象枚举"></a>3.8 对象枚举</h2><pre><code class="javascript">var arr=[1,2,3,4,5,6]for (var i=0;i&lt;arr.length;i++)&#123;    console.log(arr[i])&#125;//for in 循环var obj=&#123;    name:&#39;zs&#39;,    age:12,    sex:&#39;male&#39;,    height:180&#125;for (var prop in obj)&#123;    console.log(obj[prop]);   // 这里只能这样访问，console.log(obj.prop)会出现 undefined&#125;// 输出zs 12 male 180</code></pre><p>以上还是那个问题，obj.prop 的意思是 obj[‘prop’]。</p><pre><code class="javascript">var obj=&#123;    name:&#39;zs&#39;,    age:12,    sex:&#39;male&#39;,    height:180,    __proto__:&#123;        lastName:&#39;deng&#39;    &#125;&#125;for (var prop in obj)&#123;    console.log(obj[prop]);&#125;// 输出zs 12 male 180deng// 如果不想要 deng, 可以这样排除原型：for (var prop in obj)&#123;    if (obj.hasOwnProperty(prop))&#123;        console.log(obj[prop]);    &#125; &#125;</code></pre><p><code>instanceof</code>用法及含义</p><p>A instanceof B ：A 对象是不是 B 构造函数构造出来的（看 A 对象原型链上有没有 B 的原型）</p><pre><code>[] instanceof Array// 输出 True</code></pre><p><code>toString</code></p><pre><code class="javascript">// 让数组调用对象的 toString 方法Object.prototype.toString.call([])// 靠 call 改变 this 的指向</code></pre><h2 id="3-9- 克隆"><a href="#3-9- 克隆" class="headerlink" title="3.9 克隆"></a>3.9 克隆</h2><pre><code class="javascript">var obj=&#123;    name:&#39;abc&#39;,    age:123,    card:[&#39;vasa&#39;,&#39;master&#39;],    wife:&#123;        name:&#39;dvc&#39;,        son:&#123;            name:&#39;ass&#39;        &#125;    &#125;&#125;var obj1=&#123;    name:obj.name,    age:obj.age&#125;</code></pre><p>正菜来了：</p><pre><code class="javascript">function deepClone(origin,target)&#123;    var target=target||&#123;&#125;,        toStr=object.prototype.toString,        arrStr=&#39;[Object]&#39;;    for (var prop in origin)&#123;        if (origin.hasOwnProperty(prop))&#123;            if (origin[prop]!==&#39;null&#39;&amp;&amp; typeof(origin[prop])==&#39;object&#39;)&#123;                if(toStr.call(origin[prop])==arrStr)&#123;                    target[prop]=[];                &#125;else&#123;                    target[prop]=&#123;&#125;;                &#125;                deepClone(origin[prop],target[prop]);            &#125;else&#123;                target[prop]=origin[prop];            &#125;        &#125;    &#125;    return target&#125;</code></pre><h1 id="4、数组"><a href="#4、数组" class="headerlink" title="4、数组"></a>4、数组</h1><h2 id="4-1- 数组"><a href="#4-1- 数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><pre><code class="javascript">var arr = [1,2,,4];-------------------------------var arr = new Array(1,2,,4);</code></pre><p>数组的方法</p><ul><li><p>arr.push()：增加元素（单个，多个，数组）</p><pre><code class="javascript">// 实现 push 的方法var arr=[];Array.prototype.push=function()&#123;    for(var i=0;i&lt;arguments.length;i++)&#123;        this[this.length]=arguments[i];    &#125;    return this.length   &#125;</code></pre></li><li><p>arr.pop()：弹出最后一个元素</p></li><li><p>arr.shift()：删除元素（从前开始删）</p></li><li><p>arr.unshift()：增加元素（从前开始插）</p></li><li><p>arr.reverse()：逆转元素的顺序</p></li><li><p>arr.sort()：元素排序（默认升序），arr.sort().reverse()降序</p><pre><code class="javascript">// 这里排序有个问题var arr=[1,3,5,4,10]-----------------------// 控制台里&gt;&gt;&gt;arr.sort()Array(5) [1, 10, 3, 4, 5]  // 这里排序是按 ascii 码排的-----------------------------------------// 自定义排序//1. 函数体里必须写两形参//2. 看返回值  1)当返回值为负数时，那么前面的数放在前面//           2)为正数时，那么后面的数在前//           3)为 0，不动arr.sort(function(a,b)&#123;   return a-b;// 升序   //retrun b-a; 降序&#125;);// 控制台里&gt;&gt;&gt;arrArray(5) [1, 3, 4, 5, 10]-----------------------------------------------// 乱序arr.sort(function(a,b)&#123;   return Math.random()-0.5;&#125;);----------------------------------------------------var cheng=&#123;    name:&#39;cheng&#39;,    age:18,    sex:&#39;male&#39;,    face:&#39;handsome&#39;,&#125;;var deng=&#123;    name:&#39;deng&#39;,    age:40,    sex:undefined,    face:&#39;amazing&#39;,&#125;;var zhang=&#123;    name:&#39;zhang&#39;,    age:20,    sex:&#39;female&#39;,&#125;;var arr=[cheng,deng,zhang];arr.sort(function(a,b)&#123;    return a.age-b.age;&#125;)// 控制台里&gt;&gt;&gt;arr0: Object &#123; name: &quot;cheng&quot;, age: 18, sex: &quot;male&quot;, … &#125;1: Object &#123; name: &quot;zhang&quot;, age: 20, sex: &quot;female&quot; &#125;2: Object &#123; name: &quot;deng&quot;, age: 40, face: &quot;amazing&quot;, … &#125;length: 3&lt;prototype&gt;: Array []</code></pre></li><li><p>arr.splice(从第几位开始，截取长度，在切口处添加新元素)：切片</p><pre><code class="javascript">var arr=[1,2,3,5]-----------------------// 控制台里&gt;&gt;&gt;arrArray(4) [1, 2, 3, 5]&gt;&gt;&gt;arr.splice(3,0,4)Array[]&gt;&gt;&gt;arrArray(5) [1, 2, 3, 4, 5]---------------------------------&gt;&gt;&gt;arrArray(4) [1, 2, 3, 4, 5]&gt;&gt;&gt;arr.splice(-1,2)Array[5]&gt;&gt;&gt;arrArray(4)[1,2,3,4]</code></pre></li><li><p>arr.toString()：将数组变成字符串</p></li><li><p>arr.slice(begin,end)：切片</p></li><li><p>arr.join(str)：按照 str 的规则连接，返回字符串类型</p><pre><code class="javascript">var arr=[1, 2, 3, 4, 5]// 控制台里&gt;&gt;&gt;arr.join(&#39;-&#39;)1-2-3-4-5</code></pre></li><li><p>str.split()：按照括号里的规则拆分，返回为数组类型</p><pre><code class="javascript">var str=&#39;1-2-3-4-5&#39;// 控制台里&gt;&gt;&gt;arr.split(&#39;-&#39;)[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;]  </code></pre></li></ul><h2 id="4-2- 类数组"><a href="#4-2- 类数组" class="headerlink" title="4.2 类数组"></a>4.2 类数组 </h2><p> 类数组要求：属性要为索引（数字）属性，必须有 length 属性，最好加上 push</p><pre><code class="javascript">  var obj=&#123;      &#39;0&#39;:&#39;a&#39;,      &#39;1&#39;:&#39;b&#39;,      &#39;2&#39;:&#39;c&#39;,      &#39;length&#39;:3,      &#39;push&#39;:Array.prototype.push  &#125;  // 控制台里  &gt;&gt;&gt;obj  Object &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, push: push() &#125;  &gt;&gt;&gt;obj.push(&#39;d&#39;)  4  &gt;&gt;&gt;obj  Object &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, 3: &quot;d&quot;, length: 4, push: push() &#125;</code></pre><p>  如果 obj 对象再加个 splice 属性，长得就完全像个数组了。</p><pre><code class="javascript">  var obj=&#123;      &#39;0&#39;:&#39;a&#39;,      &#39;1&#39;:&#39;b&#39;,      &#39;2&#39;:&#39;c&#39;,      &#39;length&#39;:3,      &#39;push&#39;:Array.prototype.push,      &#39;splice&#39;:Array.prototype.splice,  &#125;  // 控制台里  &gt;&gt;&gt;obj  [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</code></pre><h1 id="5、补充知识点"><a href="#5、补充知识点" class="headerlink" title="5、补充知识点"></a>5、补充知识点</h1><h2 id="5-1- 错误类型"><a href="#5-1- 错误类型" class="headerlink" title="5.1 错误类型"></a>5.1 错误类型</h2><ul><li>EvalError：eval()的使用与定义不一致</li><li>RangeError：数值越界</li><li>ReferenceError：非法或不能识别的引用数值</li><li>SyntaxError：发生语法解析错误</li><li>TypeError：操作数类型错误</li><li>URlError：URl 处理函数使用不当</li></ul><h2 id="5-2- 错误捕捉及处理"><a href="#5-2- 错误捕捉及处理" class="headerlink" title="5.2 错误捕捉及处理"></a>5.2 错误捕捉及处理</h2><pre><code class="javascript">try&#123;    console.log(&#39;a&#39;);    console.log(b);    console.log(&#39;c&#39;);&#125;catch(e)&#123;    console.log(e.name+&#39;:&#39;+e.massage);&#125;// 尝试执行 try 里面的代码，如果出现报错，则立即转到执行 catch 里的代码</code></pre><p>在 try 里面发生错误，不会执行错误后的 try 里面的代码。例如上述代码中，console.log(‘c’)便不会执行。</p><h2 id="5-3- 严格模式"><a href="#5-3- 严格模式" class="headerlink" title="5.3 严格模式"></a>5.3 严格模式</h2><p>JavaScript 的语法标准随着时间的更替也在不断更新，从 ES3.0 到 ES5.0，语法更新可能会导致某些方法不兼容。现在主流采用 ES5.0 标准(其实目前已经到 10 版本了)。</p><pre><code class="javascript">// 写在代码最前面，表示支持 ES5.0 的严格模式&#39;use strict&#39;;</code></pre><p>严格模式既可以写在全局中，可以写在局部函数里（推荐局部）。</p><p>严格模式下，变量使用前必须先声明；局部 this 必须被赋值</p><h1 id="6、DOM"><a href="#6、DOM" class="headerlink" title="6、DOM"></a>6、DOM</h1><h2 id="6-1-DOM"><a href="#6-1-DOM" class="headerlink" title="6.1 DOM"></a>6.1 DOM</h2><p>DOM 是 Document Object Model 的缩写，定义了表示和修改文档所需的方法。DOM 对象即为宿主对象，有浏览器厂商定义，用来操作 html 和 xml 功能的一类对象的集合。也可以说 DOM 是对 HTML 及 XML 的标准编程接口。</p><p>DOM 不能直接操作 CSS。</p><p>xml 和 html：</p><p>DOM 的使用示例：</p><pre><code class="javascript">&lt;script type=&#39;text/javascript&#39;&gt;  //dom 对象  var div=documnet.getElementByTagName(&#39;div&#39;)[0]; // 选取 html 中的 div 便签  div.style.width=&#39;100px&#39;;  div.style.height=&#39;100px&#39;;  div.style.backgroundColor=&#39;red&#39;;  var count=0;  div.onclick=function()&#123;      count++;      if (count%2==1)&#123;          this.style.backgrandColor=&#39;green&#39;;// 点击变绿      &#125;else&#123;          this.style.backgrandColor=&#39;red&#39;;// 点击变红      &#125;  &#125;&lt;/script&gt;</code></pre><h2 id="6-2- 事件"><a href="#6-2- 事件" class="headerlink" title="6.2 事件"></a>6.2 事件 </h2><h1 id="7、数据传输"><a href="#7、数据传输" class="headerlink" title="7、数据传输"></a>7、数据传输</h1><h2 id="7-1-json"><a href="#7-1-json" class="headerlink" title="7.1 json"></a>7.1 json</h2><p> 一种数据传输格式，一种类似‘对象’的数据格式，便于前端和后端数据传输。</p><pre><code class="javascript">//json&#39;&#123;&#39;name&#39;:&#39;Jiang&#39;,&#39;age&#39;:18&#125;&#39;</code></pre><p>js 中的对象变为 json 格式：</p><pre><code class="javascript">var obj=&#123;    name:&#39;Jiang&#39;,    age:18&#125;var str=JSON.stringify(obj)// 控制台里&gt;&gt;&gt;str&quot;&#123;&#39;name&#39;:&#39;Jiang&#39;,&#39;age&#39;:18&#125;&quot;</code></pre><p>json 格式变 js 中的对象：</p><pre><code class="javascript">var obj=JSON.parse(str)</code></pre><h2 id="7-2- 异步加载"><a href="#7-2- 异步加载" class="headerlink" title="7.2 异步加载"></a>7.2 异步加载</h2><p>js 加载：js 加载是一种同步加载，加载到 javascript 文件时，暂时阻断了 html 和 css 的的加载线，等 js 加载并执行完毕后，再继续执行 html 的 css 的加载。注意 js 加载本身是单线程的。是阻塞的。</p><p>但是有些 js 的存在就只是为了初始化一些数据，与页面没关系，不会修改操作页面。这些 js 文件包只是为了引入工具包（模块化的 function）, 不调用就不会执行，不会影响页面，于是就可以采用并行先加载过来，提高效率。</p><p>javascript 异步加载的三种方案：</p><ul><li><p>defer 异步加载，但是要等到 dom 文档全部解析完才会被执行。只有 IE 能用，也可以将代码写到内部。</p><pre><code class="javascript">&lt;script type=&#39;text/javascript&#39; src=&#39;tools.js&#39; defer=&#39;defer&#39;&gt;&lt;/script&gt;// 执行到这时，不会阻塞后续的 html 和 css 的加载</code></pre></li><li><p>async 异步加载，加载完就执行，async 只能加载外部脚本，不能把 js 写在 script 标签里。</p><ul><li>执行时不会阻塞页面</li></ul><pre><code class="javascript">&lt;script type=&#39;text/javascript&#39; src=&#39;tools.js&#39; async=&#39;async&#39;&gt;&lt;/script&gt;</code></pre></li></ul><ul><li><p>创建 script，插入到 DOM 中，加载完毕后 callback。这种就是按需加载。</p><pre><code class="javascript">&lt;script type=&#39;text/javascript&#39;&gt;    var script=document.createElement(&#39;script&#39;);    script.type=&#39;text/javascript&#39;;    script.src=&#39;tools.js&#39;;    script.onload=function()&#123;     // 此处的作用是等 tools.js 加载完毕再执行 test        test();    &#125;//script.onload 支持 chrome,safari,firefox,opera, 不支持 IE    document.head.appendChild(script);&lt;/script&gt;-----------------------------------------//tools.js 文件alter(&#39; 我居然这么帅 &#39;)function test()&#123;    console.log(&#39;a&#39;)&#125;</code></pre><p>进行函数封装（最终的形式）：</p><pre><code class="javascript">&lt;script type=&#39;text/javascript&#39;&gt;    function loadScript(url,callback)&#123;        var script=document.createElement(&#39;script&#39;);        script.type=&#39;text/javascript&#39;;        if (script.readState)&#123;// 处理 IE 浏览器            script.onreadystatechange=function()&#123;                if (script.readyState==&#39;comlete&#39;||script.readyState==&#39;loaded&#39;)&#123;                    tools[callback]();                &#125;            &#125;        &#125;else&#123;// 处理目前几种主流浏览器             script.onload=function()&#123;                     tools[callback]();            &#125;        &#125;        script.src=url;        document.head,appendChild(script);    &#125;    load.Script(&#39;tools.js&#39;,&#39;test&#39;)&lt;/script&gt;---------------------------------------//tools.js 文件var tools=&#123;    test:function()&#123;        console.log(&#39;a&#39;)    &#125;,    demo:function()&#123;&#125;&#125;</code></pre></li></ul><blockquote><p>asynchronous javascript and xml    —-&gt;ajax</p></blockquote><h2 id="7-3-js 加载时间线"><a href="#7-3-js 加载时间线" class="headerlink" title="7.3 js 加载时间线"></a>7.3 js 加载时间线 </h2><p> 浏览器的执行顺序：</p><ol><li>创建 Document 对象，开始解析 web 页面，解析 HTML 元素和他们的文本内容后添加 Element 对象和 Text 节点到文档中。这个阶段 document.readyState=’loading’。</li><li>遇到 Link 外部 CSS，创建线程加载，并继续解析文档。</li><li>遇到 script 外部 js，并且没有设置 async，defer，浏览器加载，并阻塞，等待 js 加载完成并执行该脚本，然后继续解析文档。</li><li>遇到 script 外部 js，并且设置有 async，defer，浏览器创建线程加载，并继续解析文档。对于 async 属性的脚本，脚本加载完成后立即执行。（异步禁止使用 document.write()）</li><li>遇到 img 等，先正常解析 dom 结构，然后浏览器异步加载 src，并继续解析文档。</li><li>当文档解析完成，document.readyState=’interactive’。</li><li>当文档解析完成后，所有设置有 defer 的脚本会按照顺序执行。（注意与 async 的不同，但同样禁止使用 document.write()）</li><li>document 对象触发 DOMContenLoaded 事件，这也标志这程序执行从同步脚本执行阶段，转化为事件驱动阶段。</li><li>当所有 async 的脚本加载完毕并执行后，img 等加载完毕后，document.readyState=’complete’，window 对象触发 load 事件。</li><li>从此，以异步响应方式处理用户输入，网络事件等。</li></ol><h1 id="8、正则"><a href="#8、正则" class="headerlink" title="8、正则"></a>8、正则 </h1><h2 id="8-1- 实现方式"><a href="#8-1- 实现方式" class="headerlink" title="8.1 实现方式"></a>8.1 实现方式</h2><p> 正则实现的几种形式：</p><ul><li><code>/ 匹配规则 / 修饰符</code></li><li><code>new RegExp(匹配规则，修饰符)</code></li></ul><p>举个例子：</p><pre><code class="javascript">&lt;script type=&#39;text/javascript&#39;&gt;    var reg_1=/^a/g;                 // 第一种形式    var reg_2=new RegExp(&#39;^a&#39;,&#39;mg&#39;);  // 第二种形式    var str=&#39;abcd\na&#39;;&lt;/script&gt;-----------------------------// 控制台里&gt;&gt;&gt;reg_1.test(str)true&gt;&gt;&gt;str.match(reg_1) // 匹配以 a 开头的字符Array[&#39;a&#39;]&gt;&gt;&gt;str.match(reg_2)Array[&#39;a&#39;,&#39;a&#39;]</code></pre><h2 id="8-2- 修饰符与匹配规则"><a href="#8-2- 修饰符与匹配规则" class="headerlink" title="8.2 修饰符与匹配规则"></a>8.2 修饰符与匹配规则 </h2><p> 修饰符：</p><ul><li>i：执行对大小写不敏感的匹配</li><li>g：执行全局匹配（查找所有符合条件的匹配）</li><li>m：执行多行匹配，对于多行字符而言</li></ul><p>匹配规则：</p><p>方括号：用于查找某个范围内的字符。</p><p>如<code>[abc]</code>，查找方括号之间的任意字符</p><p>如<code>[^abc]</code>，查找不在方括号里的字符</p><p>等等…………，还有元字符，与 python 里的正则差不多。</p><p>举个例子：</p><pre><code class="javascript">&lt;script type=&#39;text/javascript&#39;&gt;   var reg=/[0-9A-z][cd][d]/g;   // 第一位匹配 0 至 9 或 A 至 z，第二位匹配 c 或 d，第三位匹配 d   var str=&#39;adc1cd&#39;&lt;/script&gt;-----------------------------// 控制台里&gt;&gt;&gt;str.match(reg)[&#39;1cd&#39;]</code></pre><p>一些常见的函数方法</p><ul><li><code>alert(a)</code>弹窗函数</li><li>字符串方法：<ul><li><code>str.charAt(1)</code>，取出字符串 str 的第 2 位字符</li><li><code>str.charCodeAt(i)</code>，给出字符串 str 的第 i+1 位字符的 unicode 编码值。</li></ul></li><li>交互输入：<code>num = window.prompt(&#39;input&#39;)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python 中的语法糖</title>
      <link href="/python%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
      <url>/python%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/3.2.1/pangu.min.js"></script><p> 链接：<a href="https://blog.csdn.net/five3/article/details/83474633">https://blog.csdn.net/five3/article/details/83474633</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python 中的进程，线程与协程</title>
      <link href="/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/"/>
      <url>/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="GIL 全局解释器锁"><a href="#GIL 全局解释器锁" class="headerlink" title="GIL 全局解释器锁"></a>GIL 全局解释器锁 </h1><p> 在提到进程、线程和协程前，不得不提下<strong>GIL</strong>(<a href="https://zhuanlan.zhihu.com/p/97218985">Global Interpreter Lock</a>)，全局解释器锁。</p><p><strong>GIL</strong>是一个互斥锁（mutex），是 CPython（Python 解释器）限制了同一时间内，一个进程里只能有一个线程运行。它阻止了 多个线程同时执行 Python 字节码，毫无疑问，这降低了执行效率。</p><p>Python 最初的设计理念在于，<strong>为了解决多线程之间数据完整性和状态同步的问题，设计为在任意时刻只有一个线程在解释器中运行。</strong>而当执行多线程程序时，由 GIL 来控制同一时刻只有一个线程能够运行。即 Python 中的多线程是表面多线程，也可以理解为‘假’多线程，不是真正的多线程。</p><p>为什么要这样做呢？举个例子，比如用 python 计算：n=n+1。这个操作被分成了四步：</p><ul><li>加载全局变量 n</li><li>加载常数 1</li><li>进行二进制加法运算</li><li>将运算结果存入变量 n</li></ul><p>以上的过程是非原子操作的，根据前面的线程释放 GIL 锁原则，线程 a 执行这四步的过程中，有可能会让出 GIL。如果这样，n=n+1 的运算过程就被打乱了。</p><p>这就是为什么我们说 GIL 是粗粒度的，它只保证了一定程度的安全。如果要做到线程的绝对安全，是不是所有的非 IO 操作，我们都需要自己再加一把锁呢？答案是否定的。在 python 中，有些操作是是原子级的，它本身就是一个字节码，GIL 无法在执行过程中释放。对于这种原子级的方法操作，我们无需担心它的安全。比如 sort 方法，[1,4,2].sort()，翻译成字节码就是 CALL METHOD 0。只有一行，无法再分，所以它是线程安全的。</p><p>同一时刻只有一个线程能够运行，那么是怎么执行多线程程序的呢？其实原理很简单：解释器的 <strong> 分时复用 </strong>。即多个线程的代码，<strong> 轮流 </strong> 被解释器 <strong> 执行 </strong>，只不过切换的很频繁很快，给人一种多线程“同时”在执行的错觉。聊的学术化一点，其实就是“<strong> 并发</strong>”。</p><p><strong>“并发”和“并行”：</strong></p><ul><li>并发：不同的代码块交替执行</li><li>并行：不同的代码块同时执行</li></ul><p><strong>GIL 锁最终是保证 Python 解释器中原子操作的线程安全</strong>。</p><p><strong>GIL 是怎么起作用的：</strong></p><ul><li>由于 GIL 的机制，单核 CPU 在同一时刻只有一个线程在运行，当线程遇到 IO（读写）操作或 Timer  Tick 到期，释放 GIL 锁。其他的两个线程去竞争这把锁，得到锁之后，才开始运行。</li><li>线程释放 GIL 锁有两种情况，一是遇到 IO 操作，二是 Time Tick 到期（执行完 100 个字节码指令或者 15ms）。IO 操作很好理解，比如发出一个 http 请求，等待响应。而 Time Tick 规定了线程的最长执行时间，超过时间后自动释放 GIL 锁。</li></ul><p>在多核 CPU 下，由于 GIL 锁的全局特性，无法发挥多核的特性，GIL 锁会使得多线程任务的效率大大降低。线程 1（Thread1）在 CPU1 上运行，线程 2（Thread2）在 CPU2 上运行。GIL 是全局的，CPU2 上的 Thread2 需要等待 CPU1 上的 Thread1 让出 GIL 锁，才有可能执行。如果在多次竞争中，Thread1 都胜出，Thread2 没有得到 GIL 锁，意味着 CPU2 一直是闲置的，无法发挥多核的优势。为了避免同一线程霸占 CPU，在 python3.x 中，线程会自动的调整自己的优先级，使得多线程任务执行效率更高。</p><p><strong>GIL 的优缺点：</strong></p><ul><li><p>GIL 的优点是显而易见的，GIL 可以保证我们在多线程编程时，无需考虑多线程之间数据完整性和状态同步的问题。</p></li><li><p>GIL 缺点是：我们的多线程程序执行起来是“并发”，而不是“并行”。因此执行效率会很低，会不如单线程的执行效率。</p></li></ul><p><strong>原子操作：</strong></p><ul><li>原子操作就是不会因为进程并发或者线程并发而导致被中断的操作。<strong>原子操作 </strong> 的特点就是 <strong> 要么一次全部执行，要么全不执行</strong>。不存在执行了一半而被中断的情况。</li></ul><p><strong>Python 解释器：</strong></p><ul><li>python 解释器是有多个版本的：CPython, Jpython 等。CPython 就是用 C 语言实现 Python 解释器，JPython 是用 Java 实现 Python 解释器。那么 GIL 的问题实际上是存在于 CPython 中的。</li></ul><p>最初是为了利用多核，Python 开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。后来发现这种‘加锁’是低效的。但 <strong> 当大家试图去拆分和去除 GIL 的时候，发现大量库代码开发者已经重度依赖 GIL 而非常难以去除了</strong>。</p><p><strong>在 Python 编程中，如果想利用计算机的多核提高程序执行效率，用多进程代替多线程。</strong></p><p>使用多进程的好处：完全并行，无 GIL 的限制，可充分利用多 cpu 多核的环境。</p><p>虽说一般使用多进程对电脑系统资源占用比较多，但是在类 unix 系统中，创建线程的开销并不比进程小，因此在并发操作时，多线程的效率还是受到了很大制约的。所以后来人们发现通过 yield 来中断代码片段的执行，同时交出了 cpu 的使用权，于是协程的概念产生了。</p><h1 id="进程、线程与协程"><a href="# 进程、线程与协程" class="headerlink" title="进程、线程与协程"></a>进程、线程与协程 </h1><p><strong> 进程（process）是系统资源分配的最小单位，线程（thread）是程序执行的最小单位</strong>。</p><p><strong>而协程（Coroutine）不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201105220526734.png" alt=""></p><p>一个程序（进程）在计算机上运行时，操作系统会以进程为单位，分配系统资源（CPU 时间片、内存等资源），当这个进程存在多个线程时，由于 GIL 锁，系统资源的红箭头会随机指向其中一个进程，供其使用。遇到 IO 操作或者 Time Tick 到期（执行完 100 个字节码指令或者 15ms），该线程被设置成睡眠状态，红箭头就又会随机重新指向其中一个线程执行（按优先级），这就是多线程。</p><p>协程的概念应该是从进程和线程演变而来的，协程其实并不真正存在，它只是人为设想的一种产物，由程序或用户可随意切换执行。协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p><strong>协程的特点在一个线程中执行，那和多线程比，协程有何优势？</strong></p><ul><li><strong>极高的执行效率 </strong>：因为<strong> 子程序切换不是线程切换，而是由程序自身控制 </strong>，因此，<strong> 没有线程切换的开销</strong>，和多线程比，线程数量越多，协程的性能优势就越明显；</li><li><strong>不需要多线程的锁机制 </strong>：因为只有一个线程，也不存在同时写变量冲突，<strong> 在协程中控制共享资源不加锁</strong>，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ul><p>当你程序中方法需要等待时间的话，就可以用协程，效率高，消耗资源少。</p><p>python 可以通过 yield/send 的方式实现 <strong> 协程</strong>。以此有程序员控制函数的中断与执行。</p><p>在 Python3.4 正式引入了协程的概念，代码示例如下：</p><pre><code class="python">import asyncio# Borrowed from http://curio.readthedocs.org/en/latest/tutorial.html.@asyncio.coroutinedef countdown(number, n):    while n &gt; 0:        print(&#39;T-minus&#39;, n, &#39;(&#123;&#125;)&#39;.format(number))        yield from asyncio.sleep(1)        n -= 1loop = asyncio.get_event_loop()tasks = [asyncio.ensure_future(countdown(&quot;A&quot;, 2)),    asyncio.ensure_future(countdown(&quot;B&quot;, 3))]loop.run_until_complete(asyncio.wait(tasks))loop.close()</code></pre><p>示例显示了在 Python3.4 引入两个重要概念 <strong> 协程 </strong> 和<strong>事件循环 </strong>。<br> 通过修饰符 @asyncio.coroutine 定义了一个协程，而通过 event loop 来执行 tasks 中所有的协程任务。</p><p>之后在 Python3.5 引入了新的 async &amp; await 语法，从而有了原生协程的概念。</p><h2 id="多进程示例"><a href="# 多进程示例" class="headerlink" title="多进程示例"></a>多进程示例</h2><p>multiprocessing 是 Python 的标准模块，它既可以用来编写多进程，也可以用来编写多线程。multiprocessing  提供了一个 Process 类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。</p><pre><code class="python">import multiprocessing       // 导入多进程库import timedef upload():    print(&quot; 开始上传文件...&quot;)    time.sleep(5)    print(&quot; 完成上传文件...&quot;)def download():    print(&quot; 开始下载文件...&quot;)    time.sleep(2)    print(&quot; 完成下载文件...&quot;)def main():    start=time.time()    #同时开启两个子进程    multiprocessing.Process(target=upload).start()    multiprocessing.Process(target=download).start()    end=time.time()    print(&#39;A 总耗时：%s&#39;%(end-start))if __name__ == &#39;__main__&#39;:    begin = time.time()    main()    stop=time.time()    print(&#39;B 总耗时：%s&#39;%(stop-begin))#输出结果：A 总耗时：0.02892470359802246B 总耗时：0.02892470359802246 开始上传文件... 开始下载文件... 完成下载文件... 完成上传文件...</code></pre><p>这里面相当于有三个进程，该程序的这个主进程加上两个子进程 upload 和 download。从运行结果看，先输出了 A 和 B 的总耗时，这个是属于主进程的，因为耗时少，先运行完先输出，upload 和 download 两个子进程因为 time.sleep()的存在，先后输出。upload 和 download 谁先执行不一定的。</p><h2 id="多线程示例"><a href="# 多线程示例" class="headerlink" title="多线程示例"></a>多线程示例 </h2><p> 当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行流的最小单元，当设置多线程时，主线程会创建多个子线程，在 python  中，主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。</p><pre><code class="python">import threadingimport timedef target():    print(&quot;%s is runing&quot;%(threading.current_thread().name))    time.sleep(2)    print(&quot;%s is ended&quot;%(threading.current_thread().name))print(&quot;%s is runing&quot;%(threading.current_thread().name))   #主程序开始t = threading.Thread(target=target)   t.start()# t.join() # t.join 是阻塞当前线程(此处的当前线程是主线程) #可以使主线程直到 Thread-1 结束之后才结束print(&quot;%s is ended&quot;%(threading.current_thread().name))#输出结果为：MainThread is runingThread-1 is runingMainThread is endedThread-1 is ended</code></pre><h2 id="进程池与线程池"><a href="# 进程池与线程池" class="headerlink" title="进程池与线程池"></a>进程池与线程池 </h2><p> 均采用 <code>concurrent.futures</code> 模块。池的好处是，对于多个的进程 / 线程，它能进行合理调控，比如可以设置同时只能进行 5 个任务，避免 python 占用过多的电脑资源，当运行中的 5 个任务完成了其中 3 个，池会自动进行补调，保证同时 5 个任务的进行。</p><p><strong>进程池</strong></p><ul><li><pre><code class="python">import concurrent.futuresprocess_pool=concurrent.futures.ProcessPoolExecutor(max_workers=) // 创建进程池process_pool.submit(tasks, arg*)    // 提交任务process_pool.shutdown()</code></pre></li><li><p>示例：</p><pre><code class="python">import concurrent.futuresdef download_one_page(url, name):    print(&#39;&#123;&#125; 对应的 &#123;&#125; 下载完毕 &#39;.format(url,name))process_pool=concurrent.futures.ProcessPoolExecutor(max_workers=5) // 设置最多子任务为 5for url, name in result:  # 每一次循环都启动一个新的线程    host_url = &#39;http://www.shuquge.com/txt/8659/&#39;    process_pool.submit(download_one_page, host_url+url, name)process_pool.shutdown()</code></pre></li></ul><p><strong>线程池</strong></p><ul><li><pre><code class="python">thread_pool=concurrent.futures.ThreadPoolExecutor(max_workers=)thread_pool.submit(tasks, arg*)thread_pool.shutdown()</code></pre></li><li><p>示例：</p><pre><code class="python">import concurrent.futuresdef download_one_page(url, name):    print(&#39;&#123;&#125; 对应的 &#123;&#125; 下载完毕 &#39;.format(url,name))thread_pool=concurrent.futures.ThreadPoolExecutor(max_workers=5) // 设置最多子任务为 5for url, name in result:  # 每一次循环都启动一个新的线程    host_url = &#39;http://www.shuquge.com/txt/8659/&#39;    thread_pool.submit(download_one_page, host_url + url, name)thread_pool.shutdown()</code></pre><p>以上程序也可这样写：</p><pre><code class="python"># 最简单方法是作为上下文管理器，使用 with 语句来管理池的创建和销毁。import concurrent.futuresif __name__ == &quot;__main__&quot;:    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:         for url, name in result:  # 每一次循环都启动一个新的线程             host_url = &#39;http://www.shuquge.com/txt/8659/&#39;             executor.map(download_one_page, host_url + url, name)</code></pre></li></ul><h3 id="多进程、多线程爬取小说"><a href="# 多进程、多线程爬取小说" class="headerlink" title="多进程、多线程爬取小说"></a>多进程、多线程爬取小说</h3><pre><code class="python">import requestsimport reimport timeimport concurrent.futuresdef get_index():    response = requests.get(&#39;http://www.shuquge.com/txt/8659/index.html&#39;)    response.encoding = response.apparent_encoding    html = response.text    result = re.findall(&#39;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#39;, html)    return result# 多线程def thread_download_ebook(url, name):    print(name, url)    response = requests.get(url)    response.encoding = response.apparent_encoding    html = response.text    result = re.findall(&#39;&lt;div id=&quot;content&quot; class=&quot;showtxt&quot;&gt;(.*?)&lt;/div&gt;&#39;, html, re.S)    with open(name + &#39;.txt&#39;, mode=&#39;w&#39;, encoding=&#39;utf-8&#39;) as f:        f.write(result[0].replace(&#39;&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#39;, &quot;&quot;).replace(&#39;&lt;br/&gt;&#39;, &quot;&quot;))# 多进程def process_download_ebook(urls):    # 每一个进程 启动五个线程 25    thread_pool = concurrent.futures.ThreadPoolExecutor(max_workers=5)    for url, name in urls:        # 往线程池里面放任务        thread_pool.submit(thread_download_ebook, &#39;http://www.shuquge.com/txt/8659/&#39; + url, name)    # 等待线程池关闭    thread_pool.shutdown()if __name__ == &#39;__main__&#39;:    content_list = get_index()[:20]    length = int(len(content_list)/5)  # 把所有任务分成五份    start_time = time.time()    # 启动五个进程    # 进程之间的相互通信 默认情况下 进程之间的变量不共享数据    process_pool = concurrent.futures.ProcessPoolExecutor(max_workers=length)    for i in range(length):        if i == length:            i += 1        process_pool.submit(process_download_ebook, content_list[i * length:(i + 1) * length])    process_pool.shutdown()    print(time.time() - start_time)</code></pre><h2 id="协程示例"><a href="# 协程示例" class="headerlink" title="协程示例"></a>协程示例 </h2><p>async/await 关键字是出现在 python3.5 版本中的新功能，是一种关于<strong> 协程 </strong> 的语法糖。从此 python 就正式有了原生协程的概念。</p><p>正常的函数在执行时是不会中断的，所以你要写一个能够中断的函数，就需要添加 async 关键词。</p><p><code>async</code> 用来声明一个函数为异步函数，异步函数的特点是能在函数执行过程中挂起，去执行其他异步函数，等到挂起条件消失后，再回来执行。</p><p><code>await</code> 用来声明程序挂起，比如异步程序执行到某一步时需要等待的时间很长，就将此挂起，去执行其他的异步程序，await 后面只能跟异步程序函数或有 <code>__await__</code> 属性的对象，也就是说 await 表达式中的对象必须是 awaitable 的。</p><p>awaitable 对象必须满足如下条件中其中之一：</p><ul><li><strong>原生协程对象</strong></li><li>types.coroutine()修饰的 <strong> 基于生成器的协程对象</strong></li><li>实现了 await method，并在其中返回了<strong>iterator 的对象（可迭代对象）</strong></li></ul><p><strong>举例一：</strong></p><pre><code class="python">def main():    //1、定义异步函数    async def funcA():             #声明 funcA 为一个异步函数（或者叫协程函数）        await asyncio.sleep(4)        print(&#39;A 函数执行完毕 &#39;)    async def funcB():              #定义的协程函数就是原生协程对象        await asyncio.sleep(2)        print(&#39;B 函数执行完毕 &#39;)    async def funcD():        await asyncio.sleep(8)        print(&#39;D 函数执行完毕 &#39;)    //2、创建一个事件循环        loop = asyncio.get_event_loop()     //3、将异步函数加入事件队列    tasks=[funcA(),funcB(),funcD()]    //4、执行事件队列, 直到最晚的一个事件被处理完毕后结束    loop.run_until_complete(asyncio.wait(tasks))    //5、如果不再使用 loop, 建议养成良好关闭的习惯    loop.close()if __name__==&#39;__main__&#39;:    start=time.time()    main()    end=time.time()    print(&#39; 总耗时为：&#39;+ str(end-start))#输出结果为：B 函数执行完毕A 函数执行完毕D 函数执行完毕总耗时为：8.006016969680786s</code></pre><p><strong>举例二：</strong></p><pre><code class="python">import asyncioimport requestsimport timeasync def download(url):     print(&quot;get %s&quot; % url)        response = requests.get(url)    print(response.status_code)async def wait_download(url):    await download(url)        # 这里 download(url)就是一个原生的协程对象    print(&quot;get &#123;&#125; data complete.&quot;.format(url))async def main():    start = time.time()    await asyncio.wait([wait_download(&quot;http://www.163.com&quot;),        wait_download(&quot;http://www.mi.com&quot;),        wait_download(&quot;http://www.baidu.com&quot;)])    end = time.time()    print(&quot;Complete in &#123;&#125; seconds&quot;.format(end - start))loop = asyncio.get_event_loop()loop.run_until_complete(main())#运行结果：get http://www.163.com200get http://www.163.com data complete.get http://www.baidu.com200get http://www.baidu.com data complete.get http://www.mi.com200get http://www.mi.com data complete.Complete in 0.49027466773986816 seconds</code></pre><p>程序可以运行，不过仍然有一个问题就是：它并没有真正地异步执行。</p><p>这里程序始终是同步执行的，这就说明仅仅是把涉及 I/O 操作的代码封装到 async 当中是不能实现异步执行的。必须使用支持异步操作的非阻塞代码才能实现真正的异步。目前支持非阻塞异步 I/O 的库是 aiohttp。</p><pre><code class="python">import asyncioimport aiohttpimport timeasync def download(url): # 通过 async def 定义的函数是原生的协程对象    print(&quot;get: %s&quot; % url)    async with aiohttp.ClientSession() as session:        async with session.get(url) as resp:            print(resp.status)            # response = await resp.read()# 此处的封装不再需要# async def wait_download(url):#    await download(url) #    print(&quot;get &#123;&#125; data complete.&quot;.format(url))async def main():    start = time.time()    await asyncio.wait([download(&quot;http://www.163.com&quot;),        download(&quot;http://www.mi.com&quot;),        download(&quot;http://www.baidu.com&quot;)])    end = time.time()    print(&quot;Complete in &#123;&#125; seconds&quot;.format(end - start))loop = asyncio.get_event_loop()loop.run_until_complete(main())#测试结果：get: http://www.mi.comget: http://www.163.comget: http://www.baidu.com200200200Complete in 0.27292490005493164 seconds</code></pre><p>可以看出这次是真正的异步了。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 常见命令学习</title>
      <link href="/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
      <url>/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个程序员连 Linux 命令都不会，还算什么程序员！</p><p>这里对常见的 Linux 命令做一个总结。</p></blockquote><p>Linux，全称 GNU/Linux，是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 Unix 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>一般 linux 系统基本上分两大类：</p><ul><li>RedHat 系列：Redhat、Centos、Fedora 等；</li><li>Debian 系列：Debian、Ubuntu 等。</li></ul><p><strong>类 Unix 系统目录结构</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201023215641344.png" alt=""></p><p>以上这个目录结构要牢记。</p><h1 id="1、Linux 常见命令"><a href="#1、Linux 常见命令" class="headerlink" title="1、Linux 常见命令"></a>1、Linux 常见命令</h1><h2 id="1-1-linux 命令格式"><a href="#1-1-linux 命令格式" class="headerlink" title="1.1 linux 命令格式"></a>1.1 linux 命令格式</h2><pre><code>command [-options] [parameter] 命令       选项        参数 </code></pre><h2 id="1-2- 查看帮助信息"><a href="#1-2- 查看帮助信息" class="headerlink" title="1.2 查看帮助信息"></a>1.2 查看帮助信息</h2><p> 方式一：</p><pre><code>command --help</code></pre><p>方式二：</p><pre><code>man [section] command</code></pre><p>man 是 linux 中的用户手册，包含的各个 section 意义如下：</p><ul><li>1 – User Commands 一般用户命令</li><li>2 - System Calls 系统调用命令, 如 open,write 之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)</li><li>3 - C library Functions C 函数库命令, 如 printf,fread</li><li>4 - Devices and Special files 是特殊文件, 也就是 /dev 下的各种设备文件 man hd</li><li>5 - File formats and conventions 是指文件的格式, 比如 man 5 passwd, 就会得到说明这个文件 /etc/passwd 中各个字段的含义</li><li>6 - games for linux 是给游戏留的, 由各个游戏自己定义</li><li>7 - Miscellanea 杂项， 例如宏命令包、惯例等。</li><li>8 - System administration tools and Deamons 是系统管理用的命令, 这些命令只能由 root 使用, 如 ifconfig</li><li>9 - 其他（Linux 特定的）， 用来存放内核例行程序的文档。</li><li>n 新文档， 可能要移到更适合的领域。</li><li>o 老文档， 可能会在一段期限内保留。</li><li>l 本地文档， 与本特定系统有关的。</li></ul><h2 id="1-3- 自动补全"><a href="#1-3- 自动补全" class="headerlink" title="1.3 自动补全"></a>1.3 自动补全 </h2><p> 想要编辑某个文件时，若文件名太长，可采用先敲几个前面的字母，按 tab 键可自动补全。</p><p>2 次 tab 键可补全显示目录下所有文件</p><p>按方向键上可出现上次输入的命令。</p><h2 id="1-4- 基础命令"><a href="#1-4- 基础命令" class="headerlink" title="1.4 基础命令"></a>1.4 基础命令</h2><ul><li><p><code>ls</code> 显示当前目录下的文件</p><pre><code class="shell">ls          #显示当前目录下的文件ls /        #显示根目录下的文件ls /bin     #显示根目录下 bin 文件夹里的文件ls -a       #显示当前目录下的所有文件（包括隐藏文件，以. 开头的文件名）ls -l        #以详细列表形式显示文件（文件大小显示以字节大小形式）ls -l -h    #以详细列表形式显示文件, 同时显示文件大小（以 k,M,G 等单位）ls -alh     #（选项可以写在一起）具体每个字符表示什么，后面会 2.6.3 介绍ls --help  #查看所有用法</code></pre></li><li><p><code>pwd</code> 显示当前所处位置（在哪个目录下）</p></li><li><p><code>cd 目录</code> 切换目录</p><pre><code class="shell">cd /bin      #切换到根目录下的 bin 文件夹里cd ~         #切换到家目录中的用户文件夹cd ./test   #切换到当前路径下的 test 文件夹里cd ..          #切换到上级目录cd -           #快速回到上次你所在的路径</code></pre></li><li><p><code>touch 文件名</code> 创建文件</p></li><li><p><code>mkdir 文件夹名</code> 创建文件夹</p><pre><code class="shell">mkdir A             #在当前目录下创建 A 文件夹mkdir A/B/C -p         #在当前目录下创建 A 文件夹, 再建 B, 再建 C</code></pre></li><li><p><code>rmdir 文件夹名</code> 删除文件夹，若文件夹不为空，则无法删除</p></li><li><p><code>rm 文件名</code> 删除文件 / 文件夹</p><pre><code class="shell">rm *.txt   #删除所有 txt 文件（空文件）rm A -r    #强制删除 A 文件 即使里面有内容find /dir/path/* -type f -mtime +2 -exec rm &#123;&#125; \;  #-type f 表示只删文件, -mtime +2 筛选修改日期是 2 天前的</code></pre></li><li><p><code>cat 文件名</code> 查看文件里的所有内容，可同时显示多个文件内容</p><p><code>cat &gt; 文件名</code> 新建文件，并在换行后继续输入，将输入内容写进文件中，ctrl + d 结束输入</p></li><li><p><code>more 文件名</code> 滑动逐次查看内容（按 Enter 键滑动阅览，f 键前翻页，b 键后翻页，q 键结束）</p><p><code>head 文件名</code> 查看前 10 行</p><p><code>tail 文件名</code> 查看后 10 行 </p><p><code>tail -f xx.log</code>动态查看（适用于 log 在随时更新的情况）</p><p><code>tail -50f xx.log</code>动态查看后 50 行</p><p>整齐输出(表格化输出)：<code>column -t</code></p><p>如：<code>tail xx.csv |colunmn -t</code></p></li><li><p><code>history</code> 查看已经使用过哪些命令</p><pre><code>！编号    #执行 history 记录的编号对应的哪个命令</code></pre></li><li><p><code>tree</code> 以目录树的形式显示当前路径下所有文件。这个命令需要安装。</p></li></ul><h2 id="1-5- 通配符"><a href="#1-5- 通配符" class="headerlink" title="1.5 通配符"></a>1.5 通配符</h2><p>linux 里也支持正则表达式进行文件的搜索。</p><pre><code class="shell">ls 1*.txt    #显示名字以 1 开头的所有 txt 文件ls 1?3       #显示名字为 1 什么 3 的所有文件ls 1[1-5]3      #显示名字为 113 或 123 或 133 或 143 或 153 的所有文件</code></pre><h2 id="1-6- 重定向"><a href="#1-6- 重定向" class="headerlink" title="1.6 重定向"></a>1.6 重定向</h2><pre><code class="shell">ls &gt; xx.txt  #把当前目录下 ls 显示的所有文件名或文件夹名写到 xx.txt 文件里ls &gt;&gt; xx.txt  #把当前目录下 ls 显示的所有文件名或文件夹名追加写到 xx.txt 文件里cat 1.txt 2.txt &gt; xxx.txt  #把 1.txt 和 2.txt 内容合并到 xxx.txt 里</code></pre><h2 id="1-7- 管道"><a href="#1-7- 管道" class="headerlink" title="1.7 管道"></a>1.7 管道</h2><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200618135249035.png" alt=""></p><p>以上的意思是 ls -alh 显示所有文件，将文件放到管道里，再调用 more 命令滑动逐次查看内容。</p><h2 id="1-8- 链接"><a href="#1-8- 链接" class="headerlink" title="1.8 链接"></a>1.8 链接 </h2><p> 分为软链接和硬链接</p><p>软链接：就是类似与快捷方式，指向源文件，加 -s </p><p>硬链接：相当于给文件又给了个名字，不加 -s</p><p><strong>用法 1：链接源文件到目标路径</strong></p><p>格式：ln -s 【源目录 / 文件】 【目标路径】</p><p>比如，将其他位置的 1.txt 文件，链接到我的目标文件夹的：</p><pre><code class="shell">ln -s /home/qiang/file/test.txt ./    # 将 1.txt 链接到当前目录下</code></pre><p>修改源目录 / 文件</p><pre><code class="shell">ln -snf /home/qiang/file/test.py ./  </code></pre><p>重命名：</p><p>在当前目录下，<code>mv test.py 1.py</code> 即可。</p><p><strong>用法 2：创建快捷方式</strong></p><pre><code class="shell">ln -s 1.txt 1-softlink.txt    #给 1.txt 创建软链接 1-softlink.txtln 1.txt 1-hardlink.txt       #给 1.txt 创建硬链接 1-hardlink.txt</code></pre><p>当删除文件时，删除的是硬链接，当文件的硬链接为 0 时，就会自动删除文件。</p><h2 id="1-9- 查找"><a href="#1-9- 查找" class="headerlink" title="1.9 查找"></a>1.9 查找</h2><h3 id="1-9-1- 文本查找"><a href="#1-9-1- 文本查找" class="headerlink" title="1.9.1 文本查找"></a>1.9.1 文本查找</h3><pre><code class="shell">grep &#39;ntfs&#39; xx.txt     #在 xx.txt 里查找‘ntfs’grep &#39;^ntfs&#39; xx.txt     #在 xx.txt 里查找开头为‘ntfs’的字符串grep -v &#39;ntfs&#39; xx.txt  # -v 作用是取反，不包含‘ntfs’grep -n &#39;ntfs&#39; xx.txt  # -n 作用是显示行数grep -r &#39;internal_crop_0810.oas&#39; ./   # 以递归的方式查找当前路径及子目录文件里指定的字符串grep -i &#39;end process&#39; test.py         # -i 是忽略查找字符的大小写</code></pre><h3 id="1-9-2- 文件查找"><a href="#1-9-2- 文件查找" class="headerlink" title="1.9.2 文件查找"></a>1.9.2 文件查找</h3><p><code>find 路径 形式 内容</code>。find 默认递归指定目录。</p><p>形式：</p><ul><li>-name 按名字</li><li>-iname 按名字，不区分大小写</li><li>-size 按大小</li></ul><pre><code class="shell">find ./temp -name test.shfind ./temp -name &#39;*.sh&#39;find ./temp -name &#39;[A-Z]*&#39;find ./temp -size 2M        #查找大小为 2M 的文件find ./temp -size -2M        #查找小于 2M 的文件find ./temp -size +2M        #查找大于 2M 的文件find ./temp -size +2M -size -4M        #查找大于 2M，小于 4M 的文件find ./ -not -name &#39;plot*&#39;  #取反，不包含</code></pre><p>遇到权限问题，一律在最前面加<code>sudo</code>。</p><h3 id="1-9-3- 查找删除"><a href="#1-9-3- 查找删除" class="headerlink" title="1.9.3 查找删除"></a>1.9.3 查找删除</h3><pre><code class="shell">find / -name *redis* -exec rm -rf &#123;&#125; \;  #查找根目录下所有包含 redis 的文件并删除find /dir/path/* -type f -mtime +2 -exec rm &#123;&#125; \;  #-type f 表示只删文件, -mtime +2 筛选修改日期是 2 天前的</code></pre><blockquote><p>-type，-mtime 都是 find 的 options，<code>find --help</code>可以查看更多用法</p><p>2.8 章节也有介绍</p></blockquote><h2 id="1-10- 移动与拷贝"><a href="#1-10- 移动与拷贝" class="headerlink" title="1.10 移动与拷贝"></a>1.10 移动与拷贝</h2><pre><code class="shell">mv 1.txt 1_1.txt  #重命名 1.txt 为 1_1.txtmv 1.txt /laowang  #移动文件 1.txt 到 laowang 文件夹里cp 1.txt /laowang  #复制文件 1.txt 到 laowang 文件夹里</code></pre><p>若被拒绝，则加 <code>-r</code> 即可解决。</p><h2 id="1-11- 压缩与解压"><a href="#1-11- 压缩与解压" class="headerlink" title="1.11 压缩与解压"></a>1.11 压缩与解压</h2><p><code>tar [参数] 打包文件名 需要打包的文件</code></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200618153443295.png" alt=""></p><p><strong>打包与解包：</strong></p><pre><code class="shell"># 将所有 py 文件打包成 test.tartar -cvf test.tar *.py   #对 test.tar 进行解包tar -xvf test.tar</code></pre><blockquote><p>注意以上命令只是打包，并没有压缩。</p></blockquote><p><strong>压缩与解压：</strong></p><pre><code class="shell"># 将所有 py 文件压缩成 test.tar.gz, 压缩比很可观tar -zcvf test.tar.gz *.py   #解包tar -zxvf test.tar.gz        #将所有 py 文件压缩成 test.tar.bz2, 压缩比上面小tar -jcvf test.tar.bz2 *.py   #解包tar -jxvf test.tar.bz2       tar -zxvf test.tar.gz -C laowang/ #解压到指定路径</code></pre><p><strong>其他压缩方式：</strong></p><pre><code class="shell">zip zzz.zip *.pyunzip -d laowang/ zzz.zip </code></pre><h2 id="1-12-which-who"><a href="#1-12-which-who" class="headerlink" title="1.12 which/who"></a>1.12 which/who</h2><pre><code class="shell">which ls    #输出 ls 命令的路径#输出如下：/bin/lswho      #显示当前的用户登陆信息whoami   #显示当前的账户名（用户名）</code></pre><h2 id="1-13- 编辑器 vim"><a href="#1-13- 编辑器 vim" class="headerlink" title="1.13 编辑器 vim"></a>1.13 编辑器 vim</h2><p>使用 <code>vi</code> 或者 <code>vim</code> 命令即可编辑</p><pre><code class="shell">vi text.py   #创建 1.py 并打开 vim 编辑器，默认进入命令模式</code></pre><p>命令与模式转换：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200619104223301.png" alt=""></p><p>由命令模式进入编辑模式时：a 命令在光标后面插入编辑，A 命令在行末编辑，O 命令在光标上一行插入，o 命令在光标下一行编辑……。</p><p><strong>退出保存 </strong>：末行模式下按<code>wq</code> 键，一个 <code>x</code> 键也可以。也可以<code>shift+zz</code></p><p><strong>命令模式下命令：</strong></p><ul><li>yy：复制光标所在的行<ul><li>4yy：复制光标所在的行开始往下的一共 4 行</li></ul></li><li>dd：剪切光标所在的行<ul><li>2dd：剪切光标所在的行开始往下的一共 4 行</li><li>D：剪切光标所在的位置一直到行末</li><li>d0：剪切光标所在的位置一直到行首</li><li>u：撤销</li><li>ctrl+r：反撤销</li><li>x：删除光标定位的那个字符</li><li>X：删除光标前的那个字符</li></ul></li><li>p：粘贴</li><li>控制光标<ul><li>h 左，j 下，k 上，l 右</li><li>M 定位屏幕中间，H 定位屏幕最上方，L 定位屏幕最下方</li><li>ctrl+f 向下翻一页，ctrl+b 向上翻一页；ctrl+d 向下翻半页，ctrl+u 向上翻半页</li><li>回到第 20 行：20+G 键；回到整个代码最后一行：G 键；回第一行：gg 键</li><li>w 向后跳一个单词长度，b 向前跳一个单词长度</li><li>shift+a：快速到行尾，并进入插入模式</li></ul></li><li>v、V：选择多行<ul><li><code>&gt;&gt;</code>：向右缩进</li><li><code>&lt;&lt;</code>：向左缩进</li><li><code>.</code>：重复上次命令</li></ul></li><li>替换<ul><li>r：替换当前字符</li><li>R：替换当前行光标及其后的字符</li><li>整体替换：末行模式下输入<code>%s/ 需替换的内容 / 替换后的内容 /g</code></li><li>替换部分：末行模式下输入 <code>1,10s/ 需替换的内容 / 替换后的内容 /g</code> 替换 1-10 行的。</li></ul></li><li>搜索<ul><li>/：进入搜索模式，输入搜索词，之后按 enter</li><li>n：下一个</li><li>N：上一个</li><li>取消高亮显示<code>:noh</code></li></ul></li><li>高频率命令（十分有用）<ul><li><code>[[</code>：跳到光标所在的程序块（函数）的开头；</li><li><code>]]</code>：跳到光标所在的下一个程序块（函数）的开头；</li><li><code>gD</code>：跳转到光标所在的局部变量的定义处</li><li><code>&#39;&#39;</code>：跳转到光标上次停靠的地方, 是两个’，而不是一个”。与上面一个命令配合用</li><li><code>&gt;&gt;</code>：增加光标所在行的缩进</li><li><code>&lt;&lt;</code>：较少光标所在行的缩进</li><li><code>ctrl+p</code>：编辑模式下的代码补全</li><li><code>ctrl+z</code>：vim 模式下回到终端（vim 后台挂起），终端下输入 <code>fg</code> 回车，重新回到 vim 界面。</li><li>分屏<ul><li><code>:sp</code>：上下分屏，ctrl+w 切换屏</li><li><code>:vs</code>：左右分屏，ctrl+ww 切换屏</li><li><code>:new</code> 新建空白分屏，:w ./new.py</li><li><code>vim -o file1 file2</code>：以水平分屏的形式打开多个文件，-O 是垂直分屏</li></ul></li></ul></li></ul><h1 id="2、补充命令"><a href="#2、补充命令" class="headerlink" title="2、补充命令"></a>2、补充命令</h1><h2 id="2-1- 时间日期相关"><a href="#2-1- 时间日期相关" class="headerlink" title="2.1 时间日期相关"></a>2.1 时间日期相关</h2><pre><code class="shell">cal #显示当前日历cal -y 2018  #显示 2018 年日历</code></pre><pre><code class="shell">date                    #显示当前时间data &quot;+%Y-%m-%d&quot;         #显示年，月，日data &gt; xx.txt        #把显示的日期写到 xx.txt 文件里</code></pre><h2 id="2-2- 查看进程"><a href="#2-2- 查看进程" class="headerlink" title="2.2 查看进程"></a>2.2 查看进程</h2><p><code>ps [选项]</code></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200618164306567.png" alt=""></p><pre><code class="shell">ps -aux  #查看当前时刻的所有进程消息ps -uftop      #查看进程消息, 持续动态存在htop  kill [PID]  #以指定 PID 方式终止对应的进程kill [PID] -9  #强制杀死进程</code></pre><h2 id="2-3- 关闭重启"><a href="#2-3- 关闭重启" class="headerlink" title="2.3 关闭重启"></a>2.3 关闭重启</h2><pre><code class="shell">reboot  #重启shutdown -h now  #立刻关机shutdown -r now  #立刻关机并通知其他用户</code></pre><h2 id="2-4- 挂载"><a href="#2-4- 挂载" class="headerlink" title="2.4 挂载"></a>2.4 挂载</h2><pre><code class="shell">df    -h        #显示文件系统的磁盘使用情况du  -h      #显示本目录所占磁盘空间du -d 1 -h  #显示本目录所占磁盘空间, 统计深度为 1</code></pre><h2 id="2-5- 查看或配置网卡"><a href="#2-5- 查看或配置网卡" class="headerlink" title="2.5 查看或配置网卡"></a>2.5 查看或配置网卡</h2><pre><code class="shell">ifconfig   #查看网卡 ip 信息ping 网址 /ip   #测试通信</code></pre><h2 id="2-6- 用户权限管理"><a href="#2-6- 用户权限管理" class="headerlink" title="2.6 用户权限管理"></a>2.6 用户权限管理</h2><h3 id="2-6-1- 用户创建切换删除"><a href="#2-6-1- 用户创建切换删除" class="headerlink" title="2.6.1 用户创建切换删除"></a>2.6.1 用户创建切换删除</h3><pre><code class="shell">sudo useradd  账户名 -m      #创建一个账户并创建一个 home 目录（-m 的作用）sudo passwd 账户名            #设置密码su 账户名                     #切换账户su - 账户名                  #切换账户的同时切换到它的家目录exit                        #登出账户</code></pre><pre><code>ssh python@ip    #远程登陆 ip 地址的 python 账户</code></pre><pre><code class="shell">userdel 账户名       #删除账户userdel -r 账户名    #删除账户并删除该账户的主目录，谨慎操作</code></pre><pre><code class="shell">sudo -s     #切换到超级管理员</code></pre><h3 id="2-6-1- 用户组"><a href="#2-6-1- 用户组" class="headerlink" title="2.6.1 用户组"></a>2.6.1 用户组</h3><pre><code class="shell">groupadd 组名   #创建用户组groupdel 组名   #删除用户组cat /etc/group  #查看有哪些组groupmod +2 次 tab 键   #查看有哪些组</code></pre><ol><li><strong>为普通账户添加 sudo 权限</strong></li></ol><p>新创建的用户，默认不能 sudo，需要以下设置</p><pre><code class="shell">sudo usermod -a -G adm 用户名sudo usermod -a -G sudo 用户名</code></pre><ol start="2"><li><strong>切换文件的用户组</strong></li></ol><pre><code class="shell">chgrp YY 1.py   #切换 1.py 到 YY 用户组chown xxx 1.py  #切换 1.py 到 xxx 用户</code></pre><h3 id="2-6-3- 权限"><a href="#2-6-3- 权限" class="headerlink" title="2.6.3 权限"></a>2.6.3 权限</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200618231136063.png" alt=""></p><pre><code class="shell">chmod u=rwx 1.py   #修改文件 owner 的权限chmod +x 1.py      #给 ower 加执行（x）的权限</code></pre><ul><li><p><code>g=r-x</code> 用户组</p></li><li><p><code>o=---</code> 其他人</p></li></ul><p>也可以以数字代表 r,w,x。</p><p>r：4      w：2       x：1       –&gt; 可以数字加和代表 rwx 三者的组合。</p><p>如 u=4，代表的是 r–；如 u=7，代表的是 rwx。依次类推。</p><p><code>chmod 751 1.py</code>等同于<code>chmod u=rwx,g=r-x,o=--x 1.py</code></p><ul><li>-R <strong>参数以递归方式对子目录和文件进行修改</strong>。</li></ul><h2 id="2-7- 下载源"><a href="#2-7- 下载源" class="headerlink" title="2.7 下载源"></a>2.7 下载源 </h2><p> 默认 ubuntu 系统使用 apt 命令下载文件，那么到底是在哪下呢？</p><p>  查看下载源： <code>cat /etc/apt/sources.list</code>  </p><p>最好使用国内镜像源。</p><p>可以自己用 vi 编辑器设置更改，完了之后记得更新：<code>sudo apt-get update</code></p><p>备份 ubuntu 默认下载源地址：</p><pre><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup</code></pre><p>下载安装某工具：</p><pre><code>sudo apt-get install 软件包名 </code></pre><p> 卸载删除某工具：</p><pre><code>sudo apt-get remove 软件包名</code></pre><blockquote><p>apt 与 apt-get：简单来说就是：apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合。</p><p>通过 apt 命令，用户可以在同一地方集中得到所有必要的工具，apt 的主要目的是提供一种以「让终端用户满意」的方式来处理 Linux 软件包的有效方式。</p><p>apt 具有更精减但足够的命令选项，而且参数选项的组织方式更为有效。</p></blockquote><hr><p><strong>详解 wget,apt-get,yum,rpm 区别</strong></p><p>（1）wget 是一个下载命令，名字是 World Wide Web 与 get 的结合</p><p>如果要下载一个软件，可以直接 wget+ 下载地址，通过 HTTP，HTTPS，FTP 三个最常见的 TCP/IP 协议下载。</p><p>（2）rpm 是 redhat 公司的一种软件包管理机制，直接通过 rpm 命令进行安装删除等操作，最大的优点是自己内部自动处理了各种软件包可能的依赖关系。</p><pre><code class="shell">rpm -ivh xx.rpm   #安装 xx.rpm 包rpm -e package    #删除包</code></pre><p>（3）yum 全称为 Yellow dog Updater, Modified， 基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p><p>是 redhat、centos 下的一个软件安装方式，基于 Linux。</p><pre><code class="shell">yum install packageyum remove packageyum update</code></pre><p>（4）apt-get 是 ubuntu 下的一个软件安装方式，它是基于 debain。</p><h2 id="2-8- 其他常见组合命令"><a href="#2-8- 其他常见组合命令" class="headerlink" title="2.8 其他常见组合命令"></a>2.8 其他常见组合命令</h2><h3 id="2-8-1- 查找删除"><a href="#2-8-1- 查找删除" class="headerlink" title="2.8.1 查找删除"></a>2.8.1 查找删除</h3><ul><li><p>按照文件创建日期删除</p><pre><code class="shell">find ./dir -type f -mtime +2 -exec rm &#123;&#125; \;</code></pre><ul><li>-type f：指定对象为文件，不含目录</li><li>-mtime +2 筛选修改日期是 2 天前的</li></ul></li><li><p>按照文件类型 / 名字删除</p><pre><code class="shell">find ./dir -name &quot;*.log&quot; -exec rm &#123;&#125; \;</code></pre></li><li><p>大量文件删除，避免删除报错</p><pre><code class="shell">find ./dir -type f -name &quot;filename&quot; | xargs rmfind ./dir -type f -name &quot;filename&quot; -print0 | xargs -0 rm</code></pre><blockquote><p>当你处理大量文件时，使用 <code>xargs</code> 可能比 <code>-exec</code> 更高效，因为它会将找到的文件批量传递给 <code>rm</code> 命令</p><p>对于包含空格或其他特殊字符的文件名，最好使用 <code>-print0</code> 和<code>-0</code>参数以避免错误</p></blockquote></li></ul><h1 id="3、Linux 文本处理"><a href="#3、Linux 文本处理" class="headerlink" title="3、Linux 文本处理"></a>3、Linux 文本处理</h1><h2 id="3-1-Sed 命令"><a href="#3-1-Sed 命令" class="headerlink" title="3.1  Sed 命令"></a>3.1  Sed 命令</h2><p>sed 是一种流编辑器，是一种面向行的文本处理工具，配合正则使用更强大。每次从文本读入一行，在“保持空间”和“模式空间”进行修改，然后再读入下一行。</p><p>主要用于字符替换、格式化。</p><p>命令格式：</p><pre><code class="shell">sed [options] &#39;command/script&#39; file(s)</code></pre><hr><table><thead><tr><th>options 选项</th><th>含义</th></tr></thead><tbody><tr><td>-e</td><td>该选项会将其后跟的脚本命令添加到已有的命令中。默认 -e</td></tr><tr><td>-f</td><td>该选项会将其后文件中的脚本命令添加到已有的命令中。</td></tr><tr><td>-n</td><td>默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。</td></tr><tr><td>-i</td><td>此选项会直接修改源文件。</td></tr></tbody></table><hr><table><thead><tr><th>command/script 命令字符</th><th>含义</th></tr></thead><tbody><tr><td>[address]s/pattern/replacement/rule</td><td>address 表示指定要操作的具体行，pattern 指的是需要替换的内容，replacement 指的是要替换的新内容。</td></tr><tr><td>[address]d</td><td>删除文本中的特定行</td></tr><tr><td>[address]a(或 i)\ 新文本内容</td><td>a 命令表示在指定行的后面附加一行；i 命令表示在指定行的前面插入一行</td></tr><tr><td>[address]c\ 用于替换的新文本</td><td>指定行中的所有内容，替换成该选项后面的字符串</td></tr><tr><td>[address]y/inchars/outchars/</td><td>处理单个字符，对 inchars 和 outchars 值进行一对一的映射，要求二者长度一致</td></tr><tr><td>[address]p</td><td>搜索符号条件的行，并输出该行的内容</td></tr><tr><td>[address]w filename</td><td>将文本 files 中指定行的内容写入文件 filename 中</td></tr><tr><td>[address]r filename</td><td>将一个独立文件 filename 的数据插入到当前数据流 files 的指定位置</td></tr><tr><td>[address]q</td><td>使 sed 命令在第一次匹配任务结束后</td></tr></tbody></table><hr><p><strong>address 介绍：</strong></p><p>格式：<code>[address]脚本命令</code>    或者   <code>address &#123; 多个脚本命令 &#125;</code></p><table><thead><tr><th>address</th><th>例子及含义</th></tr></thead><tbody><tr><td>2</td><td>sed ‘2s/dog/cat/‘ data.txt，替换第 2 行</td></tr><tr><td>2,8</td><td>sed ‘2,8s/dog/cat/‘ data.txt，替换第 2-8 行</td></tr><tr><td><code>2,$</code></td><td><code>sed &#39;2,$s/dog/cat/&#39;  data.txt</code> 替换第 2- 最后行</td></tr><tr><td>/pattern/</td><td>指定文本模式来过滤出命令要作用的行，sed ‘/line1/s/w1/w2/rule’ filename，将 line1 所在行中的 w1 替换为 w2</td></tr></tbody></table><p>介绍两个通配符：<code>^</code>行开始符；<code>$</code>行结尾符。</p><p>以下做一些常见用法介绍。</p><h3 id="3-1-1- 替换 s"><a href="#3-1-1- 替换 s" class="headerlink" title="3.1.1 替换 s"></a>3.1.1 替换 s</h3><p>格式：</p><pre><code class="shell">sed -i s#old_text#new_text#rule file       #按照 rule 规则，替换 old_text 为 new_text</code></pre><p><code>-i</code>直接修改原文件 file      <code>s</code>代表替换      <code>#</code>是分隔符，也可用 <code>/</code> 符号         </p><p><code>rule</code>表示替换的规则：</p><ul><li>若不写，只匹配替换第一个 old_text</li><li>若为<code>g</code>，表示全局替换</li><li>若为<code>i</code>，忽略大小写关键字替换</li><li>若为<code>m</code>，m 是数字，如果 old_text 的出现次数小于 m，那么替换不生效。</li><li>若为<code>p</code>，打印匹配到的字符所在的行，此标记通常与 -n 选项一起使用。</li></ul><p>举个例子：<code>sed -i s#./prep#/home/prep#g ./*/*.log</code>     也可这样写：<code>sed -i &#39;s#./prep#/home/prep#g&#39; ./*/*.log</code>  </p><p> 还可以这样用：</p><pre><code class="shell">sed -i &#39;#line1#s#old_text#new_text#rule&#39; filename      #按照 rule 规则, 将 line1 所在行中的 old_text 替换为 new_textsed -i &#39;2,6s#old_text#new_text#rule&#39; filename          #按照 rule 规则, 将 2,6 行中的 old_text 替换为 new_text#举一个使用 p 的例子sed -n &#39;s#old_text#new_text#p&#39; filename    #将 old_text 替换为 new_text，并输出替换过的该行</code></pre><blockquote><p>注意：替换类似文件路径的字符串会比较麻烦，需要将路径中的正斜线 <code>/</code> 进行转义：<code>\/</code></p></blockquote><p><strong>批量替换：</strong></p><pre><code class="shell">sed &#39;&#123;s/sales/sale/s/man/woman/&#125;&#39; data.txt</code></pre><h3 id="3-1-2- 删除 d"><a href="#3-1-2- 删除 d" class="headerlink" title="3.1.2 删除 d"></a>3.1.2 删除 d</h3><pre><code class="shell">sed -i &#39;2,3d&#39; data.txt    #删除 2-3 行</code></pre><h3 id="3-1-3- 插入 a-i"><a href="#3-1-3- 插入 a-i" class="headerlink" title="3.1.3 插入 a/i"></a>3.1.3 插入 a/i</h3><pre><code class="shell">sed -i &#39;3a\add new line&#39; data.txt            #第 3 行后面加一行文字：add new linesed -i &#39;3i\add new line&#39; data.txt            #第 3 行前面加一行文字：add new line# 加多行sed -i &#39;3a\add one line.\add two line.&#39; data.txt           </code></pre><h3 id="3-1-4- 替换整行 c"><a href="#3-1-4- 替换整行 c" class="headerlink" title="3.1.4 替换整行 c"></a>3.1.4 替换整行 c</h3><pre><code class="shell">sed -i &#39;3c\add new line&#39; data.txt            #第三行替换成 add new linesed -i &#39;/num3/c\add new line&#39; data.txt            #将 num3 所在的行全部替换为 add new line</code></pre><h3 id="3-1-5- 打印行 p"><a href="#3-1-5- 打印行 p" class="headerlink" title="3.1.5 打印行 p"></a>3.1.5 打印行 p</h3><pre><code>sed -n &#39;/num3/p&#39; data.txt         #打印 num3 所在的行</code></pre><h3 id="3-1-6- 写入 w"><a href="#3-1-6- 写入 w" class="headerlink" title="3.1.6 写入 w"></a>3.1.6 写入 w</h3><pre><code>sed -i &#39;1,2w test.txt&#39; data.txt    #将 data.txt 的第 1-2 行写入到 test.txt 中</code></pre><h3 id="3-1-7- 文件插入 r"><a href="#3-1-7- 文件插入 r" class="headerlink" title="3.1.7 文件插入 r"></a>3.1.7 文件插入 r</h3><pre><code>sed -i &#39;3r test.txt&#39; data.txt    #将 text.txt 全部插入到 data.txt 的第 3 行的后一行</code></pre><h3 id="3-1-8- 退出 q"><a href="#3-1-8- 退出 q" class="headerlink" title="3.1.8 退出 q"></a>3.1.8 退出 q</h3><pre><code>sed -i &#39;3q&#39; data.txt        #输出前 3 行并退出</code></pre><h3 id="3-1-9-option-f"><a href="#3-1-9-option-f" class="headerlink" title="3.1.9 option -f"></a>3.1.9 option -f</h3><pre><code>sed -f sed.sh data.txt     #-f 后接一个 shell 脚本文件，这个脚本定义了 command/script</code></pre><h3 id="3-1-10-option-e"><a href="#3-1-10-option-e" class="headerlink" title="3.1.10 option -e"></a>3.1.10 option -e</h3><pre><code class="shell"># 利用 -e 可以实现多点编辑sed -e &#39;3,$d&#39; -e &#39;s/bash/blueshell/&#39; data.txt  #删除 3- 最后一行，并且替换 bash 为 blueshell</code></pre><h2 id="3-2-awk 命令"><a href="#3-2-awk 命令" class="headerlink" title="3.2 awk 命令"></a>3.2 awk 命令</h2><p>awk 是一种编程语言，用于在 linux/unix 下对文本和数据进行处理。数据可以来自标准输(stdin)、一个或多个文件，或其它命令的输出。它在命令行中使用，但更多是作为脚本来使用。awk 有很多内建的功能，比如数组、函数等，这是它和 C 语言的相同之处，灵活性是 awk 最大的优势。</p><p>语法格式：</p><pre><code>awk [options] &#39;scripts&#39; var=value filename</code></pre><p><strong>options：</strong></p><ul><li>-F  fs：指定分隔符（可以是字符串或正则表达式），默认分隔符为空格或制表符</li><li>-f  file：从脚本文件中读取 awk 命令</li><li>-v var=value： 赋值变量，将外部变量传递给 awk</li></ul><p><strong>‘scripts’：</strong></p><pre><code class="shell">#&#39;scripts&#39; 基本结构&#39;BEGIN&#123; print &quot;start&quot; &#125; pattern&#123; commands &#125; END&#123; print &quot;end&quot; &#125;&#39;</code></pre><p>一个 awk 脚本通常由 <strong>BEGIN 语句</strong> + <strong> 模式匹配 </strong> + <strong>END 语句</strong> 三部分组成，这三部分都是 <strong> 可选项</strong>。</p><p>执行步骤：</p><ul><li>第一步执行 BEGIN 语句</li><li>第二步从文件或标准输入读取一行，然后再执行 pattern 语句，逐行扫描文件到文件全部被读取</li><li>第三步执行 END 语句</li></ul><p><strong>举几个简单例子：</strong></p><ul><li>1   从标准输入（管道）读取</li></ul><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20220306122301005.png" alt=""></p><p>输出为：</p><pre><code>welcomehello2022-03-06</code></pre><blockquote><p>不加 print 参数时默认只打印当前的行</p></blockquote><ul><li>2   只用 command 语句</li></ul><pre><code class="shell">&gt;&gt;&gt; echo|awk &#39;&#123; a=&quot;mgg&quot;; b=&quot;mingg&quot;; c=&quot;mingongge&quot;; print a&quot; is &quot;b&quot; or &quot;c; &#125;&#39;mgg is mingg or mingongge</code></pre><blockquote><p>awk 的 print 语句中 <strong> 双引号 </strong> 其实就是个 <strong> 拼接 </strong> 作用</p></blockquote><ul><li>3   pattern{commands}，从文件读取匹配</li></ul><pre><code>#data.txtline1  xxxx1line2  yyyy2line3  zzzz3--------------------------&gt;&gt;&gt; awk &#39;/line2/&#123;print $2&#125;&#39; data.txtyyyy2</code></pre><p>下面开始正式介绍 awk 相关例子。</p><h3 id="3-2-1- 分隔符 -F"><a href="#3-2-1- 分隔符 -F" class="headerlink" title="3.2.1 分隔符 -F"></a>3.2.1 分隔符 -F</h3><p>awk 默认以空格为分隔符，还可以接受指定的分隔符。</p><ul><li><p><code>-F &#39; &#39;</code> ：以空格为分隔符，单双引号都可</p></li><li><p><code>-F#</code> ：以 <code>#</code> 为分隔符，也可<code>-F &#39;#&#39;</code>，格式没有那么死板。</p></li><li><p><code>-F,</code>：以 <code>,</code> 为分隔符</p></li><li><p><code>-F &#39;[,]&#39;</code>：以左中括号 <code>[</code>   空格    逗号<code>，</code> 右中括号<code>]</code> 这<strong>多个单字符作为分隔符</strong></p></li><li><p><code>-F&#39;abc|cde&#39;</code>：用 abc 和 cde<strong>多个字符串来作为分隔符</strong></p></li><li><p><code>-v FS=&#39;#&#39;</code>：设置内部变量，指定输入分隔符<code>#</code>，其中 FS 是输入分隔符的意思</p></li><li><p><code>-v OFS=&#39;#&#39;</code>：设置内部变量，指定输出分隔符<code>#</code>，其中 OFS 是输出分隔符的意思</p></li></ul><pre><code>举个简单例子awk -F &#39;#&#39; &#39;&#123;print $1&#125;&#39; data.txt</code></pre><p>$1 代表文本行中的第 1 个数据字段。后面会介绍 3.3.3—Awk 的变量。</p><h3 id="3-2-2- 文件命令读取 -f"><a href="#3-2-2- 文件命令读取 -f" class="headerlink" title="3.2.2 文件命令读取 -f"></a>3.2.2 文件命令读取 -f</h3><p>awk 允许将脚本命令存储到文件中，然后再在命令行中引用。</p><pre><code class="shell">awk -f &#123;awk 脚本 &#125; &#123; 文件名 &#125;awk -f cal.awk log.txt</code></pre><p>一个 awk 脚本文件的例子：</p><pre><code class="shell">$ cat cal.awk#!/bin/awk -f#运行前BEGIN &#123;    math = 0    english = 0    computer = 0    printf &quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;    printf &quot;---------------------------------------------\n&quot;&#125;#运行中&#123;    math+=$3    english+=$4    computer+=$5    printf &quot;%-6s %-6s %4d %8d %8d %8d\n&quot;, $1, $2, $3,$4,$5, $3+$4+$5&#125;#运行后END &#123;    printf &quot;---------------------------------------------\n&quot;    printf &quot;  TOTAL:%10d %8d %8d \n&quot;, math, english, computer    printf &quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;, math/NR, english/NR, computer/NR&#125;</code></pre><blockquote><p>awk 即支持 print，也可 printf。差别可自行百度。</p></blockquote><h3 id="3-3-3- 变量赋值 -v"><a href="#3-3-3- 变量赋值 -v" class="headerlink" title="3.3.3 变量赋值 -v"></a>3.3.3 变量赋值 -v</h3><ul><li>接受内部变量</li></ul><pre><code># log.txt2 this test3 Are awkThis&#39;s a10 There apple-------------------------------------------&gt;&gt;&gt; awk -v a=1 &#39;&#123;print $1,$1+a&#125;&#39; log.txt2 33 4This&#39;s 110 11#上述中 log.txt 文本中的 a 都被赋值了</code></pre><ul><li>接受外部变量</li></ul><pre><code>&gt;&gt;&gt; val=&quot;aaa&quot;&gt;&gt;&gt; echo|awk -v v1=$val &#39;&#123;print v1&#125;&#39; aaa</code></pre><p><strong>Awk 的变量</strong></p><pre><code class="shell"># 内置变量$0   #当前记录$1~$n #当前记录的第 N 个字段FS   #输入字段分隔符（-F 相同作用）默认空格RS   #输入记录分割符，默认换行符OFS  #输出字段分隔符，默认空格ORS  #输出记录分割符，默认换行符 NF   #该行字段个数，就是列数NR   #记录数，就是行号，默认从 1 开始</code></pre><blockquote><p>这些都是比较常用的内置变量，其余的自行百度。</p></blockquote><h3 id="3-3-4- 匹配规则 pattern"><a href="#3-3-4- 匹配规则 pattern" class="headerlink" title="3.3.4 匹配规则 pattern"></a>3.3.4 匹配规则 pattern</h3><ul><li><p>正则表达式作为 pattern</p><pre><code>/A/            #去匹配含有 A 的字符awk &#39;/hello/ &#123; print $0 &#125;&#39; myfile  #输出含有 hello 的整行</code></pre></li><li><p>比较表达式作为 pattern</p><pre><code>&#39;$NF == &quot;A&quot;          #输出最后一个字段为 A 的awk &#39;$NF == &quot;A&quot; &#123; print $0 &#125;&#39; myfile        #输出最后一个字段为 A 的整行</code></pre></li><li><p>常量表达式作为 pattern，或多模式多动作</p><pre><code>awk &#39; 真 &#123; 执行代码 &#125; 假 &#123; 不执行代码 &#125;&#39; awk &#39;1 &#123; print $0 &#125;&#39; myfile                           #为真，执行输出整行awk &#39;$NR==1 &#123;print $NF&#125; $NR==3 &#123;print $NF&#125;&#39;  myfile     </code></pre></li><li><p>空 pattern 是永远匹配为真的</p><pre><code>awk &#39;&#123; print $0 &#125;&#39; myfile                   #输出所有的整行，</code></pre></li><li><p>模式范围: begpat, endpat</p><p>这个模式范围, 是由两个 pattern 组成, 每个 pattern 可以是任意的非特殊类型(可以是正则，比较，常量等 pattern).</p><pre><code>awk &#39;NR==4, /555-3430/ &#123; print $0&#125;&#39; myfile</code></pre><p>执行方式：匹配输出满足以 begpat 开始到以 endpat 结束中间的所有行，第一轮结束后可以开始下一轮（只满足这个起始和终止条件）。</p></li><li><p>特殊匹配 BEGIN、END</p><p>awk 里的 BEGIN 语句和 END 语句也是一种匹配。</p></li></ul><p><strong>Awk 正则</strong></p><pre><code class="shell">^         行首定位符$         行尾定位符.         匹配任意单个字符*         匹配 0 个或多个前导字符（包括回车）+         匹配 1 个或多个前导字符?         匹配 0 个或 1 个前导字符 []        匹配指定字符组内的任意一个字符 /^[ab][^]       匹配不在指定字符组内的任意一个字符()        子表达式|         或者\         转义符~,!~      匹配或不匹配的条件语句x&#123;m&#125;      x 字符重复 m 次x&#123;m,&#125;     x 字符至少重复 m 次X&#123;m,n&#125;    x 字符至少重复 m 次但不起过 n 次（需指定参数 -posix 或 --re-interval）</code></pre><h3 id="3-3-5- 执行命令 -commands"><a href="#3-3-5- 执行命令 -commands" class="headerlink" title="3.3.5 执行命令{commands}"></a>3.3.5 执行命令{commands}</h3><p>awk 是一种编程语言，故支持运算，文件操作，输入输出，循环语句，数组，内置函数等操作。</p><p>一般高级点的用法我们用不到，这里不做介绍。如有需要，跳转：</p><p><a href="https://www.cnblogs.com/quincyhu/p/5884390.html">shell 编程之 awk 命令详解 - QuincyHu - 博客园 (cnblogs.com)</a></p><p><a href="https://www.w3cschool.cn/awk/hs671k8f.html">AWK 概述_w3cschool</a></p><h1 id="4-Linux 下配置环境变量"><a href="#4-Linux 下配置环境变量" class="headerlink" title="4. Linux 下配置环境变量"></a>4. Linux 下配置环境变量 </h1><p> 环境变量：使得命令能够在全局使用。而不必切换到其安装目录。</p><h2 id="4-1- 环境变量的配置方法"><a href="#4-1- 环境变量的配置方法" class="headerlink" title="4.1 环境变量的配置方法"></a>4.1 环境变量的配置方法</h2><p>linux 在正常启动时，先会启动一系列配置文件，再显示命令行提示符：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20210106233834424.png" alt=""></p><p>在用户目录下的 <code>~/.bashrc</code>中配置环境变量：</p><pre><code class="shell"># vim ~/.bashrc# 添加以下一行export PATH=$PATH:/home/uusama/mysql/bin#或者export PATH=/home/uusama/mysql/bin：$PATH   #（二者表达意思一样）</code></pre><p>以上的 <code>export PATH=$PATH:/home/uusama/mysql/bin</code> 可以这样理解：</p><p><code>export</code> 是配置环境变量的命令</p><p><code>PATH</code> 是指定命令的搜索路径。类似的 Linux 中还有 9 个环境变量，见 4.2.3。</p><p><code>$PATH</code> 是指 PATH 这个环境变量，$ 符号就是表示 PATH 是个变量，$PATH 代表了 PATH 路径下所有的变量，可能在其他配置文件配置了 PATH=/etc/pangen/bin 等多个路径，$PATH 可将这些一并加载过来。</p><p><strong>冒号 <code>:</code> 是分割符的意思</strong>，意思是 PATH 环境变量不仅包含了 $PATH 代表的其他路径下的命令，还加上 /home/uusama/mysql/bin，与 win 平台的分号作用类似，<strong> 表示并列</strong>。</p><p>如果只是 <code>export PATH=/home/uusama/mysql/bin</code> 那么 <code>PATH</code> 只会指向 <code>/home/uusama/mysql/bin</code> 这个路径，覆盖了其他的指向。</p><h2 id="4-2- 扩展"><a href="#4-2- 扩展" class="headerlink" title="4.2 扩展"></a>4.2 扩展 </h2><h3 id="4-2-1-export 命令"><a href="#4-2-1-export 命令" class="headerlink" title="4.2.1 export 命令"></a>4.2.1 export 命令</h3><p> 配置环境变量当然不只是上面一种方法，还可以直接采用命令的形式：</p><p>在命令窗口输入：<code>export PATH=/home/uusama/mysql/bin:$PATH</code></p><p>注意事项：</p><ul><li>生效时间：立即生效</li><li>生效期限：当前终端有效，窗口关闭后无效</li><li>生效范围：仅对当前用户有效</li></ul><p>而相对于 <code>vim</code> 命令直接编辑<code>~/.bashrc</code>，就会永久生效：</p><ul><li>生效时间：使用相同的用户打开新的终端时生效，或者手动 <code>source ~/.bashrc</code> 生效</li><li>生效期限：永久有效</li><li>生效范围：仅对当前用户有效</li></ul><h3 id="4-2-2- 查看变量"><a href="#4-2-2- 查看变量" class="headerlink" title="4.2.2 查看变量"></a>4.2.2 查看变量</h3><ul><li><p>echo $PATH ：显示所有 PATH 环境变量的路径</p><pre><code>/home/pangen/bin:/home/pangen/pangen_build_env/bin:/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/opt/ibutils/bin:/home/qiangjiang/.local/bin:/home/qiangjiang/bin</code></pre></li><li><p>export 可以查看（显示）Shell 环境变量</p><pre><code class="shell">[roc@roclinux ~]$ exportdeclare -x CVS_RSH=&quot;ssh&quot;declare -x G_BROKEN_FILENAMES=&quot;1&quot;declare -x HISTCONTROL=&quot;ignoredups&quot;declare -x HISTSIZE=&quot;1000&quot;declare -x HOME=&quot;/home/roc&quot;declare -x HOSTNAME=&quot;roclinux&quot;…………………………</code></pre></li><li><p>env 命令显示所有的环境变量</p></li><li><p>set 命令显示所有本地定义的 Shell 变量</p></li></ul><h3 id="4-2-3-10 个环境变量"><a href="#4-2-3-10 个环境变量" class="headerlink" title="4.2.3 10 个环境变量"></a>4.2.3 10 个环境变量 </h3><p> 常用的环境变量：</p><p>PATH 决定了 shell 将到哪些目录中寻找命令或程序</p><p>HOME 当前用户主目录</p><p>HISTSIZE　历史记录数</p><p>LOGNAME 当前用户的登录名</p><p>HOSTNAME　指主机的名称</p><p>SHELL 当前用户 Shell 类型</p><p>LANGUGE 　语言相关的环境变量，多语言可以修改此环境变量</p><p>MAIL　当前用户的邮件存放目录</p><p>PS1　基本提示符，对于 root 用户是 #，对于普通用户是 $</p><h3 id="4-2-4- 给命令取别名"><a href="#4-2-4- 给命令取别名" class="headerlink" title="4.2.4 给命令取别名"></a>4.2.4 给命令取别名 </h3><p> 在配置文件中，如 <code>~/.bashrc</code> 或<code>~/.profile</code>中使用 alias 命令可以定义一些命令的别名。</p><p>如：</p><pre><code class="shell">vim ~/.bashrc#编辑添加alias rm=&#39;rm -irf&#39;</code></pre><p>这样每次使用 <code>rm</code> 命令时，就代表使用了<code>rm -irf</code></p><h1 id="5、Linux 下运行 python"><a href="#5、Linux 下运行 python" class="headerlink" title="5、Linux 下运行 python"></a>5、Linux 下运行 python</h1><p>linux 有好些发行版，ubuntu/centos 版下默认使用 python2.x 版本，这个版本注意不能卸载掉。</p><p>建议使用 Anaconda 配置 python 环境。使用 Anaconda 有许多好处，尤其是对于数据科学、机器学习以及需要处理大量数据的 Python 开发者来说。以下是使用 Anaconda 的一些主要优势：</p><ol><li><strong>环境管理</strong>：<ul><li>Anaconda 通过 <code>conda</code> 命令提供了强大的环境管理功能，使得用户可以轻松创建、管理和切换不同的开发环境。这对于同时处理多个项目或需要不同版本库的情况非常有用。</li></ul></li><li><strong>包管理</strong>：<ul><li>包含了超过 7500 个数据科学相关的开源包，可以通过简单的命令进行安装和更新。这大大简化了依赖关系的管理，避免了手动下载和安装各种库的麻烦。</li></ul></li><li><strong>跨平台支持</strong>：<ul><li>支持 Windows、macOS 和 Linux 操作系统，确保无论在哪种平台上工作，都可以获得一致的体验。</li></ul></li><li><strong>预装关键库</strong>：<ul><li>自带了许多流行的数据科学库，如 NumPy, pandas, SciPy, Matplotlib, Seaborn, Scikit-learn 等，减少了初始配置时间。</li></ul></li><li><strong>Jupyter Notebook 集成</strong>：<ul><li>预装了 Jupyter Notebook，这是一种非常适合数据分析和机器学习项目的交互式计算环境。它允许你创建和共享包含实时代码、方程式、可视化和叙述文本的文档。</li></ul></li><li><strong>企业级特性（Anaconda Distribution vs Anaconda Enterprise）</strong>：<ul><li>对于企业用户，Anaconda 还提供了额外的企业级解决方案，包括更高级的安全性、团队协作工具以及对大规模部署的支持。</li></ul></li><li><strong>社区与支持</strong>：<ul><li>拥有一个活跃且不断增长的社区，提供丰富的资源和支持。无论是新手还是有经验的开发者都能从中受益。</li></ul></li><li><strong>教育用途</strong>：<ul><li>在学术界广泛使用，许多大学课程和在线教程推荐使用 Anaconda 作为教学工具，因为它简化了设置过程，并让学生能够专注于学习而非环境配置。</li></ul></li></ol><h2 id="5-1- 安装 Anaconda"><a href="#5-1- 安装 Anaconda" class="headerlink" title="5.1 安装 Anaconda"></a>5.1 安装 Anaconda</h2><p>安装 Anaconda3 环境，安装路径：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>Linux 版本可以选择 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2023.03-Linux-x86_64.sh">Anaconda3-2023.03-Linux-x86_64.sh</a></p><p><strong>安装</strong>：下载完成后，直接在 Linux 里运行<code>./Anaconda3-2023.03-Linux-x86_64.sh</code> 安装即可</p><p><strong>配置环境变量</strong>：./anaconda3/bin 到 PATH 里面</p><p>cmd 里输入 python，检查 python 是否可以使用。</p><hr><h2 id="5-2- 改变 python 指向版本"><a href="#5-2- 改变 python 指向版本" class="headerlink" title="5.2 改变 python 指向版本"></a>5.2 改变 python 指向版本 </h2><p> 默认情况下，输入 python 还是会进入 python2.x，输入 python3 才会进入 python3.x。</p><p>可执行以下命令改变，使得 python 命令指向 python3.x。</p><pre><code class="shell">ls -l /usr/bin | grep python   #查看目前的 python 版本及其指向（链接）rm /usr/ 链接路径    #删除原有 python 链接sudo ln -s /usr/bin/python3.7 /usr/bin/python  #新建 python 链接</code></pre><p>至此已经完成了目标。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习经典算法</title>
      <link href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
      <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习经典算法"><a href="# 机器学习经典算法" class="headerlink" title="机器学习经典算法"></a>机器学习经典算法 </h1><h2 id="1- 决策树与随机森林"><a href="#1- 决策树与随机森林" class="headerlink" title="1. 决策树与随机森林"></a>1. 决策树与随机森林</h2><p> 决策树：构建树模型</p><p>分类与回归都可以做。</p><p>有时间再写……</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow 学习笔记</title>
      <link href="/tensorflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/tensorflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Tensorflow 学习笔记"><a href="#Tensorflow 学习笔记" class="headerlink" title="Tensorflow 学习笔记"></a>Tensorflow 学习笔记 </h1><h2 id="1- 基础概念"><a href="#1- 基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><h3 id="1-1- 人工智能"><a href="#1-1- 人工智能" class="headerlink" title="1.1 人工智能"></a>1.1 人工智能</h3><p> 人工智能：让机器具备人的 <u> 思维 </u> 和<u>意识</u></p><p>人工智能三学派：</p><p>行为主义：基于控制论，构建感知—动作控制系统。（如汽车的自动驾驶）</p><p>符号主义：基于数学逻辑表达式，人为发现规律，把问题描述为表达式，理性思维的实现。</p><p>连接主义：仿生学，模仿神经元连接关系，实现感性思维。（比如今天见到陌生人 A，明天再见就会感到眼熟）</p><blockquote><p><strong>深度学习——神经网络————&gt; 连接主义</strong></p></blockquote><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200605020413956.png" alt=""></p><blockquote><p><strong>利用仿生学的观点，用计算机仿出神经网络连接关系，让计算机具备感性思维</strong></p></blockquote><h3 id="1-2- 神经网络实现思路"><a href="#1-2- 神经网络实现思路" class="headerlink" title="1.2 神经网络实现思路"></a>1.2 神经网络实现思路</h3><ul><li>准备数据：采集大量“特征 / 标签”数据对。</li><li>搭建网络：搭建神经网络结构。</li><li>优化参数：训练网络获取最佳参数。</li><li>应用网络：将网络保存为模型，输入新数据，输出分类或预测结果。</li></ul><h3 id="1-3- 一些名词解释"><a href="#1-3- 一些名词解释" class="headerlink" title="1.3 一些名词解释"></a>1.3 一些名词解释</h3><hr><p>损失函数：预测值（y）与标准答案（y_)的差距。</p><p>损失函数可以定量判断 w,b 的优劣，当损失函数输出最小时，参数 w,b 会出现最优值。</p><p>常用均方误差 MSE 代表损失函数。<br>$$<br>MSE(x,y)=∑((y-y_)^2)/n<br>$$</p><p>$$<br>loss_mse=tf.reduce_mean(tf.square(y_-y))<br>$$</p><p>优化参数：找到一组参数 w,b，使得损失函数最小。</p><p>梯度：损失函数对各参数求偏导后的向量。</p><p>梯度下降法：沿损失函数梯度下降的方向，寻找损失函数的最小值，得到最优参数的方法。</p><p>w 的更新：<br>$$<br>w_{t+1}=w_t-l_r×\frac{∂loss}{∂w_t}<br>$$<br>学习率（lr）：当学习率设置过小时，收敛将变得十分缓慢。当过大时，梯度可能在最小值附近来回震荡，甚至可能无法收敛。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200605025338012.png" alt=""></p><p>指数衰减学习率：先用较大的学习率，快速得到较优的解，然后逐步减小学习率，使模型在训练后期稳定。</p><p>指数衰减学习率 = 初始学习率×学习率衰减率 ^（当前轮数 / 多少轮衰减一次）</p><p>反向传播：从后向前，逐层求损失函数对每层神经元参数的偏导数，迭代更新所有参数。</p><p><strong>举个例子</strong></p><p>损失函数 <br>$$<br>loss=(w+1)^2  \qquad ——&gt;<br>\frac{∂loss}{∂w}=2w+2<br>$$<br> 程序的实现：</p><pre><code class="python">import tensorflow as tfw=tf.Variable(tf.constant(5,dtype=tf.float32))  // 随机初始化 wlr=0.2epochs=40for epoch in range(epochs):    with tf.GradientTape() as tape:        loss=tf.square(w+1)        grads=tape.gradient(loss,w)    w.assign_sub(lr*grads)    print(&#39;After %s epoch,w is %f,loss is %f&#39;%(epoch,w.numpy(),loss))</code></pre><p><strong>张量（Tensor）</strong>：多维数组</p><p>标量（scalar）：a=0</p><p>向量（vector）：b=[0,1,2]</p><p>矩阵（matrix）：c=[[0,1,2],[3,4,5]]</p><p>张量（tensor）：d=[[[…..]]]</p><p>以上可统称张量。</p><h3 id="1-4- 常用函数"><a href="#1-4- 常用函数" class="headerlink" title="1.4 常用函数"></a>1.4 常用函数</h3><h4 id="1-4-1- 创建张量"><a href="#1-4-1- 创建张量" class="headerlink" title="1.4.1 创建张量"></a>1.4.1 创建张量</h4><blockquote><p><code>tf.constant(张量内容，dtype= 数据类型（可选）)</code></p></blockquote><p>如<code>tf.constant([1,5], dtype= 数据类型（可选）)</code></p><blockquote><p><code>tf.convert_to_tensor(numpy 数组，dtype= 数据类型)</code></p></blockquote><h4 id="1-4-2- 创建特殊张量"><a href="#1-4-2- 创建特殊张量" class="headerlink" title="1.4.2 创建特殊张量"></a>1.4.2 创建特殊张量</h4><pre><code>tf.zeros(维度)        // 创建全为 0 的张量tf.ones(维度)         // 创建全为 1 的张量tf.fill(维度，指定值)  // 创建全为指定值的张量tf.random.normal(维度，mean= 均值，stddev= 标准差)tf.random.uniform(维度，minval= 最小值，maxval= 最大值)</code></pre><h4 id="1-4-3- 统计"><a href="#1-4-3- 统计" class="headerlink" title="1.4.3 统计"></a>1.4.3 统计</h4><pre><code>tf.cast(张量名，dtype= 数据类型)  类型转换tf.reduce_min(张量名)  计算张量维度上元素的最小值tf.reduce_max(张量名)  计算张量维度上元素的最大值tf.reduce_mean(张量名，axis= 操作轴 0 or 1)tf.reduce_sum(张量名，axis= 操作轴 0 or 1)</code></pre><h4 id="1-4-4- 可训练"><a href="#1-4-4- 可训练" class="headerlink" title="1.4.4 可训练"></a>1.4.4 可训练</h4><p>tf.Variable() 将变量标记为可训练</p><pre><code>w=tf.Variable(tf.random.normal([2,2],mean=0,stddev=1))</code></pre><p>以上就是神经网络默认起始 w 的生成方法示例。</p><h4 id="1-4-5- 数学运算"><a href="#1-4-5- 数学运算" class="headerlink" title="1.4.5 数学运算"></a>1.4.5 数学运算 </h4><p> 四则运算：tf.add，tf.subtract，tf.multiply，tf.divide</p><p>平方、次方与开方：tf.square，tf.pow，tf.sqrt</p><p>矩阵乘：tf.matmul</p><h4 id="1-4-6- 数据集的构建（重要）"><a href="#1-4-6- 数据集的构建（重要）" class="headerlink" title="1.4.6 数据集的构建（重要）"></a>1.4.6 数据集的构建（重要）</h4><pre><code>data=tf.data.Dataset.from_tensor_slices((输入标签，标签))</code></pre><h4 id="1-4-7- 独热编码"><a href="#1-4-7- 独热编码" class="headerlink" title="1.4.7 独热编码"></a>1.4.7 独热编码 </h4><pre><code>tf.one_hot(待转换的数据，depth= 几分类)</code></pre><p> 如：</p><pre><code class="python">import tensorflow as tflables=tf.constant([1,0,2])output=tf.one_hot(lables,3)print(output)输出结果如下：tf.Tensor([[0. 1. 0.] [1. 0. 0.] [0. 0. 1.]], shape=(3, 3), dtype=float32)</code></pre><h4 id="1-4-8- 柔性最大值"><a href="#1-4-8- 柔性最大值" class="headerlink" title="1.4.8 柔性最大值"></a>1.4.8 柔性最大值 </h4><p><code>tf.nn.softmax(x)</code> 使输出符合概率分布</p><p>$$<br>Softmax(y_i)=\frac{e^{y_i}}{∑e^{y_i}}<br>$$</p><h4 id="1-4-9- 获取最大索引"><a href="#1-4-9- 获取最大索引" class="headerlink" title="1.4.9 获取最大索引"></a>1.4.9 获取最大索引</h4><p><code>tf.argmax(张量名，axis= 操作轴)</code></p><h3 id="1-5- 手动搭建神经网络"><a href="#1-5- 手动搭建神经网络" class="headerlink" title="1.5 手动搭建神经网络"></a>1.5 手动搭建神经网络 </h3><p> 以鸢尾花分类为例，它有四个特征值（花瓣长，花瓣宽，花萼长，花萼宽），这四个特征值表现了三种鸢尾花类型。</p><pre><code class="python"># 利用鸢尾花数据集，实现前向传播、反向传播，可视化 loss 曲线# 导入所需模块import tensorflow as tffrom sklearn import datasetsfrom matplotlib import pyplot as pltimport numpy as np# 导入数据，分别为输入特征和标签x_data = datasets.load_iris().datay_data = datasets.load_iris().target# 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）# seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样（为方便教学，以保每位同学结果一致）np.random.seed(116)  # 使用相同的 seed，保证输入特征和标签一一对应np.random.shuffle(x_data)np.random.seed(116)np.random.shuffle(y_data)tf.random.set_seed(116)# 将打乱后的数据集分割为训练集和测试集，训练集为前 120 行，测试集为后 30 行x_train = x_data[:-30]y_train = y_data[:-30]x_test = x_data[-30:]y_test = y_data[-30:]# 转换 x 的数据类型，否则后面矩阵相乘时会因数据类型不一致报错x_train = tf.cast(x_train, tf.float32)x_test = tf.cast(x_test, tf.float32)# from_tensor_slices 函数使输入特征和标签值一一对应。（把数据集分批次，每个批次 batch 组数据）train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(32)test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32)# 生成神经网络的参数，4 个输入特征故，输入层为 4 个输入节点；因为 3 分类，故输出层为 3 个神经元# 用 tf.Variable()标记参数可训练# 使用 seed 使每次生成的随机数相同（方便教学，使大家结果都一致，在现实使用时不写 seed）w1 = tf.Variable(tf.random.truncated_normal([4, 3], stddev=0.1, seed=1))b1 = tf.Variable(tf.random.truncated_normal([3], stddev=0.1, seed=1))lr = 0.1  # 学习率为 0.1train_loss_results = []  # 将每轮的 loss 记录在此列表中，为后续画 loss 曲线提供数据test_acc = []  # 将每轮的 acc 记录在此列表中，为后续画 acc 曲线提供数据epoch = 500  # 循环 500 轮loss_all = 0  # 每轮分 4 个 step，loss_all 记录四个 step 生成的 4 个 loss 的和# 训练部分for epoch in range(epoch):  #数据集级别的循环，每个 epoch 循环一次数据集    for step, (x_train, y_train) in enumerate(train_db):  #batch 级别的循环 ，每个 step 循环一个 batch        with tf.GradientTape() as tape:  # with 结构记录梯度信息            y = tf.matmul(x_train, w1) + b1  # 神经网络乘加运算            y = tf.nn.softmax(y)  # 使输出 y 符合概率分布（此操作后与独热码同量级，可相减求 loss）            y_ = tf.one_hot(y_train, depth=3)  # 将标签值转换为独热码格式，方便计算 loss 和 accuracy            loss = tf.reduce_mean(tf.square(y_ - y))  # 采用均方误差损失函数 mse = mean(sum(y-out)^2)            loss_all += loss.numpy()  # 将每个 step 计算出的 loss 累加，为后续求 loss 平均值提供数据，这样计算的 loss 更准确        # 计算 loss 对各个参数的梯度        grads = tape.gradient(loss, [w1, b1])        # 实现梯度更新 w1 = w1 - lr * w1_grad    b = b - lr * b_grad        w1.assign_sub(lr * grads[0])  # 参数 w1 自更新        b1.assign_sub(lr * grads[1])  # 参数 b 自更新    # 每个 epoch，打印 loss 信息    print(&quot;Epoch &#123;&#125;, loss: &#123;&#125;&quot;.format(epoch, loss_all/4))    train_loss_results.append(loss_all / 4)  # 将 4 个 step 的 loss 求平均记录在此变量中    loss_all = 0  # loss_all 归零，为记录下一个 epoch 的 loss 做准备    # 测试部分    # total_correct 为预测对的样本个数, total_number 为测试的总样本数，将这两个变量都初始化为 0    total_correct, total_number = 0, 0    for x_test, y_test in test_db:        # 使用更新后的参数进行预测        y = tf.matmul(x_test, w1) + b1        y = tf.nn.softmax(y)        pred = tf.argmax(y, axis=1)  # 返回 y 中最大值的索引，即预测的分类        # 将 pred 转换为 y_test 的数据类型        pred = tf.cast(pred, dtype=y_test.dtype)        # 若分类正确，则 correct=1，否则为 0，将 bool 型的结果转换为 int 型        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)        # 将每个 batch 的 correct 数加起来        correct = tf.reduce_sum(correct)        # 将所有 batch 中的 correct 数加起来        total_correct += int(correct)        # total_number 为测试的总样本数，也就是 x_test 的行数，shape[0]返回变量的行数        total_number += x_test.shape[0]    # 总的准确率等于 total_correct/total_number    acc = total_correct / total_number    test_acc.append(acc)    print(&quot;Test_acc:&quot;, acc)    print(&quot;--------------------------&quot;)# 绘制 loss 曲线plt.title(&#39;Loss Function Curve&#39;)  # 图片标题plt.xlabel(&#39;Epoch&#39;)  # x 轴变量名称plt.ylabel(&#39;Loss&#39;)  # y 轴变量名称plt.plot(train_loss_results, label=&quot;$Loss$&quot;)  # 逐点画出 trian_loss_results 值并连线，连线图标是 Lossplt.legend()  # 画出曲线图标plt.show()  # 画出图像# 绘制 Accuracy 曲线plt.title(&#39;Acc Curve&#39;)  # 图片标题plt.xlabel(&#39;Epoch&#39;)  # x 轴变量名称plt.ylabel(&#39;Acc&#39;)  # y 轴变量名称plt.plot(test_acc, label=&quot;$Accuracy$&quot;)  # 逐点画出 test_acc 值并连线，连线图标是 Accuracyplt.legend()plt.show()</code></pre><h3 id="1-6- 神经网络（NN）复杂度"><a href="#1-6- 神经网络（NN）复杂度" class="headerlink" title="1.6 神经网络（NN）复杂度"></a>1.6 神经网络（NN）复杂度</h3><p>NN 层数 +NN 参数个数表示。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200606101213975.png" style="zoom:67%;" /><blockquote><p>空间复杂度：</p></blockquote><p>层数 = 隐藏层的层数 +1 个输出层</p><p>总参数 = 总 w+ 总 b</p><p>上图示例中层数为 2，总参数为（3×4+4）+（4×2+2）=26</p><blockquote><p>时间复杂度</p></blockquote><p>乘加运算次数</p><p>上图中，时间复杂度为（3×4）+（4×2）=20</p><script> pangu.spacingElementByTagName('p');/* 在标签 p 里面进行自动加空格处理 */ </script><h3 id="1-7- 激活函数"><a href="#1-7- 激活函数" class="headerlink" title="1.7 激活函数"></a>1.7 激活函数 </h3><p> 激活函数的目的：增加网络的非线性分割能力</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200606104326748.png" alt=""></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200606104228355.png" alt=""></p><p><strong>（1）Sigmoid 函数<code>tf.nn.sigmoid(x)</code></strong><br>$$<br>f(x)=\frac{1}{1+e^{-x}}<br>$$<br><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200606103734586.png" alt=""></p><ul><li><p>特点：<br>易造成梯度消失</p><p>输出非 0 均值，收敛慢</p><p>幂运算复杂，训练时间长</p></li></ul><p><strong>（2）Tanh 函数<code>tf.math.tanh(x)</code></strong><br>$$<br>f(x)=\frac{1-e^{-2x}}{1+e^{-2x}}<br>$$<br><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200606104506328.png" alt=""></p><ul><li><p>特点：</p><p>输出是 0 均值</p><p>易造成梯度消失</p><p>幂运算复杂，训练时间长</p></li></ul><p><strong>（3）Relu 函数<code>tf.nn.relu(x)</code></strong></p><img src="/assets/image-20200606105345922.png" style="zoom:67%;" /><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200606105900451.png" alt=""></p><ul><li><p>优点：</p><p>解决了梯度消失的问题（在正区间）</p><p>只需判断输入是否大于 0，计算速度快</p><p>收敛速度远快于 sigmoid 和 tanh</p></li><li><p>缺点</p><p>输出非 0 均值，收敛慢</p><p>Dead Relu 问题，某些神经元可能永远不被激活，导致相应的参数永远不能被更新。</p></li></ul><p><strong>（4）Leaky Relu 函数<code>tf.nn.leaky_relu(x)</code></strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200606152404913.png" alt=""> </p><p><strong>几点认知</strong></p><ul><li><p>首选 relu 激活函数</p></li><li><p>学习率设置较小值</p></li><li><p>输入特征标准化，即让输入特征满足以 0 为均值，1 为标准差的正态分布</p></li><li><p>初始参数中心化，即让随机生成的参数满足以 0 为均值，sqar(2/ 当前层输入特征个数)</p></li></ul><h3 id="1-8- 损失函数"><a href="#1-8- 损失函数" class="headerlink" title="1.8 损失函数"></a>1.8 损失函数</h3><p>1.3 章节已对损失函数做了简单介绍，这里进行补充。均方误差示例代码如下：</p><pre><code class="python">import tensorflow as tfimport numpy as npSEED = 23455rdm = np.random.RandomState(seed=SEED)  # 生成 [0,1) 之间的随机数x = rdm.rand(32, 2)y_ = [[x1 + x2 + (rdm.rand() / 10.0 - 0.05)] for (x1, x2) in x]  # 生成噪声[0,1)/10=[0,0.1); [0,0.1)-0.05=[-0.05,0.05)x = tf.cast(x, dtype=tf.float32)w1 = tf.Variable(tf.random.normal([2, 1], stddev=1, seed=1))epoch = 15000lr = 0.002for epoch in range(epoch):    with tf.GradientTape() as tape:        y = tf.matmul(x, w1)        loss_mse = tf.reduce_mean(tf.square(y_ - y))    grads = tape.gradient(loss_mse, w1)    w1.assign_sub(lr * grads)    if epoch % 500 == 0:        print(&quot;After %d training steps,w1 is &quot; % (epoch))        print(w1.numpy(), &quot;\n&quot;)print(&quot;Final w1 is: &quot;, w1.numpy())</code></pre><p>除了采用均方差作为损失函数，还可采用交叉熵作为损失函数</p><p>交叉熵损失函数 CE（Cross Entropy）：表征两个概率分布之间的距离<br>$$<br>H(y_, y)=-∑y_×lny<br>$$<br><code>tf.losses.catagorical_crossentropy(y_, y)</code></p><p><strong>softmax 与交叉熵结合：</strong></p><p>输出先过 softmax 函数，再计算 y 与 y_的交叉熵损失函数。</p><p><code>tf.nn.softmax_cross_entropy_with_logits(y_, y)</code></p><pre><code class="python"># softmax 与交叉熵损失函数的结合import tensorflow as tfimport numpy as npy_ = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 0, 0], [0, 1, 0]])y = np.array([[12, 3, 2], [3, 10, 1], [1, 2, 5], [4, 6.5, 1.2], [3, 6, 1]])y_pro = tf.nn.softmax(y)loss_ce1 = tf.losses.categorical_crossentropy(y_,y_pro)loss_ce2 = tf.nn.softmax_cross_entropy_with_logits(y_, y)print(&#39; 分步计算的结果:\n&#39;, loss_ce1)print(&#39; 结合计算的结果:\n&#39;, loss_ce2)// 输出结果是一样的</code></pre><h3 id="1-9- 欠拟合和过拟合"><a href="#1-9- 欠拟合和过拟合" class="headerlink" title="1.9 欠拟合和过拟合"></a>1.9 欠拟合和过拟合 </h3><p> 欠拟合：模型不能有效拟合数据集，是对现有数据集学习的不够彻底</p><p>过拟合：模型对当前数据拟合的太好了，但对未见过的新数据难以做出正确的判断，模型缺乏泛化力。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200606162013190.png" alt=""></p><ul><li><p>欠拟合解决办法</p><p>增加输入特征项</p><p>增加网络参数</p><p>减少正则化参数</p></li><li><p>过拟合的解决办法：</p><p>数据清洗</p><p>增大训练集</p><p>采用正则化</p><p>增大正则化参数</p></li></ul><p><strong>（1）正则化缓解过拟合</strong></p><p>正则化在损失函数中引入模型复杂度指标，利用给 w 加权值，弱化了训练数据的噪声（一般不正则化 b）</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200606162802978.png" alt=""></p><p><strong>正则化的选择：</strong></p><p><strong>L1 正则化 </strong> 大概率会使很多参数变为 0，因此该方法可通过稀疏参数，即减少参数的数量，降低复杂度。<br>$$<br>loss_{L1}(w)=∑|w_i|<br>$$<br><code>tf.keras.regularizers.l1()</code></p><p><strong>L2 正则化 </strong> 会使参数很接近 0 但不为 0，因此该方法可通过减少参数值的大小降低复杂度。<br>$$<br>loss_{L2}(w)=∑|{w_i}^2|<br>$$<br><code>tf.keras.regularizers.l2()</code></p><h3 id="1-10- 优化器"><a href="#1-10- 优化器" class="headerlink" title="1.10  优化器"></a>1.10  优化器 </h3><p> 神经网络模型中有多种优化算法，优化算法的作用用来优化更新参数 w。</p><p>待优化参数 w 每迭代一个 batch(一小段)：就会有如下思考：</p><blockquote><p>a. 计算该时刻（t）损失函数关于当前参数的梯度：<br>$$<br>g_t=▽loss=\frac{∂loss}{∂(w_t)}<br>$$<br>—— t 表示当前 batch 迭代的总次数。</p><p>b. 计算 t 时刻一阶动量 m<del>t</del>和二阶动量 V<del>t</del></p><p>c. 计算 t 时刻下降梯度：η<del>t</del>=lr×m<del>t</del>/√(V<del>t</del>)</p><p>d. 计算 t+1 时刻参数：w<del>t+1</del>=w<del>t</del>-η<del>t</del>=w<del>t</del>-lr×m<del>t</del>/√(V<del>t</del>)</p></blockquote><p>一阶动量：与梯度相关的函数</p><p>二阶动量：与梯度平方相关的函数</p><table><thead><tr><th>动量的释义</th></tr></thead><tbody><tr><td>动量（momentum）来自物理类比，根据牛顿运动定律，负梯度是移动参数空间中粒子的力。 动量在物理学上定义为质量乘以速度。在动量学习算法中，我们假设是单位质量，因此速度向量 v 也可以看作是粒子的动量。</td></tr><tr><td>在某个参数值附近，有一个局部极小点（local minimum）：在这个点附近，向左移动和向右移动都会导致损失值增大。如果使用小学习率的 SGD 进行优化，那么优化过程可能会陷入局部极小点，导致无法找到全局最小点。<br />使用动量方法可以避免这样的问题，这一方法的灵感来源于物理学。有一种有用的思维图像，就是将优化过程想象成一个小球从损失函数曲线上滚下来。如果小球的动量足够大，那么它不会卡在峡谷里，最终会到达全局最小点。<br />动量方法的实现过程是每一步都移动小球，不仅要考虑当前的斜率值（当前的加速度），还要考虑当前的速度（来自于之前的加速度）。这在实践中的是指，更新参数 w 不仅要考虑当前的梯度值，还要考虑上一次的参数更新。</td></tr></tbody></table><p><strong>常见优化器如下</strong></p><p>（1）随机梯度下降法 SGD：无动量<br>$$<br>m_t=g_t<br>$$</p><p>$$<br>V_t=1<br>$$</p><p>$$<br>w_{t+1}=w_t-lr×g_t<br>$$</p><p>这里：<br>$$<br>g_t=\frac{∂loss}{∂w_t}<br>$$<br>参数 w1 自更新：<code>w1.assign_sub(lr×grads[0])</code></p><p>参数 b 自更新：<code>b.assign_sub(lr×grads[1])</code></p><p>（2）SGDM（含动量的 SGD），在 SGD 基础上增加一阶动量<br>$$<br>m_t=β·m_{t-1}+(1-β)·g_t<br>$$</p><p>$$<br>V_t=1<br>$$</p><p>$$<br>w_{t+1}=w_t-η<em>t=w_t-lr·(β·m</em>{t-1}+(1-β)·g_t)<br>$$</p><p>参数 w1 自更新：<code>w1.assign_sub(lr×m_w)</code></p><p>参数 b 自更新：<code>b.assign_sub(lr×m_b)</code></p><p>（3）Adagrad，在 SGD 基础上增加二阶动量<br>$$<br>m_t=g_t<br>$$</p><p>$$<br>V_t=∑g_i^2<br>$$</p><p>$$<br>w_{t+1}=w_t-η_t=w_t-lr·g_t/(√V_t)<br>$$</p><p>（4）RMSProp，在 SGD 基础上增加二阶动量</p><p>$$<br>m_t=g_t<br>$$</p><p>$$<br>V_t=β·V_{t-1}+(1-β)·g_t^2<br>$$</p><p>$$<br>w_{t+1}=w_t-η_t=w_t-lr·g_t/(√V_t)<br>$$</p><p>（5）Adam，同时结合 SGDM 一阶动量和 RMSProp 二阶动量</p><p>$$<br>m_t=β<em>1·m</em>{t-1}+(1-β_1)·g_t<br>\ 修正一阶动量偏差：m_t’=\frac{m_t}{1-β_1^t}<br>$$</p><p>$$<br>V_t=β<em>2·V</em>{t-1}+(1-β_2)·g_t^2<br>\ 修正二阶动量的偏差：V_t’=\frac{V_t}{1-β_2^t}<br>$$</p><p>$$<br>w_{t+1}=w_t-η_t=w_t-lr·\frac{m_t}{1-β_1^t}/√(\frac{V_t}{1-β_2^t})<br>$$</p><h2 id="2- 搭建神经网络"><a href="#2- 搭建神经网络" class="headerlink" title="2. 搭建神经网络"></a>2. 搭建神经网络</h2><p>tensorflow 核心 API：<code>tf.keras</code></p><h3 id="2-1- 六步法"><a href="#2-1- 六步法" class="headerlink" title="2.1 六步法"></a>2.1 六步法</h3><p>import</p><p>train，test</p><blockquote><p>a. 顺序网络结构：model=tf.keras.models.Sequential </p><p>b. 带跳连的非顺序结构：先定义网络类：calss MyModel(Model) </p><p>再调用 model=MyModel</p></blockquote><p>model.compile</p><p>model.fit</p><p>model.summary</p><h4 id="2-1-1- 神经网络层"><a href="#2-1-1- 神经网络层" class="headerlink" title="2.1.1 神经网络层"></a>2.1.1 神经网络层</h4><p><strong>（1）顺序网络层</strong></p><pre><code>model=tf.keras.models.Sequential([网络结构])   #描述各层网络 </code></pre><p> 网络结构有：</p><p><strong>拉直层</strong>：tf.keras.layers.Flatten()  ————&gt; 不含计算，只是形状转换，把输入特征拉直为一维数组。</p><p><strong>全连接层</strong>：</p><p>tf.keras.layers.Dense(神经元个数，activation=’激活函数’，kernel_regularizer= 哪种正则化)</p><p><strong>卷积层</strong>：</p><p>tf.keras.layers.Dense(filters= 卷积核个数，kernel_size= 卷积核尺寸，strides= 卷积步长，padding=’valid’or’same’)</p><p><strong>循环神经网络层 LSTM</strong>：</p><p>tf.keras.layers.LSTM()</p><p><strong>（2）非顺序网络层</strong></p><pre><code class="python">class MyModel(Model):    def __init__(self):        super(MyModel,self).__init__():            #这里定义网络结构快    def call(self,x):        #调用网络结构快，实现前向传播        return ymodel=MyModel()</code></pre><h4 id="2-1-2- 神经网络配置"><a href="#2-1-2- 神经网络配置" class="headerlink" title="2.1.2 神经网络配置"></a>2.1.2 神经网络配置</h4><pre><code>model.compile(optimizer= 优化器，loss= 损失函数，metrics=[&#39; 准确率 &#39;])</code></pre><p>（1）优化器</p><p>‘sgd’或者 tf.keras.optimizers.SGD(lr= 学习率，momentum= 动量参数)</p><p>‘adagrad’或者 tf.keras.optimizers.Adagred(lr= 学习率)</p><p>‘adadelta’或者 tf.keras.optimizers.Adadelta(lr= 学习率)</p><p>‘adam’或者 tf.keras.optimizers.Adam(lr= 学习率，beta_1=0.9，beta_2=0.999)</p><p>（2）损失函数 loss</p><p>‘mse’或者 tf.keras.losses.MeanSquaredError()</p><p>‘sparse_categorical_crossentropy’ 或者 tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False)</p><p>神经网络经 softmax 函数概率分布输出，就设置 from_logits=False</p><p>不经过 softmax 函数概率分布输出概率输出，而是直接输出，则设置 from_logits=True</p><p>（3）准确率指标 Metrics</p><p>‘accuracy’：y_和 y 都是数值，如 y_=[1]，y=[1]</p><p>‘categorical_accuracy’：y_和 y 都是独热码（概率分布），如 y_=[0,1,1]，y=[0.256,0.695,0.048]</p><p>‘sparse_categorical_accuracy’：y_是数值，y 是独热码（概率分布），如 y_=[1]，y=[0.256,0.695,0.048]</p><h4 id="2-1-3- 执行训练过程"><a href="#2-1-3- 执行训练过程" class="headerlink" title="2.1.3 执行训练过程"></a>2.1.3 执行训练过程</h4><pre><code>model.fit(训练集的输入特征，训练集的标签，          batch_size=,epochs=,          validation_data=(测试集的输入特征，测试集的标签),          validation_split= 从训练集划分多少比例给测试集，          validation_freq= 多少次 epoch 测试一次)</code></pre><h3 id="2-2- 鸢尾花分类示例"><a href="#2-2- 鸢尾花分类示例" class="headerlink" title="2.2 鸢尾花分类示例"></a>2.2 鸢尾花分类示例</h3><p><strong>（1）Sequential 搭建神经网络</strong></p><pre><code class="python">import tensorflow as tffrom sklearn import datasetsimport numpy as npx_train=datasets.load_iris().datay_lable=datasets.load_iris().targetnp.random.seed(10)np.random.shuffle(x_train)np.random.seed(10)np.random.shuffle(y_lable)tf.random.set_seed(10)# print(x_train,x_train.shape)# print(y_lable)model=tf.keras.models.Sequential([tf.keras.layers.Dense(4,activation=&#39;softmax&#39;,kernel_regularizer=tf.keras.regularizers.l2())])model.compile(optimizer=tf.keras.optimizers.SGD(lr=0.1),loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),              metrics=[&#39;sparse_categorical_accuracy&#39;])model.fit(x_train,y_lable,batch_size=32,epochs=50,validation_freq=20,validation_split=0.2)model.summary()</code></pre><p><strong>（2）class 类搭建神经网络</strong></p><pre><code class="python">import tensorflow as tffrom sklearn import datasetsfrom tensorflow.keras.layers import Densefrom tensorflow.keras import Modelimport numpy as npx_train=datasets.load_iris().datay_lable=datasets.load_iris().targetnp.random.seed(10)np.random.shuffle(x_train)np.random.seed(10)np.random.shuffle(y_lable)tf.random.set_seed(10)print(x_train,x_train.shape)print(y_lable)class IrisModel(Model):    def __init__(self):        super(IrisModel,self).__init__()  #这里一定是要的        self.d1=Dense(4,activation=&#39;softmax&#39;,kernel_regularizer=tf.keras.regularizers.l2())            def call(self,x):        y=self.d1(x)        return ymodel=IrisModel()model.compile(optimizer=tf.keras.optimizers.SGD(lr=0.1),loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),              metrics=[&#39;sparse_categorical_accuracy&#39;])model.fit(x_train,y_lable,batch_size=32,epochs=50,validation_freq=20,validation_split=0.2)model.summary()</code></pre><h3 id="2-3-mnist 数据集"><a href="#2-3-mnist 数据集" class="headerlink" title="2.3 mnist 数据集"></a>2.3 mnist 数据集 </h3><p> 提供 6 万张 28×28 像素点的 1-9 手写数字图片和标签，用于训练；</p><p>提供 1 万张 28×28 像素点的 1-9 手写数字图片和标签，用于测试；</p><p>数据集的导入：</p><p>mnist=tf.keras.datasets.mnist</p><p>(x_train,y_train),(x_test,y_test)=mnist.load.load_data()</p><p>作为输入特征，输入神经网络时，将数据拉伸为一维数组：</p><p>tf.keras.layers.Flatten()</p><p><strong>Sequential 搭建神经网络代码如下：</strong></p><pre><code class="python">import tensorflow as tfimport matplotlib.pyplot as plt(x_train,y_train),(x_test,y_test)=tf.keras.datasets.mnist.load_data()x_train,x_test=x_train/255,x_test/255#print(y_train)model=tf.keras.models.Sequential([tf.keras.layers.Flatten(),    tf.keras.layers.Dense(128,activation=&#39;relu&#39;),    tf.keras.layers.Dense(10,activation=&#39;softmax&#39;),])model.compile(optimizer=&#39;adam&#39;,loss=&#39;sparse_categorical_crossentropy&#39;,              metrics=[&#39;sparse_categorical_accuracy&#39;])history=model.fit(x_train,y_train,batch_size=32,epochs=8,validation_data=(x_test,y_test),          validation_freq=2)model.summary()// 输出结果如下：_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================flatten (Flatten)            multiple                  0         _________________________________________________________________dense (Dense)                multiple                  100480    _________________________________________________________________dense_1 (Dense)              multiple                  1290      =================================================================Total params: 101,770Trainable params: 101,770Non-trainable params: 0_________________________________________________________________</code></pre><p><strong>class 类搭建神经网络：</strong></p><pre><code class="python">import tensorflow as tfimport matplotlib.pyplot as pltfrom tensorflow.keras import Modelfrom tensorflow.keras.layers import Flatten,Dense(x_train,y_train),(x_test,y_test)=tf.keras.datasets.mnist.load_data()x_train,x_test=x_train/255,x_test/255#print(y_train)class MnistModel(Model):    def __init__(self):        super(MnistModel,self).__init__()        self.flatten=Flatten()        self.d1=Dense(128,activation=&#39;relu&#39;)        self.d2=Dense(10,activation=&#39;softmax&#39;)    def call(self,x):        x=self.flatten(x)        x=self.d1(x)        y=self.d2(x)        return ymodel=MnistModel()model.compile(optimizer=&#39;adam&#39;,loss=&#39;sparse_categorical_crossentropy&#39;,              metrics=[&#39;sparse_categorical_accuracy&#39;])history=model.fit(x_train,y_train,batch_size=32,epochs=8,validation_data=(x_test,y_test),          validation_freq=2)model.summary()// 输出结果如下：_________________________________________________________________Layer (type)                 Output Shape              Param #   =================================================================flatten (Flatten)            multiple                  0         _________________________________________________________________dense (Dense)                multiple                  100480    _________________________________________________________________dense_1 (Dense)              multiple                  1290      =================================================================Total params: 101,770Trainable params: 101,770Non-trainable params: 0_________________________________________________________________</code></pre><h3 id="2-4-Fashion 数据集"><a href="#2-4-Fashion 数据集" class="headerlink" title="2.4 Fashion 数据集"></a>2.4 Fashion 数据集 </h3><p> 提供 6 万张 28×18 像素点的衣服等图片和标签，用于训练。</p><p>提供 1 万张 28×18 像素点的衣服等图片和标签，用于测试。</p><p><strong>Sequential 搭建神经网络代码如下：</strong></p><pre><code class="python">import tensorflow as tfimport matplotlib.pyplot as plt(x_train,y_train),(x_test,y_test)=tf.keras.datasets.fashion_mnist.load_data()x_train,x_test=x_train/255,x_test/255#剩下代码同 minist 数据集代码</code></pre><h2 id="3- 黑白图片应用"><a href="#3- 黑白图片应用" class="headerlink" title="3. 黑白图片应用"></a>3. 黑白图片应用 </h2><p> 以上的示例都是自带准备好的数据集，直接可以拿来用，如果是我们自己的训练数据包，该如何处理成为规范化成为可以喂入神经网络的数据呢？</p><p>这里提出两个概念：<strong>自制数据集和数据增强</strong>！</p><p>数据增强：是针对于你的数据量过少，模型训练不足，泛化力会弱，这时就需要数据增强。</p><p>还有一个问题是，我们已有一些数据集，已经训练好了参数，但后面又需补充一些新的数据，如果这时又重新加入新数据重头再训练，就显得太笨了，</p><p>这时就需要 <strong> 断点续训 </strong> 了！实时保存最优模型。</p><p>训练神经网络的目的就是要获取各层神经网络的最优参数，只要拿到这些参数，就能跨机跨平台使用了，这时就需要 <strong> 参数提取 </strong> 了。</p><p>与此同时，我们还需要见证模型的优化过程，到底是不是在往好的方向优化，这时就需要绘制 <strong>acc/loss 曲线</strong> 了！</p><p>最后，训练出模型，我们就需要用它干点事了，给神经网络一组新的数据，实现前向推理，让神经网络 <strong> 预测 </strong> 出结果，实现学以致用！</p><p>以上归纳就是如下：</p><p>①自制数据集，解决本领域的应用</p><p>②数据增强，扩充数据集</p><p>③断点续训，存取模型</p><p>④参数提取，把参数存入文本</p><p>⑤acc/loss 可视化，查看训练结果</p><p>⑥应用程序，给物识图</p><h3 id="3-1- 自制数据集"><a href="#3-1- 自制数据集" class="headerlink" title="3.1 自制数据集"></a>3.1 自制数据集 </h3><p><strong> 准备两个文件夹：</strong></p><p>trian_jpg_60000   用于放置训练的图片</p><p>test_jpg_10000  用于放置测试的图片</p><p><strong>准备两个 txt 文件：</strong></p><p>train_label_60000.txt 用于放置训练的图片名及其对应标签</p><p>test_label_10000.txt   用于放置测试的图片名及其对应标签</p><p>txt 文本文件内容示例如下：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200609160339651.png" style="zoom:67%;" /><p>实现代码如下：</p><pre><code class="python">from PIL import Imageimport numpy as npimport osdef generated(path,txt): #将原生图片转换成数组格式    f=open(txt,&#39;r&#39;)    contents=f.readlines()    f.close()    x,y=[],[]    for content in contents:        img_name=content.split()[0]        img_label=content.split()[1]        img_path=path+&#39;\\&#39;+img_name        img=Image.open(img_path)        img=np.array(img.convert(&#39;L&#39;))        img=img/255.        x.append(img)        y.append(img_label)        print(&#39;loading:&#39;,img_name)    x=np.array(x)    y=np.array(y)    y=y.astype(np.int64)    return x,ytrain_img_path=&#39;D:\\ 北大 tf2 课程 \\ 制作数据集 \\mnist_train_jpg_60000&#39;  #训练图片文件夹, 这里是 6000 张 28×28 像素的图片train_label_path=&#39;D:\\ 北大 tf2 课程 \\ 制作数据集 \\mnist_train_jpg_60000.txt&#39;   #训练图片对应的 txt 文件test_img_path=&#39;D:\\ 北大 tf2 课程 \\ 制作数据集 \\mnist_test_jpg_10000&#39;  #测试图片文件夹test_label_path=&#39;D:\\ 北大 tf2 课程 \\ 制作数据集 \\mnist_test_jpg_10000.txt&#39;   #测试图片对应的 txt 文件train_datasets_path=&#39;D:\\ 北大 tf2 课程 \\ 制作数据集 \\mnist_train.npy&#39;    #训练图片转换成可用数据集，这里设置其存储路径及格式train_label_datasets_path=&#39;D:\\ 北大 tf2 课程 \\ 制作数据集 \\mnist_train_label.npy&#39; #训练图片标签转换成可用数据集，这里设置其存储路径及格式test_datasets_path=&#39;D:\\ 北大 tf2 课程 \\ 制作数据集 \\mnist_test.npy&#39;    #测试图片转换成可用数据集，这里设置其存储路径及格式test_label_datasets_path=&#39;D:\\ 北大 tf2 课程 \\ 制作数据集 \\mnist_test_label.npy&#39; #测试图片标签转换成可用数据集，这里设置其存储路径及格式if  not os.path.exists(train_datasets_path) and not os.path.exists(train_label_datasets_path) and not os.path.exists(test_datasets_path) and not os.path.exists(test_label_datasets_path):    print(&#39;-------------Generate Datasets-----------------&#39;)    x_train, y_lable = generated(train_img_path, train_label_path)    x_test, y_test_label = generated(test_img_path, test_label_path)    print(&#39;-------------Save Datasets-----------------&#39;)    x_train = np.reshape(x_train, (len(x_train), -1))    x_test = np.reshape(x_test, (len(x_test), -1))    np.save(train_datasets_path,x_train)    np.save(train_label_datasets_path,y_lable)    np.save(test_datasets_path,x_test)    np.save(test_label_datasets_path,y_test_label)else:    print(&#39;-------------Load Datasets-----------------&#39;)    x_train = np.load(train_datasets_path)    y_label = np.load(train_label_datasets_path)    x_test = np.load(test_datasets_path)    y_test_label = np.load(test_label_datasets_path)    x_train = np.reshape(x_train, (len(x_train), 28, 28))    x_test = np.reshape(x_test, (len(x_test), 28, 28))print(x_train.shape,y_label.shape)print(x_test,y_test_label)</code></pre><h3 id="3-2- 数据增强"><a href="#3-2- 数据增强" class="headerlink" title="3.2 数据增强"></a>3.2 数据增强</h3><p><code>image_gen_train=tf.keras.preprocessing.image.ImageDataGenerator(增强方法)</code></p><p><code>image_gen_train.fit(x_train)</code></p><p><strong>常用增强方法：</strong></p><p>缩放系数：rescale= 所有数据将乘以该系数</p><p>随机旋转：rotation_range= 随机旋转角度范围</p><p>宽度偏移：width_shift_range= 随机宽度偏移量</p><p>高度偏移：height_shift_range= 随机高度偏移量</p><p>水平旋转：horizontal_flip= 是否水平随机翻转</p><p>随机缩放：zoom_range= 随机缩放的范围 [1-n,1+n]</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200609175704555.png" alt=""></p><p><code>model.fit(……)</code>更新为：</p><p><code>model.fit(image_gen_train.flow(x_train,y_train,batch_size=),...)</code></p><p><strong>代码示例：</strong></p><pre><code class="python">import tensorflow as tffrom tensorflow.keras.preprocessing.image import ImageDataGeneratormnist = tf.keras.datasets.mnist(x_train, y_train), (x_test, y_test) = mnist.load_data()x_train, x_test = x_train / 255.0, x_test / 255.0x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)  # 给数据增加一个维度, 从(60000, 28, 28)reshape 为(60000, 28, 28, 1)image_gen_train = ImageDataGenerator(    rescale=1. / 1.,  # 如为图像，分母为 255 时，可归至 0～1    rotation_range=45,  # 随机 45 度旋转    width_shift_range=.15,  # 宽度偏移    height_shift_range=.15,  # 高度偏移    horizontal_flip=False,  # 水平翻转    zoom_range=0.5  # 将图像随机缩放阈量 50％)image_gen_train.fit(x_train)model = tf.keras.models.Sequential([tf.keras.layers.Flatten(),    tf.keras.layers.Dense(128, activation=&#39;relu&#39;),    tf.keras.layers.Dense(10, activation=&#39;softmax&#39;)])model.compile(optimizer=&#39;adam&#39;,        loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),              metrics=[&#39;sparse_categorical_accuracy&#39;])model.fit(image_gen_train.flow(x_train, y_train, batch_size=32), epochs=5,             validation_data=(x_test, y_test),        validation_freq=1)model.summary()</code></pre><h3 id="3-3- 保存及读取模型"><a href="#3-3- 保存及读取模型" class="headerlink" title="3.3 保存及读取模型"></a>3.3 保存及读取模型 </h3><p> 保存模型：</p><pre><code class="python">cp_callback=tf.keras.callbacks.ModelCheckpoint(        filepath=&#39; 路径文件名 &#39;,        save_weights_only=True/False,        save_best_only=True/False)model.fit(...,callback=[cp_callback])</code></pre><p>读取模型：</p><pre><code>model.load_weights(&#39; 路径文件名 &#39;)</code></pre><p>应用示例如下：</p><pre><code class="python">import tensorflow as tfimport osmnist = tf.keras.datasets.mnist(x_train, y_train), (x_test, y_test) = mnist.load_data()x_train, x_test = x_train / 255.0, x_test / 255.0model = tf.keras.models.Sequential([tf.keras.layers.Flatten(),    tf.keras.layers.Dense(128, activation=&#39;relu&#39;),    tf.keras.layers.Dense(10, activation=&#39;softmax&#39;)])model.compile(optimizer=&#39;adam&#39;,    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),    metrics=[&#39;sparse_categorical_accuracy&#39;])checkpoint_save_path = &quot;./checkpoint/mnist.ckpt&quot;if os.path.exists(checkpoint_save_path + &#39;.index&#39;):    print(&#39;-------------load the model-----------------&#39;)    model.load_weights(checkpoint_save_path)cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,                                                 save_weights_only=True,                                                 save_best_only=True)history = model.fit(x_train, y_train, batch_size=32, epochs=5,                     validation_data=(x_test, y_test), validation_freq=1,                    callbacks=[cp_callback]) #调用 callbacks 后会在加载模型基础上继续训练model.summary()</code></pre><h3 id="3-4- 参数提取"><a href="#3-4- 参数提取" class="headerlink" title="3.4 参数提取"></a>3.4 参数提取 </h3><p> 提取可训练参数：</p><p>model.trainable_variables 返回模型中可训练参数</p><p>设置 print 输出格式</p><p>np.set_printoptions(threshold= 超过多少省略显示)  #np.inf 表示无限大</p><pre><code class="python">model.sumary() #sumary 之后可接上以下代码实现参数提取print(model.trainable_variables)file=open(&#39;./weights.txt&#39;,&#39;w&#39;)for v in model.trainable_variables:    file.write(str(v.name)+&#39;\n&#39;)    file.write(str(v.shape)+&#39;\n&#39;)    file.write(str(v.numpy())+&#39;\n&#39;)file.close()</code></pre><h3 id="3-5-acc-loss 可视化"><a href="#3-5-acc-loss 可视化" class="headerlink" title="3.5 acc/loss 可视化"></a>3.5 acc/loss 可视化</h3><pre><code class="python">history=model.fit(...)acc=history.history[&#39;sparse_categorical_accuracy&#39;] #训练集准确率val_acc=history.history[&#39;val_sparse_categorical_accuracy&#39;] #测试集准确率loss=history.history[&#39;loss&#39;]       #训练集损失率val_loss=history.history[&#39;val_loss&#39;]  #测试集损失率plt.subplot(1,2,1)plt.plot(acc,label=&#39;Training Accuracy&#39;)plt.plot(val_acc,label=&#39;Validation Accuracy&#39;)plt.title(&#39;training and validation accuracy&#39;)plt.legend()plt.subplot(1,2,2)plt.plot(loss,label=&#39;Training loss&#39;)plt.plot(val_loss,label=&#39;Validation loss&#39;)plt.title(&#39;training and validation loss&#39;)plt.legend()plt.show()</code></pre><h3 id="3-6- 给图识物"><a href="#3-6- 给图识物" class="headerlink" title="3.6 给图识物"></a>3.6 给图识物</h3><pre><code class="python">model=tf.keras.models.Sequentical([tf.keras.layers.Flatten(),    tf.keras.layers.Dense(128,activation=&#39;relu&#39;),    tf.keras.layers.Dense(10,activation=&#39;softmax&#39;),])model.load_weights(model_save_path)result=model.predict(x_predict)</code></pre><p>应用示例：</p><pre><code class="python">from PIL import Imageimport numpy as npimport tensorflow as tfmodel_save_path = &#39;./checkpoint/mnist.ckpt&#39;model = tf.keras.models.Sequential([tf.keras.layers.Flatten(),    tf.keras.layers.Dense(128, activation=&#39;relu&#39;),    tf.keras.layers.Dense(10, activation=&#39;softmax&#39;)])model.load_weights(model_save_path)preNum = int(input(&quot;input the number of test pictures:&quot;))for i in range(preNum):    image_path = input(&quot;the path of test picture:&quot;)    img = Image.open(image_path)    img = img.resize((28, 28), Image.ANTIALIAS) #以高质量缩放到 28×28size 大小    img_arr = np.array(img.convert(&#39;L&#39;))    for i in range(28):        for j in range(28):            if img_arr[i][j] &lt; 200:                img_arr[i][j] = 255            else:                img_arr[i][j] = 0    img_arr = img_arr / 255.0    x_predict = img_arr[tf.newaxis, ...]  #这行代码很重要！将（28,28）变成(1,28,28)    result = model.predict(x_predict)    pred = tf.argmax(result, axis=1)    print(&#39;\n&#39;)    tf.print(pred)</code></pre><p>补充点：</p><p>Image.NEAREST ：低质量<br> Image.BILINEAR：双线性<br> Image.BICUBIC ：三次样条插值<br> Image.ANTIALIAS：高质量</p><h2 id="4- 彩色图片应用"><a href="#4- 彩色图片应用" class="headerlink" title="4. 彩色图片应用"></a>4. 彩色图片应用 </h2><p> 现实世界中，实际项目中的图片多是高分辨率彩色图，包含 RGB 三通道。</p><p>图片色彩丰富会导致待优化的参数过多，容易造成模型过拟合。</p><p>实际应用时会把原始图片进行特征提取，再把提取到的特征送给全连接网络。</p><h3 id="4-1- 卷积神经网络"><a href="#4-1- 卷积神经网络" class="headerlink" title="4.1 卷积神经网络"></a>4.1 卷积神经网络 </h3><p> 卷积计算是一种有效的提取图像特征的方法。</p><p>一般会采用一个正方形的卷积核，按指定步长，在输入特征图上滑动，遍历输入特征图中每个像素点。每一个步长，卷积核会与输入特征图出现重合区域，重合区域对应元素相乘，求和再加上偏置项，得到输入特征的一个像素点。</p><p>输入特征图的深度，决定了当前层卷积核的深度。如黑白为一维，RGB 彩色图为三维。</p><p>当前卷积核的个数，决定了当前层输出特征图的深度。</p><p>卷积计算过程：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200610160153536.png" style="zoom: 80%;" /><p>原始图像矩阵与卷积核对应位置的像素点值进行乘运算，最后把这九个值相加，并加上偏置项 1。</p><p>1×(-1)+0×0+2×1+5×(-1)+4×0+2×1+3×(-1)+4×0+5×1+1=1</p><p>以上可以看到，5×5 的图片经过 3×3 卷积核计算，输出图片变成了 3×3，大大减少了图片信息量，有利于模型训练。</p><h4 id="感受野"><a href="# 感受野" class="headerlink" title="感受野"></a>感受野</h4><p>Receptive Field，卷积神经网络各输入特征图中的每个像素点，在原始输入图片上映射区域的大小。</p><h4 id="全零填充"><a href="# 全零填充" class="headerlink" title="全零填充"></a>全零填充</h4><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200610161834423.png" style="zoom: 67%;" /><p>在原始图像像素矩阵四周加 0，使得在卷积计算过程中，输出结果图片大小与原图片一致。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200610162046768.png" style="zoom: 67%;" /><p>以上公式表现了是否采用全零填充时，原图片与输出图片，步长，核长四者之间的关系。</p><p><strong>TF 描述卷积层：</strong></p><pre><code>tf.keras.layers.Conv2D(    filters= 卷积核个数,    kernel_size= 卷积核尺寸, #也可 (高，宽) 给出    strides= 滑动步长,        # 默认 1    padding=&#39;same&#39;or&#39;valid,  #全零填充是 &#39;same&#39;, 默认 &#39;valid&#39;    activation=&#39; 激活函数 &#39;,     #若有 BN 此处不写    input_shape=(高，宽，通道数), #输入特征维度，可省略    )</code></pre><h4 id="4-1-2- 批标准化 BN"><a href="#4-1-2- 批标准化 BN" class="headerlink" title="4.1.2 批标准化 BN"></a>4.1.2 批标准化 BN</h4><p>输入数据经过网络训练之后，由于权重的不同，可能造成输出数据变得过大或过小，这样进行激活时，如使用 tanh 函数激活，一旦 x 值超过 2 之后，其激活效果没有差别，激活函数对 0 附近的数据更加敏感。</p><p>神经网络对 0 附近的数据更敏感，但是随着网络层数的增加，特征数据会出现偏离 0 均值的情况，这时可以通过标准化进行调整。</p><p>标准化：使数据整体符合 0 均值，1 为标准差的分布。</p><p>批标准化：对一小批数据，做标准化处理</p><p>为每个卷积核引入可训练参数γ<del>i</del>，β<del>i</del>，调整批归一化的力度。使得输出数据过激活函数前，进行统一的标准化处理。</p><p>不用担心批标准化之后改变原数据之间的关系，本来有的特征就是需要强化，有的需要弱化，所有的这些可训练参数（权重 w，偏置项 b，标准化参数γ<del>i</del>，β<del>i</del>等）经过训练之后，通过固定的相配对的网络结构就能准确反映预期的结果。</p><p>目的：提升激活函数对输入数据的区分力。</p><ul><li><p>BN 层位于卷积层之后，激活层之前。</p></li><li><p>TF 描述批标准化</p><p>tf.keras.layers.BatchNormalization()</p></li></ul><pre><code>model=tf.keras.models.Sequential([Conv2D(filters=6,kernel_size=(5,5),padding=&#39;same&#39;),    BatchNormalization(),    Activation(&#39;relu&#39;),    MaxPool2D(pool_size=(2,2),strides=2,padding=&#39;same&#39;),    Dropout(0.2)])</code></pre><h4 id="4-1-3- 池化"><a href="#4-1-3- 池化" class="headerlink" title="4.1.3 池化"></a>4.1.3 池化 </h4><p> 目的：减少特征数据量</p><p>所谓池化，就是取目标图片像素矩阵中一块区域数值的最大值，或均值来代替原图片像素矩阵。</p><p>最大值池化可提取图片纹理，均值池化可保留背景特征。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200611163359181.png" style="zoom:67%;" /><p><strong>TF 描述池化</strong></p><pre><code>tf.keras.layers.MaxPool2D(    pool_size= 池化核尺寸，    strides= 滑动步长,        # 默认 pool_size    padding=&#39;same&#39;or&#39;valid,  #全零填充是 &#39;same&#39;, 默认 &#39;valid&#39;    )tf.keras.layers.AveragePooling2D(    pool_size= 池化核尺寸，    strides= 滑动步长,        # 默认 pool_size    padding=&#39;same&#39;or&#39;valid,  #全零填充是 &#39;same&#39;, 默认 &#39;valid&#39;    )</code></pre><h4 id="4-1-4- 舍弃"><a href="#4-1-4- 舍弃" class="headerlink" title="4.1.4 舍弃"></a>4.1.4 舍弃 </h4><p> 为了缓解神经网络过拟合，在神经网络训练中，将隐藏层一部分神经元按照一定概率从神经网络中暂时舍弃。神经网络使用时，被舍弃的神经元恢复连接。</p><p><strong>TF 描述池化：</strong></p><p>tf.keras.layers.Dropout(舍弃概率)</p><h4 id="4-1-5- 总结"><a href="#4-1-5- 总结" class="headerlink" title="4.1.5 总结"></a>4.1.5 总结 </h4><p> 卷积神经网络：借助卷积核提取特征后，送入全连接网络。</p><p>卷积神经网络主要模块：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612101346395.png" style="zoom:80%;" /><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612101445935.png" alt=""></p><h3 id="4-2- 应用"><a href="#4-2- 应用" class="headerlink" title="4.2 应用"></a>4.2 应用 </h3><p> 以 Cifar10 数据集为例：</p><p>提供 5 万张 32×32 像素点的十分类彩色图片和标签，用于训练。</p><p>提供 1 万张 32×32 像素点的十分类彩色图片和标签，用于测试。</p><p>一共有十类动物图片。</p><p>导入 cifar10 数据集：</p><pre><code>cifar10=tf.keras.datasets.cifar10(x_train,y_train),(x_test,y_test)=cifar10.load_data()</code></pre><p>实现示例：</p><pre><code class="python">import tensorflow as tfimport osimport matplotlib.pyplot as pltfrom tensorflow.keras.models import Modelfrom tensorflow.keras.layers import Conv2D,BatchNormalization,Activation,MaxPool2D,Dropout,Flatten,Densecifar10=tf.keras.datasets.cifar10(x_train,y_train),(x_test,y_test)=cifar10.load_data()x_train=x_train/255.x_test=x_test/255.class Baseline(Model):    def __init__(self):        super(Baseline,self).__init__()        self.c1=Conv2D(filters=6,kernel_size=5,padding=&#39;same&#39;)        self.b1=BatchNormalization()        self.a1=Activation(&#39;relu&#39;)        self.p1=MaxPool2D(pool_size=2,strides=2,padding=&#39;same&#39;)        self.d1=Dropout(0.2)        self.f1=Flatten()        self.d2=Dense(128,activation=&#39;relu&#39;)        self.d3=Dropout(0.2)        self.d4=Dense(10,activation=&#39;softmax&#39;)    def call(self,x):        x=self.c1(x)        x=self.b1(x)        x=self.a1(x)        x=self.p1(x)        x=self.d1(x)        x=self.f1(x)        x=self.d2(x)        x=self.d3(x)        y=self.d4(x)        return ymodel=Baseline()model.compile(optimizer=tf.keras.optimizers.Adam(lr=0.1),              loss=&#39;sparse_categorical_crossentropy&#39;,              metrics=[&#39;sparse_categorical_accuracy&#39;])model_path=&#39;./checkpoint/cifar10.ckpt&#39;if os.path.exists(model_path+&#39;.index&#39;):    print(&#39;loading model&#39;)    model.load_weights(model_path)cp_callback=tf.keras.callbacks.ModelCheckpoint(filepath=model_path,                                               save_best_only=True,                                               save_weights_only=True)history=model.fit(x_train,y_train,batch_size=32,epochs=9,                  validation_data=(x_test,y_test),                  validation_freq=1,callbacks=[cp_callback])model.summary()loss=history.history[&#39;loss&#39;]val_loss=history.history[&#39;val_loss&#39;]acc=history.history[&#39;sparse_categorical_accuracy&#39;]val_acc=history.history[&#39;val_sparse_categorical_accuracy&#39;]plt.subplot(121)plt.plot(loss,label=&#39;loss&#39;)plt.plot(val_loss,label=&#39;val_loss&#39;)plt.legend()plt.subplot(122)plt.plot(acc,label=&#39;acc&#39;)plt.plot(val_acc,label=&#39;val_acc&#39;)plt.legend()plt.show()</code></pre><h2 id="5- 经典卷积神经网络"><a href="#5- 经典卷积神经网络" class="headerlink" title="5. 经典卷积神经网络"></a>5. 经典卷积神经网络</h2><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612145825710.png" alt=""></p><h3 id="5-1-LeNet"><a href="#5-1-LeNet" class="headerlink" title="5.1 LeNet"></a>5.1 LeNet</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612145921978.png" alt=""></p><p>LeNet 神经网络结果如上，运用了：</p><p>两个卷积神经网络 + 一个拉直层 + 三个全连接网络</p><h3 id="5-2-AlexNet"><a href="#5-2-AlexNet" class="headerlink" title="5.2 AlexNet"></a>5.2 AlexNet</h3><p>AlexNet 网络诞生于 2012 年，当年的 ImageNet 竞赛的冠军，Top5 错误率为 16.4%。</p><p><em>Alex Krizhevsky, Ilya Sutskever; Geoffrey E. Hinton. ImageNet Classfication with Deep Convolution Networks. In NIPS 2012.</em></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612150720746.png" alt=""></p><p>AlexNet 神经网络结果如上，运用了：</p><p>五个卷积神经网络 + 一个拉直层 + 三个全连接网络</p><h3 id="5-3-VGGNet"><a href="#5-3-VGGNet" class="headerlink" title="5.3 VGGNet"></a>5.3 VGGNet</h3><p>VGGNet 诞生于 2014 年，当年 ImageNet 竞赛的亚军，Top5 错误率减小到 7.3%。使用小尺寸卷积核，减少了参数的同时提高了准确率，其网络结构规整，非常适合硬件加速。</p><p><em>K Simonyan, A Zisserman. Very Deep Convolutional Networks for Large Scale Image RecognitionI. In NIPS 2015.</em></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612151928712.png" alt=""></p><p>VGGNet 神经网络结果如上，运用了：</p><p>十三个卷积神经网络 + 一个拉直层 + 三个全连接网络</p><h3 id="5-4-InceptionNet"><a href="#5-4-InceptionNet" class="headerlink" title="5.4 InceptionNet"></a>5.4 InceptionNet</h3><p> InceptionNet 诞生于 2014 年，当年 ImageNet 竞赛的亚军，Top5 错误率减小到 6.67%。</p><p><em>SzegedyC, Liu w, Jia y, et al. Going Deeper with Convolutions. In CVPR, 2015.</em></p><p>引入 Inception 结构块，在同一层网络内使用不同尺寸的卷积核，提升了模型感知力，使用批标准化，缓解了梯度消失。</p><p> InceptionNet 的核心是它的基本单元 Inception 结构块，包括其后续版本，都是基于 Inception 结构块搭建的网络。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612153034354.png" alt=""></p><p>实现代码如下：</p><pre><code class="python">import tensorflow as tfimport osimport numpy as npfrom matplotlib import pyplot as pltfrom tensorflow.keras.layers import Conv2D, BatchNormalization, Activation, MaxPool2D, Dropout, Flatten, Dense, GlobalAveragePooling2Dfrom tensorflow.keras import Modelnp.set_printoptions(threshold=np.inf)  #设置输出打印格式cifar10 = tf.keras.datasets.cifar10(x_train, y_train), (x_test, y_test) = cifar10.load_data()x_train, x_test = x_train / 255.0, x_test / 255.0class ConvBNRelu(Model):    def __init__(self, ch, kernelsz=3, strides=1, padding=&#39;same&#39;):        super(ConvBNRelu, self).__init__()        self.model = tf.keras.models.Sequential([Conv2D(ch, kernelsz, strides=strides, padding=padding),            BatchNormalization(),            Activation(&#39;relu&#39;)        ])    def call(self, x):        x = self.model(x, training=False)         #在 training=False 时，BN 通过整个训练集计算均值、方差去做批归一化，training=True 时，通过当前 batch 的均值、方差去做批归一化。推理时 training=False 效果好        return xclass InceptionBlk(Model):    def __init__(self, ch, strides=1):        super(InceptionBlk, self).__init__()        self.ch = ch        self.strides = strides        self.c1 = ConvBNRelu(ch, kernelsz=1, strides=strides)        self.c2_1 = ConvBNRelu(ch, kernelsz=1, strides=strides)        self.c2_2 = ConvBNRelu(ch, kernelsz=3, strides=1)        self.c3_1 = ConvBNRelu(ch, kernelsz=1, strides=strides)        self.c3_2 = ConvBNRelu(ch, kernelsz=5, strides=1)        self.p4_1 = MaxPool2D(3, strides=1, padding=&#39;same&#39;)        self.c4_2 = ConvBNRelu(ch, kernelsz=1, strides=strides)    def call(self, x):        x1 = self.c1(x)        x2_1 = self.c2_1(x)        x2_2 = self.c2_2(x2_1)        x3_1 = self.c3_1(x)        x3_2 = self.c3_2(x3_1)        x4_1 = self.p4_1(x)        x4_2 = self.c4_2(x4_1)        # concat along axis=channel        x = tf.concat([x1, x2_2, x3_2, x4_2], axis=3)        return xclass Inception10(Model):    def __init__(self, num_blocks, num_classes, init_ch=16, **kwargs):        super(Inception10, self).__init__(**kwargs)        self.in_channels = init_ch        self.out_channels = init_ch        self.num_blocks = num_blocks        self.init_ch = init_ch        self.c1 = ConvBNRelu(init_ch)        self.blocks = tf.keras.models.Sequential()        for block_id in range(num_blocks):            for layer_id in range(2):                if layer_id == 0:                    block = InceptionBlk(self.out_channels, strides=2)                else:                    block = InceptionBlk(self.out_channels, strides=1)                self.blocks.add(block)            # enlarger out_channels per block            self.out_channels *= 2        self.p1 = GlobalAveragePooling2D()        self.f1 = Dense(num_classes, activation=&#39;softmax&#39;)    def call(self, x):        x = self.c1(x)        x = self.blocks(x)        x = self.p1(x)        y = self.f1(x)        return ymodel = Inception10(num_blocks=2, num_classes=10)model.compile(optimizer=&#39;adam&#39;,    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),    metrics=[&#39;sparse_categorical_accuracy&#39;])checkpoint_save_path = &quot;./checkpoint/Inception10.ckpt&quot;if os.path.exists(checkpoint_save_path + &#39;.index&#39;):    print(&#39;-------------load the model-----------------&#39;)    model.load_weights(checkpoint_save_path)cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,                                                 save_weights_only=True,                                                 save_best_only=True)history = model.fit(x_train, y_train, batch_size=32,                     epochs=5, validation_data=(x_test, y_test),                    validation_freq=1,                    callbacks=[cp_callback])model.summary()</code></pre><h3 id="5-5-ResNet"><a href="#5-5-ResNet" class="headerlink" title="5.5 ResNet"></a>5.5 ResNet</h3><p>ResNet 诞生于 2015 年，当年 ImageNet 竞赛冠军，Top5 错误率为 3.57%。</p><p><em>Kaiming He, Xiangyu Zhang, Shaoqing Ren. Deep Residual Learning for Image Recognition. InCPVR2016.</em></p><p>单纯叠加网络层数会使神经网络模型退化，以至于后面的特征丢失了前边特征的原本模样。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612162433953.png" style="zoom:80%;" /><p>上述有效缓解了神经网络模型堆叠导致的退化，使得神经网络可以朝着更深层级的方向发展。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612162829214.png" alt=""></p><p>实现代码如下：</p><pre><code class="python">import tensorflow as tfimport osimport numpy as npfrom matplotlib import pyplot as pltfrom tensorflow.keras.layers import Conv2D, BatchNormalization, Activation, MaxPool2D, Dropout, Flatten, Densefrom tensorflow.keras import Modelnp.set_printoptions(threshold=np.inf)cifar10 = tf.keras.datasets.cifar10(x_train, y_train), (x_test, y_test) = cifar10.load_data()x_train, x_test = x_train / 255.0, x_test / 255.0class ResnetBlock(Model):    def __init__(self, filters, strides=1, residual_path=False):        super(ResnetBlock, self).__init__()        self.filters = filters        self.strides = strides        self.residual_path = residual_path        self.c1 = Conv2D(filters, (3, 3), strides=strides,                          padding=&#39;same&#39;, use_bias=False)        self.b1 = BatchNormalization()        self.a1 = Activation(&#39;relu&#39;)        self.c2 = Conv2D(filters, (3, 3), strides=1,                          padding=&#39;same&#39;, use_bias=False)        self.b2 = BatchNormalization()        # residual_path 为 True 时，对输入进行下采样，即用 1x1 的卷积核做卷积操作，保证 x 能和 F(x)维度相同，顺利相加        if residual_path:            self.down_c1 = Conv2D(filters, (1, 1), strides=strides,                                   padding=&#39;same&#39;, use_bias=False)            self.down_b1 = BatchNormalization()        self.a2 = Activation(&#39;relu&#39;)    def call(self, inputs):        residual = inputs  # residual 等于输入值本身，即 residual=x        # 将输入通过卷积、BN 层、激活层，计算 F(x)        x = self.c1(inputs)        x = self.b1(x)        x = self.a1(x)        x = self.c2(x)        y = self.b2(x)        if self.residual_path:            residual = self.down_c1(inputs)            residual = self.down_b1(residual)        out = self.a2(y + residual)  # 最后输出的是两部分的和，即 F(x)+x 或 F(x)+Wx, 再过激活函数        return outclass ResNet18(Model):    def __init__(self, block_list, initial_filters=64):  # block_list 表示每个 block 有几个卷积层        super(ResNet18, self).__init__()        self.num_blocks = len(block_list)  # 共有几个 block        self.block_list = block_list        self.out_filters = initial_filters        self.c1 = Conv2D(self.out_filters, (3, 3), strides=1,                          padding=&#39;same&#39;, use_bias=False)        self.b1 = BatchNormalization()        self.a1 = Activation(&#39;relu&#39;)        self.blocks = tf.keras.models.Sequential()        # 构建 ResNet 网络结构        for block_id in range(len(block_list)):  # 第几个 resnet block            for layer_id in range(block_list[block_id]):  # 第几个卷积层                if block_id != 0 and layer_id == 0:  # 对除第一个 block 以外的每个 block 的输入进行下采样                    block = ResnetBlock(self.out_filters, strides=2,                                         residual_path=True)                else:                    block = ResnetBlock(self.out_filters, residual_path=False)                self.blocks.add(block)  # 将构建好的 block 加入 resnet            self.out_filters *= 2  # 下一个 block 的卷积核数是上一个 block 的 2 倍        self.p1 = tf.keras.layers.GlobalAveragePooling2D()        self.f1 = tf.keras.layers.Dense(10, activation=&#39;softmax&#39;,                        kernel_regularizer=tf.keras.regularizers.l2())    def call(self, inputs):        x = self.c1(inputs)        x = self.b1(x)        x = self.a1(x)        x = self.blocks(x)        x = self.p1(x)        y = self.f1(x)        return ymodel = ResNet18([2, 2, 2, 2])model.compile(optimizer=&#39;adam&#39;,              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),              metrics=[&#39;sparse_categorical_accuracy&#39;])checkpoint_save_path = &quot;./checkpoint/ResNet18.ckpt&quot;if os.path.exists(checkpoint_save_path + &#39;.index&#39;):    print(&#39;-------------load the model-----------------&#39;)    model.load_weights(checkpoint_save_path)cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,                                                 save_weights_only=True,                                                 save_best_only=True)history = model.fit(x_train, y_train, batch_size=32, epochs=5,                     validation_data=(x_test, y_test), validation_freq=1,                    callbacks=[cp_callback])model.summary()</code></pre><h3 id="5-6- 小结"><a href="#5-6- 小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612163538135.png" alt=""></p><h2 id="6- 循环神经网络 RNN"><a href="#6- 循环神经网络 RNN" class="headerlink" title="6. 循环神经网络 RNN"></a>6. 循环神经网络 RNN</h2><p>实现连续数据的预测，根据上文，预测下文：如输入 abc，系统可以预测下一步是 d；如输入鱼离不开__，系统能预测空格应该填入水。</p><h3 id="6-1- 循环核"><a href="#6-1- 循环核" class="headerlink" title="6.1 循环核"></a>6.1 循环核 </h3><p> 循环核：参数时间共享，循环层提取时间信息。</p><p>循环核具有记忆力，通过不同时刻的参数共享，实现了对时间序列的信息提取。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200612201312920.png" alt=""></p><p>前向传播时，记忆体内存储的状态信息 h<del>t</del>，在每个时刻都被刷新，三个参数矩阵 w<del>xh</del>，w<del>hh</del>，w<del>hy</del>自始至终都是固定不变的。</p><p>反向传播时，三个参数矩阵 w<del>xh</del>，w<del>hh</del>，w<del>hy</del>被梯度下降法更新。</p><p>y<del>t</del>=softmax(h<del>t</del>w<del>hy</del>+by)</p><p>h<del>t</del>=tanh(x<del>t</del>w<del>xh</del>+h<del>t-1</del>w<del>hh</del>+bh)</p><p>循环神经网络：借助循环核提取时间特征后，送入全连接网络。</p><h3 id="6-2-TF 描述循环记忆层"><a href="#6-2-TF 描述循环记忆层" class="headerlink" title="6.2 TF 描述循环记忆层"></a>6.2 TF 描述循环记忆层</h3><pre><code class="python">tf.keras.layers.SimpleRNN(记忆体个数，activation=&#39; 激活函数 &#39;，                         return_sequences= 是否每个时刻输出 ht 到下一层)</code></pre><p>activation=’激活函数’，默认使用 tanh。</p><p> return_sequences=True，各时间步输出 ht</p><p>return_sequences=False，仅最后时间步输出 ht（默认）</p><p>入 RNN 时，x_train 维度：</p><p>[送入样本数，循环核时间展开步数，每个时间步输入特征个数]</p><p>如下图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200615132851909.png" alt=""></p><p>若输入 4 个字母出结果，循环核时间展开步数为 4。</p><h3 id="6-3- 应用"><a href="#6-3- 应用" class="headerlink" title="6.3 应用"></a>6.3 应用</h3><h4 id="6-3-1 依次预"><a href="#6-3-1 依次预" class="headerlink" title="6.3.1 依次预"></a><strong>6.3.1 依次预</strong></h4><pre><code class="python">import numpy as npimport tensorflow as tffrom tensorflow.keras.layers import Dense, SimpleRNNimport matplotlib.pyplot as pltimport osinput_word = &quot;abcde&quot;w_to_id = &#123;&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 2, &#39;d&#39;: 3, &#39;e&#39;: 4&#125;  # 单词映射到数值 id 的词典id_to_onehot = &#123;0: [1., 0., 0., 0., 0.], 1: [0., 1., 0., 0., 0.], 2: [0., 0., 1., 0., 0.], 3: [0., 0., 0., 1., 0.],                4: [0., 0., 0., 0., 1.]&#125;  # id 编码为 one-hotx_train = [id_to_onehot[w_to_id[&#39;a&#39;]], id_to_onehot[w_to_id[&#39;b&#39;]], id_to_onehot[w_to_id[&#39;c&#39;]],           id_to_onehot[w_to_id[&#39;d&#39;]], id_to_onehot[w_to_id[&#39;e&#39;]]]y_train = [w_to_id[&#39;b&#39;], w_to_id[&#39;c&#39;], w_to_id[&#39;d&#39;], w_to_id[&#39;e&#39;], w_to_id[&#39;a&#39;]]np.random.seed(7)np.random.shuffle(x_train)np.random.seed(7)np.random.shuffle(y_train)tf.random.set_seed(7)# 使 x_train 符合 SimpleRNN 输入要求：[送入样本数， 循环核时间展开步数， 每个时间步输入特征个数]。# 此处整个数据集送入，送入样本数为 len(x_train)；输入 1 个字母出结果，循环核时间展开步数为 1; 表示为独热码有 5 个输入特征，每个时间步输入特征个数为 5x_train = np.reshape(x_train, (len(x_train), 1, 5))y_train = np.array(y_train)model = tf.keras.Sequential([SimpleRNN(3),    Dense(5, activation=&#39;softmax&#39;)])#以下省略</code></pre><h4 id="6-3-2- 连续预测"><a href="#6-3-2- 连续预测" class="headerlink" title="6.3.2 连续预测"></a>6.3.2 连续预测</h4><pre><code class="python">import numpy as npimport tensorflow as tffrom tensorflow.keras.layers import Dense, SimpleRNNimport matplotlib.pyplot as pltimport osinput_word = &quot;abcde&quot;w_to_id = &#123;&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 2, &#39;d&#39;: 3, &#39;e&#39;: 4&#125;  # 单词映射到数值 id 的词典id_to_onehot = &#123;0: [1., 0., 0., 0., 0.], 1: [0., 1., 0., 0., 0.],                 2: [0., 0., 1., 0., 0.], 3: [0., 0., 0., 1., 0.],                4: [0., 0., 0., 0., 1.]&#125;  # id 编码为 one-hotx_train = [[id_to_onehot[w_to_id[&#39;a&#39;]], id_to_onehot[w_to_id[&#39;b&#39;]], id_to_onehot[w_to_id[&#39;c&#39;]], id_to_onehot[w_to_id[&#39;d&#39;]]],    [id_to_onehot[w_to_id[&#39;b&#39;]], id_to_onehot[w_to_id[&#39;c&#39;]], id_to_onehot[w_to_id[&#39;d&#39;]], id_to_onehot[w_to_id[&#39;e&#39;]]],    [id_to_onehot[w_to_id[&#39;c&#39;]], id_to_onehot[w_to_id[&#39;d&#39;]], id_to_onehot[w_to_id[&#39;e&#39;]], id_to_onehot[w_to_id[&#39;a&#39;]]],    [id_to_onehot[w_to_id[&#39;d&#39;]], id_to_onehot[w_to_id[&#39;e&#39;]], id_to_onehot[w_to_id[&#39;a&#39;]], id_to_onehot[w_to_id[&#39;b&#39;]]],    [id_to_onehot[w_to_id[&#39;e&#39;]], id_to_onehot[w_to_id[&#39;a&#39;]], id_to_onehot[w_to_id[&#39;b&#39;]], id_to_onehot[w_to_id[&#39;c&#39;]]],]y_train = [w_to_id[&#39;e&#39;], w_to_id[&#39;a&#39;], w_to_id[&#39;b&#39;], w_to_id[&#39;c&#39;], w_to_id[&#39;d&#39;]]np.random.seed(7)np.random.shuffle(x_train)np.random.seed(7)np.random.shuffle(y_train)tf.random.set_seed(7)# 使 x_train 符合 SimpleRNN 输入要求：[送入样本数， 循环核时间展开步数， 每个时间步输入特征个数]。# 此处整个数据集送入，送入样本数为 len(x_train)；输入 4 个字母出结果，循环核时间展开步数为 4; 表示为独热码有 5 个输入特征，每个时间步输入特征个数为 5x_train = np.reshape(x_train, (len(x_train), 4, 5))y_train = np.array(y_train)model = tf.keras.Sequential([SimpleRNN(3),    Dense(5, activation=&#39;softmax&#39;)])#以下省略</code></pre><h3 id="6-4- 编码"><a href="#6-4- 编码" class="headerlink" title="6.4 编码"></a>6.4 编码 </h3><p> 独热码：数据量大，过于稀松，映射之间是独立的，没有表现出关联性。</p><p>Embedding：是一种单词编码方法，用低维向量实现了编码，这种编码通过神经网络训练优化，能表达出单词之间的相关性。</p><pre><code>tf.keras.layers.Embedding(词汇表大小，编码维度)#编码维度就是用几个数字表达一个单词 </code></pre><p> 入 Embedding 时，x_train 维度：[送入样本数，循环核时间展开步数]</p><p>6.3.1 的例子如下：</p><pre><code class="python">import numpy as npimport tensorflow as tffrom tensorflow.keras.layers import Dense, SimpleRNN, Embeddingimport matplotlib.pyplot as pltimport osinput_word = &quot;abcde&quot;w_to_id = &#123;&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 2, &#39;d&#39;: 3, &#39;e&#39;: 4&#125;  # 单词映射到数值 id 的词典x_train = [w_to_id[&#39;a&#39;], w_to_id[&#39;b&#39;], w_to_id[&#39;c&#39;], w_to_id[&#39;d&#39;], w_to_id[&#39;e&#39;]]y_train = [w_to_id[&#39;b&#39;], w_to_id[&#39;c&#39;], w_to_id[&#39;d&#39;], w_to_id[&#39;e&#39;], w_to_id[&#39;a&#39;]]np.random.seed(7)np.random.shuffle(x_train)np.random.seed(7)np.random.shuffle(y_train)tf.random.set_seed(7)# 使 x_train 符合 Embedding 输入要求：[送入样本数， 循环核时间展开步数] ，# 此处整个数据集送入所以送入，送入样本数为 len(x_train)；输入 1 个字母出结果，循环核时间展开步数为 1。x_train = np.reshape(x_train, (len(x_train), 1))y_train = np.array(y_train)model = tf.keras.Sequential([Embedding(5, 2),    SimpleRNN(3),    Dense(5, activation=&#39;softmax&#39;)])model.compile(optimizer=tf.keras.optimizers.Adam(0.01),              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),              metrics=[&#39;sparse_categorical_accuracy&#39;])model.fit(x_train, y_train, batch_size=32, epochs=100])</code></pre><p>6.3.2 的例子如下：</p><pre><code class="python">import numpy as npimport tensorflow as tffrom tensorflow.keras.layers import Dense, SimpleRNN, Embeddingimport matplotlib.pyplot as pltimport osinput_word = &quot;abcdefghijklmnopqrstuvwxyz&quot;w_to_id = &#123;&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;c&#39;: 2, &#39;d&#39;: 3, &#39;e&#39;: 4,           &#39;f&#39;: 5, &#39;g&#39;: 6, &#39;h&#39;: 7, &#39;i&#39;: 8, &#39;j&#39;: 9,           &#39;k&#39;: 10, &#39;l&#39;: 11, &#39;m&#39;: 12, &#39;n&#39;: 13, &#39;o&#39;: 14,           &#39;p&#39;: 15, &#39;q&#39;: 16, &#39;r&#39;: 17, &#39;s&#39;: 18, &#39;t&#39;: 19,           &#39;u&#39;: 20, &#39;v&#39;: 21, &#39;w&#39;: 22, &#39;x&#39;: 23, &#39;y&#39;: 24, &#39;z&#39;: 25&#125;  # 单词映射到数值 id 的词典training_set_scaled = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,                       11, 12, 13, 14, 15, 16, 17, 18, 19, 20,                       21, 22, 23, 24, 25]x_train = []y_train = []for i in range(4, 26):    x_train.append(training_set_scaled[i - 4:i])    y_train.append(training_set_scaled[i])np.random.seed(7)np.random.shuffle(x_train)np.random.seed(7)np.random.shuffle(y_train)tf.random.set_seed(7)# 使 x_train 符合 Embedding 输入要求：[送入样本数， 循环核时间展开步数] ，# 此处整个数据集送入所以送入，送入样本数为 len(x_train)；输入 4 个字母出结果，循环核时间展开步数为 4。x_train = np.reshape(x_train, (len(x_train), 4))y_train = np.array(y_train)model = tf.keras.Sequential([Embedding(26, 2),    SimpleRNN(10),    Dense(26, activation=&#39;softmax&#39;)])model.compile(optimizer=tf.keras.optimizers.Adam(0.01),              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),              metrics=[&#39;sparse_categorical_accuracy&#39;])model.fit(x_train, y_train, batch_size=32, epochs=100])</code></pre><h2 id="7- 长短记忆网络 LSTM"><a href="#7- 长短记忆网络 LSTM" class="headerlink" title="7. 长短记忆网络 LSTM"></a>7. 长短记忆网络 LSTM</h2><p>传统的 RNN 可以通过记忆体实现短期记忆实现连续数据的预测，但是当连续的数据序列变长时，会使展开时间步变长，在反向传播更新参数时，梯度按照时间步连续相乘，会导致梯度消失，所以 1997 年由 Hochreiter 和 Schmidhuber 等人提出了长短记忆网络<strong>LSTM</strong>。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200615152345713.png" alt=""></p><p><strong>TF 描述 LSTM 层：</strong></p><pre><code class="python">tf.keras.layers.LSTM(记忆体个数，return_sequences= 是否返回输出)#示例model=tf.keras.Sequential([LSTM(80,return_sequences=True),    Dropout(0.2),    LSTM(100),    Dropout(0.2),    Dense(1)])</code></pre><p>LSTM 实现股票预测代码：</p><pre><code class="python">import numpy as npimport tensorflow as tffrom tensorflow.keras.layers import Dropout, Dense, LSTMimport matplotlib.pyplot as pltimport osimport pandas as pdfrom sklearn.preprocessing import MinMaxScalerfrom sklearn.metrics import mean_squared_error, mean_absolute_errorimport mathmaotai = pd.read_csv(&#39;./SH600519.csv&#39;)  # 读取股票文件training_set = maotai.iloc[0:2426 - 300, 2:3].values  # 前 (2426-300=2126) 天的开盘价作为训练集, 表格从 0 开始计数，2:3 是提取 [2:3) 列，前闭后开, 故提取出 C 列开盘价test_set = maotai.iloc[2426 - 300:, 2:3].values  # 后 300 天的开盘价作为测试集# 归一化sc = MinMaxScaler(feature_range=(0, 1))  # 定义归一化：归一化到 (0，1) 之间training_set_scaled = sc.fit_transform(training_set)  # 求得训练集的最大值，最小值这些训练集固有的属性，并在训练集上进行归一化test_set = sc.transform(test_set)  # 利用训练集的属性对测试集进行归一化x_train = []y_train = []x_test = []y_test = []# 测试集：csv 表格中前 2426-300=2126 天数据# 利用 for 循环，遍历整个训练集，提取训练集中连续 60 天的开盘价作为输入特征 x_train，第 61 天的数据作为标签，for 循环共构建 2426-300-60=2066 组数据。for i in range(60, len(training_set_scaled)):    x_train.append(training_set_scaled[i - 60:i, 0])    y_train.append(training_set_scaled[i, 0])# 对训练集进行打乱np.random.seed(7)np.random.shuffle(x_train)np.random.seed(7)np.random.shuffle(y_train)tf.random.set_seed(7)# 将训练集由 list 格式变为 array 格式x_train, y_train = np.array(x_train), np.array(y_train)# 使 x_train 符合 RNN 输入要求：[送入样本数， 循环核时间展开步数， 每个时间步输入特征个数]。# 此处整个数据集送入，送入样本数为 x_train.shape[0]即 2066 组数据；输入 60 个开盘价，预测出第 61 天的开盘价，循环核时间展开步数为 60; 每个时间步送入的特征是某一天的开盘价，只有 1 个数据，故每个时间步输入特征个数为 1x_train = np.reshape(x_train, (x_train.shape[0], 60, 1))# 测试集：csv 表格中后 300 天数据# 利用 for 循环，遍历整个测试集，提取测试集中连续 60 天的开盘价作为输入特征 x_train，第 61 天的数据作为标签，for 循环共构建 300-60=240 组数据。for i in range(60, len(test_set)):    x_test.append(test_set[i - 60:i, 0])    y_test.append(test_set[i, 0])# 测试集变 array 并 reshape 为符合 RNN 输入要求：[送入样本数， 循环核时间展开步数， 每个时间步输入特征个数]x_test, y_test = np.array(x_test), np.array(y_test)x_test = np.reshape(x_test, (x_test.shape[0], 60, 1))model = tf.keras.Sequential([LSTM(80, return_sequences=True),    Dropout(0.2),    LSTM(100),    Dropout(0.2),    Dense(1)])model.compile(optimizer=tf.keras.optimizers.Adam(0.001),              loss=&#39;mean_squared_error&#39;)  # 损失函数用均方误差# 该应用只观测 loss 数值，不观测准确率，所以删去 metrics 选项，一会在每个 epoch 迭代显示时只显示 loss 值checkpoint_save_path = &quot;./checkpoint/LSTM_stock.ckpt&quot;if os.path.exists(checkpoint_save_path + &#39;.index&#39;):    print(&#39;-------------load the model-----------------&#39;)    model.load_weights(checkpoint_save_path)cp_callback = tf.keras.callbacks.ModelCheckpoint(filepath=checkpoint_save_path,                                                 save_weights_only=True,                                                 save_best_only=True,                                                 monitor=&#39;val_loss&#39;)history = model.fit(x_train, y_train, batch_size=64, epochs=50, validation_data=(x_test, y_test), validation_freq=1,                    callbacks=[cp_callback])model.summary()file = open(&#39;./weights.txt&#39;, &#39;w&#39;)  # 参数提取for v in model.trainable_variables:    file.write(str(v.name) + &#39;\n&#39;)    file.write(str(v.shape) + &#39;\n&#39;)    file.write(str(v.numpy()) + &#39;\n&#39;)file.close()loss = history.history[&#39;loss&#39;]val_loss = history.history[&#39;val_loss&#39;]plt.plot(loss, label=&#39;Training Loss&#39;)plt.plot(val_loss, label=&#39;Validation Loss&#39;)plt.title(&#39;Training and Validation Loss&#39;)plt.legend()plt.show()################## predict ####################### 测试集输入模型进行预测predicted_stock_price = model.predict(x_test)# 对预测数据还原 --- 从（0，1）反归一化到原始范围predicted_stock_price = sc.inverse_transform(predicted_stock_price)# 对真实数据还原 --- 从（0，1）反归一化到原始范围real_stock_price = sc.inverse_transform(test_set[60:])# 画出真实数据和预测数据的对比曲线plt.plot(real_stock_price, color=&#39;red&#39;, label=&#39;MaoTai Stock Price&#39;)plt.plot(predicted_stock_price, color=&#39;blue&#39;, label=&#39;Predicted MaoTai Stock Price&#39;)plt.title(&#39;MaoTai Stock Price Prediction&#39;)plt.xlabel(&#39;Time&#39;)plt.ylabel(&#39;MaoTai Stock Price&#39;)plt.legend()plt.show()##########evaluate############### calculate MSE 均方误差 ---&gt; E[(预测值 - 真实值)^2] (预测值减真实值求平方后求均值)mse = mean_squared_error(predicted_stock_price, real_stock_price)# calculate RMSE 均方根误差 ---&gt;sqrt[MSE]    (对均方误差开方)rmse = math.sqrt(mean_squared_error(predicted_stock_price, real_stock_price))# calculate MAE 平均绝对误差 -----&gt;E[| 预测值 - 真实值 |](预测值减真实值求绝对值后求均值）mae = mean_absolute_error(predicted_stock_price, real_stock_price)print(&#39; 均方误差: %.6f&#39; % mse)print(&#39; 均方根误差: %.6f&#39; % rmse)print(&#39; 平均绝对误差: %.6f&#39; % mae)</code></pre><h2 id="8-GRU 网络"><a href="#8-GRU 网络" class="headerlink" title="8. GRU 网络"></a>8. GRU 网络</h2><p>2014 年 cho 等人简化了 LSTM 网络结构，提出了 GRU 网络。</p><p>GRU 使记忆体 ht 融合了长期记忆个短期记忆。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200615154320364.png" alt=""></p><p><strong>TF 描述 GRU 层：</strong></p><pre><code class="python">tf.keras.layers.GRU(记忆体个数，return_sequences= 是否返回输出)#示例model=tf.keras.Sequential([GRU(80,return_sequences=True),    Dropout(0.2),    GRU(100),    Dropout(0.2),    Dense(1)])</code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度理解卷积神经网络工作原理</title>
      <link href="/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="# 一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Dishashree Gupta 在 Analyticsvidhya 上发表了一篇题为《Architecture of Convolutional Neural Networks (CNNs) demystified》的文章，对用于图像识别和分类的卷积神经网络架构作了深度揭秘；作者在文中还作了通盘演示，期望对 CNN 的工作机制有一个深入的剖析。</p><p>这篇文章真是的深入浅出对卷积神经网络进行了剖析。一定要彻底阅读学习！</p><p>知乎作者“机器之心”对此进行了编译及补充，对此表示感谢。</p><blockquote><p>[机器视角：长文揭秘图像处理和卷积神经网络架构]</p></blockquote><h1 id="二、正文"><a href="# 二、正文" class="headerlink" title="二、正文"></a>二、正文 </h1><h2 id="2-1- 引言"><a href="#2-1- 引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h2><p> 先坦白地说，有一段时间我无法真正理解深度学习。我查看相关研究论文和文章，感觉深度学习异常复杂。我尝试去理解神经网络及其变体，但依然感到困难。</p><p>接着有一天，我决定一步一步，从基础开始。我把技术操作的步骤分解开来，并手动执行这些步骤（和计算），直到我理解它们如何工作。这相当费时，且令人紧张，但是结果非凡。</p><p>现在，我不仅对深度学习有了全面的理解，还在此基础上有了好想法，因为我的基础很扎实。随意地应用神经网络是一回事，理解它是什么以及背后的发生机制是另外一回事。</p><p>今天，我将与你共享我的心得，展示我如何上手卷积神经网络并最终弄明白了它。我将做一个通盘的展示，从而使你对 CNN 的工作机制有一个深入的了解。</p><p>在本文中，我将会讨论 CNN 背后的架构，其设计初衷在于解决图像识别和分类问题。同时我也会假设你对神经网络已经有了初步了解。</p><h2 id="2-2- 机器如何看图"><a href="#2-2- 机器如何看图" class="headerlink" title="2.2 机器如何看图"></a>2.2 机器如何看图 </h2><p> 人类大脑是一非常强大的机器，每秒内能看（捕捉）多张图，并在意识不到的情况下就完成了对这些图的处理。但机器并非如此。机器处理图像的第一步是理解，理解如何表达一张图像，进而读取图片。</p><p>简单来说，每个图像都是一系列特定排序的图点（像素）。如果你改变像素的顺序或颜色，图像也随之改变。举个例子，存储并读取一张上面写着数字 4 的图像。</p><p>基本上，机器会把图像打碎成像素矩阵，存储每个表示位置像素的颜色码。在下图的表示中，数值 1 是白色，256 是最深的绿色（为了简化，我们示例限制到了一种颜色）。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-ce7584843d74f0c90b60b5439250635a_720w.jpg" style="zoom:67%;" /><p>一旦你以这种格式存储完图像信息，下一步就是让神经网络理解这种排序与模式。</p><h2 id="2-3- 如何帮助神经网络识别图像"><a href="#2-3- 如何帮助神经网络识别图像" class="headerlink" title="2.3  如何帮助神经网络识别图像"></a>2.3  如何帮助神经网络识别图像 </h2><p> 表征像素的数值是以特定的方式排序的。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-d6e748862f4f995047b53a87009b3fb5_720w.jpg" style="zoom: 50%;" /><p>假设我们尝试使用全连接网络识别图像，该如何做？<br>全连接网络可以通过平化它，把图像当作一个数组，并把像素值当作预测图像中数值的特征。明确地说，让网络理解理解下面图中发生了什么，非常的艰难。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-25be163b4687fa9f6bf174bc95613a21_720w.jpg" alt=""></p><p>即使人类也很难理解上图中表达的含义是数字 4。我们完全丢失了像素的空间排列。我们能做什么呢？可以尝试从原图像中提取特征，从而保留空间排列。</p><h3 id="案例 1"><a href="# 案例 1" class="headerlink" title="案例 1"></a>案例 1</h3><p>这里我们使用一个权重乘以初始像素值。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-97541d570892f2b8580758655b2b737c_r.jpg" alt=""></p><p>现在裸眼识别出这是「4」就变得更简单了。但把它交给全连接网络之前，还需要平整化（flatten) 它，要让我们能够保留图像的空间排列。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-ecb23f7cce51ed444ceefa1d35bd4240_720w.jpg" alt=""></p><h3 id="案例 2"><a href="# 案例 2" class="headerlink" title="案例 2"></a>案例 2</h3><p>现在我们可以看到，把图像平整化完全破坏了它的排列。我们需要想出一种方式在没有平整化的情况下把图片馈送给网络，并且还要保留空间排列特征，也就是需要馈送像素值的 2D/3D 排列。</p><p>我们可以尝试一次采用图像的两个像素值，而非一个。这能给网络很好的洞见，观察邻近像素的特征。既然一次采用两个像素，那也就需要一次采用两个权重值了。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-5a8235754cd0ae57f475683ed6cba2b5_hd.webp" alt=""></p><p>希望你能注意到图像从之前的 4 列数值变成了 3 列。因为我们现在一次移用两个像素（在每次移动中像素被共享），图像变的更小了。虽然图像变小了，我们仍能在很大程度上理解这是「4」。而且，要意识到的一个重点是，我们采用的是两个连贯的水平像素，因此只会考虑水平的排列。</p><p>这是我们从图像中提取特征的一种方式。我们可以看到左边和中间部分，但右边部分看起来不那么清楚。主要是因为两个问题：</p><ol><li><p>图片角落左边和右边是权重相乘一次得到的。</p></li><li><p>左边仍旧保留，因为权重值高；右边因为略低的权重，有些丢失。</p></li></ol><p>现在我们有两个问题，需要两个解决方案。</p><h3 id="案例 3"><a href="# 案例 3" class="headerlink" title="案例 3"></a>案例 3</h3><p>遇到的问题是图像左右两角只被权重通过一次。我们需要做的是让网络像考虑其他像素一样考虑角落。我们有一个简单的方法解决这一问题：把零放在权重运动的两边。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-0014d5f30b87ae12947cffa0f429d5f1_hd.webp" alt=""></p><p>你可以看到通过添加零，来自角落的信息被再训练。图像也变得更大。这可被用于我们不想要缩小图像的情况下。</p><h3 id="案例 4"><a href="# 案例 4" class="headerlink" title="案例 4"></a>案例 4</h3><p>这里我们试图解决的问题是右侧角落更小的权重值正在降低像素值，因此使其难以被我们识别。我们所能做的是采取多个权重值并将其结合起来。</p><p>(1, 0.3) 的权重值给了我们一个输出表格</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-ca6e6b4afb696bccdcb67687a04c44da_720w.jpg" alt=""></p><p>同时表格 (0.1, 5) 的权重值也将给我们一个输出表格。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-cf8ff64d38ce55d2c1d1513b08e079e2_720w.jpg" alt=""></p><p>两张图像的结合版本将会给我们一个清晰的图片。因此，我们所做的是简单地使用多个权重而不是一个，从而再训练图像的更多信息。最终结果将是上述两张图像的一个结合版本。</p><h3 id="案例 5"><a href="# 案例 5" class="headerlink" title="案例 5"></a>案例 5</h3><p>我们到现在通过使用权重，试图把水平像素（horizontal pixel）结合起来。但是大多数情况下我们需要在水平和垂直方向上保持空间布局。我们采取 2D 矩阵权重，把像素在水平和垂直方向上结合起来。同样，记住已经有了水平和垂直方向的权重运动，输出会在水平和垂直方向上低一个像素。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-f1206f480077d6064e2a445ebef4ea66_hd.webp" alt=""></p><p>上面我们所做的事是试图通过使用图像的空间的安排从图像中提取特征。为了理解图像，理解像素如何安排对于一个网络极其重要。上面我们所做的也恰恰是一个卷积网络所做的。我们可以采用输入图像，定义权重矩阵，并且输入被卷积以从图像中提取特殊特征而无需损失其有关空间安排的信息。</p><p>这个方法的另一个重大好处是它可以减少图像的参数数量。正如所见，卷积图像相比于原始图像有更少的像素。</p><h2 id="2-4- 定义一个卷积神经网络"><a href="#2-4- 定义一个卷积神经网络" class="headerlink" title="2.4 定义一个卷积神经网络"></a>2.4 定义一个卷积神经网络 </h2><p> 我们需要三个基本的元素来定义一个基本的卷积网络：</p><ol><li>卷积层</li><li>池化层（可选）</li><li>输出层</li></ol><h3 id="卷积层"><a href="# 卷积层" class="headerlink" title="卷积层"></a>卷积层 </h3><p> 在这一层中，实际所发生的就像我们在上述案例 5 中见到的一样。假设我们有一个 6*6 的图像。我们定义一个权值矩阵，用来从图像中提取一定的特征。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-1e95f13c1f0d650e826e813c0e1f493a_720w.jpg" alt=""></p><p>我们把权值初始化成一个 3×3 的矩阵。这个权值现在应该与图像结合，所有的像素都被覆盖至少一次，从而来产生一个卷积化的输出。上述的 429，是通过计算权值矩阵和输入图像的 3×3 高亮部分以元素方式进行的乘积的值而得到的。</p><p> <img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-f9dab2820dc8a941e62c1e5c63e418f1_hd.webp" alt=""></p><p>现在 6×6 的图像转换成了 4×4 的图像。想象一下权值矩阵就像用来刷墙的刷子。首先在水平方向上用这个刷子进行刷墙，然后再向下移，对下一行进行水平粉刷。当权值矩阵沿着图像移动的时候，像素值再一次被使用。实际上，这样可以使参数在卷积神经网络中被共享。</p><p>下面我们以一个真实图像为例。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-56acff7742146f37317e4c36aba47234_r.jpg" alt=""></p><p>权值矩阵在图像里表现的像一个从原始图像矩阵中提取特定信息的过滤器。一个权值组合可能用来提取边缘（edge）信息，另一个可能是用来提取一个特定颜色，下一个就可能就是对不需要的噪点进行模糊化。</p><p>先对权值进行学习，然后损失函数可以被最小化，类似于多层感知机（MLP）。因此需要通过对参数进行学习来从原始图像中提取信息，从而来帮助网络进行正确的预测。当我们有多个卷积层的时候，初始层往往提取较多的一般特征，随着网络结构变得更深，权值矩阵提取的特征越来越复杂，并且越来越适用于眼前的问题。</p><h3 id="步长（stride）和边界（padding）的概念"><a href="# 步长（stride）和边界（padding）的概念" class="headerlink" title="步长（stride）和边界（padding）的概念"></a>步长（stride）和边界（padding）的概念 </h3><p> 像我们在上面看到的一样，过滤器或者说权值矩阵，在整个图像范围内一次移动一个像素。我们可以把它定义成一个超参数（hyperparameter），从而来表示我们想让权值矩阵在图像内如何移动。如果权值矩阵一次移动一个像素，我们称其步长为 1。下面我们看一下步长为 2 时的情况。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-2d5ce7b1af041dab1b4019cc2776b71b_hd.webp" alt=""></p><p>你可以看见当我们增加步长值的时候，图像的规格持续变小。</p><p>在输入图像四周填充 0 边界可以解决这个问题。我们也可以在高步长值的情况下在图像四周填加不只一层的 0 边界。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200604141426854.png" alt=""></p><p>我们可以看见在我们给图像填加一层 0 边界后，图像的原始形状是如何被保持的。由于输出图像和输入图像是大小相同的，所以这被称为 same padding。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-19f50c58341de1d5c4700972a718b8e1_hd.webp" alt=""></p><p>这就是 same padding（意味着我们仅考虑输入图像的有效像素）。中间的 4*4 像素是相同的。这里我们已经利用边界保留了更多信息，并且也已经保留了图像的原大小。</p><h3 id="多过滤与激活图"><a href="# 多过滤与激活图" class="headerlink" title="多过滤与激活图"></a>多过滤与激活图 </h3><p> 需要记住的是权值的纵深维度（depth dimension）和输入图像的纵深维度是相同的。权值会延伸到输入图像的整个深度。因此，和一个单一权值矩阵进行卷积会产生一个单一纵深维度的卷积化输出。大多数情况下都不使用单一过滤器（权值矩阵），而是应用维度相同的多个过滤器。</p><p>每一个过滤器的输出被堆叠在一起，形成卷积图像的纵深维度。假设我们有一个 32×32×3 的输入（如 32×32 像素的 GRB 三通道图片）。我们使用 5×5×3，带有 valid padding 的 10 个过滤器。输出的维度将会是 28×28×10。</p><p>如下图所示：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-defbc123f52a27bddd902761243121f8_720w.jpg" alt=""></p><p>激活图是卷积层的输出。</p><h3 id="池化层"><a href="# 池化层" class="headerlink" title="池化层"></a>池化层 </h3><p> 有时图像太大，我们需要减少训练参数的数量，它被要求在随后的卷积层之间周期性地引进池化层。池化的唯一目的是减少图像的空间大小。池化在每一个纵深维度上独自完成，因此图像的纵深保持不变。池化层的最常见形式是最大池化。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-cae74f34159e48d581156d80e8e12ec6_720w.jpg" alt=""></p><p>即取每个集合的最大值：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200604144214194.png" alt=""></p><p>还有均值池化，取每个集合的平均值。</p><p>在这里，我们把步幅定为 2，池化尺寸也为 2。最大化执行也应用在每个卷机输出的深度尺寸中。正如你所看到的，最大池化操作后，4×4 卷积的输出变成了 2×2。</p><p>让我们看看最大池化在真实图片中的效果如何。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/v2-e62be992ba35c0f79a2f54191da1defb_720w.jpg" alt=""></p><p>正如你看到的，我们卷积了图像，并最大池化了它。最大池化图像仍然保留了汽车在街上的信息。如果你仔细观察的话，你会发现图像的尺寸已经减半。这可以很大程度上减少参数。</p><h3 id="输出维度"><a href="# 输出维度" class="headerlink" title="输出维度"></a>输出维度 </h3><p> 理解每个卷积层输入和输出的尺寸可能会有点难度。以下三点或许可以让你了解输出尺寸的问题。有三个超参数可以控制输出卷的大小。</p><ol><li><p>过滤器数量 - 输出卷的深度与过滤器的数量成正比。请记住该如何堆叠每个过滤器的输出以形成激活映射。激活图的深度等于过滤器的数量。</p></li><li><p>步幅（Stride）- 如果步幅是 1，那么我们处理图片的精细度就进入单像素级别了。更高的步幅意味着同时处理更多的像素，从而产生较小的输出量。</p></li><li><p>零填充（zero padding）- 这有助于我们保留输入图像的尺寸。如果添加了单零填充，则单步幅过滤器的运动会保持在原图尺寸。</p></li></ol><p>我们可以应用一个简单的公式来计算输出尺寸。输出图像的空间尺寸可以计算为</p><p>（[W-F + 2P] / S）+1。</p><p>在这里，W 是输入尺寸，F 是过滤器的尺寸，P 是填充数量，S 是步幅数字。</p><p>假如我们有一张 32×32×3 的输入图像，我们使用 10 个尺寸为 3×3×3 的过滤器，单步幅和零填充。</p><p>那么 W=32，F=3，P=0，S=1。输出深度等于应用的滤波器的数量，即 10，输出尺寸大小为 ([32-3+0]/1)+1 = 30。因此输出尺寸是 30×30×10。</p><h3 id="输出层"><a href="# 输出层" class="headerlink" title="输出层"></a>输出层 </h3><p> 在多层卷积和填充后，我们需要以类的形式输出。卷积和池化层只会提取特征，并减少原始图像带来的参数。然而，为了生成最终的输出，我们需要应用全连接层来生成一个等于我们需要的类的数量的输出。仅仅依靠卷积层是难以达到这个要求的。卷积层可以生成 3D 激活图，而我们只需要图像是否属于一个特定的类这样的内容。输出层具有类似分类交叉熵的损失函数，用于计算预测误差。一旦前向传播完成，反向传播就会开始更新权重与偏差，以减少误差和损失。</p><h2 id="2-5- 小结"><a href="#2-5- 小结" class="headerlink" title="2.5 小结"></a>2.5 小结 </h2><p> 正如你所看到的，CNN 由不同的卷积层和池化层组成。让我们看看整个网络是什么样子：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/timg.jfif" alt=""></p><ul><li><p>我们将输入图像传递到第一个卷积层中，卷积后以激活图形式输出。图片在卷积层中过滤后的特征会被输出，并传递下去。</p></li><li><p>每个过滤器都会给出不同的特征，以帮助进行正确的类预测。因为我们需要保证图像大小的一致，所以我们使用同样的填充（零填充），否则填充会被使用，因为它可以帮助减少特征的数量。</p></li><li><p>随后加入池化层进一步减少参数的数量。</p></li><li><p>在预测最终提出前，数据会经过多个卷积和池化层的处理。卷积层会帮助提取特征，越深的卷积神经网络会提取越具体的特征，越浅的网络提取越浅显的特征。</p></li><li><p>如前所述，CNN 中的输出层是全连接层，其中来自其他层的输入在这里被平化和发送，以便将输出转换为网络所需的参数。</p></li><li><p>随后输出层会产生输出，这些信息会互相比较排除错误。损失函数是全连接输出层计算的均方根损失。随后我们会计算梯度错误。</p></li><li><p>错误会进行反向传播，以不断改进过滤器（权重）和偏差值。</p></li><li><p>一个训练周期由单次正向和反向传递完成。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫的定时执行</title>
      <link href="/%E7%88%AC%E8%99%AB%E7%9A%84%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C/"/>
      <url>/%E7%88%AC%E8%99%AB%E7%9A%84%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫的定时及自动执行"><a href="# 爬虫的定时及自动执行" class="headerlink" title="爬虫的定时及自动执行"></a>爬虫的定时及自动执行 </h1><p> 这里主要介绍使用 Linux 中自带的「crontab」命令完成定时任务。</p><p>这里常使用的命令是：</p><ul><li><code>crontab -e</code>：进入编辑模式，里面写入定时任务。</li><li><code>crontab -l</code>：进入阅览模式，查看里面的内容。</li></ul><h2 id="定时任务的书写格式"><a href="# 定时任务的书写格式" class="headerlink" title="定时任务的书写格式"></a>定时任务的书写格式</h2><h2 id="1、普通爬虫"><a href="#1、普通爬虫" class="headerlink" title="1、普通爬虫"></a>1、普通爬虫</h2><pre><code class="python"># 爬虫程序 spider.pydef main()：    #爬虫程序体    passif __name__==&#39;__main__&#39;:    main()</code></pre><p>此时，<code>crontab -e</code>进入编辑模式，书写格式为：</p><blockquote><p>[分] [时] [日] [月] [周] 命令 </p></blockquote><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200706180702430.png" style="zoom:80%;" /><p>例如写入：<code>00 21 * * * python3 /home/ubuntu/python_works/spider.py &gt;&gt; /home/ubuntu/python_works/run.log</code></p><p>上面的意思是每天 21 点 00 分使用 python3 命令执行指定路径下的 spider.py 文件，并输出日志到指定文件。</p><h3 id="解释："><a href="# 解释：" class="headerlink" title="解释："></a>解释：</h3><p>（1）上面的 <code>*</code> 是通配符。代表任意值，类似的还有：</p><p>逗号(<code>,</code>)：指定一个列表范围，例如，「00 12,21,00 * * *」代表每 12,21,00 点执行一次。</p><p>中杠(<code>-</code>)：指定整数之间的范围，例如，「00 12-19 * * *」代表 12-19 点之间每隔一小时执行一次。</p><p>斜杠(<code>/</code>)：指定时间的间隔频率，例如，「00 12-22/2 * * *」代表 12-22 点之间每隔 2 小时执行一次。</p><p>（2）<code>&gt;&gt;</code>意思是将 py 文件中 print 输出内容保存在指定文件里，以追加的方式；</p><p><code>&gt;</code>是以覆盖重写入的方式。</p><h2 id="2、框架爬虫"><a href="#2、框架爬虫" class="headerlink" title="2、框架爬虫"></a>2、框架爬虫 </h2><p> 如已写好一个爬虫项目，爬虫主文件路径为 /lagou/lagou/spiders/lg.py。</p><p>在 <code>crontab -e</code> 编辑模式中</p><ol><li><p>先写好时间</p></li><li><p>cd 到爬虫主文件里</p></li><li><p>scrapy 命令所在路径下，执行<code>scrapy crawl lg</code></p></li><li><p>最后可输出日志到指定文件</p></li></ol><p>如：</p><p><code>00 19 * * * cd /home/ubuntu/python_works/lagou/lagou/spiders &amp;&amp; /usr/local/anaconda/bin/scrapy crawl lg &gt;&gt; /home/ubuntu/python_works/lagou/lg_run.log</code></p><p>若不知道 scrapy 命令的路径，可用 which scrapy 查找。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Token ，Cookie 和 Session 的区别</title>
      <link href="/Token-%EF%BC%8CCookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/Token-%EF%BC%8CCookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><strong>Cookie</strong></h2><p>cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。</p><p>cookie 由服务器生成，发送给浏览器，浏览器把 cookie 以 kv 形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该 cookie 发送给服务器。由于 cookie 是存在客户端上的，所以浏览器加入了一些限制确保 cookie 不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的 cookie 数量是有限的。</p><p>cookie 相当于服务器给浏览器的一个临时的编号，这个编号与身份绑定，服务器通过编号再去确定你的身份。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a><strong>Session</strong></h2><p>session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。</p><p>session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。</p><p>服务器使用 session 把用户的信息临时保存在了服务器上，用户离开网站后 session 会被销毁。这种用户信息存储方式相对 cookie 来说更安全，可是 session 有一个缺陷：如果 web 服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候 session 会丢失。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a><strong>Token</strong></h2><p>Token 的引入：Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。</p><p>Token 的定义：Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。最简单的 token 组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由 token 的前几位 + 盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接 token 请求服务器)。</p><p>使用 Token 的目的：Token 的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><p> Token，直接就相当于一个身份证，给 Token 就能确定你的身份。</p><h2 id="传统身份验证"><a href="# 传统身份验证" class="headerlink" title="传统身份验证"></a><strong>传统身份验证</strong></h2><p>HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。</p><p>解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie  ，这样服务端会验证一个这个 Cookie  里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。</p><p>上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。</p><h2 id="基于 -Token- 的身份验证"><a href="# 基于 -Token- 的身份验证" class="headerlink" title="基于 Token 的身份验证"></a><strong>基于 Token 的身份验证 </strong></h2><p> 使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p><ul><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ul><p>APP 登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成 32 位的字符串作为 token，存储到服务器中，并返回 token 到 APP，以后 APP 请求时，凡是需要验证的地方都要带上该 token，然后服务器端验证 token，成功返回所需要的结果，失败返回错误信息，让他重新登录。其中服务器上 token 设置一个有效期，每次 APP 请求的时候都验证 token 和有效期。</p><p>那么我的问题来了： 1. 服务器上的 token 存储到数据库中，每次查询会不会很费时。如果不存储到数据库，应该存储到哪里呢。 2. 客户端得到的 token 肯定要加密存储的，发送 token 的时候再解密。存储到数据库还是配置文件呢？</p><p>token 是个易失数据，丢了无非让用户重新登录一下，新浪微博动不动就让我重新登录，反正这事儿我是无所谓啦。<br> 所以如果你觉得普通的数据库表撑不住了，可以放到 MSSQL/MySQL 的内存表里（不过据说 mysql 的内存表性能提升有限），可以放到  Memcache 里（讲真，这个是挺常见的策略），可以放到 redis 里（我做过这样的实现），甚至可以放到 OpenResty  的变量字典里（只要你有信心不爆内存）。</p><p>token 是个凭条，不过它比门票温柔多了，门票丢了重新花钱买，token 丢了重新操作下认证一个就可以了，因此 token 丢失的代价是可以忍受的——前提是你别丢太频繁，要是让用户隔三差五就认证一次那就损失用户体验了。</p><p>基于这个出发点，如果你认为用数据库来保持 token 查询时间太长，会成为你系统的瓶颈或者隐患，可以放在内存当中。<br> 比如 memcached、redis，KV 方式很适合你对 token 查询的需求。<br> 这个不会太占内存，比如你的 token 是 32 位字符串，要是你的用户量在百万级或者千万级，那才多少内存。<br> 要是数据量真的大到单机内存扛不住，或者觉得一宕机全丢风险大，只要这个 token 生成是足够均匀的，高低位切一下分到不同机器上就行，内存绝对不会是问题。</p><p>客户端方面这个除非你有一个非常安全的办法，比如操作系统提供的隐私数据存储，那 token 肯定会存在泄露的问题。比如我拿到你的手机，把你的 token 拷出来，在过期之前就都可以以你的身份在别的地方登录。<br> 解决这个问题的一个简单办法<br> 1、在存储的时候把 token 进行对称加密存储，用时解开。<br> 2、将请求 URL、时间戳、token 三者进行合并加盐签名，服务端校验有效性。<br> 这两种办法的出发点都是：窃取你存储的数据较为容易，而反汇编你的程序 hack 你的加密解密和签名算法是比较难的。然而其实说难也不难，所以终究是防君子不防小人的做法。话说加密存储一个你要是被人扒开客户端看也不会被喷明文存储……<br> 方法 1 它拿到存储的密文解不开、方法 2 它不知道你的签名算法和盐，两者可以结合食用。<br> 但是如果 token 被人拷走，他自然也能植入到自己的手机里面，那到时候他的手机也可以以你的身份来用着，这你就瞎了。<br> 于是可以提供一个让用户可以主动 expire 一个过去的 token 类似的机制，在被盗的时候能远程止损。</p><p>在网络层面上 token 明文传输的话会非常的危险，所以建议一定要使用 HTTPS，并且把 token 放在 post body 里。</p><p>补充：</p><p>cookie 与 session 的区别</p><p>1、cookie 数据存放在客户端上，session 数据放在服务器上。</p><p>2、cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗<br>  考虑到安全应当使用 session。</p><p>3、session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>  考虑到减轻服务器性能方面，应当使用 COOKIE。</p><p>4、单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。</p><p>5、所以个人建议：<br>  将登陆信息等重要信息存放为 SESSION<br>  其他信息如果需要保留，可以放在 COOKIE 中</p><p>session 与 token 的区别</p><p>　　session 和 oauth token 并不矛盾，作为身份认证  token 安全性比 session 好，因为每个请求都有签名还能防止监听以及重放攻击，而 session 就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加 session 来在服务器端保存一些状态</p><p>　　App 通常用 restful  api 跟 server 打交道。Rest 是 stateless 的，也就是 app 不需要像 browser 那样用 cookie 来保存 session, 因此用 session token 来标示自己就够了，session/state 由 api server 的逻辑处理。 如果你的后端不是 stateless 的 rest  api, 那么你可能需要在 app 里保存 session. 可以在 app 里嵌入 webkit, 用一个隐藏的 browser 来管理 cookie  session.</p><p>　　Session 是一种 HTTP 存储机制，目的是为无状态的 HTTP 提供的持久机制。所谓 Session 认证只是简单的把 User  信息存储到 Session 里，因为 SID 的不可预测性，暂且认为是安全的。这是一种认证手段。 而 Token ，如果指的是 OAuth Token  或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让 某 App 有权利访问 某用户 的信息。这里的  Token 是唯一的。不可以转移到其它 App 上，也不可以转到其它 用户 上。 转过来说 Session  。Session 只提供一种简单的认证，即有此 SID，即认为有此  User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。 所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</p><p>打破误解：</p><p>“只要关闭浏览器 ，session 就消失了？”</p><p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。</p><p>然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session  id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session.</p><p>恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就可以以为客户端已经停止了活动，才会把 session 删除以节省存储空间。</p><p>本文转自：<a href="https://www.cnblogs.com/JamesWang1993/articles/8593494.html">https://www.cnblogs.com/JamesWang1993/articles/8593494.html</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在 python 中进行视频 - 音频处理及合并</title>
      <link href="/%E5%9C%A8python%E4%B8%AD%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91-%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E5%8F%8A%E5%90%88%E5%B9%B6/"/>
      <url>/%E5%9C%A8python%E4%B8%AD%E8%BF%9B%E8%A1%8C%E8%A7%86%E9%A2%91-%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86%E5%8F%8A%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、ffmpeg 组件"><a href="# 一、ffmpeg 组件" class="headerlink" title="一、ffmpeg 组件"></a>一、ffmpeg 组件</h1><p>ffmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用 LGPL 或 GPL 许可证。它提供了录制、转换以及流化音视频的完整解决方案。</p><p><strong>本次介绍 ffmpeg 的目的是：合并视频，合并音频，合并视频和音频。</strong></p><p>它可以直接在命令行下直接调用；也可以通过 python 程序调用。</p><h2 id="1-1- 下载及配置环境变量"><a href="#1-1- 下载及配置环境变量" class="headerlink" title="1.1 下载及配置环境变量"></a>1.1 下载及配置环境变量 </h2><p> 下载地址：<a href="https://ffmpeg.zeranoe.com/builds/">https://ffmpeg.zeranoe.com/builds/</a></p><p>下载完直接解压即可，将文件放到合适位置。</p><p>然后在 path 中配置环境变量。</p><p>配置完需要重启电脑才能生效。</p><p>如在 CMD 下输入以下命令，若有反应，则说明环境变量配置成功。</p><pre><code>C:\Users\Aloha&gt;ffmpeg -version</code></pre><h2 id="1-2- 在 python 中使用"><a href="#1-2- 在 python 中使用" class="headerlink" title="1.2 在 python 中使用"></a>1.2 在 python 中使用</h2><h3 id="1-2-1- 视频音频合并"><a href="#1-2-1- 视频音频合并" class="headerlink" title="1.2.1 视频音频合并"></a>1.2.1 视频音频合并</h3><pre><code class="python">import subprocess  // 这个不用 pip 安装，自带的def video_add_audio(video_file, audio_file):    &quot;&quot;&quot;     视频添加音频    :param file_name: 传入视频文件的路径    :param mp3_file: 传入音频文件的路径    :return:    &quot;&quot;&quot;    outfile_name = file_name + &#39;-txt.mp4&#39;    subprocess.call(&#39;ffmpeg -i &#39; + video_file                    + &#39; -i &#39; + audio_file + &#39; -strict -2 -f mp4 &#39;                    + outfile_name, shell=True)</code></pre><h3 id="1-2-2- 视频合并"><a href="#1-2-2- 视频合并" class="headerlink" title="1.2.2 视频合并"></a>1.2.2 视频合并 </h3><h4 id="方法一：FFmpeg-concat- 协议"><a href="# 方法一：FFmpeg-concat- 协议" class="headerlink" title="方法一：FFmpeg concat 协议"></a><strong> 方法一：FFmpeg concat 协议 </strong></h4><p> 对于 MPEG 格式的视频，可以直接连接：</p><blockquote><pre><code>ffmpeg -i &quot;concat:input1.mpg|input2.mpg|input3.mpg&quot; -c copy output.mpg</code></pre></blockquote><p>对于非 MPEG 格式容器，但是是 MPEG 编码器（H.264、DivX、XviD、MPEG4、MPEG2、AAC、MP2、MP3 等），可以包装进 TS 格式的容器再合并。在新浪视频，有很多视频使用 H.264 编码器，可以采用这个方法</p><blockquote><pre><code>ffmpeg -i input1.flv -c copy -bsf:v h264_mp4toannexb -f mpegts input1.tsffmpeg -i input2.flv -c copy -bsf:v h264_mp4toannexb -f mpegts input2.tsffmpeg -i input3.flv -c copy -bsf:v h264_mp4toannexb -f mpegts input3.tsffmpeg -i &quot;concat:input1.ts|input2.ts|input3.ts&quot; -c copy -bsf:a aac_adtstoasc -movflags +faststart output.mp4</code></pre></blockquote><p>保存 QuickTime/MP4 格式容器的时候，建议加上 <code>-movflags +faststart</code>。这样分享文件给别人的时候可以边下边看。</p><h4 id="方法二：FFmpeg-concat- 分离器"><a href="# 方法二：FFmpeg-concat- 分离器" class="headerlink" title="方法二：FFmpeg concat 分离器"></a><strong>方法二：FFmpeg concat 分离器 </strong></h4><p> 这种方法成功率很高，也是最好的，但是需要 FFmpeg 1.1 以上版本。先创建一个文本文件<code>filelist.txt</code>：</p><blockquote><pre><code>file &#39;input1.mkv&#39;file &#39;input2.mkv&#39;file &#39;input3.mkv&#39;</code></pre></blockquote><p>然后：</p><blockquote><pre><code>ffmpeg -f concat -i filelist.txt -c copy output.mkv</code></pre></blockquote><p>注意：使用 FFmpeg concat 分离器时，如果文件名有奇怪的字符，要在 <code>filelist.txt</code> 中转义。</p><h2 id="1-3- 用法总结"><a href="#1-3- 用法总结" class="headerlink" title="1.3 用法总结"></a>1.3 用法总结 </h2><h3 id="1-3-1-ffmpeg 命令"><a href="#1-3-1-ffmpeg 命令" class="headerlink" title="1.3.1 ffmpeg 命令"></a>1.3.1 ffmpeg 命令</h3><p> 命令格式：</p><pre><code>ffmpeg -i [输入文件名] [参数选项] -f [格式] [输出文件]ffmpeg [[options][`-i&#39; input_file]]... &#123;[options] output_file&#125;...</code></pre><ul><li>参数选项：<br> (1) -an: 去掉音频<br> (2) -acodec: 音频选项， 一般后面加 copy 表示拷贝<br> (3) -vcodec: 视频选项，一般后面加 copy 表示拷贝</li><li>格式：<br>  (1) h264: 表示输出的是 h264 的视频裸流<br>  (2) mp4: 表示输出的是 mp4 的视频<br>  (3) mpegts: 表示 ts 视频流</li><li>注意：如果没有输入文件，那么视音频捕捉（只在 Linux 下有效，因为 Linux 下把音视频设备当作文件句柄来处理）就会起作用。作为通用的规则，选项一般用于下一个特定的文件。如果你给 –b 64 选项，改选会设置下一个视频速率。对于原始输入文件，格式选项可能是需要的。缺省情况下，ffmpeg 试图尽可能的无损转换，采用与输入同样的音频视频参数来输出。</li></ul><p><strong>视频格式转换示例：</strong></p><pre><code>//H264 视频转 ts 视频流ffmpeg -i test.h264 -vcodec copy -f mpegts test.ts//ts 视频转 mp4ffmpeg -i test.ts -acodec copy -vcodec copy -f mp4 test.mp4//mp4 视频转 flvffmpeg -i test.mp4 -acodec copy -vcodec copy -f flv test.flv </code></pre><p> <strong>将视频转为音频：</strong></p><pre><code>def video2mp3(file_name):    &quot;&quot;&quot;    将视频转为音频    :param file_name: 传入视频文件的路径    :return:    &quot;&quot;&quot;    outfile_name = file_name.split(&#39;.&#39;)[0] + &#39;.mp3&#39;    subprocess.call(&#39;ffmpeg -i &#39; + file_name                    + &#39; -f mp3 &#39; + outfile_name, shell=True)</code></pre><ul><li>分离视频：<code>ffmpeg -i 1.mp4  1.avi</code></li><li>分离音频：<code>ffmpeg -i 1.mp4 1.mp3</code></li></ul><h1 id="二、流媒体 ts 与 m3u8"><a href="# 二、流媒体 ts 与 m3u8" class="headerlink" title="二、流媒体 ts 与 m3u8"></a>二、流媒体 ts 与 m3u8</h1><p>现在大部分视频网站为了反扒，会将视频切割成很多小段，形成后缀为.ts 的视频文件。用户在网站上播放视频时，会一步步从服务器加载.ts 视频进行播放。</p><p><strong>Ts 文件视频编码主要格式 h264/mpeg4，音频位 aac/mp3</strong></p><p>与此同时，还会存在一个.m3u8 文件，它是记录了一个索引纯文本文件，视频播放时，会根据 m3u8 的索引找到对应的音视频文件的网络地址进行在线播放。</p><p><strong>原视频数据分割为很多个 TS 流，每个 TS 流的地址记录在 m3u8 文件列表中。</strong></p><p>以下是 m3u8 文件的通常格式：</p><pre><code class="python">#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:13#EXT-X-MEDIA-SEQUENCE:0#EXT-X-KEY:METHOD=AES-128,URI=&quot;.20180125/key.key&quot;  &lt;-- 有这一行说明 ts 被加密了。#EXTINF:12.5,http://www.example.com/20180125/GBDYO3576000.ts   #&lt;-- 这就是 ts 流视频的真实 url#EXTINF:12.5,http://www.example.com/20180125/GBDYO3576001.ts#EXTINF:12.5,http://www.example.com/20180125/GBDYO3576002.ts……………………#EXT-X-ENDLIST</code></pre><h2 id="2-1- 无加密"><a href="#2-1- 无加密" class="headerlink" title="2.1 无加密"></a>2.1 无加密 </h2><p> 在.m3u8 文件中，若无 #EXT-X-KEY……一行字样，说明没有加密。</p><h3 id="2-1-1-m3u8 下载合并"><a href="#2-1-1-m3u8 下载合并" class="headerlink" title="2.1.1 m3u8 下载合并"></a>2.1.1 m3u8 下载合并 </h3><p><strong> 有了 m3u8 文件，可以直接使用 ffmpeg 进行下载，合并。</strong></p><p>注意这里的 m3u8 文件地址可以是网络 url，也可以是本地 ts 文件路径。</p><pre><code>ffmpeg -i file.m3u8 -c copy new.mp4</code></pre><p>若报错： Protocol ‘http’ not on whitelist ‘file,crypto,data’!</p><p>则执行下面这个：</p><pre><code>ffmpeg -allowed_extensions ALL -protocol_whitelist &quot;file,http,crypto,tcp&quot; -i index.m3u8 -c copy out.mp4</code></pre><h3 id="2-1-2-ts 合并"><a href="#2-1-2-ts 合并" class="headerlink" title="2.1.2 ts 合并"></a>2.1.2 ts 合并 </h3><p> 当我们已经直接把 <code>.ts</code> 文件下载到本地了，可以按照以下方法合并。</p><p>CMD 下执行一下命令：</p><pre><code class="cmd">copy/b D:\temp\*.ts D:\temp\output.ts</code></pre><p><code>D:\temp\*.ts</code> 意思是 <code>D:\temp</code> 目录下所有的 <code>.ts</code> 文件。</p><h2 id="2-2- 有加密"><a href="#2-2- 有加密" class="headerlink" title="2.2 有加密"></a>2.2 有加密 </h2><p> 在.m3u8 文件中，若存在 #EXT-X-KEY……一行字样，说明.ts 有加密。</p><pre><code>#EXT-X-KEY:METHOD=AES-128,URI=&quot;key 的地址 &quot;   </code></pre><p>只要这一行有说明 key 的地址（不论本地，还是网络 url），就可以直接执行：</p><pre><code>ffmpeg -i file.m3u8 -c copy new.mp4</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反反爬虫之 JS 解密</title>
      <link href="/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8BJS%E8%A7%A3%E5%AF%86/"/>
      <url>/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8BJS%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>对传输的数据进行 JS 加密是网站常用的加密方式，以防止爬虫的爬取，以下对有道翻译进行破解示例。</p><h1 id="一、手动破解"><a href="# 一、手动破解" class="headerlink" title="一、手动破解"></a>一、手动破解 </h1><p> 打开有道翻译：<a href="http://fanyi.youdao.com/">http://fanyi.youdao.com/</a></p><p>输入翻译内容：你好，世界</p><p>打开开发者调试工具：</p><p>【Network】—刷新—重新输入需要翻译的内容</p><p>在【XHR】过滤后，可看到【Js】传来的数据：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_10-20-51.png" alt=""></p><p>在【Headers】里可以看到请求的【url，请求方式】：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_10-23-37.png" alt=""></p><p>再往下翻，可以看到发送的表单数据：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_10-25-34.png" alt=""></p><p>这里面是重点！</p><p>重新输入翻译内容，再对比看看两份表单数据：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_10-28-53.png" alt=""></p><p>以上红框里四个参数是关键，需要搞清楚它是怎么产生的。</p><p>【ctrl+f】打开搜索框，搜索【salt】参数</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_10-37-46.png" alt=""></p><p>搜到了【fanyi.min.js】，这就说明【salt】【sign】【ts】【bv】可能是在这里面产生的。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_10-43-48.png" alt=""></p><p>显示内容：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_10-45-38.png" alt=""></p><p>为了便于分析查找，将【fanyi.min.js】数据复制到 pycharm 里。</p><p>在 pycharm 里新建【JavaScript file】，命名为【fanyi.min.js】，把数据复制进去。</p><p>【ctrl+f】打开搜索框，搜索【translate_o】关键词</p><p>因为这是数据传输的 url：【Request URL: ==<a href="http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule==】">http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule==】</a></p><p>找到：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_10-55-15.png" alt=""></p><p>这里面的（data: e）中的 e 是指查询或者说翻译参数，用户需要翻译的值。这个数据在函数 c(e,t)里处理，故先 ctrl+ 鼠标左键，点击函数名 c 进入：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_11-08-55.png" style="zoom:80%;" /><p>可以看到我们需要的参数【salt】【sign】【ts】【bv】这些参数都跟 r 有关，ctrl+ 鼠标左键，点击 r 进入：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_11-11-39.png" style="zoom:80%;" /><p>可以看到，r 是由 v.generateSaltSign(n)产生的，ctrl+ 鼠标左键，点击进入：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_11-14-25.png" alt=""></p><p>可以看到，generateSaltSign 是由 r 产生的，ctrl+ 鼠标左键，点击 r 进入：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_11-16-45.png" alt=""></p><p>由此终于可以看到【ts】【bv】【sign】【salt】是怎么来的了。</p><p>【ts】与时间有关，再结合 ts 在表单数据里的值【ts: 1585016297455】，很容易知道它就是个时间戳，只不过是个 13 位数的时间戳。python 里面可以得到：</p><pre><code class="python">ts=str(int(time.time()*1000))</code></pre><p>【bv】是由(navigator.appVersion）进行 md5 加密而来，(navigator.appVersion）其实就是 User-Agent。</p><p>【sign】是由 (“fanyideskweb” + e + i + “Nw(nmmbP%A-r6U3EUn]Aj”) 进行 md5 加密而来，这里的 e 是翻译的查询参数，比如这里翻译的内容是”你好，世界”，e 就是”你好，世界”；i 就是 salt。</p><p>【salt】是 i，与 r(即时间戳有关)，再结合 salt 在表单数据里的值【salt: 15850162974555】，很明显就知道 salt 是在 ts 时间戳后面再加了一位随机数。</p><pre><code class="python">salt=ts+str(random.randint(0,9))  // 字符串拼接</code></pre><p>剩下的就是在 python 里面实现 md5 加密。</p><pre><code class="python">import hashlibdef make_md5(string):    string=string.encode(&#39;utf-8&#39;)    md5=hashlib.md5(string).hexdigest()    return md5bv=make_md5(&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&quot;)sign=make_md5(&quot;fanyideskweb&quot; + &quot; 你好，世界 &quot; + str(salt) + &quot;Nw(nmmbP%A-r6U3EUn]Aj&quot;)</code></pre><p>整个程序：</p><pre><code class="python">import requestsimport timeimport randomimport hashlibdef make_md5(string):    string=string.encode(&#39;utf-8&#39;)    md5=hashlib.md5(string).hexdigest()    return md5def translate(e):    #特征值破解    ts=str(int(time.time()*1000))    salt=ts+str(random.randint(0,9))    bv=make_md5(&#39;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&#39;)    sign=make_md5(&quot;fanyideskweb&quot; + e + salt + &quot;n%A-rKaT5fb[Gy?;N5@Tj&quot;)    formdata=&#123;        &quot;i&quot;: str(e),        &quot;from&quot;: &#39;AUTO&#39;,         &quot;to&quot;: &quot;AUTO&quot;,        &quot;smartresult&quot;: &quot;dict&quot;,        &quot;client&quot;: &quot;fanyideskweb&quot;,        &quot;salt&quot;: salt,        &quot;sign&quot;: sign,        &quot;ts&quot;: ts,        &quot;bv&quot;: bv,        &quot;doctype&quot;: &quot;json&quot;,        &quot;version&quot;: &quot;2.1&quot;,        &quot;keyfrom&quot;: &quot;fanyi.web&quot;,        &quot;action&quot;: &quot;FY_BY_REALTlME&quot;    &#125;    headers=&#123;        &#39;Accept&#39;: &#39;application/json, text/javascript, */*; q=0.01&#39;,        &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,        &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.9&#39;,        &#39;Connection&#39;: &#39;keep-alive&#39;,        &#39;Content-Length&#39;: &#39;251&#39;,        &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded; charset=UTF-8&#39;,        &#39;Cookie&#39;: &#39;OUTFOX_SEARCH_USER_ID=289052185@10.108.160.18; OUTFOX_SEARCH_USER_ID_NCOO=469089922.02312773; DICT_UGC=be3af0da19b5c5e6aa4e17bd8d90b28a|; JSESSIONID=abczzcxuVriBO6I1nFq0w; ___rl__test__cookies=1567939951177&#39;,        &#39;Host&#39;: &#39;fanyi.youdao.com&#39;,        &#39;Origin&#39;: &#39;http://fanyi.youdao.com&#39;,        &#39;Referer&#39;: &#39;http://fanyi.youdao.com/&#39;,        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&#39;,        &#39;X-Requested-With&#39;:&#39;XMLHttpRequest&#39;,    &#125;    res=requests.post(&quot;http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule&quot;,data=formdata,headers=headers).json()    text=res[&#39;translateResult&#39;][0][0][&#39;tgt&#39;]    return textif __name__==&#39;__main__&#39;:    e=input(&#39; 请输入需要翻译的词或句子：&#39;)    result=translate(e)    print(result)</code></pre><h1 id="二、JavaScript 破解"><a href="# 二、JavaScript 破解" class="headerlink" title="二、JavaScript 破解"></a>二、JavaScript 破解 </h1><p> 原理：直接在网页调试工具中将实现 JS 加密的 JavaScript 代码整个赋值下来，在 python 中执行，这样就无需人为去破解。</p><h2 id="2-1- 搭建环境"><a href="#2-1- 搭建环境" class="headerlink" title="2.1 搭建环境"></a>2.1 搭建环境 </h2><p> 如果想用 python 代码直接调用 js 的代码，则需要搭建 js 环境，并安装相关的库直接调用 JS 代码。</p><p><a href="https://pypi.org/project/PyExecJS/">PyExecJS</a> ，就是其中一个比较好的库。可以使用 python 运行 JavaScript 代码。</p><p>需要注意的是：这个库已经不再维护了，如果因为版本更新所导致的一些错误是无法修复的。</p><p><code>PyExecJS</code> 的优点是不需要关心 JavaScript 环境。 特别是它可以在 Windows 环境下工作，而不需要安装额外的库。</p><p>缺点之一是性能。 通过文本传递 JavaScript 运行时，速度很慢。 另一个缺点是它不完全支持运行时特定的特性。</p><p>首先下载安装 Node.js：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p>然后安装 python 库：</p><pre><code>pip install PyExecJS</code></pre><h2 id="2-2- 配置 Pycharm"><a href="#2-2- 配置 Pycharm" class="headerlink" title="2.2 配置 Pycharm"></a>2.2 配置 Pycharm</h2><p>目的：在 pycharm 中运行 js 代码。</p><p>在 pycharm 中安装插件 Node.js：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_13-29-37.png" alt=""></p><p>尝试运行：</p><pre><code>// 新建文件 youdao.js，并输入以下代码console.log(&#39;hello&#39;)// 运行输出hello</code></pre><p>如果提示没有编译器，则按下面配置：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_13-37-20.png" alt=""></p><h2 id="2-3- 复制 JS 代码"><a href="#2-3- 复制 JS 代码" class="headerlink" title="2.3 复制 JS 代码"></a>2.3 复制 JS 代码 </h2><p> 上面已经找到了关键数据的加密方式，直接复制过来：</p><p>在 pycharm 里新建【JavaScript file】，命名为【fanyi.js】，把数据复制进去。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_13-46-28.png" alt=""></p><p>这里面用到了 n.md5 函数，ctrl+ 鼠标左键，点击函数名找到位置：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_13-56-54.png" alt=""></p><p>找到 md5 之后，发现里面的还有 h(e),f(e)等函数，不可直接复制 md5 函数里的内容，应该向上找，找到包含 md5 的完整函数。</p><p>按缩进判断函数体：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_14-00-27.png" alt=""></p><p>然后将断点之间的代码都复制到【fanyi.js】：</p><p>并删掉引用：e(“./jquery-1.7”).extend({</p><pre><code class="javascript">var n = function (e, t) &#123;        return e &lt;&lt; t | e &gt;&gt;&gt; 32 - t    &#125;, r = function (e, t) &#123;        var n, r, i, a, o;        return i = 2147483648 &amp; e, a = 2147483648 &amp; t, n = 1073741824 &amp; e, r = 1073741824 &amp; t, o = (1073741823 &amp; e) + (1073741823 &amp; t), n &amp; r ? 2147483648 ^ o ^ i ^ a : n | r ? 1073741824 &amp; o ? 3221225472 ^ o ^ i ^ a : 1073741824 ^ o ^ i ^ a : o ^ i ^ a    &#125;, i = function (e, t, n) &#123;        return e &amp; t | ~e &amp; n    &#125;, a = function (e, t, n) &#123;        return e &amp; n | t &amp; ~n    &#125;, o = function (e, t, n) &#123;        return e ^ t ^ n    &#125;, s = function (e, t, n) &#123;        return t ^ (e | ~n)    &#125;, l = function (e, t, a, o, s, l, c) &#123;        return e = r(e, r(r(i(t, a, o), s), c)), r(n(e, l), t)    &#125;, c = function (e, t, i, o, s, l, c) &#123;        return e = r(e, r(r(a(t, i, o), s), c)), r(n(e, l), t)    &#125;, u = function (e, t, i, a, s, l, c) &#123;        return e = r(e, r(r(o(t, i, a), s), c)), r(n(e, l), t)    &#125;, d = function (e, t, i, a, o, l, c) &#123;        return e = r(e, r(r(s(t, i, a), o), c)), r(n(e, l), t)    &#125;, f = function (e) &#123;        for (var t, n = e.length, r = n + 8, i = 16 * ((r - r % 64) / 64 + 1), a = Array(i - 1), o = 0, s = 0; s &lt; n;) o = s % 4 * 8, a[t = (s - s % 4) / 4] = a[t] | e.charCodeAt(s) &lt;&lt; o, s++;        return t = (s - s % 4) / 4, o = s % 4 * 8, a[t] = a[t] | 128 &lt;&lt; o, a[i - 2] = n &lt;&lt; 3, a[i - 1] = n &gt;&gt;&gt; 29, a    &#125;, p = function (e) &#123;        var t, n = &quot;&quot;, r = &quot;&quot;;        for (t = 0; t &lt;= 3; t++) n += (r = &quot;0&quot; + (e &gt;&gt;&gt; 8 * t &amp; 255).toString(16)).substr(r.length - 2, 2);        return n    &#125;, h = function (e) &#123;        e = e.replace(/\x0d\x0a/g, &quot;\n&quot;);        for (var t = &quot;&quot;, n = 0; n &lt; e.length; n++) &#123;            var r = e.charCodeAt(n);            if (r &lt; 128) t += String.fromCharCode(r); else if (r &gt; 127 &amp;&amp; r &lt; 2048) t += String.fromCharCode(r &gt;&gt; 6 | 192), t += String.fromCharCode(63 &amp; r | 128); else if (r &gt;= 55296 &amp;&amp; r &lt;= 56319) &#123;                if (n + 1 &lt; e.length) &#123;                    var i = e.charCodeAt(n + 1);                    if (i &gt;= 56320 &amp;&amp; i &lt;= 57343) &#123;                        var a = 1024 * (r - 55296) + (i - 56320) + 65536;                        t += String.fromCharCode(240 | a &gt;&gt; 18 &amp; 7), t += String.fromCharCode(128 | a &gt;&gt; 12 &amp; 63), t += String.fromCharCode(128 | a &gt;&gt; 6 &amp; 63), t += String.fromCharCode(128 | 63 &amp; a), n++                    &#125;                &#125;            &#125; else t += String.fromCharCode(r &gt;&gt; 12 | 224), t += String.fromCharCode(r &gt;&gt; 6 &amp; 63 | 128), t += String.fromCharCode(63 &amp; r | 128)        &#125;        return t    &#125;;      md5=function (e) &#123;            var t, n, i, a, o, s, m, g, v, y = Array();            for (e = h(e), y = f(e), s = 1732584193, m = 4023233417, g = 2562383102, v = 271733878, t = 0; t &lt; y.length; t += 16) n = s, i = m, a = g, o = v, s = l(s, m, g, v, y[t + 0], 7, 3614090360), v = l(v, s, m, g, y[t + 1], 12, 3905402710), g = l(g, v, s, m, y[t + 2], 17, 606105819), m = l(m, g, v, s, y[t + 3], 22, 3250441966), s = l(s, m, g, v, y[t + 4], 7, 4118548399), v = l(v, s, m, g, y[t + 5], 12, 1200080426), g = l(g, v, s, m, y[t + 6], 17, 2821735955), m = l(m, g, v, s, y[t + 7], 22, 4249261313), s = l(s, m, g, v, y[t + 8], 7, 1770035416), v = l(v, s, m, g, y[t + 9], 12, 2336552879), g = l(g, v, s, m, y[t + 10], 17, 4294925233), m = l(m, g, v, s, y[t + 11], 22, 2304563134), s = l(s, m, g, v, y[t + 12], 7, 1804603682), v = l(v, s, m, g, y[t + 13], 12, 4254626195), g = l(g, v, s, m, y[t + 14], 17, 2792965006), m = l(m, g, v, s, y[t + 15], 22, 1236535329), s = c(s, m, g, v, y[t + 1], 5, 4129170786), v = c(v, s, m, g, y[t + 6], 9, 3225465664), g = c(g, v, s, m, y[t + 11], 14, 643717713), m = c(m, g, v, s, y[t + 0], 20, 3921069994), s = c(s, m, g, v, y[t + 5], 5, 3593408605), v = c(v, s, m, g, y[t + 10], 9, 38016083), g = c(g, v, s, m, y[t + 15], 14, 3634488961), m = c(m, g, v, s, y[t + 4], 20, 3889429448), s = c(s, m, g, v, y[t + 9], 5, 568446438), v = c(v, s, m, g, y[t + 14], 9, 3275163606), g = c(g, v, s, m, y[t + 3], 14, 4107603335), m = c(m, g, v, s, y[t + 8], 20, 1163531501), s = c(s, m, g, v, y[t + 13], 5, 2850285829), v = c(v, s, m, g, y[t + 2], 9, 4243563512), g = c(g, v, s, m, y[t + 7], 14, 1735328473), m = c(m, g, v, s, y[t + 12], 20, 2368359562), s = u(s, m, g, v, y[t + 5], 4, 4294588738), v = u(v, s, m, g, y[t + 8], 11, 2272392833), g = u(g, v, s, m, y[t + 11], 16, 1839030562), m = u(m, g, v, s, y[t + 14], 23, 4259657740), s = u(s, m, g, v, y[t + 1], 4, 2763975236), v = u(v, s, m, g, y[t + 4], 11, 1272893353), g = u(g, v, s, m, y[t + 7], 16, 4139469664), m = u(m, g, v, s, y[t + 10], 23, 3200236656), s = u(s, m, g, v, y[t + 13], 4, 681279174), v = u(v, s, m, g, y[t + 0], 11, 3936430074), g = u(g, v, s, m, y[t + 3], 16, 3572445317), m = u(m, g, v, s, y[t + 6], 23, 76029189), s = u(s, m, g, v, y[t + 9], 4, 3654602809), v = u(v, s, m, g, y[t + 12], 11, 3873151461), g = u(g, v, s, m, y[t + 15], 16, 530742520), m = u(m, g, v, s, y[t + 2], 23, 3299628645), s = d(s, m, g, v, y[t + 0], 6, 4096336452), v = d(v, s, m, g, y[t + 7], 10, 1126891415), g = d(g, v, s, m, y[t + 14], 15, 2878612391), m = d(m, g, v, s, y[t + 5], 21, 4237533241), s = d(s, m, g, v, y[t + 12], 6, 1700485571), v = d(v, s, m, g, y[t + 3], 10, 2399980690), g = d(g, v, s, m, y[t + 10], 15, 4293915773), m = d(m, g, v, s, y[t + 1], 21, 2240044497), s = d(s, m, g, v, y[t + 8], 6, 1873313359), v = d(v, s, m, g, y[t + 15], 10, 4264355552), g = d(g, v, s, m, y[t + 6], 15, 2734768916), m = d(m, g, v, s, y[t + 13], 21, 1309151649), s = d(s, m, g, v, y[t + 4], 6, 4149444226), v = d(v, s, m, g, y[t + 11], 10, 3174756917), g = d(g, v, s, m, y[t + 2], 15, 718787259), m = d(m, g, v, s, y[t + 9], 21, 3951481745), s = r(s, n), m = r(m, i), g = r(g, a), v = r(v, o);            return (p(s) + p(m) + p(g) + p(v)).toLowerCase()        &#125;var r = function (e) &#123;        var t = md5(navigator.appVersion), r = &quot;&quot; + (new Date).getTime(), i = r + parseInt(10 * Math.random(), 10);        return &#123;ts: r, bv: t, salt: i, sign: md5(&quot;fanyideskweb&quot; + e + i + &quot;Nw(nmmbP%A-r6U3EUn]Aj&quot;)&#125;    &#125;;console.log(r(&#39; 你好世界 &#39;))// 输出如下：var t = md5(navigator.appVersion), r = &quot;&quot; + (new Date).getTime(), i = r + parseInt(10 * Math.random(), 10);                    ^ReferenceError: navigator is not defined</code></pre><p>说明这里还有    navigator    这个参数还未定义。</p><p>在 console 中输入 navigator，可得到数据：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_14-25-13.png" alt=""></p><p>将 navigator 的参数以字典的形式添加到到代码中（其实只是需要键名为 appVersion 的值，即浏览器的 UA）再运行：</p><p>提示以下错误：</p><pre><code> e = e.replace(/\x0d\x0a/g, &quot;\n&quot;);              ^RangeError: Maximum call stack size exceededat String.replace (&lt;anonymous&gt;)</code></pre><p>这是因为：</p><pre><code class="javascript">var r = function (e) &#123;……&#125;;</code></pre><p>变量名 r 与之前的重复了，改掉就好。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-24_14-32-47.png" alt=""></p><pre><code>&#123;  ts: &#39;1585031532017&#39;,  bv: &#39;901200199a98c590144a961dac532964&#39;,  salt: &#39;15850315320171&#39;,  sign: &#39;e04455ff433514e20647a2a96c759bd0&#39;&#125;</code></pre><p>终于得到了想要的数据！</p><h2 id="2-4- 在 python 调用 Js 代码"><a href="#2-4- 在 python 调用 Js 代码" class="headerlink" title="2.4 在 python 调用 Js 代码"></a>2.4 在 python 调用 Js 代码</h2><pre><code class="python">import execjswith open(&#39;fanyi.min.js&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;) as f:    js_code=f.read()// 使用 compile 加载 JavaScript 代码ctx=execjs.compile(js_code)// 使用 call 调用对象result=ctx.call(&#39;youdao&#39;,&#39; 你好世界 &#39;)print(result)// 输出结果如下&#123;&#39;ts&#39;: &#39;1585032669319&#39;, &#39;bv&#39;: &#39;901200199a98c590144a961dac532964&#39;, &#39;salt&#39;: &#39;15850326693199&#39;, &#39;sign&#39;: &#39;7b5bd55eb8c7c5f3c9ea99f9632109e4&#39;&#125;</code></pre><h1 id="三、JS 混淆"><a href="# 三、JS 混淆" class="headerlink" title="三、JS 混淆"></a>三、JS 混淆 </h1><h2 id="3-1- 利与弊"><a href="#3-1- 利与弊" class="headerlink" title="3.1 利与弊"></a>3.1 利与弊</h2><p><strong> 站在网站开发者的角度</strong></p><p>1、是为了保护我们的前端代码逻辑<br>2、精简代码、加快传输</p><p><strong>站在爬虫者的角度</strong></p><p>1、增加了获取数据的难度<br>2、增加了获取数据的难度</p><h2 id="3-2- 混淆与反混淆"><a href="#3-2- 混淆与反混淆" class="headerlink" title="3.2 混淆与反混淆"></a>3.2 混淆与反混淆</h2><h3 id="3-2-1-JS 压缩"><a href="#3-2-1-JS 压缩" class="headerlink" title="3.2.1 JS 压缩"></a>3.2.1 JS 压缩</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20191225190455160.png" alt=""></p><p>特点：把 JS 代码写在一起。让你难以阅读，难以破解</p><p>削减是一个从源代码中删除不必要的字符的技术使它看起来简单而整洁。这种技术也被称为代码压缩和最小化。</p><p>常用压缩工具：<br><a href="https://javascript-minifier.com/">https://javascript-minifier.com/</a></p><p>破解方法 - 代码格式化：<br><a href="http://tool.oschina.net/codeformat/js/">http://tool.oschina.net/codeformat/js/</a></p><h3 id="3-2-2-eval 加密"><a href="#3-2-2-eval 加密" class="headerlink" title="3.2.2 eval 加密"></a>3.2.2 eval 加密</h3><p>js 中的 eval() 方法就是一个 js 语言的执行器，它能把其中的参数按照 JavaScript 语法进行解析并执行，简单来说就是把原本的 js 代码变成了 eval 的参数，变成参数后代码就成了字符串，其中的一些字符就会被按照特定格式“编码”。</p><p><strong>特征：</strong></p><p>最明显的特征是生成的代码以 <code>eval(function(p,a,c,k,e,r))</code> 开头。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20191225190543248.png" style="zoom:100%;" /><p><strong>原理：</strong></p><p>这类混淆的关键思想在于将需要执行的代码进行一次编码，在执行的时候还原出浏览器可执行的合法 的脚本</p><p>破解方法 - 浏览器 <br> 打开 谷歌 或者 火狐 浏览器 <br> 按 F12 打开控制台 <br> 把代码复制进去 <br> 删除开头 eval 这 4 个字母 <br> 按回车键</p><p>常用混淆工具：<br><a href="http://dean.edwards.name/packer/">http://dean.edwards.name/packer/</a></p><h3 id="3-2-3- 公钥加密关键字段"><a href="#3-2-3- 公钥加密关键字段" class="headerlink" title="3.2.3 公钥加密关键字段"></a>3.2.3 公钥加密关键字段 </h3><p><strong> 特征：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20191225190622791.png" alt=""></p><p><strong>原理：</strong><br>用户访问客户端，客户端向服务器请求获取一个 RSA 公钥以及键值 key，存储在本地 <br> 用户在本地公钥失效前发起登录请求，则使用已有公钥对用户密码进行加密；若已过期则执行 1 后 再加密 <br> 客户端将密文与 key 一起传回后台 <br> 后台通过 key 找到缓存里面的私钥，对密文进行解密</p><p>常用混淆工具：<br><a href="http://travistidwell.com/jsencrypt/">http://travistidwell.com/jsencrypt/</a></p><h3 id="3-2-4- 变量名混淆"><a href="#3-2-4- 变量名混淆" class="headerlink" title="3.2.4 变量名混淆"></a>3.2.4 变量名混淆 </h3><p><strong> 特征：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20191225190656223.png" alt=""></p><p><strong>原理</strong></p><p>字符串字面量混淆：首先提取全部的字符串，在全局作用域创建一个字符串数组，同时转义字符增大 阅读难度，然后将字符串出现的地方替换成为数组元素的引用 <br> 变量名混淆：不同于压缩器的缩短命名，此处使用了下划线加数字的格式，变量之间区分度很低，相 比单个字母更难以阅读 <br> 成员运算符混淆：将点运算符替换为字符串下标形式，然后对字符串进行混淆 删除多余的空白字符：减小文件体积，这是所有压缩器都会做的事。</p><p>常用混淆工具：<br><a href="http://javascriptobfuscator.com/Javascript-Obfuscator.aspx">http://javascriptobfuscator.com/Javascript-Obfuscator.aspx</a><br><a href="http://js.51tools.info/">http://js.51tools.info/</a><br>破解方法 -IDE、解密工具、浏览器：  <a href="http://jsnice.org/">http://jsnice.org/</a>  <a href="http://js.51tools.info/">http://js.51tools.info/</a></p><p>（1）把变量名、函数名、参数名等，替换成没有语义，看着又很像的名字。</p><pre><code>_0x21dd83、_0x21dd84、_0x21dd85</code></pre><p>（2）用十六进制文本去表示一个字符串</p><pre><code>\x56\x49\x12\x23</code></pre><p>（3）利用 JS 能识别的编码来做混淆。JS 是 Unicode 编码，本身就能识别这种编码。类似的一些变量名，函数名都可以用这个表示，并且调用。</p><p>  类似： <code>\u6210\u529f</code> 表示中文字符(成功)。</p><p>  类似：<code>\u0053\u0074\u0072\u0069\u006e\u0067.\u0066\u0072\u006f\u006d\u0043\u0068\u0061\u0072\u0043\u006f\u0064\u0065</code>  </p><p>代表 String.fromCharCode</p><p>  类似：</p><p>  <code>(&#39;&#39;)[&#39;\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72&#39;][&#39;\x66\x72\x6f\x6d\x43\x68\x61\x72\x43\x6f\x64\x65&#39;];</code> </p><p>效果等同于 String.fromCharCode</p><p>（4）把一大堆方法名、字符串等存到数组中，这个数组可以是上千个成员。然后调用的时候，取数组成员去用</p><pre><code class="javascript">var arr = [&quot;Date&quot;,&quot;getTime&quot;];var time = new window[arr[0]]()[arr[1]]();console.log(time);</code></pre><p>（5）字符串加密后发送到前端，然后前端调用对应的函数去解密，得到明文</p><pre><code class="javascript">var arr = [&#39;xxxx&#39;]// 定义的解密函数function dec(str)&#123;  return &#39;push&#39;&#125;test[dec(arr[0])](200);</code></pre><h3 id="3-2-5- 控制流平坦化"><a href="#3-2-5- 控制流平坦化" class="headerlink" title="3.2.5 控制流平坦化"></a>3.2.5 控制流平坦化 </h3><p> 将顺序执行的代码混淆成乱序执行, 并加以混淆</p><p>以下两段代码的执行结果是相同的:</p><pre><code class="javascript">// 正常形态function test(a)&#123;    var b = a;    b += 1;    b += 2;    b += 3;    b += 4;    return a + b&#125;// 乱序形态//（这里比较简单, 在很多加密网站上 case 后面往往不是数字或字符串, 而是类似 YFp[15][45][4]这样的对象，相当恶心）function test1(a)&#123;  var arr = [1,2,3,4,5,6]  for(var i = 0, i &lt; arr.lenght, i++)&#123;    switch (arr[i]) &#123;      case 4:        b += 3;        break;      case 2:        b += 1;      break;      case 1:        var b = a;      break;      case 3:        b += 2;      break;      case 6:        return a + b      case 5:        b += 4;      break;    &#125;  &#125;&#125;// 结果都是 30 但是 test1 看着费劲console.log(test1(10));console.log(test(10));</code></pre><h3 id="3-2-6- 使用特定符号编写 js 脚本"><a href="#3-2-6- 使用特定符号编写 js 脚本" class="headerlink" title="3.2.6 使用特定符号编写 js 脚本"></a>3.2.6 使用特定符号编写 js 脚本 </h3><p><strong> 特征：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20191225190724159.png" alt=""></p><p><strong>原理：</strong><br>jsfuck 源于一门编程语言 brainfuck，其主要的思想就是只使用 8 种特定的符号来编写代码。而 jsfuck<br>也是沿用了这个思想，它仅仅使用 6 种符号来编写代码。它们分别是(、)、+、[、]、!。</p><p>常用混淆工具：<br><a href="http://www.jsfuck.com/">http://www.jsfuck.com/</a><br>破解方法： 超级难</p><h3 id="3-2-7- 特殊转化规则"><a href="#3-2-7- 特殊转化规则" class="headerlink" title="3.2.7 特殊转化规则"></a>3.2.7 特殊转化规则 </h3><p> 利用一些只能在浏览器中运行的特殊语句进行反扒，这种只能将语法重新进行改写。</p><p>在浏览器中 base64 编码转换使用的是</p><p><code>_0x1c0cdf = _0xcbc80b[&#39;atob&#39;](_0x1c0cdf)</code>,</p><p>但是在 nodejs 调试的时候使用的是</p><pre><code>Buffer.from(_0x1c0cdf,&quot;base64&quot;).toString()</code></pre><h1 id="四、练手项目"><a href="# 四、练手项目" class="headerlink" title="四、练手项目"></a>四、练手项目</h1><p>（1）获取一品威客登录页面，找到密码的加密方式</p><p><a href="https://www.epwk.com/login.html">https://www.epwk.com/login.html</a></p><p>（2）获取电信官网登录页面，找到密码的加密方式</p><p><a href="https://login.189.cn/web/login">https://login.189.cn/web/login</a></p><p>（3）梦幻西游装备属性数据的加密方式</p><p>[<a href="https://xyq.cbg.163.com/equip?s=40&amp;eid=202002011900113-40-NXOJDHZ8TKFX9&amp;o&amp;equip_refer=27&amp;view_loc=reco_sim|%7B%22tag%22%3A%20%22RL_sim2%22%7D]">https://xyq.cbg.163.com/equip?s=40&amp;eid=202002011900113-40-NXOJDHZ8TKFX9&amp;o&amp;equip_refer=27&amp;view_loc=reco_sim|%7B%22tag%22%3A%20%22RL_sim2%22%7D]</a>(<a href="https://xyq.cbg.163.com/equip?s=40&amp;eid=202002011900113-40-NXOJDHZ8TKFX9&amp;o&amp;equip_refer=27&amp;view_loc=reco_sim|{&quot;tag&quot;%3A">https://xyq.cbg.163.com/equip?s=40&amp;eid=202002011900113-40-NXOJDHZ8TKFX9&amp;o&amp;equip_refer=27&amp;view_loc=reco_sim|{&quot;tag&quot;%3A</a> “RL_sim2”})</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>理解 python 中的闭包与装饰器</title>
      <link href="/%E7%90%86%E8%A7%A3python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/%E7%90%86%E8%A7%A3python%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、闭包"><a href="# 一、闭包" class="headerlink" title="一、闭包"></a>一、闭包 </h1><h2 id="1-1- 基本认识"><a href="#1-1- 基本认识" class="headerlink" title="1.1 基本认识"></a>1.1 基本认识</h2><p> 闭包是 python 面向对象编程中一个很重要的知识点。</p><p>闭包函数有几个特点：</p><p>（1）有函数的嵌套（外函数包裹着内涵数）</p><p>（2）内涵数引用了外函数中的变量</p><p>（3）外函数的返回值是内函数的引用</p><p>以上三点不难理解。在第（2）条中，这里再强调一下，也就是说外函数的局部变量会传入到内涵中。</p><p>以下是一个普通的嵌套函数：</p><pre><code class="python">def outer():   x=1   def inner():      y=1+x      print(y)   inner()   #return     函数必有返回，返回为空时可省略。outer()// 输出结果2</code></pre><p>以下是一个闭包函数：</p><pre><code class="python">def outer():   x=1   def inner():      y=1+x      print(y)   return innerouter()()// 输出结果2</code></pre><p>一般情况下，在我们认知当中，如果一个函数结束（<code>retrun</code>完之后），函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。如下：</p><p><strong>而：</strong></p><p><strong>闭包中被内部函数引用的变量，不会因为外部函数结束而被释放掉，而是一直存在内存中，直到内部函数被调用结束。</strong></p><p>这是闭包函数所独有的特性。</p><h2 id="1-2- 重点把握"><a href="#1-2- 重点把握" class="headerlink" title="1.2 重点把握"></a>1.2 重点把握 </h2><p> 下面再看看两个对比的例子：</p><pre><code class="python">def funcX():    x = 2    def funcY():        y = 2 + x        return y    return funcYprint(funcX()())#输出结果4</code></pre><p>以上的例子好理解。</p><p>下面却又是为啥呢？</p><pre><code class="python">def funcX():    x = 2    def funcY():        x = 2 + x        return x    return funcYprint(funcX()())// 输出错误UnboundLocalError: local variable &#39;x&#39; referenced before assignment</code></pre><p>……………………………………………………………………………………………………………………………………</p><p>这是为啥呢？？？？</p><p>为啥？？？</p><p>这是由于 Python 语言采用的是”动态类型“技术，变量使用前不需要先声明，对变量的赋值即可自动创建变量。</p><p>当程序运行到子函数 <code>funcY()</code> 里面，对 x 进行 x+2 赋值时，首先，x 作为被赋值对象，不管三七二十一，首先会在函数内部动态创建一个局部变量 x（严格来讲是标签 x），从而覆盖掉之前的父函数的 x，这个 x 就成为了 <code>funcY()</code> 里面的局部变量，这时对 x 运行加法运算，当然会报错，因为这个 x 是新的 x，没有被赋值，不能运算。</p><p>在其他静态语言中，也是要先定义变量，才能进行赋值运算。</p><p>解决办法是：在 funcY()里面，添加一行：</p><pre><code class="python">nonlocal x   // 申明 x 为非局部变量</code></pre><p>再举一个例子：</p><pre><code class="python">def swap(a,b):    a,b=b,a    print(a,b)a=1b=2swap(a,b)// 输出结果：2 1</code></pre><p>以上的例子是 python 中独特的交换值的代码写法，这里值得注意的是，a，b 两个变量被传到 swap 函数里面，故在进行赋值操作时，a，b 不会重新被定义。</p><h2 id="1-3- 全局变量与局部变量"><a href="#1-3- 全局变量与局部变量" class="headerlink" title="1.3 全局变量与局部变量"></a>1.3 全局变量与局部变量 </h2><p> 对比举例：</p><pre><code class="python">// 例 1：def funcX():    x = 2    def funcY():        return x    funcY()print(funcX())// 输出结果为：None-----------------------------------------------------------// 例 2：x = 2def funcX():    return xfuncX()print(funcX())// 输出结果为：2</code></pre><p>出现以上结果的原因是：例 1 里面，x 是在函数里定义，自带 local 属性，是局部变量，无法进入到 <code>funcY()</code>；而在例 2 里面，x 自带 global 属性，可以进入到<code>funcX()</code>。</p><p>在看个例子：</p><pre><code class="python">x=2def funcX():    x=x+2    print(x)funcX()// 输出结果为：UnboundLocalError: local variable &#39;x&#39; referenced before assignment</code></pre><p>出现以上结果的原因是：x 虽然是全局变量，但是在函数体内又对 x 进行了赋值操作，首先就要重新定义 x，这个 x 为局部变量，<strong>局部变量优先级高于全局变量</strong>，局部变量 x 没有值，进行运算肯定报错。</p><pre><code class="python">x=2def funcX():    print(x)funcX()// 输出结果为：2</code></pre><p>这里没有对 x 进行赋值，故碰到 x 直接用了全局变量的 x，并进行输出。</p><h2 id="1-3- 重学赋值操作"><a href="#1-3- 重学赋值操作" class="headerlink" title="1.3 重学赋值操作"></a>1.3 重学赋值操作</h2><pre><code>x = 1x = x+1</code></pre><p>你觉得 python 是怎么执行上面代码的？</p><p>为了彻底弄懂 python 中变量与赋值的内在含义，下面有个经典的案例：</p><pre><code>values=[0,1,2]values[1]=valuesprint(values)</code></pre><p>你觉得上面打印的结果是怎样的？</p><p>……………………………………………………………………………………………………………………………………</p><pre><code>// 结果如下：[0, [...], 2]</code></pre><p>出乎意料吧，结果被赋值了无数次。</p><p><strong>Python 没有赋值，只有引用！</strong></p><p>你这样相当于创建了一个引用自身的结构，所以导致了无限循环。为了理解这个问题，有个基本概念需要搞清楚。</p><p><strong>Python 没有「变量」，我们平时所说的变量其实只是「标签」，是引用。</strong></p><p>执行 <code>values=[0,1,2]</code> 的时候，python 首先做的是分配一块内存空间，以创建一个列表对象 [0, 1, 2]，然后给它贴上名为 values 的标签。如果随后又执行 <code>values = [3, 4, 5]</code> ，python 则会把刚才那张名为 values 的标签从前面的 [0, 1, 2] 对象上撕下来，重新贴到 [3, 4, 5] 这个对象上。</p><p>至始至终，并没有一个叫做 values 的列表对象容器存在，Python 也没有把任何对象的值复制进 values 去。</p><p>执行 <code>values[1]=values</code> 的时候，<strong>Python 做的事情则是把 values 这个标签所引用的列表对象的第二个元素指向 values 所引用的列表对象本身。</strong>执行完毕后，values 标签还是指向原来那个对象。列表的第 2 个值又指向列表本身，就这样循环嵌套。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-21_20-56-36.png" alt=""></p><p>为了避免以上的情况，可使用如下方法：</p><pre><code>values=[0,1,2]values[1]=values[:]    // 利用浅复制print(values)// 输出结果如下：[0, [0, 1, 2], 2]</code></pre><p>再回到问题的起点：</p><pre><code>x = 1x = x+1</code></pre><p>先分配一块内存空间 A，标签 x 指向内存空间 A，把 1 放进去；再分配一块内存空间 B，碰到 x 被赋值，x 已经被声明为全局变量，就直接执行 x+1 运算，将其结果放进内存空间 B 的同时，x 标签更改指向内存空间 B。</p><h1 id="二、装饰器"><a href="# 二、装饰器" class="headerlink" title="二、装饰器"></a>二、装饰器</h1><h2 id="2-1- 前话"><a href="#2-1- 前话" class="headerlink" title="2.1 前话"></a>2.1 前话</h2><h3 id="2-1-1-A 函数对象作为 B 函数形参"><a href="#2-1-1-A 函数对象作为 B 函数形参" class="headerlink" title="2.1.1 A 函数对象作为 B 函数形参"></a>2.1.1 A 函数对象作为 B 函数形参</h3><pre><code class="python">import requestsimport timedef get_html(url):    response=requests.get(url)    return response.textdef timer(func,url):    start_time=time.time()    html=func(url)    print(&#39; 网页请求时间为 &#39;,time.time() - start_time)    return htmltimer(get_html,&#39;https://www.baidu.com&#39;)</code></pre><h3 id="2-1-2- 多形参"><a href="#2-1-2- 多形参" class="headerlink" title="2.1.2 多形参"></a>2.1.2 多形参</h3><pre><code class="python">import requestsimport timedef get_html(url):    response=requests.get(url)    return response.textdef save_html(name,html):    with open(name,mode=&#39;w&#39;,encoding=&#39;utf-8&#39;) as f:        f.write(html)def timer(func,*args,**kwargs):      start_time=time.time()    html=func(*args,**kwargs)    print(&#39; 网页请求时间为 &#39;,time.time() - start_time)    return htmlbaidu_html=timer(get_html,&#39;https://www.baidu.com&#39;)timer(save_html,&#39;baidu&#39;,baidu_html)</code></pre><h3 id="2-1-3- 闭包封装"><a href="#2-1-3- 闭包封装" class="headerlink" title="2.1.3 闭包封装"></a>2.1.3 闭包封装</h3><pre><code class="python">import requestsimport timedef get_html(url):    response=requests.get(url)    return response.textdef timer(func):    def warpper(*args,**kwargs):        start_time=time.time()        html=func(*args,**kwargs)        print(&#39; 网页请求时间为 &#39;,time.time() - start_time)        return html    return warpperwarp=timer(get_html)warp(&#39;https://www.baidu.com&#39;)  // 只需要改动这里网址即可实现计算不同网页打开时间</code></pre><h2 id="2-2- 装饰器"><a href="#2-2- 装饰器" class="headerlink" title="2.2 装饰器"></a>2.2 装饰器</h2><p><strong>python 装饰器本质上就是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外的功能，装饰器的返回值也是一个函数对象（函数的指针）</strong>。装饰器函数的外部函数传入我要装饰的函数名字，返回经过修饰后函数的名字；内层函数（闭包）负责修饰被修饰函数。</p><h3 id="2-2-1- 装饰器"><a href="#2-2-1- 装饰器" class="headerlink" title="2.2.1 装饰器"></a>2.2.1 装饰器</h3><pre><code class="python">import requestsimport timedef timer(func):    def warpper(*args,**kwargs):        start_time=time.time()        html=func(*args,**kwargs)        print(&#39; 网页请求时间为 &#39;,time.time() - start_time)        return html    return warpper@timerdef get_html(url):    response=requests.get(url)    return response.textget_html(&#39;https://www.baidu.com&#39;)  </code></pre><p>这里的 <code>@</code> 就是语法糖，代表一种特定用法，用来声明装饰器的。</p><p>意思是：执行 <code>get_html(&#39;https://www.baidu.com&#39;)</code> 时，找到函数<code>get_html(url)</code>，发现其上面有<code>@timer</code>，等同于<code>timer(get_html(url))</code>。</p><p>案例：过滤 url</p><pre><code>urls = [    &#39;https://maoyan.com/board/4?offset=0&#39;,    &#39;https://maoyan.com/board/4?offset=10&#39;,    &#39;https://maoyan.com/board/4?offset=20&#39;,    &#39;https://maoyan.com/board/4?offset=30&#39;,    &#39;https://www.baidu.com&#39;,    &#39;https://www.sohu.com&#39;,    &#39;https://maoyan.com/board/4?offset=40&#39;,    &#39;https://maoyan.com/board/4?offset=50&#39;,]import requestsdef filter_url(func):    def wrapper(*args, **kwargs):        if &#39;maoyan&#39; in kwargs[&#39;url&#39;]:            result = func(*args, **kwargs)            print(&#39; 下载成功 &#39;, kwargs[&#39;url&#39;])            return result        else:            print(&#39; 不是猫眼电影的网址 &#39;, kwargs[&#39;url&#39;])    return wrapper@filter_urldef download_maoyan(url):    response = requests.get(url)    return response.textfor url in urls:    download_maoyan(url=urls)</code></pre><h3 id="2-2-2- 带参数的装饰器"><a href="#2-2-2- 带参数的装饰器" class="headerlink" title="2.2.2 带参数的装饰器"></a>2.2.2 带参数的装饰器 </h3><p> 我们已经知道，下面两种是等价的：</p><pre><code class="python">@decdef func(...):    ...…………………………………………………………………………………………………………………………………………………………………………func = dec(func)</code></pre><p>我们可以把它当成是纯文本的替换，于是可以是这样的：</p><pre><code>@dec(arg)def func(...):    ...………………………………………………………………………………………………………………………………………………………………func = dec(arg)(func)</code></pre><p>这也就是我们看到的“带参数”的装饰器。可见，只要 <code>dec(arg)</code> 的返回值满足 “装饰器” 的定义即可。（接受一个函数，并返回一个新的函数）。</p><h3 id="2-2-3- 多层装饰器"><a href="#2-2-3- 多层装饰器" class="headerlink" title="2.2.3 多层装饰器"></a>2.2.3 多层装饰器 </h3><p> 以下是个带参数的多层装饰器</p><pre><code class="python">import timedef level(level, *args1, **kwargs1):    def timer(func):        &quot;&quot;&quot; 第一步确定需要装饰的对象 &quot;&quot;&quot;        def warper(*agrs, **kwargs):            &quot;&quot;&quot; 第二步 给对象穿衣服（装饰）&quot;&quot;&quot;            start_time = time.time()            print(&quot; 当前的权限级别 &quot;, level)            print(&quot; 当前的使用的对象 &quot;, func)            print(&quot; 当前的参数 &quot;, (agrs, kwargs))            result = func(*agrs, **kwargs)            time.sleep(0.0001)            print(time.time() - start_time)            return result        return warper    return timer@level(5)def sub(x, y=10):    result = x - y    return resultresult=sub(3)print(result)// 输出结果：当前的权限级别 5当前的使用的对象 &lt;function sub at 0x000001AA13109400&gt;当前的参数 ((3,), &#123;&#125;)0.0030984878540039062-7</code></pre><h3 id="2-2-4- 类装饰器"><a href="#2-2-4- 类装饰器" class="headerlink" title="2.2.4 类装饰器"></a>2.2.4 类装饰器 </h3><p> 如果说 Python 里一切都是对象的话，那函数怎么表示成对象呢？其实只需要一个类实现 <code>__call__</code> 方法即可。<strong><strong>call</strong>()是一个特殊方法，它可将一个类实例变成一个可调用对象</strong>:</p><pre><code class="python">class Timer:    def __init__(self, func):        self._func = func    def __call__(self, *args, **kwargs):        print(&#39;__call__方法被执行 &#39;)        result = self._func(*args, **kwargs)        return result@Timerdef add():    print(&#39;add 函数被执行 &#39;)add()          //Timer(add())</code></pre><p>也就是说把类的构造函数当成了一个装饰器，它接受一个函数作为参数，并返回了一个对象，而由于对象实现了 <code>__call__</code> 方法，因此返回的对象相当于返回了一个函数。因此该类的构造函数就是一个装饰器。</p><p><strong>简单来理解：调用了 Timer 类，则必然会调用 <code>__call__</code> 方法。<code>__call__</code>就是调用执行的意思，如 add()等同于<code>add.__call__()</code>。</strong></p><h3 id="2-2-5- 装饰器链"><a href="#2-2-5- 装饰器链" class="headerlink" title="2.2.5 装饰器链"></a>2.2.5 装饰器链 </h3><p><strong> 一个 python 函数也可以被多个装饰器修饰。执行顺序是从近到远依次执行。</strong></p><pre><code class="python">import timeclass Timer:    def __init__(self, func):        self._func = func    def __call__(self, *args, **kwargs):        before = time.time()        result = self._func(*args, **kwargs)        after = time.time()        print(&quot;elapsed: &quot;, after - before)        return resultdef sum(func):    def wrapper(*args, **kwargs):        result=func(*args, **kwargs)        print(&#39;sum 被调用 &#39;)        return result    return wrapper@sum@Timerdef add(x, y=100000):    return x**yresults=add(3)print(results)// 输出结果elapsed:  0.0059871673583984375sum 被调用1334971414230401469458914390489782292……// 从结果看，Timer 装饰器先被调用，然后再调用 sum//Timer(add(3))、sum(add(3))</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mongodb 数据库入门</title>
      <link href="/Mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"/>
      <url>/Mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 <strong>WEB 应用 </strong> 提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><p>Mongo 最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言。</p><p><strong>MongoDB 数据存储方式 </strong>：<strong> 虚拟内存 + 持久化</strong>，使用的内存映射技术，写入数据时候只要在内存里完成就可以返回给应用程序，这样并发量自然就很高。然后再将数据从内存里写到硬盘保存。（当然，mongdb 也支持把常用的数据放在内存里供读取，以提高效率）。</p><h1 id="1-Mongodb 准备"><a href="#1-Mongodb 准备" class="headerlink" title="1. Mongodb 准备"></a>1. Mongodb 准备 </h1><h2 id="1-1-Windows"><a href="#1-1-Windows" class="headerlink" title="1.1 Windows"></a>1.1 Windows</h2><h3 id="1-1-1- 下载与安装："><a href="#1-1-1- 下载与安装：" class="headerlink" title="1.1.1 下载与安装："></a>1.1.1 下载与安装：</h3><p> 下载地址：<a href="https://www.mongodb.com/download-center/community">https://www.mongodb.com/download-center/community</a></p><p>下载完成之后可以选择自定义安装</p><h3 id="1-1-2- 配置"><a href="#1-1-2- 配置" class="headerlink" title="1.1.2 配置"></a>1.1.2 配置</h3><p>（1）认识执行命令</p><p><code>mongo</code>  用于连接 mongodb 数据库服务器</p><p><code>mongod</code> 用于开启服务器</p><h3 id="1-1-3- 设置环境变量"><a href="#1-1-3- 设置环境变量" class="headerlink" title="1.1.3 设置环境变量"></a>1.1.3 设置环境变量 </h3><p> 将执行文件所在的目录设置为环境变量 D:\Database\Mongodb\bin\</p><h3 id="1-1-4- 创建文件夹"><a href="#1-1-4- 创建文件夹" class="headerlink" title="1.1.4 创建文件夹"></a>1.1.4 创建文件夹</h3><p>D:\Database\Mongodb\data 用于存储数据库</p><p>D:\Database\Mongodb\log 用于存储日志</p><h3 id="1-1-5- 开启服务器（挂起）"><a href="#1-1-5- 开启服务器（挂起）" class="headerlink" title="1.1.5 开启服务器（挂起）"></a>1.1.5 开启服务器（挂起）</h3><p>CMD 命令行下（以管理员身份）</p><p><code>mongod -dppath D:\Database\Mongodb\data --logpath D:\Database\Mongodb\log</code></p><p>开启服务，并指定数据存储位置和日志存储位置</p><p>服务开启后会自动挂在后台，可在：任务管理器 \ 服务 中看到</p><p>将 mongodb 挂载成 windows 服务，开机自启动：</p><p><code>mongod -dppath D:\Database\Mongodb\data --logpath D:\Database\Mongodb\log  --install --serviceName &quot;Mongodb&quot;</code></p><p>操作服务的命令：</p><p>net start mongodb 开启 mongodb 服务</p><p>net stop mongodb 关闭 mongodb 服务</p><p>sc delete mongodb 卸载 mongodb 服务</p><h3 id="1-1-6- 连接服务器"><a href="#1-1-6- 连接服务器" class="headerlink" title="1.1.6 连接服务器"></a>1.1.6 连接服务器</h3><p><code>mongo</code></p><p><code>show dbs</code>显示所有数据库列表</p><h2 id="1-2-Linux"><a href="#1-2-Linux" class="headerlink" title="1.2 Linux"></a>1.2 Linux</h2><p>下载安装：<code>sudo apt install mongodb-server</code></p><p>添加到 Path 路径中：<code>export PATH=/usr/local/mongodb4/bin:$PATH</code></p><p>设置数据存储目录及日志文件目录：</p><pre><code>sudo mkdir -p /var/lib/mongosudo mkdir -p /var/log/mongodbsudo chown `whoami` /var/lib/mongo     # 设置权限sudo chown `whoami` /var/log/mongodb   # 设置权限mongod --dbpath /var/lib/mongo --logpath /var/log/mongodb/mongod.log --forkmongo   #启动</code></pre><h1 id="2- 数据库操作"><a href="#2- 数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h1><h2 id="2-1- 基础命令"><a href="#2-1- 基础命令" class="headerlink" title="2.1 基础命令"></a>2.1 基础命令</h2><p><code>show dbs;</code>   显示数据库列表</p><p><code>db;</code> 显示当前正在使用的数据库</p><p><code>use dbname;</code> 创建或切换数据库  </p><p>如果数据库不存在，则创建数据库 dbname，否则切换到指定数据库 dbname。创建的数据库并不在数据库的列表中，要显示它，我们需要向数据库 dbname 插入一些数据。</p><p><code>db.dropDatabase();</code> 切到要删除的数据库，就可以删除数据库</p><p><strong>MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。</strong></p><h2 id="1-2- 集合操作"><a href="#1-2- 集合操作" class="headerlink" title="1.2 集合操作"></a>1.2 集合操作 </h2><p> 注意：<strong>正常来讲在 MongoDB 中不需要创建集合。当插入一些文档时，MongoDB 会自动创建集合。</strong></p><h3 id="1-2-1- 创建集合"><a href="#1-2-1- 创建集合" class="headerlink" title="1.2.1 创建集合"></a>1.2.1 创建集合</h3><p><code>db.createCollection(name, options);</code></p><p>name 是要创建的集合的名称</p><p>options 是一个文档，用于指定集合的配置</p><p>选项参数是可选的，所以只需要到指定的集合名称。</p><p>例 1：不限制集合大小</p><p><code>db.createCollection(&quot;stu&quot;)</code></p><p>例 2：限制集合大小，后面学会插入语句后可以查看效果</p><p>参数 capped：默认值为 false 表示不设置上限，值为 true 表示设置上限</p><p>参数 size：当 capped 值为 true 时，需要指定此参数，表示上限大小，当文档达到上限时，会将之前的数据覆盖，单位为字节。如：</p><p><code>db.createCollection(&quot;sub&quot;, &#123; capped : true, size : 10 &#125;)</code></p><h3 id="1-2-2- 显示集合"><a href="#1-2-2- 显示集合" class="headerlink" title="1.2.2  显示集合"></a>1.2.2  显示集合</h3><p><code>show collections;</code> 显示数据库中的集合列表</p><h3 id="1-2-3- 删除集合"><a href="#1-2-3- 删除集合" class="headerlink" title="1.2.3  删除集合"></a>1.2.3  删除集合</h3><p><code>db. 集合名.drop();</code> 删除指定的集合</p><h2 id="2-3- 数据操作（重点）"><a href="#2-3- 数据操作（重点）" class="headerlink" title="2.3 数据操作（重点）"></a>2.3 数据操作（重点）</h2><h3 id="2-3-1- 增加数据"><a href="#2-3-1- 增加数据" class="headerlink" title="2.3.1 增加数据"></a>2.3.1 增加数据</h3><p><code>db.web.insert(&#123;&quot;name&quot;:&quot;ghost&quot;, &quot;age&quot;:10&#125;)</code></p><p>在 web 集合中插入一条新数据，如果没有 web 这个集合，mongodb 会自动创建</p><p>_id 是主键，主键是每条数据的唯一标识，不能重复，就像身份证是每个人唯一的编号一样。</p><h3 id="2-3-2- 查看数据"><a href="#2-3-2- 查看数据" class="headerlink" title="2.3.2 查看数据"></a>2.3.2 查看数据 </h3><p><code>db. 集合名.find();</code> 查找 users 集合中所有数据</p><p><code>db. 集合名.findOne();</code> 查找 users 集合中的第一条数据</p><p><code>db. 集合名.find().pretty();</code>  格式化查询到的数据</p><p>示例：</p><pre><code>db.web.find();&#123; &quot;_id&quot; : ObjectId(&quot;5e70f05a7de50c32cd5380c9&quot;), &quot;name&quot; : &quot;ghost&quot;, &quot;age&quot; : 10 &#125;</code></pre><h3 id="2-3-3- 修改数据"><a href="#2-3-3- 修改数据" class="headerlink" title="2.3.3 修改数据"></a>2.3.3 修改数据</h3><p><code>db. 集合名.update(&#123; 查询条件 &#125;,&#123; 修改的目标 &#125;);</code></p><p><code>db. 集合名.update(&#123; 查询条件 &#125;,&#123;$set:&#123;&#39; 键名 &#39;:&#39; 新的值 &#39;&#125;&#125;);</code> 修改指定键名的值</p><p>示例：</p><pre><code>db.web.update(&#123;&quot;name&quot;:&quot;a1&quot;&#125;, &#123;&quot;age&quot;:10&#125;);db.web.update(&#123;&quot;name&quot;:&quot;a1&quot;&#125;, &#123;$set:&#123;&quot;age&quot;:10&#125;&#125;);</code></pre><h3 id="2-3-4- 删除数据"><a href="#2-3-4- 删除数据" class="headerlink" title="2.3.4 删除数据"></a>2.3.4 删除数据 </h3><p><code>db.users.remove(&#123;&#125;);</code> 删除集合中全部数据</p><p><code>db.users.remove(&#123; 查询条件 &#125;);</code>删除集合中全部数据</p><p>示例：</p><pre><code>db.users.remove(&#123;&quot;name&quot;: &quot;lecaf&quot;&#125;)   删除 users 集合下 name=”lecaf”的数据</code></pre><h1 id="3- 高级命令"><a href="#3- 高级命令" class="headerlink" title="3. 高级命令"></a>3. 高级命令</h1><h2 id="3-1- 按条件查询"><a href="#3-1- 按条件查询" class="headerlink" title="3.1 按条件查询"></a>3.1 按条件查询</h2><h3 id="3-1-1- 根据条件查询"><a href="#3-1-1- 根据条件查询" class="headerlink" title="3.1.1 根据条件查询"></a>3.1.1 根据条件查询</h3><p><code>db. 集合名.find(&#123; 查询条件 &#125;);</code></p><p>示例：</p><pre><code>db.singer.find(&#123;&quot;sex&quot;:&quot; 男 &quot;&#125;)；</code></pre><h3 id="3-1-2-gt- 大于"><a href="#3-1-2-gt- 大于" class="headerlink" title="3.1.2 $gt 大于"></a>3.1.2 $gt 大于</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;:&#123;$gt: 值 &#125;&#125;);</code></p><p>示例：</p><pre><code>`db.singer.find(&#123;&quot;age&quot;:&#123;$gt:50&#125;&#125;);`查询所有年龄大于 50 的歌手</code></pre><h3 id="3-1-3-lt- 小于"><a href="#3-1-3-lt- 小于" class="headerlink" title="3.1.3 $lt 小于"></a>3.1.3 $lt 小于</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;:&#123;$lt: 值 &#125;&#125;);</code></p><h3 id="3-1-4-gte- 大于等于"><a href="#3-1-4-gte- 大于等于" class="headerlink" title="3.1.4 $gte 大于等于"></a>3.1.4 $gte 大于等于</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;:&#123;$gte: 值 &#125;&#125;);</code></p><h3 id="3-1-5-lte- 大于等于"><a href="#3-1-5-lte- 大于等于" class="headerlink" title="3.1.5 $lte 大于等于"></a>3.1.5 $lte 大于等于</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;:&#123;$lte: 值 &#125;&#125;);</code></p><h3 id="3-1-6- 选择区间"><a href="#3-1-6- 选择区间" class="headerlink" title="3.1.6 选择区间"></a>3.1.6 选择区间</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;:&#123;$gt: 值 1,$lt: 值 2&#125;&#125;);</code></p><h3 id="3-1-7-ne- 不等于"><a href="#3-1-7-ne- 不等于" class="headerlink" title="3.1.7 $ne 不等于"></a>3.1.7 $ne 不等于</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;:&#123;$ne: 值 &#125;&#125;);</code></p><h3 id="3-1-8-in- 在集合中"><a href="#3-1-8-in- 在集合中" class="headerlink" title="3.1.8 $in 在集合中"></a>3.1.8 $in 在集合中</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;:&#123;$in:&#123; 值 1, 值 2, 值 n&#125;&#125;&#125;);</code></p><h3 id="3-1-9-nin- 不在集合中"><a href="#3-1-9-nin- 不在集合中" class="headerlink" title="3.1.9 $nin 不在集合中"></a>3.1.9 $nin 不在集合中</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;:&#123;$nin:&#123; 值 1, 值 2, 值 n&#125;&#125;&#125;);</code></p><h3 id="3-1-10-size- 值的个数"><a href="#3-1-10-size- 值的个数" class="headerlink" title="3.1.10 $size 值的个数"></a>3.1.10 $size 值的个数</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;:&#123;$size:num&#125;&#125;);</code></p><p>示例：</p><pre><code>`db.singers.find(&#123;&quot;works&quot;:&#123;$size:2&#125;&#125;);`</code></pre><h3 id="3-1-11-exists- 是否存在某个键名"><a href="#3-1-11-exists- 是否存在某个键名" class="headerlink" title="3.1.11 $exists 是否存在某个键名"></a>3.1.11 $exists 是否存在某个键名</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;:&#123;$exists:true|false&#125;&#125;);</code></p><h3 id="3-1-12-or- 存在任意一个"><a href="#3-1-12-or- 存在任意一个" class="headerlink" title="3.1.12 $or 存在任意一个"></a>3.1.12 $or 存在任意一个</h3><p><code>db. 集合名.find(&#123;$or:[条件 1, 条件 2, 条件 n]&#125;);</code></p><h3 id="3-1-13- 模糊查询"><a href="#3-1-13- 模糊查询" class="headerlink" title="3.1.13 模糊查询"></a>3.1.13 模糊查询</h3><p><code>db. 集合名.find(&#123;&quot; 键名 &quot;, 值 &#125;);</code></p><p>示例：</p><pre><code>db.singers.find(&#123;&quot;name&quot;,/xx/&#125;);   #查出含 XX 的歌手db.singers.find(&#123;&#39;name&#39;:/^xx/&#125;)； #查出所有以 xx 开头的歌手db.singers.find(&#123;&#39;name&#39;:/xx^/&#125;)； #查出所有以 xx 结尾的歌手db.singers.find(&#123;&#39;name&#39;:/xx/i&#125;)； #查出所有含 xx（忽略大小写）的歌手</code></pre><h2 id="3-2- 排序"><a href="#3-2- 排序" class="headerlink" title="3.2 排序"></a>3.2 排序</h2><p><code>db. 集合名.find(&#123;&#125;).sort(&#123;&quot; 键名 1&quot;:1,&quot; 键名 2&quot;:-1&#125;)</code></p><p>1：升序</p><p>-1：降序</p><h2 id="3-3- 限制输出"><a href="#3-3- 限制输出" class="headerlink" title="3.3 限制输出"></a>3.3 限制输出</h2><h3 id="3-3-1-limit"><a href="#3-3-1-limit" class="headerlink" title="3.3.1 limit()"></a>3.3.1 limit()</h3><p><code>db. 集合名.find(&#123;&#125;).limit(n)</code></p><p>示例：</p><pre><code>db. 集合名.find(&#123;&#125;).sort(&#123;&quot;age&quot;:1&#125;).limit(3)找出年龄最小的三个歌手</code></pre><h3 id="3-3-2-skip"><a href="#3-3-2-skip" class="headerlink" title="3.3.2 skip()"></a>3.3.2 skip()</h3><p><code>db. 集合名.find(&#123;&#125;).skip(n)</code></p><p>示例：</p><pre><code>db. 集合名.find(&#123;&#125;).sort(&#123;&quot;age&quot;:1&#125;).skip(3).limit(3)找出年龄最小的三个以外的 2 个歌手 </code></pre><p> 这个方法通常的用法是实现分页。</p><h2 id="3-4- 数据类型"><a href="#3-4- 数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h2><p>Mongdb 中常见的数据类型：</p><p>● Object ID： ⽂档 ID<br>● String： 字符串， 最常⽤， 必须是有效的 UTF-8<br>● Boolean： 存储⼀个布尔值， true 或 false<br>● Integer： 整数可以是 32 位或 64 位， 这取决于服务器<br>● Double： 存储浮点值<br>● Arrays： 数组或列表， 多个值存储到⼀个键<br>● Object： ⽤于嵌⼊式的⽂档， 即⼀个值为⼀个⽂档<br>● Null： 存储 Null 值<br>● Timestamp： 时间戳， 表示从 1970-1-1 到现在的总秒数<br>● Date： 存储当前⽇期或时间的 UNIX 时间格式</p><h3 id="3-4-1-Object-ID"><a href="#3-4-1-Object-ID" class="headerlink" title="3.4.1 Object ID"></a>3.4.1 Object ID</h3><p>每个文档都有一个属性，为_id，以保证每个文档的唯一性。mongodb 默认使用 id 作为主键。</p><p>可以自己指定设置，也可以自动生成。</p><p>默认生成的 Object ID 是十六进制的 12 位数。</p><h1 id="4- 聚合与分组"><a href="#4- 聚合与分组" class="headerlink" title="4. 聚合与分组"></a>4. 聚合与分组</h1><h2 id="4-1- 聚合"><a href="#4-1- 聚合" class="headerlink" title="4.1 聚合"></a>4.1 聚合</h2><pre><code>db. 集合名.aggregate([                    &#123; 管道 1:&#123; 表达式 1&#125;&#125;,                    &#123; 管道 2:&#123; 表达式 2&#125;&#125;,                    &#123; 管道 3:&#123; 表达式 3&#125;&#125;,                    ])</code></pre><p>管道：管道一般用于将当前的命令的输出结果作为下一个命令的输入，在 mongodb 中，管道具有同样的作用，文档处理完毕后，通过管道进行下一次的处理。</p><p><strong>常用的管道：</strong></p><ul><li>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</li><li>$match：用于过滤数据，只输出符合条件的文档。$match 使用 MongoDB 的标准查询操作。</li><li>$limit：用来限制 MongoDB 聚合管道返回的文档数。</li><li>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</li><li>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</li><li>$group：将集合中的文档分组，可用于统计结果。</li><li>$sort：将输入文档排序后输出。</li><li>$geoNear：输出接近某一地理位置的有序文档。</li></ul><p><strong>常用的表达式：</strong></p><ul><li><p>$sum：对目标键对应的值计算总和。</p></li><li><p>$avg：对目标键对应的值计算平均值。</p></li><li><p>$min：取目标键对应的值的最小值。</p></li><li><p>$max：取目标键对应的值的最大值。</p></li><li><p>$push：取出目标值组成一个数组</p></li><li><p>$addToSet：在结果文档中插入值到一个数组中，但不创建副本。</p></li><li><p>$first：取目标键对应的值的第一个文档数据。</p></li><li><p>$last：取目标键对应的值的最后一个文档数据。</p></li></ul><p>更多请参阅官方文档。</p><h2 id="4-2- 聚合示例"><a href="#4-2- 聚合示例" class="headerlink" title="4.2 聚合示例"></a>4.2 聚合示例 </h2><h3 id="4-2-1-group"><a href="#4-2-1-group" class="headerlink" title="4.2.1 $group"></a>4.2.1 $group</h3><p> 作用：分组</p><pre><code>db. 集合名.aggreate(     &#123;$group:         &#123;         _id:&#39;$ 字段名 &#39;         别名：&#123;$ 聚合函数：&#39;$ 字段名 &#39;&#125;         &#125;      &#125;)</code></pre><p>示例：</p><pre><code>统计男和女生的总人数db.singer.aggreate(     &#123;$group:         &#123;         _id:&#39;$sex&#39;,         count：&#123;$sum：1&#125;         &#125;      &#125;)输出结果：&lt;&quot;_id&quot;:&quot; 男 &quot;,&quot;count&quot;:11&gt;&lt;&quot;_id&quot;:&quot; 女 &quot;,&quot;count&quot;:4&gt;统计男和女生的总人数及名单db.singer.aggreate(     &#123;$group:         &#123;         _id:null,         总人数:&#123;$sum：1&#125;         平均年龄:&#123;&#39;$avg&#39;:&#39;$age&#39;&#125;         名单:&#123;$push:&#39;$name&#39;&#125;         &#125;      &#125;)输出结果：&lt;&quot;_id&quot;:null,&quot; 总人数 &quot;:15,&quot; 平均年龄 &quot;:42.666,&quot; 名单 &quot;:[&#39; 刘德华 &#39;,&#39; 许嵩 &#39;,&#39; 周华健 &#39;……]&gt;</code></pre><h3 id="4-2-2-match"><a href="#4-2-2-match" class="headerlink" title="4.2.2 $match"></a>4.2.2 $match</h3><p>作用：过滤</p><pre><code>db. 集合名.aggreate(&#123;$match:&#123;&quot; 键名 &quot;:&#123;$gt:30&#125;&#125;&#125;)</code></pre><p>示例：</p><pre><code>对年龄大于 40 的歌手进行性别分组统计db.singer.aggreate([     &#123;$match:&#123;&quot;age&quot;:&#123;$gt:40&#125;&#125;&#125;,     &#123;$group:&#123;_id:&#39;$sex&#39;, 总人数:&#123;$sum:1&#125;&#125;&#125;     ])输出结果：&lt;&quot;_id&quot;:&quot; 男 &quot;,&quot; 总人数 &quot;:8&gt;&lt;&quot;_id&quot;:&quot; 女 &quot;,&quot; 总人数 &quot;:1&gt;</code></pre><h3 id="4-2-3-project"><a href="#4-2-3-project" class="headerlink" title="4.2.3 $project"></a>4.2.3 $project</h3><p>作用：限定输出字段</p><pre><code>db. 集合名.aggreate(&#123;$project:&#123;&quot; 键名 &quot;:1)  //1 表示显示，0 表示不显示 </code></pre><p> 示例：</p><pre><code>找出年龄大于 50 的选手，只显示姓名和年龄db.singer.aggreate([     &#123;$match:&#123;&quot;age&quot;:&#123;$gt:50&#125;&#125;&#125;,     &#123;$group:&#123;_id:0,name:1,age:1&#125;&#125;     ])</code></pre><h3 id="4-2-4-sort"><a href="#4-2-4-sort" class="headerlink" title="4.2.4 $sort"></a>4.2.4 $sort</h3><p>作用：排序</p><pre><code>db. 集合名.aggreate(&#123;$project:&#123;&quot; 键名 &quot;:1|-1&#125;&#125;)  //1 表示升序，-1 表示降序 </code></pre><p> 示例：</p><pre><code>db.singer.aggreate([     &#123;$match:&#123;&quot;age&quot;:&#123;$gt:50&#125;&#125;&#125;,     &#123;$group:&#123;_id:0,name:1,age:1&#125;&#125;,     &#123;$sort:&#123;age:1&#125;&#125;,     &#123;$limit:3&#125;     ])</code></pre><h3 id="4-2-5-skip"><a href="#4-2-5-skip" class="headerlink" title="4.2.5 $skip"></a>4.2.5 $skip</h3><p>作用：跳过</p><pre><code>db. 集合名.aggreate(&#123;$skip:n&#125;)  </code></pre><h3 id="4-2-6-unwind"><a href="#4-2-6-unwind" class="headerlink" title="4.2.6 $unwind"></a>4.2.6 $unwind</h3><p>作用：拆分字段</p><pre><code>db. 集合名.aggreate(&#123;$unwind:&quot; 键名 &quot;&#125;)  </code></pre><h1 id="5- 安全"><a href="#5- 安全" class="headerlink" title="5. 安全"></a>5. 安全 </h1><h2 id="5-1- 进入管理平台"><a href="#5-1- 进入管理平台" class="headerlink" title="5.1 进入管理平台"></a>5.1 进入管理平台</h2><p> 首先以无密码形式登陆：<code>mongo</code></p><h2 id="5-2- 创建管理员"><a href="#5-2- 创建管理员" class="headerlink" title="5.2 创建管理员"></a>5.2 创建管理员 </h2><p> 新建数据库：admin</p><p><code>use admin</code></p><p>创建用户名及密码</p><p><code>db.createUser(&#123;user:&quot;admin&quot;,pwd:&quot;123&quot;,roles:[&quot;root&quot;]&#125;)</code></p><h2 id="5-3- 验证账户和密码"><a href="#5-3- 验证账户和密码" class="headerlink" title="5.3 验证账户和密码"></a>5.3 验证账户和密码</h2><p><code>db.auth(&quot;admin&quot;,&quot;123&quot;)</code></p><h2 id="5-4- 挂起需要验证的服务"><a href="#5-4- 挂起需要验证的服务" class="headerlink" title="5.4 挂起需要验证的服务"></a>5.4 挂起需要验证的服务 </h2><p> 先停止已有的服务，并卸载：<code>sc delete mongodb</code></p><p>重新挂载服务：</p><p><code>mongod -dppath D:\Database\Mongodb\data --logpath D:\Database\Mongodb\log  --install --serviceName &quot;Mongodb&quot; --auth</code></p><p>–auth 开启需要身份验证</p><p>服务可以临时挂起多个。</p><h2 id="5-5- 测试账户"><a href="#5-5- 测试账户" class="headerlink" title="5.5 测试账户"></a>5.5 测试账户</h2><p><code>show dbs</code> 会显示 无法访问，需要身份验证</p><p>切换到 admin 数据库，再验证。</p><p><code>db.auth(账户, 密码)</code></p><h2 id="5-6- 为指定数据库添加用户"><a href="#5-6- 为指定数据库添加用户" class="headerlink" title="5.6 为指定数据库添加用户"></a>5.6 为指定数据库添加用户</h2><p><code>db.createUser(&#123;user:&quot;itsource&quot;,pwd:&quot;123&quot;,roles:[&#123;role:&quot;dbOwer&quot;,db:&quot;python&quot;&#125;]&#125;)</code></p><h1 id="6- 主从服务器"><a href="#6- 主从服务器" class="headerlink" title="6. 主从服务器"></a>6. 主从服务器 </h1><p> 主从服务器：也叫复制，将数据同步在多个服务器的过程。主服务器用来写，从服务器用来读。</p><p>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。</p><p>复制还允许您从硬件故障和服务中断中恢复数据。</p><ul><li><p>复制原理</p><p>mongodb 的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。</p><p>mongodb 各个节点常见的搭配方式为：一主一从、一主多从。</p><p>主节点记录在其上的所有操作 oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p></li><li><p>为什么要复制</p><p>数据备份</p><p>数据灾难恢复</p><p>读写分离</p><p>数据可用性高</p><p>无宕机维护</p><p>副本集对应的程序是透明</p></li></ul><h2 id="6-1- 设置复制节点"><a href="#6-1- 设置复制节点" class="headerlink" title="6.1 设置复制节点"></a>6.1 设置复制节点 </h2><h3 id="6-1-1- 创建数据库目录"><a href="#6-1-1- 创建数据库目录" class="headerlink" title="6.1.1 创建数据库目录"></a>6.1.1 创建数据库目录</h3><p> 创建两个数据库目录，如 db1，db2，用于挂起两个 mongodb 服务。</p><h3 id="6-1-2- 启动 mongodb 服务"><a href="#6-1-2- 启动 mongodb 服务" class="headerlink" title="6.1.2 启动 mongodb 服务"></a>6.1.2 启动 mongodb 服务 </h3><p> 使用如下格式启动 mongod，注意 replSet 的名称是一样的。</p><p><code>mongod --bind_ip 192.168.0.104 --port 27017 --dbpath d:\Database\Mongodb\db1 --replSet rs0</code></p><p><code>mongod --bind_ip 192.168.0.104 --port 27018 --dbpath d:\Database\Mongodb\db2 --replSet rs0</code></p><p><strong>注意上面的要写自己的 ip，开两个命令行分别输入以上两个命令，这两个服务器同属于集群 rs0。</strong></p><h3 id="6-1-3- 连接服务器"><a href="#6-1-3- 连接服务器" class="headerlink" title="6.1.3 连接服务器"></a>6.1.3 连接服务器 </h3><p> 连接服务器，此处设置 <code>192.168.0.104:27017</code> 为主服务器。再打开一个命令行，输入：</p><p><code>mongo --host 192.168.0.104 --port 27017</code></p><p>先连接的为主服务器。</p><h3 id="6-1-4- 初始化"><a href="#6-1-4- 初始化" class="headerlink" title="6.1.4 初始化"></a>6.1.4 初始化</h3><p><code>rs.initiate()</code></p><h3 id="6-1-5- 查看当前状态"><a href="#6-1-5- 查看当前状态" class="headerlink" title="6.1.5 查看当前状态"></a>6.1.5 查看当前状态</h3><p><code>rs.status()</code></p><h3 id="6-1-6- 添加副本集"><a href="#6-1-6- 添加副本集" class="headerlink" title="6.1.6 添加副本集"></a>6.1.6 添加副本集</h3><p><code>rs.add(&quot;192.168.0.104:27018&quot;)</code></p><h3 id="6-1-7- 连接从服务器"><a href="#6-1-7- 连接从服务器" class="headerlink" title="6.1.7 连接从服务器"></a>6.1.7 连接从服务器</h3><p><code>mongo --host 192.168.0.104 --port 27018</code></p><h3 id="6-1-8- 在从服务器中查询"><a href="#6-1-8- 在从服务器中查询" class="headerlink" title="6.1.8 在从服务器中查询"></a>6.1.8 在从服务器中查询 </h3><p> 在从服务器中进行读操作，需要设置：</p><p><code>rs.slaveOk()</code></p><p><code>db.users,find()</code></p><h3 id="6-1-9- 其他"><a href="#6-1-9- 其他" class="headerlink" title="6.1.9 其他"></a>6.1.9 其他 </h3><p> 主从切换：主从服务器可以自行切换，无需人为设置</p><pre><code>主服务器标志：rs0:PRIMARY&gt;从服务器标志：rs0:SECONDARY&gt;</code></pre><p>删除从节点：</p><p><code>rs.remove(&quot;192.168.0.104:27018&quot;)</code></p><h1 id="7- 备份与恢复"><a href="#7- 备份与恢复" class="headerlink" title="7. 备份与恢复"></a>7. 备份与恢复 </h1><h2 id="7-1- 备份"><a href="#7-1- 备份" class="headerlink" title="7.1 备份"></a>7.1 备份</h2><p> 语法：<code>mongodump --h dbhost -d dbname -o dbdirectory</code></p><p>-h：指定服务器地址，也可指定端口号</p><p>-d：需要备份的数据库名称</p><p>-o：备份数据存放的位置，此目录中存放这备份出来的数据</p><p>示例：</p><pre><code>mongodump --h 127.0.0.1:27017 -d itsource -o d:\bakup</code></pre><p><strong>注意：备份前保证服务器在后台开着</strong></p><h2 id="7-2- 恢复"><a href="#7-2- 恢复" class="headerlink" title="7.2 恢复"></a>7.2 恢复 </h2><p> 语法：<code>mongorestore --h dbhost -d dbname --dir dbdirectory</code></p><p>-h：指定服务器地址，也可指定端口号</p><p>-d：需要恢复的数据库名称</p><p>-o：备份数据存放的位置。</p><h1 id="8-python 操作"><a href="#8-python 操作" class="headerlink" title="8. python 操作"></a>8. python 操作 </h1><p> 官方文档：<a href="https://pymongo.readthedocs.io/en/stable/tutorial.html">https://pymongo.readthedocs.io/en/stable/tutorial.html</a></p><p>首先安装 python 包：<code>pip install pymongo</code></p><h2 id="8-1- 连接数据库"><a href="#8-1- 连接数据库" class="headerlink" title="8.1 连接数据库"></a>8.1 连接数据库</h2><pre><code class="python">import pymongoclient = pymongo.MongoClient(&#39;localhost&#39;, 27017)db=client[&#39;itsource&#39;]</code></pre><h2 id="8-2- 插入数据"><a href="#8-2- 插入数据" class="headerlink" title="8.2 插入数据"></a>8.2 插入数据</h2><pre><code class="python">db.admin.insert_one(&#123;&#39;name&#39;:&#39; 小明 &#39;,&#39;age&#39;:&#39;18&#39;&#125;)  // 插入一条数据db.admin.insert_many([&#123;&#39;name&#39;:&#39; 小明 &#39;,&#39;age&#39;:&#39;18&#39;&#125;,&#123;&#39;name&#39;:&#39; 张飞 &#39;,&#39;age&#39;:&#39;27&#39;&#125;]) // 插入多条数据</code></pre><h2 id="8-3- 读取数据"><a href="#8-3- 读取数据" class="headerlink" title="8.3 读取数据"></a>8.3 读取数据</h2><pre><code class="python">data=db.admin.find_one()  // 读取一条数据datas=db.admin.find()   // 这里得到的游标，可通过遍历游标获取数据for data in datas:    print(data)print(datas.count) // 打印读取到的数据数目</code></pre><p>还可按条件获取数据：</p><pre><code>datas=db.admin.find(&#39; 条件 &#39;)</code></pre><p>条件语法结构可参照【3.1】</p><h2 id="8-4- 修改文档"><a href="#8-4- 修改文档" class="headerlink" title="8.4 修改文档"></a>8.4 修改文档 </h2><pre><code>db.admin.update_one(filter=&#123; 查询条件 &#125;,update=&#123;&#39;$set&#39;:&#123; 修改目标 &#125;&#125;)</code></pre><p> 示例：</p><pre><code>db.admin.update_one(filter=&#123;&#39;name&#39;:&#39; 小明 &#39;&#125;,update=&#123;&#39;$set&#39;:&#123;&#39;age&#39;:18&#125;&#125;)</code></pre><h2 id="8-5- 删除数据"><a href="#8-5- 删除数据" class="headerlink" title="8.5 删除数据"></a>8.5 删除数据 </h2><p> 语法：<code>db.admin.delete_one(&#123; 条件 &#125;)</code></p><p><code>db.admin.delete_many(&#123; 条件 &#125;)</code></p><p>示例：</p><pre><code>db.admin.delete_many(&#123;&#39;name&#39;:&#39; 小明 &#39;&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么不加个空格呢</title>
      <link href="/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8A%A0%E4%B8%AA%E7%A9%BA%E6%A0%BC%E5%91%A2/"/>
      <url>/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8A%A0%E4%B8%AA%E7%A9%BA%E6%A0%BC%E5%91%A2/</url>
      
        <content type="html"><![CDATA[<p>自动给你的博客的中英文间加上空格</p><p>用 Markdown 编辑器编辑文章部署到网页时，对于英文单词频繁穿插的中文句子来说实在是有点繁琐和难看（特别是技术向文章），自从发现了有自动在博客的中英文间加上空格的脚本后，就放弃手动加空格的做法，这些频繁的工作，就交给脚本去做吧。</p><h2 id="自动加空格的工具 pangu-js"><a href="# 自动加空格的工具 pangu-js" class="headerlink" title="自动加空格的工具 pangu.js"></a>自动加空格的工具 <a href="https://github.com/vinta/pangu.js">pangu.js</a></h2><p><a href="https://github.com/vinta/pangu.js">pangu.js</a> 是一个综合的开源项目，包括了各种平台的“自动加空格”的工具（库），比如浏览器插件、Java、Object-C、Ruby 等。比如我自己，<strong>需要用在自己的博客上，所以选择 JavaScript。</strong></p><h2 id="如何使用"><a href="# 如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>1、首先在你的 Markdown 编辑器中，首行加上一下 js 代码：</p><pre><code class="js">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/pangu/3.2.1/pangu.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>2、然后在适当的时刻（比如写完文章的时候）继续在 Markdown 编辑器中调用以下语句即可。</p><pre><code class="js">&lt;script&gt; pangu.spacingPage();/* 这个是博客全局都进行自动加空格处理 */ &lt;/script&gt;</code></pre><p>以上基本就完事了。</p><ul><li><p>但是如果你不想在博客全局都自动空格处理，可根据需要将 2 中的 <code>pangu.spacingPage();</code> 换成下面的代码：</p><pre><code class="js">pangu.spacingElementById(&#39;main&#39;);/* 在 id=main 的区域进行自动加空格处理 */pangu.spacingElementByClassName(&#39;comment&#39;);/* 在 class=comment 的区域进行自动加空格处理 */pangu.spacingElementByTagName(&#39;p&#39;);/* 在标签 p 里面进行自动加空格处理 */</code></pre></li></ul><p>如以上都配置好了，但是没有生效，可安装：</p><pre><code>npm install pangu --save</code></pre><p>另外，如想更改博客中字体，可至主题文件夹下，如 3-hexo/source/css 下，找到 style.styl 文件夹，第 8 行 font 中添加所需字体，如”Consolas”加到第一个，可优先被调用。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器与生成器</title>
      <link href="/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一、迭代器"><a href="# 一、迭代器" class="headerlink" title="一、迭代器"></a>一、迭代器 </h1><h2 id="1-1- 定义"><a href="#1-1- 定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p> 在讲迭代之前，先搞清楚这些名词：</p><ul><li>循环（loop），指的是在满足条件的情况下，重复执行同一段代码。比如，while 语句。</li><li>迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项。比如，for 语句。</li><li>递归（recursion），指的是一个函数不断调用自身的行为。比如，以编程方式输出著名的斐波纳契数列。</li><li>遍历（traversal），指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。</li></ul><p>能够用循环语句之类的方法来一个一个读取元素的对象，就称之为可迭代的对象。</p><p>可迭代对象有：</p><p>一类是：list、tuple、dict、set、str，这些都是普通的迭代器。</p><p>一类是：generator，这个属于特殊的迭代器，又称生成器。</p><p>用来循环的如 for 就被称之为迭代工具。</p><p>用严格点的语言说：所谓迭代工具，就是能够按照一定顺序扫描迭代对象的每个元素（按照从左到右的顺序）。</p><p>显然，除了 for 之外，还有别的可以称作迭代工具。</p><p>下面介绍一个内置函数 <code>iter()</code></p><p><code>iter()</code>作用是获取可迭代对象的迭代器，常与 <code>next()</code> 配合使用。</p><pre><code class="python">lis=[1,2,3]it=iter(lis)while True:   print(it.__next__())// 运行一次，从 lis 中获取一个结果，按顺序执行。123StopIteration// 以上还可以这样写：while True:   print(next(it))</code></pre><p>当迭代对象 it 被迭代结束，即每个元素都读取了一遍之后，指针就移动到了最后一个元素的后面。如果再访问，指针并没有自动返回到首位置，而是仍然停留在末位置，所以报 StopIteration，想要再开始，需要重新载入迭代对象。所以，当我在上面重新进行迭代对象赋值之后，又可以继续了。这在 for 等类型的迭代工具中是没有的。</p><p>下面再看一个例子：</p><pre><code>f = open(&#39; 并发编程 / 协程 /file.txt&#39;, encoding=&#39;utf-8&#39;)next(f)大千世界，无奇不有。next(f)天地中央，有个曾用一剑劈出天河瀑布的读书人，人间最得意。next(f)东海崖畔，有个不愿飞升枯坐山巅的无名道人，只愿清风拂面。next(f)西方净土，有个喜欢给人说故事的老和尚，豢养有九条天龙。next(f)蛮荒南疆，有个目盲画师，驱使与山岳等高的金甲傀儡，搬动十万大山，铺就一幅锦绣图画。next(f)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration</code></pre><p>由此可见，文件是天然的可迭代对象，不需要用 iter() 转换了。</p><h2 id="1-2- 应用"><a href="#1-2- 应用" class="headerlink" title="1.2 应用"></a>1.2 应用 </h2><p> 判断一个对象是否可迭代：</p><p>可以使用 <code>isinstance()</code> 判断一个对象是否是 <code>Iterable</code> 对象：</p><blockquote><p><code>isinstance()</code> 函数来判断一个对象是否是一个已知的类型，类似 type()。</p></blockquote><pre><code class="python">from collections.abc import IterableIn [1]: isinstance([], Iterable)Out[1]: TrueIn [52]: isinstance(&#123;&#125;, Iterable)Out[2]: TrueIn [3]: isinstance(&#39;abc&#39;, Iterable)Out[3]: TrueIn [4]: isinstance(100, Iterable)Out[4]: False</code></pre><h3 id="iter- 与 -next"><a href="#iter- 与 -next" class="headerlink" title="iter() 与 next()"></a>iter() 与 next()</h3><p>我们可以通过 <code>iter()</code> 函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用 next()函数来获取下一条数据。<code>iter()</code> 函数实际上就是调用了可迭代对象的 <code>__iter__</code> 方法。</p><pre><code class="python">&gt;&gt;&gt;li = [11, 22, 33, 44, 55]&gt;&gt;&gt;li_iter = iter(li)&gt;&gt;&gt;next(li_iter)11&gt;&gt;&gt;next(li_iter)22&gt;&gt;&gt; next(li_iter)33&gt;&gt;&gt; next(li_iter)44&gt;&gt;&gt; next(li_iter)55&gt;&gt;&gt; next(li_iter)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration</code></pre><blockquote><p>注意，当我们已经迭代完最后一个数据之后，再次调用 next()函数会抛出 <code>StopIteration</code> 的异常，来告诉我们所有数据都已迭代完成，不用再执行 next()函数了。</p></blockquote><h3 id="for…in…循环的本质"><a href="#for…in…循环的本质" class="headerlink" title="for…in…循环的本质"></a>for…in…循环的本质 </h3><p>for <strong><code>item</code></strong> in <strong><code>Iterable</code></strong> 循环的本质就是先通过 <code>iter()</code> 函数获取可迭代对象 <code>Iterable</code> 的迭代器，然后对获取到的迭代器不断调用 next() 方法来获取下一个值并将其赋值给 item，当遇到 <code>StopIteration</code> 的异常后循环结束。</p><h3 id="迭代器作用："><a href="# 迭代器作用：" class="headerlink" title="迭代器作用："></a>迭代器作用：</h3><p>节省内存空间！</p><p>不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，而是用到再读取。通过再次调用 next()读取下一个数据。</p><h1 id="二、生成器"><a href="# 二、生成器" class="headerlink" title="二、生成器"></a>二、生成器 </h1><p> 生成器（英文：generator）是一类特殊的迭代器。</p><p>我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合 <code>next()</code> 函数进行迭代使用，我们可以采用更简便的语法，即 <strong> 生成器(generator)</strong>。</p><h2 id="2-1- 简单的生成器"><a href="#2-1- 简单的生成器" class="headerlink" title="2.1 简单的生成器"></a>2.1 简单的生成器</h2><pre><code class="python">g = (x*x for x in range(4))print(g)// 输出结果&lt;generator object &lt;genexpr&gt; at 0x00000233A8DA2D68&gt;</code></pre><p>这是不是跟列表解析很类似呢？仔细观察，它不是列表，如果这样的得到的才是列表：</p><pre><code class="python">my_list = [x*x for x in range(4)]print(my_list)// 输出结果[0, 1, 4, 9]</code></pre><p>以上两的区别在于是 <code>[]</code> 还是 <code>()</code>，虽然是细小的差别，但是结果完全不一样。</p><pre><code class="python">g = (x*x for x in range(4))print(list(g))// 输出结果[0, 1, 4, 9]</code></pre><p>这样生成器又变成了列表！</p><p>对生成器调用 next()方法：</p><pre><code>In [1]: next(g)Out[1]: 0In [2]: next(g)Out[2]: 1In [3]: next(g)Out[3]: 4In [4]: next(g)Out[4]: 9In [5]: next(g)---------------------------------------------------------------------------StopIteration                             Traceback (most recent call last)&lt;ipython-input-24-380e167d6934&gt; in &lt;module&gt;()----&gt; 1 next(my_generator)</code></pre><p>难道生成器就是把列表解析中的 <code>[]</code> 换成 <code>()</code> 就行了吗？这仅仅是生成器的一种表现形式和使用方法罢了，仿照列表解析式的命名，可以称之为“生成器解析式”（或者：生成器推导式、生成器表达式）。</p><h2 id="2-2- 高级生成器："><a href="#2-2- 高级生成器：" class="headerlink" title="2.2 高级生成器："></a>2.2 高级生成器：</h2><p>上述中通过生成器解析式得到的生成器，掩盖了生成器的一些细节，并且适用领域也有限。下面就要剖析生成器的内部，深入理解这个魔法工具。</p><p>python 定义了一个关键词：</p> <center><font size=10 face="times new roman">yield</font></center>作为生成器的标志。<p>例如：</p><pre><code class="python">def g():    yield 0    yield 1    yield 2gen=g()print(gen)// 输出结果&lt;generator object g at 0xb7200edc&gt;</code></pre><p>使用了 <code>yield</code> 代替了<code>return</code>，就把函数 g 变成了一个生成器。</p><p>查看生成器中的方法：</p><pre><code>dir(gen)输出如下[&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__doc__&#39;, &#39;__format__&#39;, &#39;__getattribute__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__iter__&#39;, &#39;__name__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;close&#39;, &#39;gi_code&#39;, &#39;gi_frame&#39;, &#39;gi_running&#39;, &#39;next&#39;, &#39;send&#39;, &#39;throw&#39;]</code></pre><p>在这里看到了<code>__iter__()</code> 和 <code>next()</code>，也可以说明它是迭代器。</p><p>我们把含有 <code>yield</code> 语句的函数称作生成器。生成器是一种用普通函数语法定义的迭代器。通过上面的例子可以看出，这个生成器（也是迭代器），在定义过程中并没有像上节迭代器那样写 <code>__inter__()</code> 和 <code>next()</code>，而是只要用了 <code>yield</code> 语句，那个普通函数就神奇般地成为了生成器，也就具备了迭代器的功能特性。</p><h3 id="2-2-1-yield 与 return 区别"><a href="#2-2-1-yield 与 return 区别" class="headerlink" title="2.2.1 yield 与 return 区别"></a>2.2.1 yield 与 return 区别 </h3><p> 首先看一个普通含 <code>return</code> 的函数：</p><pre><code class="python">def r_return(n):    print(&quot; 进入了函数 &quot;)    while n &gt; 0:        print(&quot; 返回内容之前 &quot;)        return n        n -= 1        print(&quot; 返回内容之后 &quot;)r=r_return(3)print(r)// 输出结果如下进入了函数返回内容之前3</code></pre><p>遇到 <code>return</code> 关键词之后，函数体就停止运行了。</p><p>下面将 <code>return</code> 改为 <code>yield</code>：</p><pre><code class="python">def y_yield(n):    print(&quot; 进入了函数 &quot;)    while n &gt; 0:        print(&quot; 返回内容之前 &quot;)        yield n        n -= 1        print(&quot; 返回内容之后 &quot;)r = y_yield(3)print(next(r))print(next(r))print(next(r))// 输出结果如下进入了函数返回内容之前3返回内容之后返回内容之前2返回内容之后返回内容之前1</code></pre><p>一般的函数，都是止于 <code>return</code>。作为生成器的函数，由于有了 <code>yield</code>，则会遇到它挂起，如果还有 <code>return</code>，遇到它就直接抛出 <code>SoptIteration</code> 异常而中止迭代。</p><p>程序执行的逻辑是：遇到 <code>yield</code> 即返回 <code>n</code>，并挂起等待，直到在执行下一个<code>next()</code> 时，再从挂起的地方继续开始运行……</p><h3 id="2-2-2- 接收参数的生成器"><a href="#2-2-2- 接收参数的生成器" class="headerlink" title="2.2.2 接收参数的生成器"></a>2.2.2 接收参数的生成器 </h3><p> 再看一个例子深入了解生成器的工作原理：</p><pre><code class="python">def foo():    print(&quot;starting...&quot;)    while True:        res = yield &#39; 到我这了 &#39;        print(&quot;res:&quot;, res)f = foo()print(next(f))print(&quot;---&quot; *10)print(next(f))// 输出结果如下：starting...到我这了------------------------------res: None到我这了</code></pre><p><strong>它的运行逻辑是：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-13_22-22-56.png" alt=""></p><p>从Ⅰ部分开始运行，第 1 行将函数实例化，再依次运行第 2 行，next(f) 即运行一次 f， f 就是 foo() ，foo() 里面有 yield ，因此他就是一个生成器，跳转到第Ⅱ部分，到 foo() 函数里面，运行第 1 行，输出 “starting…’’ ，接下来进入到 while 循环里面， 执行第 2 行，yield 返回一个 ‘’到我这了’’ 直接给到  foo() ， 输出 ‘’到我这了’’，而 res 只能接受到 None ，此时不再进一步执行，yield 挂起，在第 2 行执行完毕被挂起，第一个 next(f)执行完毕。</p><p>回到第Ⅰ部分，执行第 3 行，输出 ‘’——————————‘’ ，接着执行第 4 行，又是一个 next(f) ，再跳到第Ⅱ部分，直接进入到第 3 行，（从哪挂起，从哪里开始），输出 ‘’res: None’’ ，while True 还是成立，继续在循环体内运行，执行第 2 行，将 ‘’到我这了’’ yield 出去给到 foo() , 输出 ‘’到我这了’’，res 又只能接受到 None ，此时不再进一步执行，yield 挂起，第二个 next(f)执行完毕。</p><p>最后：程序结束。</p><p>再看一个例子：</p><pre><code class="python">def yield_test(n):    yield n*2    print(&#39;n=&#39; , n)    print(&#39;do something.&#39;)    print(&#39;end.&#39;)#调用生成器for i in yield_test(5):    print(i, &#39;,&#39;)    print(&#39;next&#39;)// 输出结果如下：10 ,nextn= 5do something.end.</code></pre><p>如果你已经明白了第一个例子，那么这个就不难理解了！</p><p>这个循环体只执行了两次。</p><p>只有触发调用生成器返回值 yield 表达式时，才会在生成器内部产生位置记录和循环迭代（如果有可供循环的可迭代值的话），如果调用生成器 yield_test()返回值 yield 表达式时，生成器 yield_test()的返回值 yield 表达式只有一次可迭代值，因为生成器可迭代值只能迭代一次的特性，生成器将不再循环，继续执行生成器剩余代码直至结束。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yield </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反反爬虫之滑块验证码</title>
      <link href="/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8B%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8B%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1- 滑动验证码"><a href="#1- 滑动验证码" class="headerlink" title="1. 滑动验证码"></a>1. 滑动验证码 </h1><p> 说到滑动验证码，一定一定要提某验，虽然说市面上关于滑动验证码的产品有很多，但是某验的地位就像 10 年前脑白金在保健品市场的地位一样，业界标杆啊。</p><p>它越牛逼，市场上用它做防护的网站也越多，像国家企业信用信息公示系统、B 站、京东等等。</p><p>像某验的解决方案也有很多，不过原理大同小异。</p><h2 id="1-1- 简单滑动验证码"><a href="#1-1- 简单滑动验证码" class="headerlink" title="1.1 简单滑动验证码"></a>1.1 简单滑动验证码 </h2><p> 目标网址：<a href="https://member.zjtcn.com/common/login.html">https://member.zjtcn.com/common/login.html</a></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-08_21-13-51.png" alt=""></p><p>一般来说我们与页面的交互可以使用 <code>Webelement</code> 的方法来进行点击等操作。</p><p>但是，有时候我们需要一些更复杂的动作，类似于拖动，双击，长按等等。</p><p>这时候就需要用到我们的 <code>Action Chains</code>（动作链）了。使用 selenium 去实现。</p><pre><code class="python">from selenium import webdriverurl=&#39;https://member.zjtcn.com/common/login.html&#39;browser=webdriver.Chrome()browser.get(url)slider=browser.find_element_by_css_selector(&#39;.ui-slider-btn&#39;)// 使用动作链action=webdriver.ActionChains(browser)action.click_and_hold(slider).perform()  //perform()是按住不放的意思action.move_by_offset(300,0)action.release().perform()</code></pre><h1 id="2- 极验验证"><a href="#2- 极验验证" class="headerlink" title="2. 极验验证"></a>2. 极验验证</h1><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1327694-20180419013633887-1956614758.png" alt=""></p><p>以上图片是最典型的要属于极验滑动认证了，极验官网：<a href="http://www.geetest.com/。">http://www.geetest.com/。</a></p><p>现在极验验证码已经更新到了 3.0 版本，截至 2017 年 7 月全球已有十六万家企业正在使用极验，每天服务响应超过四亿次，广泛应用于直播视频、金融服务、电子商务、游戏娱乐、政府企业等各大类型网站</p><p>对于这类验证，如果我们直接模拟表单请求，繁琐的认证参数与认证流程会让你蛋碎一地，我们可以用 selenium 驱动浏览器来解决这个问题，大致分为以下几个步骤</p><p><strong>1、输入用户名，密码</strong></p><p><strong>2、点击按钮验证，弹出没有缺口的图</strong></p><p><strong>3、获得没有缺口的图片</strong></p><p><strong>4、点击滑动按钮，弹出有缺口的图</strong></p><p><strong>5、获得有缺口的图片</strong></p><p><strong>6、对比两张图片，找出缺口，即滑动的位移</strong></p><p><strong>7、按照人的行为行为习惯，把总位移切成一段段小的位移</strong></p><p><strong>8、按照位移移动</strong></p><p><strong>9、完成登录</strong></p><p>步骤大致是将缺口图和原图进行对比获取缺口的横坐标，并使用计算完成拖动轨迹模拟，之后使用 selenium 按照轨迹滑动完成缺口的拼接。</p><p>这一类方法的优点是门槛低，原理简单，缺点是完成滑动耗时较长，成功率无法估计（同一轨迹计算规则使用多次后成功率迅速下降）</p><h2 id="2-1- 滑动验证"><a href="#2-1- 滑动验证" class="headerlink" title="2.1 滑动验证"></a>2.1 滑动验证 </h2><p> 目标网址：<a href="http://www.cnbaowen.net/api/geetest">http://www.cnbaowen.net/api/geetest</a></p><p><strong>位移移动相当于匀变速直线运动，类似于小汽车从起点开始运行到终点的过程（首先为匀加速，然后再匀减速）。</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1327694-20180419003434653-666693563.png" alt=""></p><p><strong>其中 a 为加速度，且为恒量（即单位时间内的加速度是不变的），t 为时间</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1327694-20180419004117298-644560068.png" alt=""></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1327694-20180419004741089-303812653.png" alt=""></p><h3 id="2-1-1- 获取图片"><a href="#2-1-1- 获取图片" class="headerlink" title="2.1.1 获取图片"></a>2.1.1 获取图片</h3><pre><code>def get_image(driver, div_path):    &#39;&#39;&#39;    下载无序的图片  然后进行拼接 获得完整的图片    :param driver:    :param div_path:    :return:    &#39;&#39;&#39;    time.sleep(2)    # 获取图片地址    background_images = driver.find_elements_by_xpath(div_path)    # 图片位置信息    location_list = []    # 获取图片碎片    for background_image in background_images:        # 当前碎片位置        location = &#123;&#125;        # 匹配当前图片碎片的地址，位置        result = re.findall(&#39;background-image: url\(&quot;(.*?)&quot;\); background-position: (.*?)px (.*?)px;&#39;,background_image.get_attribute(&#39;style&#39;))        # print(result)        location[&#39;x&#39;] = int(result[0][1])        location[&#39;y&#39;] = int(result[0][2])        image_url = result[0][0]        # 将当前碎片信息添加到图片位置信息列表        location_list.append(location)        print(&#39;==================================&#39;)        # 获取图片        image_url = image_url.replace(&#39;webp&#39;, &#39;jpg&#39;)        # &#39; 替换 url http://static.geetest.com/pictures/gt/579066de6/579066de6.webp&#39;        image_result = requests.get(image_url).content        # with open(&#39;1.jpg&#39;,&#39;wb&#39;) as f:        #     f.write(image_result)        # 是一张无序的图片        image_file = BytesIO(image_result)    // 将 image_result 以二进制的形式写进内存        # image = merge_image(image_file, location_list)        return image_file, location_list</code></pre><h3 id="2-1-2- 对图片进行处理"><a href="#2-1-2- 对图片进行处理" class="headerlink" title="2.1.2 对图片进行处理"></a>2.1.2 对图片进行处理</h3><pre><code>def merge_image(image_file, location_list):    &quot;&quot;&quot;     拼接图片    :param image_file:    :param location_list:    :return:    &quot;&quot;&quot;    im = Image.open(image_file)    im.save(&#39;code.jpg&#39;)    new_im = Image.new(&#39;RGB&#39;, (260, 116))    # 把无序的图片 切成 52 张小图片    im_list_upper = []    im_list_down = []    # print(location_list)    for location in location_list:        # print(location[&#39;y&#39;])        if location[&#39;y&#39;] == -58:  # 上半边            im_list_upper.append(im.crop((abs(location[&#39;x&#39;]), 58, abs(location[&#39;x&#39;]) + 10, 116)))        if location[&#39;y&#39;] == 0:  # 下半边            im_list_down.append(im.crop((abs(location[&#39;x&#39;]), 0, abs(location[&#39;x&#39;]) + 10, 58)))    x_offset = 0    for im in im_list_upper:        new_im.paste(im, (x_offset, 0))  # 把小图片放到 新的空白图片上        x_offset += im.size[0]    x_offset = 0    for im in im_list_down:        new_im.paste(im, (x_offset, 58))        x_offset += im.size[0]    new_im.show()    return new_im</code></pre><h3 id="2-1-3- 计算移动距离"><a href="#2-1-3- 计算移动距离" class="headerlink" title="2.1.3 计算移动距离"></a>2.1.3 计算移动距离</h3><pre><code>def get_distance(image1, image2):    &quot;&quot;&quot;    拿到滑动验证码需要移动的距离    :param image1: 没有缺口的图片对象    :param image2: 带缺口的图片对象    :return: 需要移动的距离    &quot;&quot;&quot;    # print(&#39;size&#39;, image1.size)    threshold = 50    for i in range(0, image1.size[0]):  # 260        for j in range(0, image1.size[1]):  # 160            pixel1 = image1.getpixel((i, j))            pixel2 = image2.getpixel((i, j))            res_R = abs(pixel1[0] - pixel2[0])  # 计算 RGB 差            res_G = abs(pixel1[1] - pixel2[1])  # 计算 RGB 差            res_B = abs(pixel1[2] - pixel2[2])  # 计算 RGB 差            if res_R &gt; threshold and res_G &gt; threshold and res_B &gt; threshold:                return i  # 需要移动的距离</code></pre><h3 id="2-1-4- 获取移动轨迹"><a href="#2-1-4- 获取移动轨迹" class="headerlink" title="2.1.4 获取移动轨迹"></a>2.1.4 获取移动轨迹</h3><pre><code>def get_track(distance):    &#39;&#39;&#39;    拿到移动轨迹，模仿人的滑动行为，先匀加速后匀减速    匀变速运动基本公式：    ① v=v0+at    ② s=v0t+(1/2)at²    ③ v²-v0²=2as    :param distance: 需要移动的距离    :return: 存放每 0.2 秒移动的距离    &#39;&#39;&#39;    # 初速度    v = 0    # 单位时间为 0.2s 来统计轨迹，轨迹即 0.2 内的位移    t = 0.2    # 位移 / 轨迹列表，列表内的一个元素代表 0.2s 的位移    tracks = []    # 当前的位移    current = 0    # 到达 mid 值开始减速    mid = distance * 7 / 8    distance += 10  # 先滑过一点，最后再反着滑动回来    # a = random.randint(1,3)    while current &lt; distance:        # 设置速度        if current &lt; mid:            # 加速度越小，单位时间的位移越小, 模拟的轨迹就越多越详细            a = random.randint(2, 4)  # 加速运动        else:            a = -random.randint(3, 5)  # 减速运动        # 初速度        v0 = v        # 0.2 秒时间内的位移        s = v0 * t + 0.5 * a * (t ** 2)        # 当前的位置        current += s        # 添加到轨迹列表        tracks.append(round(s))        # 速度已经达到 v, 该速度作为下次的初速度        v = v0 + a * t    while (total - distance - 10) &gt; 0:        # 反着滑动到大概准确位置        tracks.append(-random.randint(2, 3))        total = sum(tracks)    return tracks</code></pre><h1 id="3- 浏览器使用用户数据"><a href="#3- 浏览器使用用户数据" class="headerlink" title="3. 浏览器使用用户数据"></a>3. 浏览器使用用户数据</h1><blockquote><p>加载 Chrome 用户默认数据绕过登录</p></blockquote><p>用户每次打开浏览器做相应操作时，对应的缓存和 cookie 会保存到浏览器默认的路径下，我们先查看个人资料路径，以 chrome 为例，我们在地址栏输入 chrome://version/</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1581676388412.png" alt=""></p><p>图中的个人资料路径就是我们需要的，我们去掉后面的 \Default，然后在路径前加上「–user-data-dir=」就拼接出我们要的路径了。</p><pre><code>from selenium import webdriveroption = webdriver.ChromeOptions()option.add_argument(r&#39;--user-data-dir=C:\Users\xxp\AppData\Local\Google\Chrome\User Data&#39;)  # 设置成用户自己的数据目录driver = webdriver.Chrome(chrome_options=option)driver.get(&#39;https://www.baidu.com&#39;)</code></pre><p>我们启动浏览器的时候采用带选项时的启动，这种方式启动浏览器需要注意，运行代码前需要关闭所有的正在运行 chrome 程序，不然会报错。</p><p>执行代码运行程序，selenium 自动化启动浏览器后我们会发现我之前保存的书签完整在浏览器上方，个人数据全部都在。</p><p>参考：</p><p><a href="https://github.com/duziea/Python-imitate-login">https://github.com/duziea/Python-imitate-login</a></p><p><a href="https://blog.csdn.net/qq_34192032/article/details/101059706">https://blog.csdn.net/qq_34192032/article/details/101059706</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反反爬虫之图片验证码</title>
      <link href="/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8B%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/%E5%8F%8D%E5%8F%8D%E7%88%AC%E8%99%AB%E4%B9%8B%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言 </h1><p> 目前，很多网站为了防止爬虫爬取，登录时需要用户输入验证码 ，以识别是否是人为操作，从而规避爬虫等软件的爬取。</p><h2 id="1-1- 图片验证码："><a href="#1-1- 图片验证码：" class="headerlink" title="1.1 图片验证码："></a>1.1 图片验证码：</h2><p>验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分计算机和人类的图灵测试）的缩写，是一种区分用户是计算机还是人的公共全自动程序。</p><h2 id="1-2- 图片验证码的作用："><a href="#1-2- 图片验证码的作用：" class="headerlink" title="1.2 图片验证码的作用："></a>1.2 图片验证码的作用：</h2><p>防止恶意破解密码、刷票、论坛灌水、刷页。有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登录尝试，实际上使用验证码是现在很多网站通行的方式（比如招商银行的网上个人银行，百度社区），我们利用比较简易的方式实现了这个功能。虽然登录麻烦一点，但是对网友的密码安全来说这个功能还是很有必要，也很重要。</p><h2 id="1-3- 处理方案"><a href="#1-3- 处理方案" class="headerlink" title="1.3 处理方案"></a>1.3 处理方案 </h2><p><strong> 手动输入(input)：</strong> 这种方法仅限于登录一次就可持续使用的情况</p><p><strong>图像识别引擎解析：</strong> 使用光学识别引擎处理图片中的数据，目前常用于图片数据提取，较少用于验证码处理</p><p><strong>打码平台：</strong> 爬虫常用的验证码解决方案</p><h1 id="2、OCR 识别"><a href="#2、OCR 识别" class="headerlink" title="2、OCR 识别"></a>2、OCR 识别</h1><p>OCR（Optical Character Recognition）是指使用扫描仪或数码相机对文本资料进行扫描成图像文件，然后对图像文件进行分析处理，自动识别获取文字信息及版面信息的软件。</p><p>在读取和处理图像、图像相关的机器学习以及创建图像等任务中，Python 一直都是非常出色的语言。虽然有很多库可以进行图像处理，但在这里我们只重点介绍：<a href="https://pypi.python.org/pypi/pytesseract">Tesseract</a> </p><p>Tesseract 是一个 OCR 库, 目前由 Google 赞助(Google 也是一家以 OCR 和机器学习技术闻名于世的公司)。Tesseract 是目前公认最优秀、最精确的开源 OCR 系统，除了极高的精确度，Tesseract 也具有很高的灵活性。它可以通过训练识别出任何字体，也可以识别出任何 Unicode 字符。</p><h2 id="2-1-Tesseract"><a href="#2-1-Tesseract" class="headerlink" title="2.1 Tesseract"></a>2.1 Tesseract</h2><h3 id="2-1-1- 引擎的安装"><a href="#2-1-1- 引擎的安装" class="headerlink" title="2.1.1 引擎的安装"></a>2.1.1 引擎的安装</h3><ul><li><p>mac 环境</p><pre><code>brew install --with-training-tools tesseract</code></pre></li></ul><ul><li><p>windows 环境</p><p>下的安装可以通过 exe 安装包安装，下载地址可以从 GitHub 项目中的 wiki 找到。安装完成后记得将 Tesseract 执行文件的目录加入到 PATH 中，方便后续调用。</p><ul><li>下载可执行安装文件 <a href="https://github.com/UB-Mannheim/tesseract/wiki">https://github.com/UB-Mannheim/tesseract/wiki</a></li></ul></li><li><p>linux 环境下的安装</p><p>sudo apt-get install tesseract-ocr</p></li></ul><p>安装完后记得配置环境变量（将安装路径加到 path 里）。</p><p>注意，要想提高识别率，是需要对 Tesseract 进行训练的，两种方式：</p><p>①直接安装现成的包到”..\Tesseract-OCR\tessdata”目录下</p><p>获取链接<a href="https://github.com/tesseract-ocr/tessdata/blob/master/">https://github.com/tesseract-ocr/tessdata/blob/master/</a></p><p>②大量样本进行训练：jTessBoxEditor2.0 工具</p><h3 id="2-1-2-Python 库的安装"><a href="#2-1-2-Python 库的安装" class="headerlink" title="2.1.2 Python 库的安装"></a>2.1.2 Python 库的安装</h3><pre><code>  // PIL 用于打开图片文件  pip install pillow  // pytesseract 模块用于从图片中解析数据  pip install pytesseract</code></pre><h2 id="2-2- 引擎的使用"><a href="#2-2- 引擎的使用" class="headerlink" title="2.2 引擎的使用"></a>2.2 引擎的使用</h2><p>  通过 pytesseract 模块的 image_to_string 方法就能将打开的图片文件中的数据提取成字符串数据，具体方法如下</p><pre><code class="python">from PIL import Imageimport pytesseractim = Image.open() // 指定一张图片的路径result = pytesseract.image_to_string(im)print(result)</code></pre><p>  二值化：</p><pre><code>def binarizing(img, threshold):      &quot;&quot;&quot; 传入 image 对象进行灰度、二值处理 &quot;&quot;&quot;      img = img.convert(&quot;L&quot;)  # 转灰度      pixdata = img.load()      w, h = img.size      # 遍历所有像素，大于阈值的为黑色      for y in range(h):          for x in range(w):              if pixdata[x, y] &lt; threshold:                  pixdata[x, y] = 0              else:                  pixdata[x, y] = 255      return imgimg = Image.open(&#39;D:\\Desktop\\asw.png&#39;)imag=binarizing(img, 100)imag.show()result = pytesseract.image_to_string(imag)print(result)</code></pre><p>  降噪：</p><pre><code>def depoint(img):      &quot;&quot;&quot; 传入二值化后的图片进行降噪 &quot;&quot;&quot;      pixdata = img.load()      w, h = img.size      for y in range(1, h - 1):          for x in range(1, w - 1):              count = 0              if pixdata[x, y - 1] &gt; 245:  # 上                  count = count + 1              if pixdata[x, y + 1] &gt; 245:  # 下                  count = count + 1              if pixdata[x - 1, y] &gt; 245:  # 左                  count = count + 1              if pixdata[x + 1, y] &gt; 245:  # 右                  count = count + 1              if pixdata[x - 1, y - 1] &gt; 245:  # 左上                  count = count + 1              if pixdata[x - 1, y + 1] &gt; 245:  # 左下                  count = count + 1              if pixdata[x + 1, y - 1] &gt; 245:  # 右上                  count = count + 1              if pixdata[x + 1, y + 1] &gt; 245:  # 右下                  count = count + 1              if count &gt; 4:                  pixdata[x, y] = 255      return img</code></pre><h1 id="2- 百度开发者平台"><a href="#2- 百度开发者平台" class="headerlink" title="2. 百度开发者平台"></a>2. 百度开发者平台 </h1><p> 可以实现 OCR 的底层库并不多，目前很多库都是使用共同的几个底层 OCR 库，或者是在上面进行定制。一些人是通过机器学习的方法，自己进行训练来实现识别，但那样识别率不高，并且也较为繁琐，今天我们使用的方法是调用现成的 API, 来达成我们的目的。</p><p>API（Application Programing Interface）应用编程接口，它们为不同的应用提供了方便友好的接口。不同的开发者用不同的架构，甚至不同的语言编写软件都没问题。因为 API 设计的目的就是要成为一种通用语言，让不同的软件进行信息共享。我们通过调用百度 AI 的 API，可以使用百度 AI 的文字识别技术，响应一般以 XML 和 JSON 格式返回，经验证，百度返回的是 JSON 格式，可见 JSON 格式已经越来越流行。</p><p>一些 API 是直接可以调用的，而另一些是需要收费和认证的，百度 API 必须经过验证，它提供每天五百次免费的使用机会，对于一般人这已经足够了，下面介绍获得验证指令的方法。</p><p><strong>注册百度账号、百度云管理中心创建应用、生成 AppKey、SecretKey（程序调用接口是要生成 access_token）</strong></p><p><a href="https://console.bce.baidu.com/ai/#/ai/ocr/overview/index">https://console.bce.baidu.com/ai/#/ai/ocr/overview/index</a></p><p>登陆—创建应用—获得 API Key/Secret Key</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-08_20-30-55.png" alt=""></p><pre><code>from aip import AipOcr   //pip install baidu_aip# 你的 APPID AK SKAPP_ID = &#39; 你的 App ID&#39;API_KEY = &#39; 你的 Api Key&#39;SECRET_KEY = &#39; 你的 Secret Key&#39;client = AipOcr(APP_ID, API_KEY, SECRET_KEY)# 读取图片def get_file_content(filePath):      with open(filePath, &#39;rb&#39;) as fp:          return fp.read()# 测试文件也可以写路径image = get_file_content(&#39;images/depoint.jpg&#39;)# 定义参数变量options = &#123;      # 定义图像方向      &#39;detect_direction&#39;: &#39;true&#39;,      # 识别语言类型，&#39;CHN_ENG&#39; 中英文混合      &#39;language_type&#39;: &#39;CHN_ENG&#39;,  &#125;  # 调用通用文字识别接口  results = client.basicGeneral(image, options)  print(results)  # 遍历取出图片解析的内容  # for word in results[&#39;words_result&#39;]:  #     print(word[&#39;words&#39;])  try:     code = results[&#39;words_result&#39;][0][&#39;words&#39;]  except:     code = &#39; 验证码匹配失败 &#39;print(code) </code></pre><h1 id="3- 打码平台"><a href="#3- 打码平台" class="headerlink" title="3. 打码平台"></a>3. 打码平台</h1><p>  现在很多网站都会使用验证码来进行反爬，所以为了能够更好的获取数据，需要了解如何使用打码平台爬虫中的验证码</p><p>  斐斐打码：<a href="http://www.fateadm.com/">http://www.fateadm.com/</a></p><h1 id="4- 人工识别"><a href="#4- 人工识别" class="headerlink" title="4. 人工识别"></a>4. 人工识别 </h1><p> 通常网站只需登录一次便可爬取，在 <strong> 其他识别方式不管用时</strong>，人工识别一次验证码也是可行的，其实现也非常简单——在下载完验证码图片后，调用 Image.show 方法将图片显示出来，然后调用 Python 内置的 input 函数，等待用户肉眼识别后输入识别结果。</p><p>  <strong>参考</strong></p><p>  Python 利用百度文字识别 API 识别并提取图片中文字：<a href="https://blog.csdn.net/XnCSD/article/details/80786793">https://blog.csdn.net/XnCSD/article/details/80786793</a></p><p>  利用百度 API 实现文字识别：<a href="https://blog.csdn.net/JBlock/article/details/79317878">https://blog.csdn.net/JBlock/article/details/79317878</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 操作 Redis</title>
      <link href="/Python%E6%93%8D%E4%BD%9CRedis/"/>
      <url>/Python%E6%93%8D%E4%BD%9CRedis/</url>
      
        <content type="html"><![CDATA[<h2 id="1-redis 连接"><a href="#1-redis 连接" class="headerlink" title="1. redis 连接"></a>1. redis 连接</h2><blockquote><p>redis 提供两个类 Redis 和 StrictRedis 用于实现 Redis 的命令，StrictRedis 用于实现大部分官方的命令，并使用官方的语法和命令，Redis 是 StrictRedis 的子类，用于向后兼容旧版本的 redis-py。</p></blockquote><blockquote><p>redis 连接实例是线程安全的，可以直接将 redis 连接实例设置为一个全局变量，直接使用。如果需要另一个 Redis 实例（or Redis 数据库）时，就需要重新创建 redis 连接实例来获取一个新的连接。同理，python 的 redis 没有实现 select 命令。</p></blockquote><p>安装 redis</p><pre><code>pip install redis</code></pre><p>连接 redis，加上 decode_responses=True，写入的键值对中的 value 为 str 类型，不加这个参数写入的则为字节类型。</p><pre><code class="python"># 导入 redis 模块，通过 python 操作 redis 也可以直接在 redis 主机的服务端操作缓存数据库import redis# host 是 redis 主机，需要 redis 服务端和客户端都启动 redis 默认端口是 6379r = redis.Redis(host=&#39;134.175.188.27&#39;, port=6379, decode_responses=True, password=123456)# key 是 &quot;foo&quot; value 是 &quot;bar&quot; 将键值对存入 redis 缓存r.set(&#39;name&#39;, &#39;junxi&#39;)print(r[&#39;name&#39;])# 取出键 name 对应的值print(r.get(&#39;name&#39;))print(type(r.get(&#39;name&#39;)))</code></pre><h2 id="2-redis 基本命令"><a href="#2-redis 基本命令" class="headerlink" title="2. redis 基本命令"></a>2. redis 基本命令</h2><h3 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h3><p>set(name, value, ex=None, px=None, nx=False, xx=False)</p><p>在 Redis 中设置值，默认，不存在则创建，存在则修改<br> 参数：<br> ex，过期时间（秒）<br> px，过期时间（毫秒）<br> nx，如果设置为 True，则只有 name 不存在时，当前 set 操作才执行<br> xx，如果设置为 True，则只有 name 存在时，当前 set 操作才执行</p><p>ex，过期时间（秒） 这里过期时间是 3 秒，3 秒后 p，键 food 的值就变成 None</p><pre><code>import redispool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)# key 是 &quot;food&quot; value 是 &quot;mutton&quot; 将键值对存入 redis 缓存r.set(&#39;food&#39;, &#39;mutton&#39;, ex=3)# mutton 取出键 food 对应的值print(r.get(&#39;food&#39;)) </code></pre><p>px，过期时间（豪秒） 这里过期时间是 3 豪秒，3 毫秒后，键 foo 的值就变成 None</p><pre><code>import redispool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.set(&#39;food&#39;, &#39;beef&#39;, px=3)print(r.get(&#39;food&#39;))</code></pre><p>nx，如果设置为 True，则只有 name 不存在时，当前 set 操作才执行 （新建）</p><pre><code>import redispool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)print(r.set(&#39;fruit&#39;, &#39;watermelon&#39;, nx=True))    # True-- 不存在# 如果键 fruit 不存在，那么输出是 True；如果键 fruit 已经存在，输出是 None</code></pre><p>xx，如果设置为 True，则只有 name 存在时，当前 set 操作才执行 （修改）</p><pre><code># True-- 已经存在 # 如果键 fruit 已经存在，那么输出是 True；如果键 fruit 不存在，输出是 Noneprint((r.set(&#39;fruit&#39;, &#39;watermelon&#39;, xx=True)))   </code></pre><p>setnx(name, value)<br> 设置值，只有 name 不存在时，执行设置操作（添加）</p><pre><code>print(r.setnx(&#39;fruit1&#39;, &#39;banana&#39;))  # fruit1 不存在，输出为 True</code></pre><p>setex(name, value, time)<br> 设置值<br> 参数： time，过期时间（数字秒 或 timedelta 对象）</p><pre><code>import redisimport timepool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.setex(&quot;fruit2&quot;, &quot;orange&quot;, 5)time.sleep(5)# 5 秒后，取值就从 orange 变成 Noneprint(r.get(&#39;fruit2&#39;)) </code></pre><p>psetex(name, time_ms, value)<br> 设置值<br> 参数： time_ms，过期时间（数字毫秒 或 timedelta 对象）</p><pre><code>r.psetex(&quot;fruit3&quot;, 5000, &quot;apple&quot;)time.sleep(5)print(r.get(&#39;fruit3&#39;))  # 5000 毫秒后，取值就从 apple 变成 None</code></pre><p>mset(<em>args, *</em>kwargs)<br> 批量设置值</p><pre><code>r.mset(&#123;&#39;k1&#39;: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;&#125;)print(r.mget(&quot;k1&quot;, &quot;k2&quot;))   # 一次取出多个键对应的值print(r.mget(&quot;k1&quot;))</code></pre><p>mget(keys, *args)<br> 批量获取 如：</p><pre><code>print(r.mget(&#39;k1&#39;, &#39;k2&#39;))print(r.mget([&#39;k1&#39;, &#39;k2&#39;]))# 将目前 redis 缓存中的键对应的值批量取出来print(r.mget(&quot;fruit&quot;, &quot;fruit1&quot;, &quot;fruit2&quot;, &quot;k1&quot;, &quot;k2&quot;))  </code></pre><p>getrange(key, start, end)<br> 获取子序列（根据字节获取，非字符）<br> 参数：<br> name，Redis 的 name<br> start，起始位置（字节）<br> end，结束位置（字节）<br> 如： “君惜大大” ，0-3 表示 “君”</p><pre><code>r.set(&quot;cn_name&quot;, &quot; 君惜大大 &quot;) # 汉字# 取索引号是 0-2 前 3 位的字节 君 切片操作 （一个汉字 3 个字节 1 个字母一个字节 每个字节 8bit）print(r.getrange(&quot;cn_name&quot;, 0, 2))# 取所有的字节 君惜大大 切片操作print(r.getrange(&quot;cn_name&quot;, 0, -1)) # 字母r.set(&quot;en_name&quot;,&quot;junxi&quot;) # 取索引号是 0-2 前 3 位的字节 jun 切片操作 （一个汉字 3 个字节 1 个字母一个字节 每个字节 8bit）print(r.getrange(&quot;en_name&quot;, 0, 2))# 取所有的字节 junxi 切片操作print(r.getrange(&quot;en_name&quot;, 0, -1))</code></pre><p>setrange(name, offset, value)<br> 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）<br> 参数：<br> offset，字符串的索引，字节（一个汉字三个字节）<br> value，要设置的值</p><pre><code>r.setrange(&quot;en_name&quot;, 1, &quot;ccc&quot;)# jccci 原始值是 junxi 从索引号是 1 开始替换成 ccc 变成 jccciprint(r.get(&quot;en_name&quot;))   </code></pre><p>strlen(name)<br> 返回 name 对应值的字节长度（一个汉字 3 个字节）</p><pre><code>print(r.strlen(&quot;foo&quot;))  # 4 &#39;goo1&#39; 的长度是 4</code></pre><p>incr(self, name, amount=1)<br> 自增 name 对应的值，当 name 不存在时，则创建 name＝amount，否则，则自增。<br> 参数：<br> name,Redis 的 name<br> amount, 自增数（必须是整数）<br> 注：同 incrby</p><pre><code>r.set(&quot;foo&quot;, 123)print(r.mget(&quot;foo&quot;, &quot;foo1&quot;, &quot;foo2&quot;, &quot;k1&quot;, &quot;k2&quot;))r.incr(&quot;foo&quot;, amount=1)print(r.mget(&quot;foo&quot;, &quot;foo1&quot;, &quot;foo2&quot;, &quot;k1&quot;, &quot;k2&quot;))</code></pre><p>应用场景 – 页面点击数 <br> 假定我们对一系列页面需要记录点击次数。例如论坛的每个帖子都要记录点击次数，而点击次数比回帖的次数的多得多。如果使用关系数据库来存储点击，可能存在大量的行级锁争用。所以，点击数的增加使用 redis 的 INCR 命令最好不过了。<br>当 redis 服务器启动时，可以从关系数据库读入点击数的初始值（12306 这个页面被访问了 34634 次）</p><pre><code>r.set(&quot;visit:12306:totals&quot;, 34634)print(r.get(&quot;visit:12306:totals&quot;))</code></pre><p>每当有一个页面点击，则使用 INCR 增加点击数即可。</p><pre><code>r.incr(&quot;visit:12306:totals&quot;)r.incr(&quot;visit:12306:totals&quot;)</code></pre><p>页面载入的时候则可直接获取这个值</p><pre><code>print(r.get(&quot;visit:12306:totals&quot;))</code></pre><p>incrbyfloat(self, name, amount=1.0)<br> 自增 name 对应的值，当 name 不存在时，则创建 name＝amount，否则，则自增。<br> 参数：<br> name,Redis 的 name<br> amount, 自增数（浮点型）</p><pre><code>r.set(&quot;foo1&quot;, &quot;123.0&quot;)r.set(&quot;foo2&quot;, &quot;221.0&quot;)print(r.mget(&quot;foo1&quot;, &quot;foo2&quot;))r.incrbyfloat(&quot;foo1&quot;, amount=2.0)r.incrbyfloat(&quot;foo2&quot;, amount=3.0)print(r.mget(&quot;foo1&quot;, &quot;foo2&quot;))</code></pre><p>decr(self, name, amount=1)<br> 自减 name 对应的值，当 name 不存在时，则创建 name＝amount，否则，则自减。<br> 参数：<br> name,Redis 的 name<br> amount, 自减数（整数)</p><pre><code>r.decr(&quot;foo4&quot;, amount=3) # 递减 3r.decr(&quot;foo1&quot;, amount=1) # 递减 1print(r.mget(&quot;foo1&quot;, &quot;foo4&quot;))</code></pre><p>append(key, value)<br> 在 redis name 对应的值后面追加内容<br> 参数：<br> key, redis 的 name<br> value, 要追加的字符串</p><pre><code>r.append(&quot;name&quot;, &quot;haha&quot;)    # 在 name 对应的值 junxi 后面追加字符串 hahaprint(r.mget(&quot;name&quot;))</code></pre><p>2.2 ###  list</p><p>增加（类似于 list 的 append，只是这里是从左边新增加）–没有就新建<br> lpush(name,values)<br> 在 name 对应的 list 中添加元素，每个新的元素都添加到列表的最左边<br> 如：</p><pre><code>import redisimport timepool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.lpush(&quot;list1&quot;, 11, 22, 33)print(r.lrange(&#39;list1&#39;, 0, -1))</code></pre><p>保存顺序为: 33,22,11</p><p>扩展：</p><pre><code>r.rpush(&quot;list2&quot;, 11, 22, 33)  # 表示从右向左操作print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, 3))  # 切片取出值，范围是索引号 0-3</code></pre><p>增加（从右边增加）–没有就新建</p><pre><code>r.rpush(&quot;list2&quot;, 44, 55, 66)    # 在列表的右边，依次添加 44,55,66print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, -1)) # 切片取出值，范围是索引号 0 到 -1(最后一个元素)</code></pre><p>往已经有的 name 的列表的左边添加元素，没有的话无法创建 <br>lpushx(name,value)<br> 在 name 对应的 list 中添加元素，只有 name 已经存在时，值添加到列表的最左边 <br> 更多：</p><pre><code>r.lpushx(&quot;list10&quot;, 10)   # 这里 list10 不存在print(r.llen(&quot;list10&quot;))  # 0print(r.lrange(&quot;list10&quot;, 0, -1))  # []r.lpushx(&quot;list2&quot;, 77)   # 这里 &quot;list2&quot; 之前已经存在，往列表最左边添加一个元素，一次只能添加一个print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, -1)) # 切片取出值，范围是索引号 0 到 -1(最后一个元素 </code></pre><p> 往已经有的 name 的列表的右边添加元素，没有的话无法创建</p><pre><code>r.rpushx(&quot;list2&quot;, 99)   # 这里 &quot;foo_list1&quot; 之前已经存在，往列表最右边添加一个元素，一次只能添加一个print(r.llen(&quot;list2&quot;))  # 列表长度print(r.lrange(&quot;list2&quot;, 0, -1)) # 切片取出值，范围是索引号 0 到 -1(最后一个元素)</code></pre><p>新增（固定索引号位置插入元素）<br>linsert(name, where, refvalue, value))<br>在 name 对应的列表的某一个值前或后插入一个新值 <br> 参数：<br>name，redis 的 name<br>where，BEFORE 或 AFTER<br>refvalue，标杆值，即：在它前后插入数据<br>value，要插入的数据</p><pre><code>r.linsert(&quot;list2&quot;, &quot;before&quot;, &quot;11&quot;, &quot;00&quot;)   # 往列表中左边第一个出现的元素 &quot;11&quot; 前插入元素 &quot;00&quot;print(r.lrange(&quot;list2&quot;, 0, -1))   # 切片取出值，范围是索引号 0- 最后一个元素 </code></pre><p> 修改（指定索引号进行修改）<br> r.lset(name, index, value)<br> 对 name 对应的 list 中的某一个索引位置重新赋值<br> 参数：<br> name，redis 的 name<br> index，list 的索引位置<br> value，要设置的值</p><pre><code>r.lset(&quot;list2&quot;, 0, -11)    # 把索引号是 0 的元素修改成 -11print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><p>删除（指定值进行删除）<br> r.lrem(name, value, num)<br> 在 name 对应的 list 中删除指定的值<br> 参数：<br> name，redis 的 name<br> value，要删除的值<br> num， num=0，删除列表中所有的指定值；<br> num=2, 从前到后，删除 2 个； num=1, 从前到后，删除左边第 1 个<br> num=-2, 从后向前，删除 2 个</p><pre><code>r.lrem(&quot;list2&quot;, &quot;11&quot;, 1)    # 将列表中左边第一次出现的 &quot;11&quot; 删除print(r.lrange(&quot;list2&quot;, 0, -1))r.lrem(&quot;list2&quot;, &quot;99&quot;, -1)    # 将列表中右边第一次出现的 &quot;99&quot; 删除print(r.lrange(&quot;list2&quot;, 0, -1))r.lrem(&quot;list2&quot;, &quot;22&quot;, 0)    # 将列表中所有的 &quot;22&quot; 删除print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><p>删除并返回 <br>lpop(name)<br> 在 name 对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素 <br> 更多：<br>rpop(name) 表示从右向左操作</p><pre><code>r.lpop(&quot;list2&quot;)    # 删除列表最左边的元素，并且返回删除的元素print(r.lrange(&quot;list2&quot;, 0, -1))r.rpop(&quot;list2&quot;)    # 删除列表最右边的元素，并且返回删除的元素print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><p>删除索引之外的值 <br>ltrim(name, start, end)<br> 在 name 对应的列表中移除没有在 start-end 索引之间的值 <br> 参数：<br>name，redis 的 name<br>start，索引的起始位置<br>end，索引结束位置</p><pre><code>r.ltrim(&quot;list2&quot;, 0, 2)    # 删除索引号是 0-2 之外的元素，值保留索引号是 0-2 的元素print(r.lrange(&quot;list2&quot;, 0, -1))</code></pre><p>取值（根据索引号取值）<br>lindex(name, index)<br>在 name 对应的列表中根据索引获取列表元素</p><pre><code>print(r.lindex(&quot;list2&quot;, 0))  # 取出索引号是 0 的值 </code></pre><h3 id="2-3-set"><a href="#2-3-set" class="headerlink" title="2.3 set"></a>2.3 set</h3><p> 新增<br> sadd(name,values)<br> name 对应的集合中添加元素</p><pre><code>r.sadd(&quot;set1&quot;, 33, 44, 55, 66)  # 往集合中添加元素print(r.scard(&quot;set1&quot;))  # 集合的长度是 4print(r.smembers(&quot;set1&quot;))   # 获取集合中所有的成员 </code></pre><p> 获取元素个数 类似于 len<br>scard(name)<br>获取 name 对应的集合中元素个数</p><pre><code>print(r.scard(&quot;set1&quot;))  # 集合的长度是 4</code></pre><p>获取集合中所有的成员 <br>smembers(name)<br> 获取 name 对应的集合的所有成员</p><pre><code>print(r.smembers(&quot;set1&quot;))   # 获取集合中所有的成员 </code></pre><p> 获取集合中所有的成员–元组形式<br>sscan(name, cursor=0, match=None, count=None)</p><pre><code>print(r.sscan(&quot;set1&quot;))</code></pre><p>获取集合中所有的成员–迭代器的方式<br> sscan_iter(name, match=None, count=None)<br> 同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大</p><pre><code>for i in r.sscan_iter(&quot;set1&quot;):    print(i)</code></pre><p>差集 <br>sdiff(keys, *args)<br> 在第一个 name 对应的集合中且不在其他 name 对应的集合的元素集合</p><pre><code>r.sadd(&quot;set2&quot;, 11, 22, 33)print(r.smembers(&quot;set1&quot;))   # 获取集合中所有的成员print(r.smembers(&quot;set2&quot;))print(r.sdiff(&quot;set1&quot;, &quot;set2&quot;))   # 在集合 set1 但是不在集合 set2 中print(r.sdiff(&quot;set2&quot;, &quot;set1&quot;))   # 在集合 set2 但是不在集合 set1 中 </code></pre><p> 差集–差集存在一个新的集合中 <br>sdiffstore(dest, keys, *args)<br> 获取第一个 name 对应的集合中且不在其他 name 对应的集合，再将其新加入到 dest 对应的集合中</p><pre><code>r.sdiffstore(&quot;set3&quot;, &quot;set1&quot;, &quot;set2&quot;)    # 在集合 set1 但是不在集合 set2 中print(r.smembers(&quot;set3&quot;))   # 获取集合 3 中所有的成员 </code></pre><p> 交集 <br>sinter(keys, *args)<br> 获取多一个 name 对应集合的交集</p><pre><code>print(r.sinter(&quot;set1&quot;, &quot;set2&quot;)) # 取 2 个集合的交集 </code></pre><p> 交集–交集存在一个新的集合中 <br>sinterstore(dest, keys, *args)<br> 获取多一个 name 对应集合的并集，再将其加入到 dest 对应的集合中</p><pre><code>print(r.sinterstore(&quot;set3&quot;, &quot;set1&quot;, &quot;set2&quot;)) # 取 2 个集合的交集print(r.smembers(&quot;set3&quot;))</code></pre><p>并集<br> sunion(keys, *args)<br> 获取多个 name 对应的集合的并集</p><pre><code>print(r.sunion(&quot;set1&quot;, &quot;set2&quot;)) # 取 2 个集合的并集 </code></pre><p> 并集–并集存在一个新的集合<br> sunionstore(dest,keys, *args)<br> 获取多一个 name 对应的集合的并集，并将结果保存到 dest 对应的集合中</p><pre><code>print(r.sunionstore(&quot;set3&quot;, &quot;set1&quot;, &quot;set2&quot;)) # 取 2 个集合的并集print(r.smembers(&quot;set3&quot;))</code></pre><p>判断是否是集合的成员 类似 in<br>sismember(name, value)<br>检查 value 是否是 name 对应的集合的成员，结果为 True 和 False</p><pre><code>print(r.sismember(&quot;set1&quot;, 33))  # 33 是集合的成员print(r.sismember(&quot;set1&quot;, 23))  # 23 不是集合的成员 </code></pre><p> 移动 <br>smove(src, dst, value)<br> 将某个成员从一个集合中移动到另外一个集合</p><pre><code>r.smove(&quot;set1&quot;, &quot;set2&quot;, 44)print(r.smembers(&quot;set1&quot;))print(r.smembers(&quot;set2&quot;))</code></pre><p>删除–随机删除并且返回被删除值 <br>spop(name)<br> 从集合移除一个成员，并将其返回, 说明一下，集合是无序的，所有是随机删除的</p><pre><code>print(r.spop(&quot;set2&quot;))   # 这个删除的值是随机删除的，集合是无序的print(r.smembers(&quot;set2&quot;))</code></pre><p>删除–指定值删除 <br>srem(name, values)<br> 在 name 对应的集合中删除某些值</p><pre><code>print(r.srem(&quot;set2&quot;, 11))   # 从集合中删除指定值 11print(r.smembers(&quot;set2&quot;))</code></pre><h3 id="2-4-Zset"><a href="#2-4-Zset" class="headerlink" title="2.4  Zset"></a>2.4  Zset</h3><p>Set 操作，Set 集合就是不允许重复的列表，本身是无序的<br> 有序集合，在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，<br> 所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。</p><p>新增 <br>zadd(name, <em>args, *</em>kwargs)<br> 在 name 对应的有序集合中添加元素 <br> 如：</p><pre><code>import redisimport timepool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.zadd(&quot;zset1&quot;, n1=11, n2=22)r.zadd(&quot;zset2&quot;, &#39;m1&#39;, 22, &#39;m2&#39;, 44)print(r.zcard(&quot;zset1&quot;)) # 集合长度print(r.zcard(&quot;zset2&quot;)) # 集合长度print(r.zrange(&quot;zset1&quot;, 0, -1))   # 获取有序集合中所有元素print(r.zrange(&quot;zset2&quot;, 0, -1, withscores=True))   # 获取有序集合中所有元素和分数 </code></pre><p> 获取有序集合元素个数 类似于 len<br>zcard(name)<br>获取 name 对应的有序集合元素的数量</p><pre><code>print(r.zcard(&quot;zset1&quot;)) # 集合长度 </code></pre><p> 获取有序集合的所有元素 <br>r.zrange(name, start, end, desc=False, withscores=False, score_cast_func=float)<br> 按照索引范围获取 name 对应的有序集合的元素 <br> 参数：<br>name，redis 的 name<br>start，有序集合索引起始位置（非分数）<br>end，有序集合索引结束位置（非分数）<br>desc，排序规则，默认按照分数从小到大排序<br>withscores，是否获取元素的分数，默认只获取元素的值<br>score_cast_func，对分数进行数据转换的函数</p><p>从大到小排序(同 zrange，集合是从大到小排序的)<br> zrevrange(name, start, end, withscores=False, score_cast_func=float)</p><pre><code>print(r.zrevrange(&quot;zset1&quot;, 0, -1))    # 只获取元素，不显示分数print(r.zrevrange(&quot;zset1&quot;, 0, -1, withscores=True)) # 获取有序集合中所有元素和分数, 分数倒序 </code></pre><p> 按照分数范围获取 name 对应的有序集合的元素<br>zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)</p><pre><code>for i in range(1, 30):   element = &#39;n&#39; + str(i)   r.zadd(&quot;zset3&quot;, element, i)print(r.zrangebyscore(&quot;zset3&quot;, 15, 25)) # # 在分数是 15-25 之间，取出符合条件的元素print(r.zrangebyscore(&quot;zset3&quot;, 12, 22, withscores=True))    # 在分数是 12-22 之间，取出符合条件的元素（带分数）</code></pre><p>按照分数范围获取有序集合的元素并排序（默认从大到小排序）<br> zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=float)</p><pre><code>print(r.zrevrangebyscore(&quot;zset3&quot;, 22, 11, withscores=True)) # 在分数是 22-11 之间，取出符合条件的元素 按照分数倒序 </code></pre><p> 获取所有元素–默认按照分数顺序排序<br>zscan(name, cursor=0, match=None, count=None, score_cast_func=float)</p><pre><code>print(r.zscan(&quot;zset3&quot;))</code></pre><p>获取值的索引号 <br>zrank(name, value)<br> 获取某个值在 name 对应的有序集合中的索引（从 0 开始）<br>更多：<br> zrevrank(name, value)，从大到小排序</p><pre><code>print(r.zrank(&quot;zset3&quot;, &quot;n1&quot;))   # n1 的索引号是 0 这里按照分数顺序（从小到大）print(r.zrank(&quot;zset3&quot;, &quot;n6&quot;))   # n6 的索引号是 1print(r.zrevrank(&quot;zset3&quot;, &quot;n1&quot;))    # n1 的索引号是 29 这里安照分数倒序（从大到小）</code></pre><p>删除–指定值删除 <br>zrem(name, values)<br> 删除 name 对应的有序集合中值是 values 的成员</p><pre><code>r.zrem(&quot;zset3&quot;, &quot;n3&quot;)   # 删除有序集合中的元素 n3 删除单个print(r.zrange(&quot;zset3&quot;, 0, -1))</code></pre><p>删除–根据排行范围删除，按照索引号来删除 <br>zremrangebyrank(name, min, max)<br> 根据排行范围删除</p><pre><code>r.zremrangebyrank(&quot;zset3&quot;, 0, 1)  # 删除有序集合中的索引号是 0, 1 的元素print(r.zrange(&quot;zset3&quot;, 0, -1))</code></pre><p>删除–根据分数范围删除 <br>zremrangebyscore(name, min, max)<br> 根据分数范围删除</p><pre><code>r.zremrangebyscore(&quot;zset3&quot;, 11, 22)   # 删除有序集合中的分数是 11-22 的元素print(r.zrange(&quot;zset3&quot;, 0, -1))</code></pre><p>获取值对应的分数 <br>zscore(name, value)<br> 获取 name 对应有序集合中 value 对应的分数</p><pre><code>print(r.zscore(&quot;zset3&quot;, &quot;n27&quot;))   # 获取元素 n27 对应的分数 27</code></pre><h3 id="2-5-hash"><a href="#2-5-hash" class="headerlink" title="2.5 hash"></a>2.5 hash</h3><p>单个增加–修改 (单个取出)–没有就新增，有的话就修改<br>hset(name, key, value)<br>name 对应的 hash 中设置一个键值对（不存在，则创建；否则，修改）<br> 参数：<br>name，redis 的 name<br>key，name 对应的 hash 中的 key<br>value，name 对应的 hash 中的 value<br>注：<br>hsetnx(name, key, value), 当 name 对应的 hash 中不存在当前 key 时则创建（相当于添加）</p><pre><code>import redisimport timepool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379, decode_responses=True)r = redis.Redis(connection_pool=pool)r.hset(&quot;hash1&quot;, &quot;k1&quot;, &quot;v1&quot;)r.hset(&quot;hash1&quot;, &quot;k2&quot;, &quot;v2&quot;)print(r.hkeys(&quot;hash1&quot;)) # 取 hash 中所有的 keyprint(r.hget(&quot;hash1&quot;, &quot;k1&quot;))    # 单个取 hash 的 key 对应的值print(r.hmget(&quot;hash1&quot;, &quot;k1&quot;, &quot;k2&quot;)) # 多个取 hash 的 key 对应的值r.hsetnx(&quot;hash1&quot;, &quot;k2&quot;, &quot;v3&quot;) # 只能新建print(r.hget(&quot;hash1&quot;, &quot;k2&quot;))</code></pre><p>批量增加（取出）<br>hmset(name, mapping)<br>在 name 对应的 hash 中批量设置键值对 <br> 参数：<br>name，redis 的 name<br>mapping，字典，如：{‘k1’:’v1’, ‘k2’: ‘v2’}<br>如：</p><pre><code>r.hmset(&quot;hash2&quot;, &#123;&quot;k2&quot;: &quot;v2&quot;, &quot;k3&quot;: &quot;v3&quot;&#125;)</code></pre><p>hget(name,key)<br> 在 name 对应的 hash 中获取根据 key 获取 value<br> hmget(name, keys, *args)<br> 在 name 对应的 hash 中获取多个 key 的值<br> 参数：<br> name，reids 对应的 name<br> keys，要获取 key 集合，如：[‘k1’, ‘k2’, ‘k3’]<br> *args，要获取的 key，如：k1,k2,k3<br> 如：</p><pre><code>print(r.hget(&quot;hash2&quot;, &quot;k2&quot;))  # 单个取出 &quot;hash2&quot; 的 key-k2 对应的 valueprint(r.hmget(&quot;hash2&quot;, &quot;k2&quot;, &quot;k3&quot;))  # 批量取出 &quot;hash2&quot; 的 key-k2 k3 对应的 value -- 方式 1print(r.hmget(&quot;hash2&quot;, [&quot;k2&quot;, &quot;k3&quot;]))  # 批量取出 &quot;hash2&quot; 的 key-k2 k3 对应的 value -- 方式 2</code></pre><p>取出所有的键值对<br> hgetall(name)<br> 获取 name 对应 hash 的所有键值</p><pre><code>print(r.hgetall(&quot;hash1&quot;))</code></pre><p>得到所有键值对的格式 hash 长度<br> hlen(name)<br> 获取 name 对应的 hash 中键值对的个数</p><pre><code>print(r.hlen(&quot;hash1&quot;))</code></pre><p>得到所有的 keys（类似字典的取所有 keys）<br> hkeys(name)<br> 获取 name 对应的 hash 中所有的 key 的值</p><pre><code>print(r.hkeys(&quot;hash1&quot;))</code></pre><p>得到所有的 value（类似字典的取所有 value）<br> hvals(name)<br> 获取 name 对应的 hash 中所有的 value 的值</p><pre><code>print(r.hvals(&quot;hash1&quot;))</code></pre><p>判断成员是否存在（类似字典的 in）<br> hexists(name, key)<br> 检查 name 对应的 hash 是否存在当前传入的 key</p><pre><code>print(r.hexists(&quot;hash1&quot;, &quot;k4&quot;))  # False 不存在print(r.hexists(&quot;hash1&quot;, &quot;k1&quot;))  # True 存在 </code></pre><p> 删除键值对<br> hdel(name,*keys)<br> 将 name 对应的 hash 中指定 key 的键值对删除</p><pre><code>print(r.hgetall(&quot;hash1&quot;))r.hset(&quot;hash1&quot;, &quot;k2&quot;, &quot;v222&quot;)   # 修改已有的 key k2r.hset(&quot;hash1&quot;, &quot;k11&quot;, &quot;v1&quot;)   # 新增键值对 k11r.hdel(&quot;hash1&quot;, &quot;k1&quot;)    # 删除一个键值对print(r.hgetall(&quot;hash1&quot;))</code></pre><h2 id="3- 其他常用操作"><a href="#3- 其他常用操作" class="headerlink" title="3. 其他常用操作"></a>3. 其他常用操作 </h2><p><strong> 删除</strong><br> delete(*names)<br> 根据删除 redis 中的任意数据类型（string、hash、list、set、有序 set）</p><pre><code>r.delete(&quot;gender&quot;)  # 删除 key 为 gender 的键值对 </code></pre><p><strong> 检查名字是否存在</strong><br> exists(name)<br> 检测 redis 的 name 是否存在，存在就是 True，False 不存在</p><pre><code>print(r.exists(&quot;zset1&quot;))</code></pre><p><strong>模糊匹配</strong><br> keys(pattern=’<em>‘) 根据模型获取 redis 的 name 更多： KEYS \</em> 匹配数据库中所有 key 。 KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。 KEYS h*llo 匹配 hllo 和 heeeeello 等。<br> KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo</p><pre><code>print(r.keys(&quot;foo*&quot;))</code></pre><p><strong>设置超时时间</strong><br> expire(name ,time)<br> 为某个 redis 的某个 name 设置超时时间</p><pre><code>r.lpush(&quot;list5&quot;, 11, 22)r.expire(&quot;list5&quot;, time=3)print(r.lrange(&quot;list5&quot;, 0, -1))time.sleep(3)print(r.lrange(&quot;list5&quot;, 0, -1))</code></pre><p><strong>重命名</strong><br> rename(src, dst)<br> 对 redis 的 name 重命名</p><pre><code>r.lpush(&quot;list5&quot;, 11, 22)r.rename(&quot;list5&quot;, &quot;list5-1&quot;)</code></pre><p><strong>随机获取 name</strong><br> randomkey()<br> 随机获取一个 redis 的 name（不删除）</p><pre><code>print(r.randomkey())</code></pre><p><strong>获取类型</strong><br> type(name)<br> 获取 name 对应值的类型</p><pre><code>print(r.type(&quot;set1&quot;))print(r.type(&quot;hash2&quot;))</code></pre><p><strong>查看所有元素</strong><br> scan(cursor=0, match=None, count=None)</p><pre><code>print(r.hscan(&quot;hash2&quot;))print(r.sscan(&quot;set3&quot;))print(r.zscan(&quot;zset2&quot;))print(r.getrange(&quot;foo1&quot;, 0, -1))print(r.lrange(&quot;list2&quot;, 0, -1))print(r.smembers(&quot;set3&quot;))print(r.zrange(&quot;zset3&quot;, 0, -1))print(r.hgetall(&quot;hash1&quot;))</code></pre><p><strong>查看所有元素–迭代器</strong><br> scan_iter(match=None, count=None)</p><pre><code>for i in r.hscan_iter(&quot;hash1&quot;):    print(i)for i in r.sscan_iter(&quot;set3&quot;):    print(i)for i in r.zscan_iter(&quot;zset3&quot;):    print(i)</code></pre><p><strong>其他方法</strong></p><pre><code>print(r.get(&#39;name&#39;))    # 查询 key 为 name 的值r.delete(&quot;gender&quot;)  # 删除 key 为 gender 的键值对print(r.keys()) # 查询所有的 Keyprint(r.dbsize())   # 当前 redis 包含多少条数据r.save()    # 执行 &quot; 检查点 &quot; 操作，将数据写回磁盘。保存时阻塞# r.flushdb()        # 清空 r 中的所有数据</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy-Redis 分布式爬虫</title>
      <link href="/Scrapy-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB/"/>
      <url>/Scrapy-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Scrapy-redis 介绍"><a href="#1、Scrapy-redis 介绍" class="headerlink" title="1、Scrapy-redis 介绍"></a>1、Scrapy-redis 介绍</h1><p>Scrapy_redis ： Redis-based components for Scrapy.</p><p>Github 地址：<a href="https://github.com/rmax/scrapy-redis">https://github.com/rmax/scrapy-redis</a></p><p>Scrapy_redis 在 scrapy 的基础上实现了更多，更强大的功能，具体体现在：reqeust 去重，爬虫持久化，和轻松实现分布式</p><p>那么，scrapy_redis 是如何帮助我们抓取数据的呢？</p><h2 id="1-1- 单机爬虫"><a href="#1-1- 单机爬虫" class="headerlink" title="1.1 单机爬虫"></a>1.1 单机爬虫 </h2><p> 默认情况下 Scrapy 是不支持分布式的，需要使用基于 Redis 的 Scrapy-Redis 组件才能实现分布式。</p><p>正常的 Scrapy 单机爬虫：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1563094178551.png" style="zoom:150%;" /><p>Scrapy 并不会共享调度队列，也就是说 Scrapy 是不支持分布式的。为了支持分布式，我们需要让 Scrapy 支持共享调度队列，也就是改造成共享调度和去重的功能。</p><h2 id="1-2- 分布式爬虫"><a href="#1-2- 分布式爬虫" class="headerlink" title="1.2 分布式爬虫"></a>1.2 分布式爬虫 </h2><p><strong> 分布式：分而治之</strong></p><p>将一个爬虫代码，分别部署在多台电脑上，共同完成整个爬虫任务。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1563094209564.png" style="zoom:150%;" /><p>使用 Redis 服务器来集中处理所有的请求，主要负责请求的去重和调度。通过这种方式，所有电脑端的爬虫共享了一个爬取队列，并且每个电脑端每次得到的请求都是其他爬虫未曾访问的。从而提高了爬虫效率。</p><p>得到一个请求之后，检查一下这个 Request 是否在 Redis 去重，如果在就证明其它的 spider 采集过啦！如果不在就添加进调度队列，等待别人获取。</p><p>Scrapy 是一个通用的爬虫框架，但是不支持分布式，Scrapy-redis 是为了更方便地实现 Scrapy 分布式爬取，而提供了一些以 redis 为基础的组件。</p><p>安装如下：<code>pip install scrapy-redis</code></p><p>Scrapy-redis 提供了下面四种组件（components）：(四种组件意味着这四个模块都要做相应的修改) </p><ol><li>Scheduler（调度器）</li><li>Duplication Filter（去重）</li><li>Item Pipeline（管道）</li><li>Base Spider（爬虫类）</li></ol><p><strong>（1）Scheduler（调度器）</strong></p><p>Scrapy 改造了 Python 本来的 collection.deque(双向队列)形成了自己的 Scrapy queue，但是 Scrapy 多个 spider 不能共享待爬取队列 Scrapy queue， 即 Scrapy 本身不支持爬虫分布式，scrapy-redis 的解决是把这个 Scrapy queue 换成 redis 数据库（也是指 redis 队列），便能让多个 spider 去同一个数据库里读取，这样实现共享爬取队列。</p><p>Redis 支持多种数据结构，这些数据结构可以很方便的实现这样的需求：</p><ul><li><p>列表有 lpush()，lpop()，rpush()，rpop()，这些方法可以实现先进先出，或者先进后出式的爬取队列。</p></li><li><p>集合元素是无序且不重复的，可以很方便的实现随机排序且不重复的爬取队列。</p></li><li><p>Scrapy 的 Request 带有优先级控制，Redis 中的集合也是带有分数表示的，可以用这个功能实现带有优先级调度的爬取队列。</p><p>Scrapy 把待爬队列按照优先级建立了一个字典结构，比如：</p></li></ul><pre><code class="json">&#123;    优先级 0 : 队列 0    优先级 1 : 队列 1    优先级 2 : 队列 2&#125;</code></pre><p>然后根据 request 中的优先级，来决定该入哪个队列，出列时则按优先级较小的优先出列。由于 Scrapy 原来的 Scheduler 只能处理 Scrapy 自身的队列，不能处理 Redis 中的队列，所以原来的 Scheduler 已经无法使用，应该使用 Scrapy-Redis 的 Scheduler 组件。</p><p><strong>（2）Duplication Filter（去重）</strong></p><p>Scrapy 自带去重模块，该模块使用的是 Python 中的集合类型。该集合会记录每个请求的指纹，指纹也就是 Request 的散列值。指纹的计算采用的是 hashlib 的 sha1()方法。计算的字段包含了，请求的 Method，URL，Body，Header 这几个内容，这些字符串里面只要里面有一点不同，那么计算出来的指纹就是不一样的。也就是说，计算的结果是加密后的字符串，这就是请求指纹。通过加密后的字符串，使得每个请求都是唯一的，也就是指纹是惟一的。并且指纹是一个字符串，在判断字符串的时候，要比判断整个请求对象容易。所以采用了指纹作为判断去重的依据。</p><p>Scrapy-Redis 要想实现分布式爬虫的去重功能，也是需要更新指纹集合的，但是不能每个爬虫维护自己的单独的指纹集合。利用 Redis 集合的数据结构类型，可以轻松实现分布式爬虫的指纹判重。也就是说：每台主机得到 Request 的指纹去和 Redis 中的集合进行对比，如果指纹存在，说明是重复的，也就不会再去发送请求，如果不曾存在于 Redis 中的指纹集合，就会发送请求，并且将该指纹加入 Redis 的集合中。这样就实现了分布式爬虫的指纹集合的共享。</p><p><strong>（3）Item Pipeline</strong></p><p>引擎将 (Spider 返回的) 爬取到的 Item 给 Item Pipeline，scrapy-redis 的 Item Pipeline 将爬取到的 Item 存⼊redis 的 items queue。修改过 Item Pipeline 可以很方便的根据 key 从 items queue 提取 item，从⽽实现 items processes 集群。</p><p><strong>（4）Base Spider</strong></p><p>不再使用 scrapy 原有的 Spider 类，重写的 RedisSpider 继承了 Spider 和 RedisMixin 这两个类，RedisMixin 是用来从 redis 读取 url 的类。当我们生成一个 Spider 继承 RedisSpider 时，调用 setup_redis 函数，这个函数会去连接 redis 数据库，然后会设置 signals(信号)：</p><p>当 spider 空闲时候的 signal，会调用 spider_idle 函数，这个函数调用 schedule_next_request 函数，保证 spider 是一直活着的状态，并且抛出 DontCloseSpider 异常。</p><p>当抓到一个 item 时的 signal，会调用 item_scraped 函数，这个函数会调用 schedule_next_request 函数，获取下一个 request。</p><h1 id="2、Scrapy-redis 使用"><a href="#2、Scrapy-redis 使用" class="headerlink" title="2、Scrapy_redis 使用"></a>2、Scrapy_redis 使用</h1><p>1、clone github scrapy-redis 源码文件<br>    git clone <a href="https://github.com/rolando/scrapy-redis.git">https://github.com/rolando/scrapy-redis.git</a><br>2、研究项目自带的三个 demo<br>    mv scrapy-redis/example-project ~/scrapyredis-project</p><h2 id="2-1-Scrapy-redis 之 domz"><a href="#2-1-Scrapy-redis 之 domz" class="headerlink" title="2.1 Scrapy_redis 之 domz"></a>2.1 Scrapy_redis 之 domz</h2><p><strong>首先看看 Spider 文件：</strong></p><pre><code class="python">// filename(spider):domz.pyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Ruleclass DmozSpider(CrawlSpider):    &quot;&quot;&quot;Follow categories and extract links.&quot;&quot;&quot;    name = &#39;dmoz&#39;    allowed_domains = [&#39;dmoztools.net&#39;]    start_urls = [&#39;http://dmoztools.net/&#39;]    rules = [        # 定义一个 url 提取规则，满足条件的 url 交给 callback 函数处理        Rule(LinkExtractor(restrict_css=(&#39;.top-cat&#39;, &#39;.sub-cat&#39;, &#39;.cat-item&#39;)        ), callback=&#39;parse_directory&#39;, follow=True),    ]    def parse_directory(self, response):        for div in response.css(&#39;.title-and-desc&#39;):            # 将结果返回给引擎            yield &#123;                &#39;name&#39;: div.css(&#39;.site-title::text&#39;).extract_first(),                &#39;description&#39;: div.css(&#39;.site-descr::text&#39;).extract_first().strip(),                &#39;link&#39;: div.css(&#39;a::attr(href)&#39;).extract_first(),            &#125;</code></pre><p>domz.py 这个部分与我们自己写的 crawlspider 没有任何区别。</p><p><strong>下一步再看对应的 Settings.py 文件，里面新增内容如下</strong></p><pre><code class="python">//filename:settings.py# Scrapy settings for example project# For simplicity, this file contains only the most important settings by# default. All the other settings are documented here:##     http://doc.scrapy.org/topics/settings.htmlSPIDER_MODULES = [&#39;example.spiders&#39;]NEWSPIDER_MODULE = &#39;example.spiders&#39;  // 上两个是自动生成的，不用设置。意思是爬虫位于 example 项目的 spiders 文件夹下USER_AGENT = &#39;scrapy-redis (+https://github.com/rolando/scrapy-redis)&#39;// 根据需要看是否设置// 重点 1 指定去重方法DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;// 重点 2 指定调度器SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;// 重点 3 指定队列中的内容是否持久保存，为 False 的时候在关闭爬虫时清空 redis 数据SCHEDULER_PERSIST = True#SCHEDULER_QUEUE_CLASS = &quot;scrapy_redis.queue.SpiderPriorityQueue&quot;#SCHEDULER_QUEUE_CLASS = &quot;scrapy_redis.queue.SpiderQueue&quot;#SCHEDULER_QUEUE_CLASS = &quot;scrapy_redis.queue.SpiderStack&quot;ITEM_PIPELINES = &#123;    &#39;example.pipelines.ExamplePipeline&#39;: 300,    &#39;scrapy_redis.pipelines.RedisPipeline&#39;: 400,&#125;// 利用 scrapy_redis 里的 pipelines 实现数据保存LOG_LEVEL = &#39;DEBUG&#39;# Introduce an artifical delay to make use of parallelism. to speed up the crawl.DOWNLOAD_DELAY = 1// 默认为 3s，这里设置为 1s// 重点 4 配置数据库连接REDIS_URL = &quot;redis://127.0.0.1:6379&quot;&#39;&#39;&#39;redis 的地址可以写成如下形式REDIS_HOST = &quot;127.0.0.1&quot;  // 服务器 ip, 若为本地，则为 &#39;localhost&#39;REDIS_PORT = 6379        // 指定端口&#39;&#39;&#39;</code></pre><p>我们执行 domz.py 的爬虫，会发现 redis 数据库中多了一下三个键。我们可以尝试在 setting 中关闭 redispipeline，</p><p>观察 redis 中三个键的存储数据量的变化</p><p>变化结果：<br>    dmoz:requests 有变化(变多或者变少或者不变)<br>    dmoz:dupefilter 变多<br>    dmoz:items 不变</p><p>变化结果分析:<br>    redispipeline 中仅仅实现了 item 数据存储到 redis 的过程，我们可以新建一个 pipeline（或者修改默认的 ExamplePipeline），让数据存储到任意地方</p><p>那么问题来了：以上的这些功能 scrapy_redis 都是如何实现的呢？</p><h2 id="2-2-Scrapy-redis 之 RedisPipeline"><a href="#2-2-Scrapy-redis 之 RedisPipeline" class="headerlink" title="2.2 Scrapy_redis 之 RedisPipeline"></a>2.2 Scrapy_redis 之 RedisPipeline</h2><pre><code class="python">class RedisPipeline(object):    # 使用 process_item 的方法，实现数据保存    def process_item(self, item, spider):        return deferToThread(self._process_item, item, spider)    def _process_item(self, item, spider):        key = self.item_key(item, spider)        data = self.serialize(item)        # 向 dmoz:item 中添加 item        self.server.rpush(key, data)        return item    def item_key(self, item, spider):        return self.key % &#123;&#39;spider&#39;: spider.name&#125;</code></pre><h2 id="2-3-Scrapy-redis 之 RFPDupeFilter"><a href="#2-3-Scrapy-redis 之 RFPDupeFilter" class="headerlink" title="2.3 Scrapy_redis 之 RFPDupeFilter"></a>2.3 Scrapy_redis 之 RFPDupeFilter</h2><pre><code class="python"># filename:scrapy_redis/dupeFilter.pyimport loggingimport timefrom scrapy.dupefilters import BaseDupeFilterfrom scrapy.utils.request import request_fingerprintclass RFPDupeFilter(BaseDupeFilter):    def request_seen(self, request):        &quot;&quot;&quot; 判断 request 对象是否已经存在 &quot;&quot;&quot;        fp = self.request_fingerprint(request)        # 添加到 dupefilter 中，返回 0 表示数据已经存在        added = self.server.sadd(self.key, fp)        return added == 0    def request_fingerprint(self, request):        return request_fingerprint(request)</code></pre><pre><code class="python"># filename:scrapy/utils/request.pydef request_fingerprint(request, include_headers=None):    if include_headers:        include_headers = tuple(to_bytes(h.lower())                                 for h in sorted(include_headers))    cache = _fingerprint_cache.setdefault(request, &#123;&#125;)    if include_headers not in cache:        # sha1 加密        fp = hashlib.sha1()        fp.update(to_bytes(request.method))        fp.update(to_bytes(canonicalize_url(request.url)))        fp.update(request.body or b&#39;&#39;)        # 添加请求头，默认不加请求头（因为 headers 的 cookies 中含有 session_id, 这在不同的网站中是随机的，会给 sha1 带来误差）        if include_headers:            for hdr in include_headers:                if hdr in request.headers:                    fp.update(hdr)                    for v in request.headers.getlist(hdr):                        fp.update(v)        # 返回加密之后的 16 进制        cache[include_headers] = fp.hexdigest()    return cache[include_headers]</code></pre><h2 id="2-4-scrapy-redis 去重方法"><a href="#2-4-scrapy-redis 去重方法" class="headerlink" title="2.4 scrapy_redis 去重方法"></a>2.4 scrapy_redis 去重方法</h2><ul><li>使用 sha1 加密 request 得到指纹</li><li>把指纹存在 redis 的集合中</li><li>下一次新来一个 request，同样的方式生成指纹，判断指纹是否存在 reids 的集合中</li></ul><p><strong>生成指纹</strong></p><pre><code class="python">fp = hashlib.sha1()fp.update(to_bytes(request.method))  #请求方法fp.update(to_bytes(canonicalize_url(request.url))) #urlfp.update(request.body or b&#39;&#39;)  #请求体return fp.hexdigest()</code></pre><h2 id="2-5-Scrapy-redis 之 Scheduler"><a href="#2-5-Scrapy-redis 之 Scheduler" class="headerlink" title="2.5 Scrapy_redis 之 Scheduler"></a>2.5 Scrapy_redis 之 Scheduler</h2><pre><code class="python"># filename:scrapy_redis/dupeFilter.pyclass Scheduler(object):    def close(self, reason):        # 如果在 settings 中设置不持久，那么在退出时候就会清空        if not self.persist:            self.flush()    def flush(self):        # 存放 dupefilter 的 redis        self.df.clear()        # 存放 request 的 redis        self.queue.clear()    def enqueue_request(self, request):        # 不能加入带爬取队列的条件，当 url 需要经过 allow_domain 过滤并且 request 不存在 dp 的时候        if not request.dont_filter and self.df.request_seen(request):            self.df.log(request, self.spider)            return False        if self.stats:            self.stats.inc_value(&#39;scheduler/enqueued/redis&#39;, spider=self.spider)        self.queue.push(request)        return True</code></pre><p><strong>request 对象什么时候入队</strong></p><ul><li>dont_filter = True , 构造请求的时候，把 dont_filter 置为 True，该 url 会被反复抓取（url 地址对应的内容会更新的情况）</li><li>一个全新的 url 地址被抓到的时候，构造 request 请求</li><li>url 地址在 start_urls 中的时候，会入队，不管之前是否请求过<ul><li>构造 start_url 地址的请求时候，dont_filter = True</li></ul></li></ul><pre><code class="python">def enqueue_request(self, request):    if not request.dont_filter and self.df.request_seen(request):        # dont_filter=False Ture  True request 指纹已经存在  #不会入队        # dont_filter=False Ture  False  request 指纹已经存在 全新的 url  #会入队        # dont_filter=Ture False  #会入队        self.df.log(request, self.spider)        return False    self.queue.push(request) #入队    return True</code></pre><p>通过以上知识点的学习，我们会发现：<br>    domz 相比于之前的 spider 多了持久化和 request 去重的功能<br>    在之后的爬虫中，我们可以模仿 domz 的用法，使用 scrapy_redis 实现相同的功能</p><p>注意：setting 中的配置都是可以自己设定的，意味着我们的可以重写去重和调度器的方法，包括是否要把数据存储到 redis(pipeline)</p><p>配置文件：</p><pre><code># 修改调度器SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;# 修改去重工具DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;# 开启数据持久化SCHEDULER_PERSIST = TrueREDIS_HOST = &#39;127.0.0.1&#39;REDIS_PORT = 6379# 验证数据库密码REDIS_PARAMS = &#123;    &#39;password&#39;: &#39;123456&#39;,&#125;</code></pre><h1 id="3、分布式爬取"><a href="#3、分布式爬取" class="headerlink" title="3、分布式爬取"></a>3、分布式爬取 </h1><p> 了解了 scrapy-redis 的原理后，我们学习使用 scrapy + scrapy-redis 进行分布式爬取。</p><h2 id="3-1- 搭建环境"><a href="#3-1- 搭建环境" class="headerlink" title="3.1　搭建环境"></a>3.1　搭建环境 </h2><p> 首先搭建 scrapy-redis 分布式爬虫环境，当前我们有 3 台 Linux 主机。</p><p>云服务器（A）：116.29.35.201 (Redis Server)</p><p>云服务器（B）：123.59.45.155</p><p>本机（C）：1.13.41.127</p><p>在 3 台主机上安装 scrapy 和 scrapy-redis：</p><pre><code>$ pip install scrapy$ pip install scrapy-redis</code></pre><p>选择其中一台云服务器搭建供所有爬虫使用的 Redis 数据库，步骤如下：</p><p><strong>[步骤　01]</strong>　在云服务器上安装 redis-server。</p><p><strong>[步骤　02]</strong>　在 Redis 配置文件中修改服务器的绑定地址（确保数据库可被所有爬虫访问）。</p><p><strong>[步骤　03]</strong>　启动／重启 Redis 服务器。</p><p>登录云服务器（A），在 bash 中完成上述步骤：</p><pre><code>116.29.35.201$ sudo apt-get install redis-server116.29.35.201$ sudo vi /etc/redis/redis.conf...# bind 127.0.0.1bind 0.0.0.0...116.29.35.201$ sudo service redis-server restart</code></pre><p>最后，在 3 台主机上测试能否访问云服务器（A）上的 Redis 数据库：</p><pre><code>$ redis-cli -a 123456 -h 116.29.35.201 ping     PONG</code></pre><p>-a 后面接 redis 的密码（若有），-h 后面接目标 ip 地址。</p><p>到此，Scrapy 分布式爬虫环境搭建完毕。</p><h2 id="3-2- 项目实战"><a href="#3-2- 项目实战" class="headerlink" title="3.2　项目实战"></a>3.2　项目实战 </h2><p> 本章的核心知识点是分布式爬取，因此本项目不再对分析页面、编写 Spider 等大家熟知的技术进行展示。我们可以任意挑选一个在之前章节中做过的项目，将其改为分布式爬取的版本，这里以第 8 章的 toscrape_book 项目（爬取 books.toscrape.com 中的书籍信息）为例进行讲解。</p><p>复制 toscrape_book 项目，得到新项目 toscrape_book_distributed：</p><pre><code>$ cp -r toscrape_book toscrape_book_distributed     $ cd toscrape_book_distributed</code></pre><p>在配置文件 settings.py 中添加 scrapy-redis 的相关配置：</p><pre><code># 必选项# ==================================================================# 指定爬虫所使用的 Redis 数据库（在云服务器 116.29.35.201 上）REDIS_URL = &#39;redis://116.29.35.201:6379&#39;# 使用 scrapy_redis 的调度器替代 Scrapy 原版调度器SCHEDULER = &quot;scrapy_redis.scheduler.Scheduler&quot;# 使用 scrapy_redis 的 RFPDupeFilter 作为去重过滤器DUPEFILTER_CLASS = &quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;# 启用 scrapy_redis 的 RedisPipeline 将爬取到的数据汇总到 Redis 数据库ITEM_PIPELINES = &#123;&#39;scrapy_redis.pipelines.RedisPipeline&#39;: 300,&#125;# 可选项# ==================================================================#爬虫停止后，保留／清理 Redis 中的请求队列以及去重集合# True：保留，False：清理，默认为 FalseSCHEDULER_PERSIST = True</code></pre><p>将单机版本的 Spider 改为分布式版本的 Spider，只需做如下简单改动：</p><pre><code>from scrapy_redis.spiders import RedisSpider     # 1. 更改基类     # class BooksSpider(spider.Spider):class BooksSpider(RedisSpider):        ...        # 2. 注释 start_urls        #start_urls = [&#39;http://books.toscrape.com/&#39;]        ...</code></pre><p>上述改动针对“如何为多个爬虫设置起始爬取点”这个问题，解释如下：</p><p>●　在分布式爬取时，所有主机上的代码是相同的，如果使用之前单机版本的 Spider 代码，那么每一台主机上的 Spider 都通过 start_urls 属性定义了起始爬取点，在构造起始爬取点的 Request 对象时，dont_filter 参数设置为了 True，即忽略去重过滤器的过滤。因此多个（数量等于爬虫数量）重复请求将强行进入 Redis 中的请求队列，这可能导致爬取到重复数据。</p><p>●　为了解决上述问题，scrapy-redis 提供了一个新的 Spider 基类 RedisSpider，RedisSpider 重写了 start_requests 方法，它尝试从 Redis 数据库的某个特定列表中获取起始爬取点，并构造 Request 对象（dont_filter=False），该列表的键可通过配置文件设置（REDIS_START_URLS_KEY），默认为<spider_name>:start_urls。在分布式爬取时，用户运行所有爬虫后，需手动使用 Redis 命令向该列表添加起始爬取点，之后只有其中一个爬虫能获取到起始爬取点，因此对应的请求也就只有一个，从而避免了重复。</p><p>到此，分布式版本的项目代码已经完成了，分发到各个主机：</p><pre><code>     $ scp -r toscrape_book_distributed liushuo@116.29.35.201:～/scrapy_book          $ scp -r toscrape_book_distributed liushuo@123.59.45.155:～/scrapy_book</code></pre><p>分别在 3 台主机使用相同命令运行爬虫：</p><pre><code>$ scrapy crawl books         2017-05-14 17:56:42 [scrapy.utils.log] INFO: Scrapy 1.3.3 started (bot: toscrape_book)         2017-05-14 17:56:42 [scrapy.utils.log] INFO: Overridden settings: &#123;&#39;DUPEFILTER_CLASS&#39;:     &#39;scrapy_redis.dupefilter.RFPDupeFilter&#39;, &#39;FEED_EXPORT_FIELDS&#39;: [&#39;upc&#39;, &#39;name&#39;, &#39;price&#39;, &#39;stock&#39;,     &#39;review_rating&#39;, &#39;review_num&#39;], &#39;SCHEDULER&#39;: &#39;scrapy_redis.scheduler.Scheduler&#39;, &#39;BOT_NAME&#39;:     &#39;toscrape_book&#39;, &#39;ROBOTSTXT_OBEY&#39;: True, &#39;NEWSPIDER_MODULE&#39;: &#39;toscrape_book.spiders&#39;,     &#39;SPIDER_MODULES&#39;: [&#39;toscrape_book.spiders&#39;]&#125;         2017-05-14 17:56:42 [scrapy.middleware] INFO: Enabled extensions:         [&#39;scrapy.extensions.logstats.LogStats&#39;,          &#39;scrapy.extensions.telnet.TelnetConsole&#39;,          &#39;scrapy.extensions.corestats.CoreStats&#39;]         2017-05-14 17:56:42 [books] INFO: Reading start URLs from redis key &#39;books:start_urls&#39; (batch size:     16, encoding: utf-8         2017-05-14 17:56:42 [scrapy.middleware] INFO: Enabled downloader middlewares:         [&#39;scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware&#39;,          &#39;scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware&#39;,          &#39;scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware&#39;,          &#39;scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware&#39;,          &#39;scrapy.downloadermiddlewares.useragent.UserAgentMiddleware&#39;,          &#39;scrapy.downloadermiddlewares.retry.RetryMiddleware&#39;,          &#39;scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware&#39;,          &#39;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#39;,          &#39;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&#39;,          &#39;scrapy.downloadermiddlewares.cookies.CookiesMiddleware&#39;,          &#39;scrapy.downloadermiddlewares.stats.DownloaderStats&#39;]         2017-05-14 17:56:42 [scrapy.middleware] INFO: Enabled spider middlewares:         [&#39;scrapy.spidermiddlewares.httperror.HttpErrorMiddleware&#39;,          &#39;scrapy.spidermiddlewares.offsite.OffsiteMiddleware&#39;,          &#39;scrapy.spidermiddlewares.referer.RefererMiddleware&#39;,          &#39;scrapy.spidermiddlewares.urllength.UrlLengthMiddleware&#39;,          &#39;scrapy.spidermiddlewares.depth.DepthMiddleware&#39;]         2017-05-14 17:56:42 [scrapy.middleware] INFO: Enabled item pipelines:          [&#39;scrapy_redis.pipelines.RedisPipeline&#39;]          2017-05-14 17:56:42 [scrapy.core.engine] INFO: Spider opened          2017-05-14 17:56:42 [scrapy.extensions.logstats] INFO: Crawled 0 pages (at 0 pages/min), scraped 0     items (at 0 items/min)          2017-05-14 17:56:42 [scrapy.extensions.telnet] DEBUG: Telnet console listening on 127.0.0.1:6023          ... 阻塞在此处...</code></pre><p>运行后，由于 Redis 中的起始爬取点列表和请求队列都是空的，3 个爬虫都进入了暂停等待的状态，因此在任意主机上使用 Redis 客户端设置起始爬取点：</p><pre><code>$ redis-cli -h 116.29.35.201     116.29.35.201:6379&gt; lpush books:start_urls &#39;http://books.toscrape.com/&#39;     (integer) 1</code></pre><p>随后，其中一个爬虫（本实验中是云服务器 A）从起始爬取点列表中获取到了 url，在其 log 中观察到如下信息：</p><pre><code>2017-05-14 17:57:18 [books] DEBUG: Read 1 requests from &#39;books:start_urls&#39;</code></pre><p>该爬虫用起始爬取点 url 构造的 Request 对象最终被添加到 Redis 中的请求队列之后。各个爬虫相继开始工作了，可在各爬虫的 log 中观察到类似于如下的信息：</p><pre><code>2017-05-14 18:00:42 [scrapy.core.scraper] DEBUG: Scraped from &lt;200     http://books.toscrape.com/catalogue/arena_587/index.html&gt;          &#123;&#39;name&#39;: &#39;Arena&#39;,           &#39;price&#39;: &#39;￡21.36&#39;,           &#39;review_num&#39;: &#39;0&#39;,           &#39;review_rating&#39;: &#39;Four&#39;,           &#39;stock&#39;: &#39;11&#39;,           &#39;upc&#39;: &#39;2c34f9432069b52b&#39;&#125;          2017-05-14 18:00:42 [scrapy.core.engine] DEBUG: Crawled (200)  (referer:     http://books.toscrape.com/catalogue/page-21.html)          2017-05-14 18:00:42 [scrapy.core.scraper] DEBUG: Scraped from &lt;200     http://books.toscrape.com/catalogue/adultery_586/index.html&gt;          &#123;&#39;name&#39;: &#39;Adultery&#39;,           &#39;price&#39;: &#39;￡20.88&#39;,           &#39;review_num&#39;: &#39;0&#39;,           &#39;review_rating&#39;: &#39;Five&#39;,           &#39;stock&#39;: &#39;11&#39;,           &#39;upc&#39;: &#39;bb967277222e689c&#39;&#125;          2017-05-14 18:00:42 [scrapy.core.engine] DEBUG: Crawled (200)  (referer:     http://books.toscrape.com/catalogue/page-21.html)          2017-05-14 18:00:42 [scrapy.core.scraper] DEBUG: Scraped from &lt;200     http://books.toscrape.com/catalogue/a-mothers-reckoning-living-in-the-aftermath-of-tragedy_585/index.htm     l&gt;          &#123;&#39;name&#39;: &quot;A Mother&#39;s Reckoning: Living in the Aftermath of Tragedy&quot;,           &#39;price&#39;: &#39;￡19.53&#39;,           &#39;review_num&#39;: &#39;0&#39;,           &#39;review_rating&#39;: &#39;Three&#39;,           &#39;stock&#39;: &#39;11&#39;,           &#39;upc&#39;: &#39;2b69dec0193511d9&#39;&#125;          2017-05-14 18:00:43 [scrapy.core.scraper] DEBUG: Scraped from &lt;200     http://books.toscrape.com/catalogue/112263_583/index.html&gt;          &#123;&#39;name&#39;: &#39;11/22/63&#39;,           &#39;price&#39;: &#39;￡48.48&#39;,           &#39;review_num&#39;: &#39;0&#39;,           &#39;review_rating&#39;: &#39;Three&#39;,           &#39;stock&#39;: &#39;11&#39;,           &#39;upc&#39;: &#39;a9d7b75461084a26&#39;&#125;          2017-05-14 18:00:43 [scrapy.core.engine] DEBUG: Crawled (200)  (referer:     http://books.toscrape.com/catalogue/page-21.html)          2017-05-14 18:00:43 [scrapy.core.scraper] DEBUG: Scraped from &lt;200     http://books.toscrape.com/catalogue/10-happier-how-i-tamed-the-voice-in-my-head-reduced-stress-without-     losing-my-edge-and-found-self-help-that-actually-works_582/index.html&gt;          &#123;&#39;name&#39;: &#39;10% Happier: How I Tamed the Voice in My Head, Reduced Stress &#39;                  &#39;Without Losing My Edge, and Found Self-Help That Actually Works&#39;,           &#39;price&#39;: &#39;￡24.57&#39;,           &#39;review_num&#39;: &#39;0&#39;,           &#39;review_rating&#39;: &#39;Two&#39;,           &#39;stock&#39;: &#39;10&#39;,           &#39;upc&#39;: &#39;34669b2e9d407d3a&#39;&#125;</code></pre><p>等待全部爬取完成后，在 Redis 中查看爬取到的数据：</p><pre><code>116.29.35.201:6379&gt; keys *     1) &quot;books:items&quot;     2) &quot;books:dupefilter&quot;     116.29.35.201:6379&gt; llen books:items     (integer) 1000     116.29.35.201:6379&gt; LRANGE books:items 0 4          1) &quot;&#123;\&quot;stock\&quot;: \&quot;22\&quot;, \&quot;review_num\&quot;: \&quot;0\&quot;, \&quot;upc\&quot;: \&quot;a897fe39b1053632\&quot;, \&quot;name\&quot;: \&quot;A Light in     the Attic\&quot;, \&quot;review_rating\&quot;: \&quot;Three\&quot;, \&quot;price\&quot;: \&quot;\\u00a351.77\&quot;&#125;&quot;          2) &quot;&#123;\&quot;stock\&quot;: \&quot;20\&quot;, \&quot;review_num\&quot;: \&quot;0\&quot;, \&quot;upc\&quot;: \&quot;e00eb4fd7b871a48\&quot;, \&quot;name\&quot;: \&quot;Sharp     Objects\&quot;, \&quot;review_rating\&quot;: \&quot;Four\&quot;, \&quot;price\&quot;: \&quot;\\u00a347.82\&quot;&#125;&quot;          3) &quot;&#123;\&quot;stock\&quot;: \&quot;20\&quot;, \&quot;review_num\&quot;: \&quot;0\&quot;, \&quot;upc\&quot;: \&quot;90fa61229261140a\&quot;, \&quot;name\&quot;: \&quot;Tipping the     Velvet\&quot;, \&quot;review_rating\&quot;: \&quot;One\&quot;, \&quot;price\&quot;: \&quot;\\u00a353.74\&quot;&#125;&quot;          4) &quot;&#123;\&quot;stock\&quot;: \&quot;20\&quot;, \&quot;review_num\&quot;: \&quot;0\&quot;, \&quot;upc\&quot;: \&quot;6957f44c3847a760\&quot;, \&quot;name\&quot;:     \&quot;Soumission\&quot;, \&quot;review_rating\&quot;: \&quot;One\&quot;, \&quot;price\&quot;: \&quot;\\u00a350.10\&quot;&#125;&quot;          5) &quot;&#123;\&quot;stock\&quot;: \&quot;19\&quot;, \&quot;review_num\&quot;: \&quot;0\&quot;, \&quot;upc\&quot;: \&quot;2597b5a345f45e1b\&quot;, \&quot;name\&quot;: \&quot;The Dirty     Little Secrets of Getting Your Dream Job\&quot;, \&quot;review_rating\&quot;: \&quot;Four\&quot;, \&quot;price\&quot;: \&quot;\\u00a333.34\&quot;&#125;&quot;          116.29.35.201:6379&gt; LRANGE books:items -5 -1          1) &quot;&#123;\&quot;name\&quot;: \&quot;Shameless\&quot;, \&quot;price\&quot;: \&quot;\\u00a358.35\&quot;, \&quot;review_rating\&quot;: \&quot;Three\&quot;, \&quot;upc\&quot;:     \&quot;c068c013d6921fea\&quot;, \&quot;review_num\&quot;: \&quot;0\&quot;, \&quot;stock\&quot;: \&quot;1\&quot;&#125;&quot;          2) &quot;&#123;\&quot;stock\&quot;: \&quot;1\&quot;, \&quot;review_num\&quot;: \&quot;0\&quot;, \&quot;upc\&quot;: \&quot;19fec36a1dfb4c16\&quot;, \&quot;name\&quot;: \&quot;A Spy&#39;s     Devotion (The Regency Spies of London ##1)\&quot;, \&quot;review_rating\&quot;: \&quot;Five\&quot;, \&quot;price\&quot;: \&quot;\\u00a316.97\&quot;&#125;&quot;          3) &quot;&#123;\&quot;stock\&quot;: \&quot;1\&quot;, \&quot;review_num\&quot;: \&quot;0\&quot;, \&quot;upc\&quot;: \&quot;f684a82adc49f011\&quot;, \&quot;name\&quot;: \&quot;1st to Die     (Women&#39;s Murder Club ##1)\&quot;, \&quot;review_rating\&quot;: \&quot;One\&quot;, \&quot;price\&quot;: \&quot;\\u00a353.98\&quot;&#125;&quot;          4) &quot;&#123;\&quot;stock\&quot;: \&quot;1\&quot;, \&quot;review_num\&quot;: \&quot;0\&quot;, \&quot;upc\&quot;: \&quot;228ba5e7577e1d49\&quot;, \&quot;name\&quot;: \&quot;1,000 Places     to See Before You Die\&quot;, \&quot;review_rating\&quot;: \&quot;Five\&quot;, \&quot;price\&quot;: \&quot;\\u00a326.08\&quot;&#125;&quot;          5) &quot;&#123;\&quot;name\&quot;: \&quot;Girl in the Blue Coat\&quot;, \&quot;price\&quot;: \&quot;\\u00a346.83\&quot;, \&quot;review_rating\&quot;: \&quot;Two\&quot;,     \&quot;upc\&quot;: \&quot;41fc5dce044f16f5\&quot;, \&quot;review_num\&quot;: \&quot;0\&quot;, \&quot;stock\&quot;: \&quot;3\&quot;&#125;&quot;</code></pre><p>如上所示，我们成功地爬取到了 1000 项数据（由各爬虫最后的 log 信息得知，爬虫 A:514 项，爬虫 B:123 项，爬虫 C:363 项）。每一项数据以 json 形式存储在 Redis 的列表中，需要使用这些数据时，可以编写 Python 程序将它们从 Redis 中读出，代码框架如下：</p><pre><code class="python">import redisimport jsonITEM_KEY = &#39;books:items&#39;def process_item(item):        # 添加处理数据的代码        &#39;&#39;&#39;...&#39;&#39;&#39;def main():        r = redis.StrictRedis(host=&#39;116.29.35.201&#39;, port=6379)        for _ in range(r.llen(ITEM_KEY)):            data = r.lpop(ITEM_KEY)            item = json.loads(data.decode(&#39;utf8&#39;))            process_item(item)if __name__ == &#39;__main__&#39;:        main()</code></pre><p>到此，我们完成了分布式爬取的项目。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫 Request 去重及过滤器</title>
      <link href="/%E7%88%AC%E8%99%ABRequest%E5%8E%BB%E9%87%8D%E5%8F%8A%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/%E7%88%AC%E8%99%ABRequest%E5%8E%BB%E9%87%8D%E5%8F%8A%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1、过滤器"><a href="#1、过滤器" class="headerlink" title="1、过滤器"></a>1、过滤器 </h1><p> 过滤器 (Filter) 是处于客户端与服务器资源文件之间的一道过滤网，在访问资源文件之前，通过一系列的过滤器对请求进行修改、判断等，把不符合规则的请求在中途拦截或修改。也可以对响应进行过滤，拦截或修改响应。</p><p>过滤器主要用于增量式爬虫中，所谓增量式爬虫并不是新型的爬虫架构，而是根据项目需求而产生的一种爬虫类型。例如我们想爬取智联的职位信息，可是我们只想爬取每天更新的职位信息，不想全部都爬取，这就需要增量式爬虫。增量式爬虫的核心在于快速去重，我们必须判断哪些是已经爬取过的，哪些是新产生的。</p><h2 id="1-1- 去重方案"><a href="#1-1- 去重方案" class="headerlink" title="1.1 去重方案"></a>1.1 去重方案 </h2><p> 对于爬虫来说，由于网络间的链接错综复杂，爬虫在网络间爬行很可能会形成“环”，这对爬虫来说是非常可怕的事情，会一直做无用功。为了避免形成“环”，就需要知道 Spider 已经访问过哪些 URL，基本上有如下几种方案。</p><h3 id="1-1-1- 关系型数据库去重"><a href="#1-1-1- 关系型数据库去重" class="headerlink" title="1.1.1 关系型数据库去重"></a>1.1.1 <strong>关系型数据库去重 </strong></h3><p> 关系型数据库去重，需要将 URL 存入到数据库中，每来一个 URL 就启动一次数据库查询，数据量变得非常庞大后关系型数据库查询的效率会变得很低，不推荐。</p><h3 id="1-1-2- 缓存数据库去重"><a href="#1-1-2- 缓存数据库去重" class="headerlink" title="1.1.2 缓存数据库去重"></a>1.1.2 <strong>缓存数据库去重 </strong></h3><p> 缓存数据库，比如现在比较流行的 Redis，去重方式是使用其中的 Set 数据类型，类似于 Python 中的 Set，也是一种内存去重方式，但是它可以将内存中的数据持久化到硬盘中，应用非常广泛，推荐。</p><h3 id="1-1-3- 内存去重"><a href="#1-1-3- 内存去重" class="headerlink" title="1.1.3 内存去重"></a>1.1.3 <strong>内存去重 </strong></h3><p> 内存去重方案，可以细分出三种不同的实现方式：</p><ul><li>将 URL 直接存储到 HashSet 中，也就是 Python 中的 Set 数据结构中，但是这种方式最明显的缺点是太消耗内存。随着 URL 的增多，占用的内存会越来越多。大家可以计算一下假如存储了 1 亿个链接，每个链接平均 40 个字符，这就占用了 4G 内存。</li><li>将 URL 经过 MD5 或者 SHA-1 等单向哈希算法生成摘要，再存储到 HashSet 中。由于字符串经过 MD5 处理后的信息摘要长度只有 128 位，SHA-1 处理后也只有 160 位，所以占用的内存将比第一种方式小很多倍。</li><li>采用 Bit-Map 方法，建立一个 BitSet，将每个 URL 经过一个哈希函数映射到某一位。这种方式消耗内存是最少，但缺点是单一哈希函数发生冲突的概率太高，极易发生误判。</li></ul><h2 id="1-2-Scrapy 默认去重"><a href="#1-2-Scrapy 默认去重" class="headerlink" title="1.2 Scrapy 默认去重"></a>1.2 Scrapy 默认去重</h2><p>scrapy 默认是进行 url 去重，scrapy 内部默认也提供了一个去重方案，位于<code>scrapy.dupefilters.RFPDupeFilter</code>, 具体逻辑如下</p><pre><code class="python">class RFPDupeFilter(BaseDupeFilter):    &quot;&quot;&quot;Request Fingerprint duplicates filter&quot;&quot;&quot;    ...    def __init__(self, path=None, debug=False):        self.file = None        self.fingerprints = set()        self.logdupes = True        self.debug = debug        self.logger = logging.getLogger(__name__)        if path:            self.file = open(os.path.join(path, &#39;requests.seen&#39;), &#39;a+&#39;)            self.file.seek(0)            self.fingerprints.update(x.rstrip() for x in self.file)    def request_seen(self, request):        fp = self.request_fingerprint(request)        if fp in self.fingerprints:            return True        self.fingerprints.add(fp)        if self.file:            self.file.write(fp + os.linesep)    def request_fingerprint(self, request):        return request_fingerprint(request)</code></pre><p>由类里面的 <code>request_seen</code> 实现去重的逻辑，具体的逻辑被封装在 <code>request_fingerprint（request 指纹）</code> 方法里面。</p><p>继续查看源代码，可以了解到 Scrapy 是根据 request_fingerprint 方法实现过滤的，将 Request 指纹添加到 set（）中。部分源码如下：</p><pre><code class="python">def request_fingerprint(request, include_headers=None):    if include_headers:        include_headers = tuple(to_bytes(h.lower())        for h in sorted(include_headers))    cache = _fingerprint_cache.setdefault(request, &#123;&#125;)    if include_headers not in cache:        fp = hashlib.sha1()        fp.update(to_bytes(request.method))        fp.update(to_bytes(canonicalize_url(request.url)))        fp.update(request.body or b&#39;&#39;)        if include_headers:            for hdr in include_headers:                if hdr in request.headers:                    fp.update(hdr)                    for v in request.headers.getlist(hdr):                        fp.update(v)        cache[include_headers] = fp.hexdigest()    return cache[include_headers]</code></pre><p>从代码中我们可以看到，去重指纹为 sha1（method+url+body+header），对这个整体进行去重，去重比例太小。</p><p>scrapy 自带过滤器的缺点：</p><ol><li>存储在本机的内存里面（set）</li><li>没有数据持久化，重启爬虫之后，数据都没了</li><li>存储的是 url 的指纹，一旦请求的 url 很多，去重数据就会变得非常大。</li></ol><h2 id="1-3- 修改过滤器"><a href="#1-3- 修改过滤器" class="headerlink" title="1.3 修改过滤器"></a>1.3 修改过滤器 </h2><p> 下面我们根据 URL 进行去重，定制过滤器。代码如下：</p><pre><code class="python">from scrapy.dupefilter import RFPDupeFilterclass URLFilter(RFPDupeFilter):    &quot;&quot;&quot; 根据 URL 过滤 &quot;&quot;&quot;    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        self.urls_seen = set()    def request_seen(self, request):        if request.url in self.urls_seen:            return True        else:            self.urls_seen.add(request.url)</code></pre><p>但是这样依旧不是很好，因为 URL 有时候会很长导致内存上升，我们可以将 URL 经过 sha1 操作之后再去重，改进如下：</p><pre><code class="python"> from scrapy.dupefilter import RFPDupeFilter from w3lib.util.url import canonicalize_url class URLSha1Filter(RFPDupeFilter):    &quot;&quot;&quot; 根据 urlsha1 过滤 &quot;&quot;&quot;    def __init__(self, path=None):        self.urls_seen = set()        super().__init__(self, path)    def request_seen(self, request):        fp = hashlib.sha1()        fp.update(canonicalize_url(request.url))        url_sha1 = fp.hexdigest()        if url_sha1 in self.urls_seen:            return True        else:            self.urls_seen.add(url_sha1)</code></pre><h1 id="2、布隆过滤器"><a href="#2、布隆过滤器" class="headerlink" title="2、布隆过滤器"></a>2、布隆过滤器 </h1><p> 本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><p><a href="https://www.jianshu.com/p/2104d11ee0a2">详解布隆过滤器的原理、使用场景和注意事项</a></p><p>特点：布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势；空间效率和查询时间都远远超过一般的 <strong> 算法</strong>，布隆过滤器存储空间和插入 / 查询时间都是常数 O(k)。</p><h2 id="2-1- 介绍及原理"><a href="#2-1- 介绍及原理" class="headerlink" title="2.1 介绍及原理"></a>2.1 介绍及原理 </h2><h3 id="前置需求"><a href="# 前置需求" class="headerlink" title="前置需求"></a> 前置需求</h3><ul><li>需求<ul><li>已经有 50 亿个电话号码，现在给出 10 万个电话号码，如何快速准确地判断这些电话号码是否已经存在？</li></ul></li><li>参考方案<ul><li>通过数据库查询：比如 MySQL，性能不行，速度太慢</li><li>将数据先放进内存：50 亿 *8 字节 =40GB，内存占用太大</li><li>hyperloglog 算法：准确度不行</li></ul></li><li>现实类似问题<ul><li>垃圾邮件判断</li><li>文字处理软件的错误单词检测</li><li>网络爬虫的 url 去重</li></ul></li><li>解决方法<ul><li>使用布隆过滤器</li></ul></li></ul><h3 id="布隆过滤器介绍以及原理"><a href="# 布隆过滤器介绍以及原理" class="headerlink" title="布隆过滤器介绍以及原理"></a>布隆过滤器介绍以及原理</h3><ul><li><p>布隆过滤器作用</p><ul><li>占用很少的空间和使用较少的时间判断一个小数据集是否是一个大数据集的子集</li></ul></li><li><p>布隆过滤器参数</p><ul><li>n：一个很长的二进制，n 位</li><li>m：需要放入的数据数量，m 个</li><li>k：k 个哈希函数</li></ul></li><li><p>布隆过滤器构建过程</p><ul><li><p>初始化：原始二进制数字中的每一位都置为 0</p></li><li><p>一个数据经过 1 个哈希函数会得到一个位置，该位置置 1</p></li><li><p>一个数据经过 k 个哈希函数处理会，在原理二进制中会有 k 个位置被置 1</p></li><li><p>所有数据重复以上两步，即可构建出对于这个数据集的布隆过滤器</p></li></ul></li></ul><pre><code>![布隆过滤器过程](https://image--1.oss-cn-shenzhen.aliyuncs.com/ 布隆过滤器过程 -1573824010772.png)</code></pre><ul><li><p>布隆过滤器判断有无</p><ul><li>一个数据经过 k 个哈希函数处理，查看得到的位置是否都为 1，如果有至少一个位置不为 1，则证明这个数据不在数据集中，反之，这个数据很大可能在这个数据集中（因为存在误差）</li></ul></li><li><p>布隆过滤器的误差</p><ul><li><p>误差可能存在</p><ul><li>一个数据并未参数构建布隆过滤器，但是它的计算结果可能会“已经存在”，比如当只用 1 个哈希函数或者二进制数很短时，可能别的数据的结果刚好与整个数据相同，于是这个数据也被当做存在了</li><li>已有的数据一定显示已有，未有数据可能”已有“</li></ul></li><li><p>误差计算</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/%E8%AF%AF%E5%B7%AE%E7%8E%87%E8%AE%A1%E7%AE%97.png" alt="误差率计算"></p></li><li><p>误差率统计</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%AF%E5%B7%AE%E7%8E%87%E7%BB%9F%E8%AE%A1.png" alt="布隆过滤器误差率统计"></p></li></ul></li></ul><h3 id="布隆过滤器的实现"><a href="# 布隆过滤器的实现" class="headerlink" title="布隆过滤器的实现"></a>布隆过滤器的实现</h3><ul><li>由 Go 和 redis 组合实现一个布隆过滤器</li><li>底层数据结构<ul><li>redis 中衍生数据类型很适合作为实现布隆过滤器的底层数据类型</li></ul></li><li>实现方法<ul><li>布隆过滤器的构造参数：插入数量 m，哈希函数个数 k</li><li>布隆过滤器的操作函数：Add，Contains，Probability</li><li>封装 redis 位图操作</li><li>总体代码</li><li>样例测试</li></ul></li></ul><h2 id="2-2- 对接 Scrapy"><a href="#2-2- 对接 Scrapy" class="headerlink" title="2.2 对接 Scrapy"></a>2.2 对接 Scrapy</h2><p>实现 Bloom Filter 时，Bloom Filter 的实现需要借助于一个位数组，既然当前架构依赖于 Redis，那么位数组的维护直接使用 Redis 就好了。</p><p>首先实现一个基本的散列算法，将一个值经过散列运算后映射到一个 m 位数组的某一位上，代码如下：</p><pre><code class="javascript">class HashMap(object):    def __init__(self, m, seed):        self.m = m        self.seed = seed    def hash(self, value):        &quot;&quot;&quot;        Hash Algorithm        :param value: Value        :return: Hash Value        &quot;&quot;&quot;        ret = 0        for i in range(len(value)):            ret += self.seed * ret + ord(value[i])                return (self.m - 1) &amp; ret</code></pre><p>这里新建了一个 <code>HashMap</code> 类。构造函数传入两个值，一个是 m 位数组的位数，另一个是种子值<code>seed</code>。不同的散列函数需要有不同的<code>seed</code>，这样可以保证不同的散列函数的结果不会碰撞。</p><p>在 <code>hash()</code> 方法的实现中，<code>value</code>是要被处理的内容。这里遍历了 <code>value</code> 的每一位，并利用 <code>ord()</code> 方法取到每一位的 ASCII 码值，然后混淆 <code>seed</code> 进行迭代求和运算，最终得到一个数值。这个数值的结果就由 <code>value</code> 和<code>seed</code>唯一确定。我们再将这个数值和 m 进行按位与运算，即可获取到 m 位数组的映射结果，这样就实现了一个由字符串和 <code>seed</code> 来确定的散列函数。当 m 固定时，只要 <code>seed</code> 值相同，散列函数就是相同的，相同的 <code>value</code> 必然会映射到相同的位置。所以如果想要构造几个不同的散列函数，只需要改变其 <code>seed</code> 就好了。以上内容便是一个简易的散列函数的实现。</p><p>接下来我们再实现 Bloom Filter。Bloom Filter 里面需要用到 k 个散列函数，这里要对这几个散列函数指定相同的 m 值和不同的 <code>seed</code> 值，构造如下：</p><pre><code class="javascript">BLOOMFILTER_HASH_NUMBER = 6BLOOMFILTER_BIT = 30class BloomFilter(object):    def __init__(self, server, key, bit=BLOOMFILTER_BIT, hash_number=BLOOMFILTER_HASH_NUMBER):        &quot;&quot;&quot;        Initialize BloomFilter        :param server: Redis Server        :param key: BloomFilter Key        :param bit: m = 2 ^ bit        :param hash_number: the number of hash function        &quot;&quot;&quot;        # default to 1 &lt;&lt; 30 = 10,7374,1824 = 2^30 = 128MB, max filter 2^30/hash_number = 1,7895,6970 fingerprints        self.m = 1 &lt;&lt; bit        self.seeds = range(hash_number)        self.maps = [HashMap(self.m, seed) for seed in self.seeds]        self.server = server        self.key = key</code></pre><p>由于我们需要亿级别的数据的去重，即前文介绍的算法中的 n 为 1 亿以上，散列函数的个数 k 大约取 10 左右的量级。而 m&gt;kn，这里 m 值大约保底在 10 亿，由于这个数值比较大，所以这里用移位操作来实现，传入位数 bit，将其定义为 30，然后做一个移位操作<code>1&lt;&lt;30</code>，相当于 2 的 30 次方，等于 1073741824，量级也是恰好在 10 亿左右，由于是位数组，所以这个位数组占用的大小就是 2^30 b=128 MB。开头我们计算过 Scrapy-Redis 集合去重的占用空间大约在 2 GB 左右，可见 Bloom Filter 的空间利用效率极高。</p><p>随后我们再传入散列函数的个数，用它来生成几个不同的 <code>seed</code>。用不同的<code>seed</code> 来定义不同的散列函数，这样我们就可以构造一个散列函数列表。遍历 <code>seed</code>，构造带有不同<code>seed</code> 值的 <code>HashMap</code> 对象，然后将 <code>HashMap</code> 对象保存成变量 <code>maps</code> 供后续使用。</p><p>另外，<code>server</code>就是 Redis 连接对象，<code>key</code>就是这个 m 位数组的名称。</p><p>接下来，我们要实现比较关键的两个方法：一个是判定元素是否重复的方法<code>exists()</code>，另一个是添加元素到集合中的方法<code>insert()</code>，实现如下：</p><pre><code class="javascript">def exists(self, value):    &quot;&quot;&quot;    if value exists    :param value:    :return:    &quot;&quot;&quot;    if not value:                return False    exist = 1    for map in self.maps:        offset = map.hash(value)        exist = exist &amp; self.server.getbit(self.key, offset)        return existdef insert(self, value):    &quot;&quot;&quot;    add value to bloom    :param value:    :return:    &quot;&quot;&quot;    for f in self.maps:        offset = f.hash(value)        self.server.setbit(self.key, offset, 1)</code></pre><p>首先看下 <code>insert()</code> 方法。Bloom Filter 算法会逐个调用散列函数对放入集合中的元素进行运算，得到在 m 位位数组中的映射位置，然后将位数组对应的位置置 1。这里代码中我们遍历了初始化好的散列函数，然后调用其 <code>hash()</code> 方法算出映射位置 <code>offset</code>，再利用 Redis 的<code>setbit()</code> 方法将该位置 1。</p><p>在 <code>exists()</code> 方法中，我们要实现判定是否重复的逻辑，方法参数 <code>value</code> 为待判断的元素。我们首先定义一个变量 <code>exist</code>，遍历所有散列函数对<code>value</code> 进行散列运算，得到映射位置，用 <code>getbit()</code> 方法取得该映射位置的结果，循环进行与运算。这样只有每次 <code>getbit()</code> 得到的结果都为 1 时，最后的 <code>exist</code> 才为 <code>True</code>，即代表<code>value</code> 属于这个集合。如果其中只要有一次 <code>getbit()</code> 得到的结果为 0，即 m 位数组中有对应的 0 位，那么最终的结果 <code>exist</code> 就为 <code>False</code>，即代表<code>value</code> 不属于这个集合。</p><p>Bloom Filter 的实现就已经完成了，我们可以用一个实例来测试一下，代码如下：</p><pre><code class="javascript">conn = StrictRedis(host=&#39;localhost&#39;, port=6379, password=&#39;foobared&#39;)bf = BloomFilter(conn, &#39;testbf&#39;, 5, 6)bf.insert(&#39;Hello&#39;)bf.insert(&#39;World&#39;)result = bf.exists(&#39;Hello&#39;)print(bool(result))result = bf.exists(&#39;Python&#39;)print(bool(result))</code></pre><p>这里首先定义了一个 Redis 连接对象，然后传递给 Bloom Filter。为了避免内存占用过大，这里传的位数 bit 比较小，设置为 5，散列函数的个数设置为 6。</p><p>调用 <code>insert()</code> 方法插入 <code>Hello</code> 和<code>World</code>两个字符串，随后判断 <code>Hello</code> 和<code>Python</code>这两个字符串是否存在，最后输出它的结果，运行结果如下：</p><pre><code class="javascript">TrueFalse</code></pre><p>很明显，结果完全没有问题。这样我们就借助 Redis 成功实现了 Bloom Filter 的算法。</p><p>接下来继续修改 Scrapy-Redis 的源码，将它的 dupefilter 逻辑替换为 Bloom Filter 的逻辑。这里主要是修改 <code>RFPDupeFilter</code> 类的 <code>request_seen()</code> 方法，实现如下：</p><pre><code class="javascript">def request_seen(self, request):    fp = self.request_fingerprint(request)        if self.bf.exists(fp):                return True    self.bf.insert(fp)        return False</code></pre><p>利用 <code>request_fingerprint()</code> 方法获取 Request 的指纹，调用 Bloom Filter 的 <code>exists()</code> 方法判定该指纹是否存在。如果存在，则说明该 Request 是重复的，返回 <code>True</code>，否则调用 Bloom Filter 的<code>insert()</code> 方法将该指纹添加并返回<code>False</code>。这样就成功利用 Bloom Filter 替换了 Scrapy-Redis 的集合去重。</p><p>对于 Bloom Filter 的初始化定义，我们可以将 <code>__init__()</code> 方法修改为如下内容：</p><pre><code class="javascript">def __init__(self, server, key, debug, bit, hash_number):    self.server = server    self.key = key    self.debug = debug    self.bit = bit    self.hash_number = hash_number    self.logdupes = True    self.bf = BloomFilter(server, self.key, bit, hash_number)</code></pre><p>其中 <code>bit</code> 和<code>hash_number</code>需要使用 <code>from_settings()</code> 方法传递，修改如下：</p><pre><code class="javascript">@classmethoddef from_settings(cls, settings):    server = get_redis_from_settings(settings)    key = defaults.DUPEFILTER_KEY % &#123;&#39;timestamp&#39;: int(time.time())&#125;    debug = settings.getbool(&#39;DUPEFILTER_DEBUG&#39;, DUPEFILTER_DEBUG)    bit = settings.getint(&#39;BLOOMFILTER_BIT&#39;, BLOOMFILTER_BIT)    hash_number = settings.getint(&#39;BLOOMFILTER_HASH_NUMBER&#39;, BLOOMFILTER_HASH_NUMBER)        return cls(server, key=key, debug=debug, bit=bit, hash_number=hash_number)</code></pre><p>其中，常量 <code>DUPEFILTER_DEBUG</code> 和<code>BLOOMFILTER_BIT</code>统一定义在 defaults.py 中，默认如下：</p><pre><code class="javascript">BLOOMFILTER_HASH_NUMBER = 6BLOOMFILTER_BIT = 30</code></pre><p>现在，我们成功实现了 Bloom Filter 和 Scrapy-Redis 的对接。</p><h2 id="2-3- 封装使用"><a href="#2-3- 封装使用" class="headerlink" title="2.3 封装使用"></a>2.3 封装使用 </h2><p> 本节代码地址为：<a href="https://github.com/Python3WebSpider/ScrapyRedisBloomFilter。">https://github.com/Python3WebSpider/ScrapyRedisBloomFilter。</a></p><p>为了方便使用，本节的代码已经打包成一个 Python 包并发布到 PyPi，链接为<a href="https://pypi.python.org/pypi/scrapy-redis-bloomfilter，可以直接使用 ScrapyRedisBloomFilter，不需要自己实现一遍。">https://pypi.python.org/pypi/scrapy-redis-bloomfilter，可以直接使用 ScrapyRedisBloomFilter，不需要自己实现一遍。</a></p><p>我们可以直接使用 pip 来安装，命令如下：</p><pre><code class="javascript">pip3 install scrapy-redis-bloomfilter</code></pre><p>使用的方法和 Scrapy-Redis 基本相似，在这里说明几个关键配置。</p><pre><code class="javascript"># 去重类，要使用 Bloom Filter 请替换 DUPEFILTER_CLASSDUPEFILTER_CLASS = &quot;scrapy_redis_bloomfilter.dupefilter.RFPDupeFilter&quot;# 散列函数的个数，默认为 6，可以自行修改BLOOMFILTER_HASH_NUMBER = 6# Bloom Filter 的 bit 参数，默认 30，占用 128MB 空间，去重量级 1 亿BLOOMFILTER_BIT = 30</code></pre><ul><li><code>DUPEFILTER_CLASS</code>是去重类，如果要使用 Bloom Filter，则 <code>DUPEFILTER_CLASS</code> 需要修改为该包的去重类。</li><li><code>BLOOMFILTER_HASH_NUMBER</code>是 Bloom Filter 使用的散列函数的个数，默认为 6，可以根据去重量级自行修改。</li><li><code>BLOOMFILTER_BIT</code>即前文所介绍的 <code>BloomFilter</code> 类的 <code>bit</code> 参数，它决定了位数组的位数。如果 <code>BLOOMFILTER_BIT</code> 为 30，那么位数组位数为 2 的 30 次方，这将占用 Redis 128 MB 的存储空间，去重量级在 1 亿左右，即对应爬取量级 1 亿左右。如果爬取量级在 10 亿、20 亿甚至 100 亿，请务必将此参数对应调高。</li></ul><p>以上内容便是 Bloom Filter 的原理及对接实现，Bloom Filter 的使用可以大大节省 Redis 内存。在数据量大的情况下推荐此方案。</p><h1 id="3、摘要算法"><a href="#3、摘要算法" class="headerlink" title="3、摘要算法"></a>3、摘要算法 </h1><h2 id="3-1-SHA"><a href="#3-1-SHA" class="headerlink" title="3.1 SHA"></a>3.1 SHA</h2><p>SHA（Secure Hash Algorithm）是由美国专门制定密码算法的标准机构——美国国家标准技术研究院（NIST）制定的，SHA 系列算法的摘要长度分别为：SHA 为 20 字节（160 位）、SHA256 为 32 字节（256 位）、 SHA384 为 48 字节（384 位）、SHA512 为 64 字节（512 位），由于它产生的数据摘要的长度更长，因此更难以发生碰撞，因此也更为安全，它是未来数据摘要算法的发展方向。由于 SHA 系列算法的数据摘要长度较长，因此其运算速度与 MD5 相比，也相对较慢。<br> 目前 SHA1 的应用较为广泛，主要应用于 CA 和数字证书中，另外在目前互联网中流行的 BT 软件中，也是使用 SHA1 来进行文件校验的。</p><h3 id="3-1-1-SHA-1"><a href="#3-1-1-SHA-1" class="headerlink" title="3.1.1 SHA-1"></a>3.1.1 SHA-1</h3><p>SHA-1 算法可以从明文生成 160bit 的信息摘要，示例如下：</p><p>给定明文：      abcd</p><p>SHA-1 摘要：   81FE8BFE87576C3ECB22426F8E57847382917ACF</p><pre><code>import hashlibsha1 = hashlib.sha1()sha1.update(b&#39;abcd&#39;)print(sha1.hexdigest())</code></pre><p>SHA-1 与 MD5 的主要区别是什么呢？</p><p><strong>1. 摘要长度不同</strong>。</p><p>MD5 的摘要的长度为 128bit，SHA-1 摘要长度 160bit。多出 32bit 意味着什么呢？不同明文的碰撞几率降低了 2^32 = 324294967296 倍。</p><p><strong>2. 性能略有差别</strong></p><p>SHA-1 生成摘要的性能比 MD5 略低。</p><h3 id="3-1-2-SHA-2"><a href="#3-1-2-SHA-2" class="headerlink" title="3.1.2 SHA-2"></a>3.1.2 SHA-2</h3><p>SHA-2 是一系列 SHA 算法变体的总称，其中包含如下子版本：</p><p>SHA-256：可以生成长度 256bit 的信息摘要。</p><p>SHA-224：SHA-256 的“阉割版”，可以生成长度 224bit 的信息摘要。</p><p>SHA-512：可以生成长度 512bit 的信息摘要。</p><p>SHA-384：SHA-512 的“阉割版”，可以生成长度 384bit 的信息摘要。</p><h2 id="3-2-MD5"><a href="#3-2-MD5" class="headerlink" title="3.2 MD5"></a>3.2 MD5</h2><p>Message-Digest Algorithm 5，消息摘要算法版本 5。由 Ron Rivest（RSA 公司）在 1992 年提出，目前被广泛应用于数据完整性校验、数据（消息）摘要、数据加密等。MD2、MD4、MD5 都产生 16 字节（128 位）的校验值，一般用 32 位十六进制数表示。MD2 的算法较慢但相对安全，MD4 速度很快，但安全性下降，MD5 比 MD4 更安全、速度更快。</p><p>是信息摘要的一种实现，它可以从任意长度的明文字符串生成 128 位哈希值</p><p><strong>摘要哈希生成的正确姿势是什么样呢？分三步：</strong></p><p>1. 收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。</p><p>2. 按照规则，把参数名和参数值拼接成一个字符串，同时把给定的 <strong> 密钥 </strong> 也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。</p><p>3. 利用 MD5 算法，从原文生成哈希值。MD5 生成的哈希值是 128 位的二进制数，也就是 32 位的十六进制数。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/8776693-db5a3acd161b4d61.webp" alt=""></p><p>考虑把多种摘要算法结合使用比如</p><p>明文：        abcd</p><p>MD5 摘要：</p><p>e2fc714c4727ee9395f324cd2e7f331f</p><p>SHA-256 摘要：</p><p>88d4266fd4e6338d13b845fcf289579d209c897823b9217da3e161936f031589</p><p>取 MD5 摘要的前 16 位，取 SHA-256 的后 32 位</p><p><strong>简单概括起来，MD5 算法的过程分为四步：</strong>处理原文 <strong>，</strong> 设置初始值 <strong>，</strong> 循环加工，拼接结果。</p><p><strong>第一步: 处理原文</strong></p><p>首先，计算出原文长度 (bit) 对 512 求余的结果，如果不等于 448，就需要填充原文使得原文对 512 求余的结果等于 448。填充的方法是第一位填充 1，其余位填充 0。填充完后，信息的长度就是 512*N+448。</p><p>之后，用剩余的位置（512-448=64 位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是 512*(N+1)。</p><p><strong>第二步: 设置初始值</strong></p><p>MD5 的哈希结果长度为 128 位，按每 32 位分成一组共 4 组。这 4 组结果是由 4 个初始值 A、B、C、D 经过不断演变得到。</p><p><strong>第三步: 循环加工</strong></p><p>这一步是最复杂的一步，我们看看下面这张图，此图代表了单次 A,B,C,D 值演变的流程。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/8776693-04ea4d70cced29bb.webp" alt=""></p><p>图中，A，B，C，D 就是哈希值的四个分组。每一次循环都会让旧的 ABCD 产生新的 ABCD。一共进行多少次循环呢？由处理后的原文长度决定。</p><p>假设处理后的原文长度是 M</p><p>主循环次数 = <strong>M / 512</strong></p><p>每个主循环中包含 <strong>512 / 32 * 4 = 64</strong> 次 子循环。</p><p>上面这张图所表达的就是 <strong> 单次子循环 </strong> 的流程。</p><p>1. 图中的绿色 F，代表非线性函数</p><p>2. 红色的田字代表相加</p><p>3. 黄色的 &lt;&lt;&lt;S(左移 S 位)</p><p>4.Mi 是第一步处理后的原文。在第一步中，处理后原文的长度是 512 的整数倍。把原文的每 512 位再分成 16 等份，命名为 M0M15，每一等份长度 32。在 64 次子循环中，每 16 次循环，都会交替用到 M1M16 之一。</p><p>5.ki 一个常量，在 64 次子循环中，每一次用到的常量都是不同的</p><p><strong>第四步：拼接结果</strong></p><p>这一步就很简单了，把循环加工最终产生的 A，B，C，D 四个值拼接在一起，转换成字符串即可。</p><p><strong>简而言之，MD5 把 128bit 的信息摘要分成 A，B，C，D 四段（Words），每段 32bit，在循环过程中交替运算 A，B，C，D，最终组成 128bit 的摘要结果。</strong></p><p>SHA 算法与 MD5 区别</p><p>SHA-1 算法，核心过程大同小异，主要的不同点是把 160bit 的信息摘要分成了 A，B，C，D，E 五段。</p><p>SHA-2 系列算法，核心过程更复杂一些，把信息摘要分成了 A，B，C，D，E，F，G，H 八段。</p><p>其中 SHA-256 的每一段摘要长度是 32bit，SHA-512 的每一段摘要长度是 64bit。SHA-224 和 SHA-384 则是在前两者生成结果的基础上做出裁剪。</p><h2 id="3-3-CRC"><a href="#3-3-CRC" class="headerlink" title="3.3 CRC"></a>3.3 CRC</h2><p>CRC（Cyclic Redundancy Check，循环冗余校验）算法出现时间较长，应用也十分广泛，尤其是通讯领域，现在应用最多的就是 CRC32 算法，它产生一个 4 字节（32 位）的校验值，一般是以 8 位十六进制数，如 FA 12 CD 45 等。CRC 算法的优点在于简便、速度快，严格的来说，CRC 更应该被称为数据校验算法，但其功能与数据摘要算法类似，因此也作为测试的可选算法。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis 数据库</title>
      <link href="/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-redis 介绍"><a href="#1-redis 介绍" class="headerlink" title="1. redis 介绍"></a>1. redis 介绍</h1><h2 id="1-1-Redis- 是什么"><a href="#1-1-Redis- 是什么" class="headerlink" title="1.1 Redis 是什么"></a>1.1 Redis 是什么</h2><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统。它是一种非关系型数据库， 提供了一些丰富的数据结构，包括 lists、sets、ordered sets 以及 hashes ，当然还有和 Memcached 一样的 strings 结构。Redis 当然还包括了对这些数据结构的丰富操作。</p><p>Redis 常被称作是一款数据结构服务器（data structure server）。Redis 的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。</p><p>对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（append）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。</p><h2 id="1-2-Redis- 的优点"><a href="#1-2-Redis- 的优点" class="headerlink" title="1.2 Redis 的优点"></a>1.2 Redis 的优点</h2><ul><li>性能极高 : Redis 能读的速度是 110000 次 /s, 写的速度是 81000 次 /s 。</li><li>丰富的数据类型：Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子：Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行。</li><li>丰富的特性：Redis 还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><p>使用 Redis 只需要下载对应的软件包开箱即用，截止目前（2019.1）最新的版本有 5.* 可用</p><h2 id="1-3-redis 应用场景"><a href="#1-3-redis 应用场景" class="headerlink" title="1.3 redis 应用场景"></a>1.3 redis 应用场景</h2><ul><li>用来做缓存(ehcache/memcached)——redis 的所有数据是放在内存中的（内存数据库）</li><li>可以在某些特定应用场景下替代传统数据库——比如社交类的应用</li><li>在一些大型系统中，巧妙地实现一些特定的功能：session 共享、购物车</li><li>只要你有丰富的想象力，redis 可以用在可以给你无限的惊喜…….</li></ul><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-06_20-59-24.png" alt=""></p><h2 id="1-4-redis 对比 mysql"><a href="#1-4-redis 对比 mysql" class="headerlink" title="1.4 redis 对比 mysql"></a>1.4 redis 对比 mysql</h2><p>Redis 的数据存放在内存，所以速度快但是会受到内存空间限制。MySQL 存放在硬盘，在速度上没有 Redis 快，但是存放的数据量要多的多。所以 redis 适合放一些频繁使用，比较热的数据，因为是放在内存中，读写速度都非常快，一般会应用在下面一些场景: 排行榜、计数器、消息队列推送。</p><p>Redis 是一个 K-V 数据库，同时还支持 List/Hash/Set/Sorted Set 等几个简单数据结构，所以只能以这些数据结构为基础实现功能。而 MySQL 这点就不必说了。</p><p>Redis 是内存型数据库，不可能存储过大的数据；而 mysql 是存储在硬盘上的，可以支持更大规模的数据，成本更低。</p><p>目前大多数公司的存储都是 mysql + redis，mysql 作为主存储，redis 作为辅助存储被用作缓存，加快访问读取的速度，提高性能。</p><h2 id="1-5- 推荐阅读"><a href="#1-5- 推荐阅读" class="headerlink" title="1.5 推荐阅读"></a>1.5 推荐阅读</h2><ul><li><a href="https://redis.io/">redis 官方网站</a> </li><li><a href="http://redis.cn/">redis 中文官网</a> </li></ul><h1 id="2-Redis- 安装"><a href="#2-Redis- 安装" class="headerlink" title="2. Redis 安装"></a>2. Redis 安装 </h1><h2 id="2-1-Linux"><a href="#2-1-Linux" class="headerlink" title="2.1 Linux"></a>2.1 Linux</h2><h3 id="2-1-1- 在线安装"><a href="#2-1-1- 在线安装" class="headerlink" title="2.1.1 在线安装"></a>2.1.1 在线安装</h3><p> 直接输入命令 </p><pre><code>sudo apt-get install redis-server</code></pre><p>安装完成后，Redis 服务器会自动启动。<br>使用</p><pre><code>ps -aux|grep redis</code></pre><p>命令可以看到服务器系统进程默认端口 6379</p><p>配置文件为 /etc/redis/redis.conf(在线安装推荐)或者 /usr/local/redis/redis.conf(手动安装)</p><p><strong>【调整默认配置】</strong></p><pre><code>sudo vi /etc/redis/redis.conf</code></pre><p>①开启 Redis 的远程连接：<br>注释掉绑定地址 ，不然只允许本机访问</p><p><code># bind 127.0.0.1</code></p><p>②修改 Redis 的默认端口<br><code>port 6379</code></p><p>③关闭保护模式：</p><p><code>redis.conf 修改 88 行为 no</code></p><p>④开启后台启动:</p><p><code>redis.conf 修改 136 行为 yes</code></p><p>⑤添加 Redis 的访问账号：<br>Redis 服务器默认是不需要密码的，假设设置密码为 123456。</p><p><code>config set requirepass 123456</code></p><p>如此，便将密码设置成了 123456<br>设置之后，可通过以下指令查看密码</p><pre><code>config get requirepass</code></pre><p>密码设置之后，当你退出再次连上 redis 的时候，就需要输入密码了，不然是无法操作的。这里有两种方式输入密码，一是连接的时候直接输入密码，而是连接上之后再输入密码，分别如下所示：</p><pre><code>auth 123456</code></pre><p><strong>配置完成后重新启动服务器</strong></p><p>sudo service redis-server   + 下面的命令：</p><p>start 启动服务</p><p>restart 重启服务</p><p>stop 停止服务</p><pre><code>sudo /etc/init.d/redis-server restarsudo service redis-server restartsudo redis-server /etc/redis/redis.conf</code></pre><h3 id="2-1-2- 从源码开始安装"><a href="#2-1-2- 从源码开始安装" class="headerlink" title="2.1.2 从源码开始安装"></a>2.1.2 从源码开始安装 </h3><p> 进入 root 目录，并下载 Redis 的程序包：</p><pre><code>sudo suwget http://download.redis.io/redis-stable.tar.gz</code></pre><p>在目录下，解压安装包，生成新的目录 redis-4.0.14：</p><pre><code>tar -xzvf redis-stable.tar.gz</code></pre><p>进入解压之后的目录，进行编译：</p><pre><code>cd redis-stablemake</code></pre><p>说明：如果没有明显的错误，则表示编译成功。</p><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558538164013.png" alt=""></p><h5 id="查看重要文件"><a href="# 查看重要文件" class="headerlink" title="查看重要文件"></a>查看重要文件 </h5><p> 在 Redis 安装完成后，注意一些重要的文件，可用 <strong>ls</strong> 命令查看。</p><ul><li>服务端：src/redis-server</li><li>客户端：src/redis-cli</li><li>默认配置文件：redis.conf</li></ul><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558543779151.png" alt=""></p><h5 id="设置环境变量"><a href="# 设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量 </h5><p> 为了今后能更方便地打开 Redis 服务器和客户端，可以将 src 目录下的 redis-server 和 redis-cli 添加进环境变量所属目录里面。</p><pre><code>cp redis-server /usr/local/bin/cp redis-cli /usr/local/bin/</code></pre><p>添加完成后在任何目录下输入 <code>redis-server</code> 可启动服务器，输入 <code>redis-cli</code> 可启动客户端。</p><h5 id="运行测试"><a href="# 运行测试" class="headerlink" title="运行测试"></a>运行测试 </h5><p> 在前面的步骤设置完成后可以运行测试，确认 Redis 的功能是否正常：</p><pre><code>cd /root/redis-2.8.4make test</code></pre><p>运行测试需要花费一定的时间。操作截图如下：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539004966.png" alt=""></p><h3 id="2-1-3-Redis- 启动"><a href="#2-1-3-Redis- 启动" class="headerlink" title="2.1.3 Redis 启动"></a>2.1.3 Redis 启动</h3><p>Redis 是一个服务端和客户端配合的程序，和 Mysql 类似，因此要使用 Redis 需要先启动服务端，客户端有多种形式，比如在 Java 中连接 Redis 服务器也是扮演了一个客户端的角色，本节实验中采用终端的形式来对 Redis 的各项操作进行练习。</p><h4 id="启动 -Redis-server"><a href="# 启动 -Redis-server" class="headerlink" title="启动 Redis-server"></a>启动 Redis-server</h4><p>在命令行终端输入如下命令：</p><pre><code>redis-server  </code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539083727.png" alt=""></p><p>说明：从以上的截图中，可以发现启动的端口为缺省的 6379。用户可以在启动的时候，指定具体的配置文件，并在其中指定启动的端口。</p><p>保持此终端的运行，Ctrl+Shift+T 重开一个终端标签。</p><h4 id="查看 -Redis"><a href="# 查看 -Redis" class="headerlink" title="查看 Redis"></a>查看 Redis</h4><p>在命令行终端执行如下命令查看 Redis：</p><pre><code>ps -ef | grep redis</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539129020.png" alt=""></p><p>通过端口号检查 Redis 服务器状态：</p><pre><code>netstat -nlt|grep 6379</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539149394.png" alt=""></p><h4 id="启动 -Redis-client"><a href="# 启动 -Redis-client" class="headerlink" title="启动 Redis-client"></a>启动 Redis-client</h4><p>在命令行终端执行如下命令启动 Redis-client：</p><pre><code>redis-cli</code></pre><p>操作结果：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539282420.png" alt=""></p><p>至此，redis 启动完成。</p><p>在有的环境下，redis 交互环境可能出现中文乱码的情况，解决办法是用下列命令启动 redis 客户端：</p><pre><code>redis-cli --raw</code></pre><h2 id="2-2-windows 安装"><a href="#2-2-windows 安装" class="headerlink" title="2.2 windows 安装"></a>2.2 windows 安装 </h2><p> 点击: <a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></p><p>然后选择 msi 文件</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1568647099924.png" alt=""></p><p>下载完成后双击打开安装（安装过程中一定要添加到 path 环境）</p><h3 id="启动 REdis"><a href="# 启动 REdis" class="headerlink" title="启动 REdis"></a>启动 REdis</h3><p>在命令行终端执行如下命令启动 Redis-client：</p><pre><code>redis-cli</code></pre><h1 id="3- 数据类型"><a href="#3- 数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h1><p>Redis 不仅仅是简单的 key-value 存储器，同时也是一种 data structures server。传统的 key-value 是指支持使用一个 key 字符串来索引 value 字符串的存储，而 Redis 中，value 不仅仅支持字符串，还支持更多的复杂结构，包括列表、集合、哈希表等。</p><p>现在我们一一讲解：Redis keys 是采用二进制安全，这就意味着你可以使用任何二进制序列作为重点，比如：”foo” 可以联系一个 JPEG 文件；空字符串也是一个有效的密钥。</p><p>Redis 字符串是二进制安全的，这意味着一个 Redis 字符串能包含任意类型的数据，例如： 一张经过 base64 编码的图片或者一个序列化的对象。通过这样的方式，Redis 的字符串可以支持任意形式的数据，但是对于过大的文件不适合存入 redis，一方面系统内存有限，另外一方面字符串类型的值最多能存储 512M 字节的内容。</p><p><strong>知识点</strong> </p><ul><li>Redis strings</li><li>Redis Lists</li><li>Redis Hashes</li><li>Redis set</li></ul><h3 id="3-1-Redis-strings"><a href="#3-1-Redis-strings" class="headerlink" title="3.1 Redis strings"></a>3.1 Redis strings</h3><ul><li><p><strong>set</strong> 设置值</p></li><li><p><strong>get</strong> 获取值</p></li></ul><pre><code>$ redis-cli&gt; set mykey somevalue&gt; get mykey</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539338731.png" alt=""></p><p>如上例所示，可以使用 set 和 get 命令来创建和检索 strings。</p><ul><li><strong>mset</strong> 设置多个值</li><li><strong>mget</strong> 获取多个值</li><li><strong>keys *</strong> 获取所有的键</li></ul><p>Redis 可以运用 mset 和 mget 命令一次性完成多个 key-value 的对应关系，使用 mget 命令，Redis 返回一个 value 数组：</p><pre><code>&gt; mset a 10 b 20 c 30&gt; mget a b c</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539651556.png" alt=""></p><ul><li><strong>append</strong> 添加字符</li><li><strong>del</strong>  删除</li><li><strong>incr/decr</strong> 增加 / 减少</li></ul><p>即使 string 是 Redis 的基本类型，也可以对其进行一些有趣的操作，例如加法器：</p><pre><code>&gt; set counter 100 # 初始化&gt; incr counter   # +1&gt; incr counter   # +1&gt; incrby counter 50 # +50 自定义计数 </code></pre><p> 操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539601807.png" alt=""></p><p>incr 命令让 the value 成为一个整数，运行一次 incr 便加一。incrby 命令便是一个加法运算。类似的命令如减法运算为： decr 和 decrby。</p><p>注意：set 命令将取代现有的任何已经存在的 key。set 命令还有一个提供附加参数的选项，我们能够让 set 命令只有在没有相同 key 的情况下成功，反之亦然，可以让 set 命令在有相同 key 值的情况下成功：</p><pre><code>&gt; set mykey newval nx&gt; set mykey newval xx</code></pre><p>操作截图;</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539410969.png" alt=""></p><p><strong>set 完整内容</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1559386310906.png" alt=""></p><p>参数含义:</p><ul><li>set : 设置一个键值对内容</li><li>key : 键名</li><li>value : 值内容</li><li>[EX seconds] : 设置指定的过期时间，以秒为单位。(可选)</li><li>[PX milliseconds] : 设置指定的过期时间，以毫秒为单位。(可选)</li><li>NX : 只有键 key 不存在的时候才会设置 key 的值</li><li>XX : 只有键 key 存在的时候才会设置 key 的值</li></ul><h3 id="3-2-Redis-Lists"><a href="#3-2-Redis-Lists" class="headerlink" title="3.2 Redis Lists"></a>3.2 Redis Lists</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），lpush 命令插入一个新的元素到头部，而 rpush 命令插入一个新元素到尾部。当这两个操作中的任一操作在一个空的 Key 上执行时就会创建一个新的列表。相似的，如果一个列表操作清空一个列表，那么对应的 key 将被从 key 空间删除。</p><ul><li><strong>lpush/rpush</strong> 队列左边或者右边增加内容</li><li><strong>lrange</strong> 获取指定长度的内容</li></ul><p>push 一类的命令的返回值为 list 的长度。这里有一些类表操作和结果的例子：</p><pre><code>&gt; rpush mylist A&gt; rpush mylist B&gt; lpush mylist first&gt; lrange mylist 0 -1</code></pre><p>操作截图:</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539705684.png" alt=""></p><p><strong>注意</strong>：lrange 需要两个索引，0 表示 list 开头第一个，-1 表示 list 的倒数第一个，即最后一个。-2 则是 list 的倒数第二个，以此类推。</p><p>这些命令都是可变的命令，也就是说你可以一次加入多个元素放入 list：</p><pre><code>&gt; rpush mylist 1 2 3 4 5 &quot;foo bar&quot;&gt; lrange mylist 0 -1</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539832387.png" alt=""></p><ul><li><strong>ltrim</strong> 对一个列表进行修剪(trim)，保留指定区间内的元素，不在指定区间之内的元素都将被删除。</li><li><strong>lpop/rpop</strong> 从队列左边或者右边弹出内容</li></ul><p>在 Redis 的命令操作中，还有一类重要的操作：pop，它可以弹出一个元素，简单的理解就是获取并删除第一个元素，和 push 类似的是它也支持双边的操作，可以从右边弹出一个元素也可以从左边弹出一个元素，对应的指令为 rpop 和 lpop：</p><pre><code>&gt; del mylist&gt; rpush mylist a b c&gt; rpop mylist&gt; lrange mylist 0 -1&gt; lpop mylist&gt; lrange mylist 0 -1</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558539989212.png" alt=""></p><ul><li><strong>lpushx/rpushx</strong> key 存在时才插入数据, 不存在是不做任何处理</li></ul><p>一个列表最多可以包含 4294967295（2 的 32 次方减一） 个元素，这意味着它可以容纳海量的信息，最终瓶颈一般都取决于服务器内存大小。</p><p>事实上，在高级的企业架构当中，会把缓存服务器分离开来，因为数据库服务器和缓存服务器的特点各异，比如对于数据库服务器应该用更快、更大的硬盘，而缓存专用服务器则偏向内存性能，一般都是 64GB 起步。</p><h4 id="List- 阻塞操作"><a href="#List- 阻塞操作" class="headerlink" title="List 阻塞操作"></a>List 阻塞操作 </h4><p> 理解阻塞操作对一些请求操作有很大的帮助，关于阻塞操作的作用，这里举一个例子。</p><p>假如你要去楼下买一个汉堡，一个汉堡需要花一定的时间才能做出来，非阻塞式的做法是去付完钱走人，过一段时间来看一下汉堡是否做好了，没好就先离开，过一会儿再来，而且要知道可能不止你一个人在买汉堡，在你离开的时候很可能别人会取走你的汉堡，这是很让人烦的事情。</p><p>阻塞式就不一样了，付完钱一直在那儿等着，不拿到汉堡不走人，并且后面来的人统统排队。</p><p>Redis 提供了阻塞式访问 brpop 和 blpop 命令。用户可以在获取数据不存在时阻塞请求队列，如果在时限内获得数据则立即返回，如果超时还没有数据则返回 null。</p><h4 id="List- 常见应用场景"><a href="#List- 常见应用场景" class="headerlink" title="List 常见应用场景"></a>List 常见应用场景 </h4><p> 分析 List 应用场景需要结合它的特点，List 元素是线性有序的，很容易就可以联想到聊天记录，你一言我一语都有先后，因此 List 很适合用来存储聊天记录等顺序结构的数据。</p><h3 id="3-3-Redis- 无序集合"><a href="#3-3-Redis- 无序集合" class="headerlink" title="3.3 Redis 无序集合"></a>3.3 Redis 无序集合</h3><p>Redis 集合（Set）是一个无序的字符串集合。你可以以 O(1) 的时间复杂度 (无论集合中有多少元素时间复杂度都是常量）完成添加、删除以及测试元素是否存在。</p><p>Redis 集合拥有令人满意的不允许包含相同成员的属性，多次添加相同的元素，最终在集合里只会有一个元素，这意味着它可以非常方便地对数据进行去重操作，一个 Redis 集合的非常有趣的事情是它支持一些服务端的命令从现有的集合出发去进行集合运算，因此你可以在非常短的时间内进行合并（unions）, 求交集（intersections）, 找出不同的元素（differences of sets）。</p><ul><li><strong>sadd/srem</strong> 添加 / 删除元素</li><li><strong>sismember</strong> 判断是否为 set 的一个元素</li><li><strong>smembers</strong> 返回该集合的所有成员 </li></ul><pre><code>&gt; sadd myset 1 2 3&gt; smembers myset</code></pre><p>sadd 命令产生一个无序集合，返回集合的元素个数。smembers 用于查看集合。</p><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558540427157.png" alt=""></p><p>sismember 用于查看集合是否存在，匹配项包括集合名和元素个数。匹配成功返回 1，匹配失败返回 0。</p><pre><code>&gt; sismember myset 3&gt; sismember myset 30&gt; sismember mys 3</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558540577228.png" alt=""></p><ul><li><strong>sdiff</strong> 返回一个集合与其他集合的差异</li><li><strong>sinter</strong> 返回几个集合的交集</li><li><strong>sunion</strong> 返回几个集合的并集</li></ul><h3 id="3-4-Redis- 有序集合"><a href="#3-4-Redis- 有序集合" class="headerlink" title="3.4 Redis 有序集合"></a>3.4 Redis 有序集合</h3><p>Redis 有序集合与普通集合非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每一个成员都关联了一个权值，这个权值被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是权值可以是重复的。</p><p>使用有序集合你可以以非常快的速度（O(log(N))）添加、删除和更新元素。因为元素是有序的, 所以你也可以很快的根据权值（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中，你可以很快捷的访问一切你需要的东西：有序的元素，快速的存在性测试，快速访问集合的中间元素！简而言之使用有序集合你可以完成许多对性能有极端要求的任务，而那些任务使用其它类型的数据库真的是很难完成的。</p><p>zadd 与 sadd 类似，但是在元素之前多了一个参数，这个参数便是用于排序的。形成一个有序的集合。</p><pre><code>&gt; zadd hackers 1940 &quot;Alan Kay&quot;&gt; zadd hackers 1957 &quot;Sophie Wilson&quot;&gt; zadd hackers 1953 &quot;Richard Stallman&quot;&gt; zadd hackers 1949 &quot;Anita Borg&quot;&gt; zadd hackers 1965 &quot;Yukihiro Matsumoto&quot;&gt; zadd hackers 1914 &quot;Hedy Lamarr&quot;&gt; zadd hackers 1916 &quot;Claude Shannon&quot;&gt; zadd hackers 1969 &quot;Linus Torvalds&quot;&gt; zadd hackers 1912 &quot;Alan Turing&quot;</code></pre><p>查看集合：<strong>zrange 是查看正序的集合</strong>，<strong>zrevrange 是查看反序的集合</strong>。0 表示集合第一个元素，-1 表示集合的倒数第一个元素。</p><pre><code>&gt; zrange hackers 0 -1&gt; zrevrange hackers 0 -1</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558540664912.png" alt=""></p><p>使用 withscores 参数返回记录值。</p><pre><code>&gt; zrange hackers 0 -1 withscores</code></pre><p>操截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558540712107.png" alt=""></p><h3 id="3-5-Redis-Hashes"><a href="#3-5-Redis-Hashes" class="headerlink" title="3.5 Redis Hashes"></a>3.5 Redis Hashes</h3><p>Redis Hashes 是字符串字段和字符串值之间的映射，因此它们是展现对象的完美数据类型。例如一个有名、姓、年龄等等属性的用户：一个带有一些字段的 hash 仅仅需要一块很小的空间存储，因此你可以存储数以百万计的对象在一个小的 Redis 实例中。哈希主要用来表现对象，它们有能力存储很多对象，因此你可以将哈希用于许多其它的任务。</p><ul><li><strong>hset/hget</strong> 设置 / 获取散列值</li><li><strong>hmset/hgetall</strong> 设置 / 获取多对散列值</li></ul><pre><code>&gt; hmset user:1000 username antirez birthyear 1977 verified 1&gt; hget user:1000 username&gt; hget user:1000 birthyear&gt; hgetall user:1000</code></pre><p>格式：<code>hset key field values</code></p><p>格式：<code>hmset [key:[seq_num]] field values field values</code></p><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558540146964.png" alt=""></p><p>hmset 命令设置一个多域的 hash 表，hget 命令获取指定的单域，hgetall 命令获取指定 key 的所有信息。hmget 类似于 hget，只是返回一个 value 数组。</p><pre><code>&gt; hmget user:1000 username birthyear</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558540248325.png" alt=""></p><p>同样可以根据需要对 hash 表的表项进行单独的操作，例如 hincrby： （原本 birthyear 为 1977，见上一图）</p><pre><code>&gt; hincrby user:1000 birthyear 10&gt; hincrby user:1000 birthyear 10</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558540391566.png" alt=""></p><ul><li><strong>hsetnx</strong> 如果散列已经存在, 则不设置</li><li><strong>hkeys/hvals</strong> 查看散列的 keys/valus</li><li><strong>hlen</strong> 返回散列指定的域(field)</li><li><strong>hexists</strong> 判断是否存在</li></ul><p>参看:</p><p><a href="http://redis.io/topics/data-types-intro">http://redis.io/topics/data-types-intro</a></p><h1 id="4- 操作"><a href="#4- 操作" class="headerlink" title="4. 操作"></a>4. 操作 </h1><p> 前面讲述了 Redis 的基本数据类型，接下来继续讲解 Redis 相关命令及管理操作。</p><p>在 Redis 中，命令大小写不敏感。</p><ul><li>适合全体类型的常用命令</li><li>Redis 时间相关命令</li><li>Redis 设置相关命令</li><li>查询信息</li></ul><h3 id="适合全体类型的常用命令"><a href="# 适合全体类型的常用命令" class="headerlink" title="适合全体类型的常用命令"></a>适合全体类型的常用命令 </h3><p> 启动 redis 服务和 redis-cli 命令界面继续后续实验：</p><pre><code>sudo service redis-server startredis-cli</code></pre><h4 id="EXISTS-and-DEL"><a href="#EXISTS-and-DEL" class="headerlink" title="EXISTS and DEL"></a>EXISTS and DEL</h4><p>exists key：判断一个 key 是否存在，存在返回 1，否则返回 0。</p><p><code>del</code> key：删除某个 key，或是一系列 key，比如：del key1 key2 key3 key4。成功返回 1，失败返回 0（key 值不存在）。</p><pre><code>&gt; set mykey hello&gt; exists mykey&gt; del mykey&gt; exists mykey</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558540770677.png" alt=""></p><h4 id="TYPE-and-KEYS"><a href="#TYPE-and-KEYS" class="headerlink" title="TYPE and KEYS"></a>TYPE and KEYS</h4><p><code>type</code> key：返回某个 key 元素的数据类型 (none: 不存在，string: 字符，list: 列表，set: 元组，zset: 有序集合，hash: 哈希)，key 不存在返回空。</p><p><code>keys</code> key—pattern：返回匹配的 key 列表，比如：keys foo* 表示查找 foo 开头的 keys。</p><pre><code>&gt; set mykey x&gt; type mykey&gt; keys my*&gt; del mykey&gt; keys my*&gt; type mykey</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558540853713.png" alt=""></p><h4 id="RANDOMKEY-and-CLEAR"><a href="#RANDOMKEY-and-CLEAR" class="headerlink" title="RANDOMKEY and CLEAR"></a>RANDOMKEY and CLEAR</h4><p><code>randomkey</code>：随机获得一个已经存在的 key，如果当前数据库为空，则返回空字符串。</p><pre><code>&gt; randomkey</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558540896368.png" alt=""></p><p><code>clear</code>：清除界面。</p><pre><code>&gt; clear</code></pre><h4 id="RENAME-and-RENAMENX"><a href="#RENAME-and-RENAMENX" class="headerlink" title="RENAME and RENAMENX"></a>RENAME and RENAMENX</h4><p><code>rename oldname newname</code>：更改 key 的名字，新键如果存在将被覆盖。</p><p><code>renamenx oldname newname</code>：更改 key 的名字，新键如果存在则更新失败。</p><p>比如这里 randomkey 结果为 mylist，将此 key 值更名为 newlist。</p><pre><code>&gt; randomkey&gt; rename mylist newlist&gt; exists mylist&gt; exists newlist</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558542077323.png" alt=""></p><h4 id="DBSIZE"><a href="#DBSIZE" class="headerlink" title="DBSIZE"></a>DBSIZE</h4><p><code>dbsize</code>：返回当前数据库的 key 的总数。</p><pre><code>&gt; dbsize</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558542094849.png" alt=""></p><h3 id="Redis- 时间相关命令"><a href="#Redis- 时间相关命令" class="headerlink" title="Redis 时间相关命令"></a>Redis 时间相关命令 </h3><p> 下面我们将会学习 Redis 时间相关命令。</p><h4 id="限定 -key- 生存时间"><a href="# 限定 -key- 生存时间" class="headerlink" title="限定 key 生存时间"></a>限定 key 生存时间 </h4><p> 这同样是一个无视数据类型的命令，对于临时存储很有用处。避免进行大量的 DEL 操作。</p><p><code>expire</code>：设置某个 key 的过期时间（秒)，比如：expire bruce 1000 表示设置 bruce 这个 key 1000 秒后系统自动删除，注意：如果在还没有过期的时候，对值进行了改变，那么那个值会被清除。</p><pre><code>&gt; set key some-value&gt; expire key 10&gt; get key       (马上执行此命令)&gt; get key       (10s 后执行此命令)</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558542163817.png" alt=""></p><p>结果显示：执行 expire 命令后，马上 get 会显示 key 存在；10 秒后再 get 时，key 已经被自动删除。</p><h4 id="查询 -key- 剩余生存时间"><a href="# 查询 -key- 剩余生存时间" class="headerlink" title="查询 key 剩余生存时间"></a>查询 key 剩余生存时间 </h4><p> 限时操作可以在 set 命令中实现，并且可用 ttl 命令查询 key 剩余生存时间。</p><p><code>ttl</code>：查找某个 key 还有多长时间过期，返回时间单位为秒。</p><pre><code>&gt; set key 100 ex 30&gt; ttl key&gt; ttl key</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558542626030.png" alt=""></p><h4 id="清除 -key"><a href="# 清除 -key" class="headerlink" title="清除 key"></a>清除 key</h4><p><code>flushdb</code>：清空当前数据库中的所有键。</p><p><code>flushall</code>：清空所有数据库中的所有键。</p><pre><code>&gt; flushdb&gt; flushall</code></pre><h3 id="Redis- 设置相关命令"><a href="#Redis- 设置相关命令" class="headerlink" title="Redis 设置相关命令"></a>Redis 设置相关命令</h3><p>Redis 有其配置文件，可以通过 client-command 窗口查看或者更改相关配置。下面介绍相关命令。</p><h4 id="CONFIG-GET-and-CONFIG-SET"><a href="#CONFIG-GET-and-CONFIG-SET" class="headerlink" title="CONFIG GET and CONFIG SET"></a>CONFIG GET and CONFIG SET</h4><p><code>config get</code>：用来读取运行 Redis 服务器的配置参数。</p><p><code>config set</code>：用于更改运行 Redis 服务器的配置参数。</p><p><code>auth</code>：认证密码。</p><p>下面针对 Redis 密码的示例：</p><pre><code>&gt; config get requirepass  # 查看密码&gt; config set requirepass 123456  # 设置密码为 123456&gt; config get requirepass  # 报错，没有认证&gt; auth 123456  # 认证密码&gt; config get requirepass</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558542785780.png" alt=""></p><p>由结果可知，刚开始时 Reids 并未设置密码，密码查询结果为空。然后设置密码为 123456，再次查询报错。经过 auth 命令认证后，可正常查询。</p><p>可以通过修改 Redis 的配置文件 redis.conf 修改密码。</p><h1 id="5- 查询信息"><a href="#5- 查询信息" class="headerlink" title="5. 查询信息"></a>5. 查询信息</h1><p><code>info [section]</code>：查询 Redis 相关信息。</p><p>info 命令可以查询 Redis 几乎所有的信息，其命令选项有如下：</p><ul><li>server: Redis server 的常规信息</li><li>clients: Client 的连接选项</li><li>memory: 存储占用相关信息</li><li>persistence: RDB and AOF 相关信息</li><li>stats: 常规统计</li><li>replication: Master/Slave 请求信息</li><li>cpu: CPU 占用信息统计</li><li>cluster: Redis 集群信息</li><li>keyspace: 数据库信息统计</li><li>all: 返回所有信息</li><li>default: 返回常规设置信息</li></ul><p>若命令参数为空，info 命令返回所有信息。</p><pre><code>&gt; info server</code></pre><p>操作截图：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558542924652.png" alt=""></p><p>参考:</p><p><a href="http://redis.io/commands/config-resetstat">http://redis.io/commands/config-resetstat</a></p><h1 id="6- 高级操作"><a href="#6- 高级操作" class="headerlink" title="6. 高级操作"></a>6. 高级操作 </h1><p> 前面学习了 Redis 的基础知识和基本命令，接下来继续讲解 Redis 的高级应用，包括：安全性设置，主从复制，事务处理，持久化机制，虚拟内存的使用。</p><p><strong>知识点</strong> </p><ul><li>安全性</li><li>主从复制</li><li>事务处理</li><li>持久化机制</li><li>虚拟内存的使用</li></ul><h3 id="安全性"><a href="# 安全性" class="headerlink" title="安全性"></a>安全性 </h3><p> 涉及到客户端连接是需要指定密码的（由于 redis 速度相当的快，一秒钟可以 150K 次的密码尝试，所以需要设置一个强度很大的密码）。</p><p>设置密码的方式有两种：</p><ul><li>使用 <code>config set</code> 命令的 requirepass 参数，具体格式为 <code>config set requirepass “password”</code>。</li><li>在 redis.conf 文件中设置 requirepass 属性，后面为密码。</li></ul><p>输入认证的方式也有两种：</p><ul><li>登录时可以使用 <code>redis-cli -a password</code>。</li><li>登录后可以使用 <code>auth password</code>。</li></ul><h4 id="设置密码"><a href="# 设置密码" class="headerlink" title="设置密码"></a>设置密码 </h4><p> 第一种密码设置方式在上一个实验中已经提到（在 CONFIG SET 命令讲解的实例），此处我们来看看第二种方式设置密码。</p><p>首先需要进入 Redis 的安装目录，然后修改配置文件 redis.conf。根据 grep 命令的结果，使用 vim 编辑器修改 “# requirepass foobared” 为 “requirepass test123”，然后保存退出。</p><pre><code>sudo vim /etc/redis/redis.conf</code></pre><p>编辑 redis.conf 的结果：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558543168293.png" alt=""></p><p>重启之后就需要验证密码了</p><h3 id="主从复制"><a href="# 主从复制" class="headerlink" title="主从复制"></a>主从复制 </h3><p> 为了分担服务器压力，会在特定情况下部署多台服务器分别用于缓存的读和写操作，用于写操作的服务器称为主服务器，用于读操作的服务器称为从服务器。</p><p>从服务器通过 psync 操作同步主服务器的写操作，并按照一定的时间间隔更新主服务器上新写入的内容。</p><p>Redis 主从复制的过程：</p><ol><li>Slave 与 Master 建立连接，发送 psync 同步命令。</li><li>Master 会启动一个后台进程，将数据库快照保存到文件中，同时 Master 主进程会开始收集新的写命令并缓存。</li><li>后台完成保存后，就将此文件发送给 Slave。</li><li>Slave 将此文件保存到磁盘上。</li></ol><p>Redis 主从复制特点：</p><ol><li>可以拥有多个 Slave。</li><li>多个 Slave 可以连接同一个 Master 外，还可以连接到其它的 Slave。（当 Master 宕机后，相连的 Slave 转变为 Master）</li><li>主从复制不会阻塞 Master，在同步数据时， Master 可以继续处理 Client 请求。</li><li>提高了系统的可伸缩性。</li></ol><p>从服务器的主要作用是响应客户端的数据请求，比如返回一篇博客信息。</p><p>上面说到了主从复制是不会阻塞 Master 的，就是说 Slave 在从 Master 复制数据时，Master 的删改插入等操作继续进行不受影响。</p><p>如果在同步过程中，主服务器修改了一篇博客，而同步到从服务器上的博客是修改前的。这时候就会出现时间差，即修改了博客过后，在访问网站的时候还是原来的数据，这是因为从服务器还未同步最新的更改，这也就意味着非阻塞式的同步只能应用于对读数据延迟接受度较高的场景。</p><p><strong>【主从服务器的配置】</strong></p><p>（1）首先确保云服务器开启了 6379（默认的 redis 端口）端口，本地电脑 6379 端口一般默认是开的。</p><p>开启云服务器端口的方法：</p><p>① 新建安全组</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201020211017731.png" style="zoom: 80%;" /><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201020211134490.png" style="zoom:80%;" /><p>② 将新建的安全组加入到云服务器实例中</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201020211429320.png" style="zoom:80%;" /><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201020211632016.png" style="zoom:80%;" /><p>（2）主服务器配置</p><p>装好 redis 之后，<code>redis-cli</code>可启动 redis。</p><p>命令 <code>ps -aux|grep redis</code> 出现：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201020221441021.png" alt=""></p><p>会发现 redis 只能本机访问（127.0.0.1 代表本机 ip）</p><p>需要做如下修改</p><p>编辑 /etc/redis/redis.conf 文件：</p><pre><code>sudo vim /etc/redis/redis.conf</code></pre><p>将 bind 127.0.0.1 注释掉：# bind 127.0.0.1</p><p>增加：bind 0.0.0.0    代表任何 ip 都可以访问</p><p>然后确认：daemonize yes  若为 no，则改为 yes</p><p>然后确认：protected-mode yes  若为 no，则改为 yes (若这一行本身没有，则不用管)</p><p>设置密码：requirepass 123456</p><p>最后重启 redis 服务：</p><pre><code> /etc/init.d/redis-server restart</code></pre><p>然后就可以看到：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201020222540484.png" alt=""></p><p>这样就允许任何 ip 地址访问了。</p><p>（2）从服务器配置</p><p>Linux 中编辑 /etc/redis/redis.conf 文件：</p><pre><code>sudo vim /etc/redis/redis.conf</code></pre><p>将 bind 127.0.0.1 注释掉：# bind 127.0.0.1</p><p>增加：bind 0.0.0.0    代表任何 ip 都可以访问</p><p>然后确认：daemonize yes  若为 no，则改为 yes</p><p>设置密码：requirepass 123456</p><p>增加：slaveof 81.68.121.123 6379  (绑定主服务器 ip 和 redis 端口)</p><p>增加：masterauth 123456   （加上主服务器的密码）</p><p>最后重启 redis 服务。</p><p>（若是 windows 系统，在 redis.windows.conf 和 redis.windows-service.conf 文件中设置上述参数，重启命令为<code>net stop redis</code> 和<code>net start redis</code>）</p><p>（3）验证是否连接成功</p><p>在从服务器中，输入命令：</p><pre><code>redis-cliauth 123456info replication</code></pre><p>若出现 <code>master_link_status:up</code> 则说明连接成功。</p><p>若出现 <code>master_link_status:down</code> 则说明连接失败。</p><p>可以尝试关闭主服务器的防火墙：</p><pre><code>sudo ufw status #查看防火墙状态sudo ufw disable #关闭防火墙sudo ufw enable  #启用防火墙</code></pre><hr><p>要建立这样一个主从关系的缓存服务器，只需要在 Slave 端执行命令:</p><pre><code>&gt; SLAVEOF 81.68.121.172 6379&gt; config set masterauth &lt;password&gt;</code></pre><p>以上命令可以实现设置从服务器和设置密码的目的，但是不持久，当关闭 redis 服务时，设置将会失效。</p><p>这样，<strong>当前服务器就作为 81.68.121.142:6379 下的一个从服务器</strong>，它将定期从该服务器复制数据到自身。</p><p>在以前的版本中（2.8 以前），你应该慎用 redis 的主从复制功能，因为它的同步机制效率低下，可以想象每一次短线重连都要复制主服务器上的全部数据，算上网络通讯所耗费的时间，反而可能达不到通过 redis 缓存来提升应用响应速度的效果。但是幸运的是，官方在 2.8 以后推出了解决方案，通过部分同步来解决大量的重复操作。</p><p>这需要主服务器和从服务器都至少达到 2.8 的版本要求。</p><h3 id="事务处理"><a href="# 事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><p>Redis 的事务处理比较简单。只能保证 client 发起的事务中的命令可以连续的执行，而且不会插入其它的 client 命令，当一个 client 在连接中发出 <code>multi</code> 命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放到一个队列中，当执行 <code>exec</code> 命令时，redis 会顺序的执行队列中的所有命令。</p><p>需要注意的是，redis 对于事务的处理方式比较特殊，它不会在事务过程中出错时恢复到之前的状态，这在实际应用中导致我们不能依赖 redis 的事务来保证数据一致性。</p><h3 id="持久化机制"><a href="# 持久化机制" class="headerlink" title="持久化机制"></a>持久化机制 </h3><p> 内存和磁盘的区别除了速度差别以外，还有就是内存中的数据会在重启之后消失，持久化的作用就是要将这些数据长久存到磁盘中以支持长久使用。</p><p>Redis 是一个支持持久化的内存数据库，Redis 需要经常将内存中的数据同步到磁盘来保证持久化。</p><p>Redis 支持两种持久化方式：</p><p>1、<code>snapshotting</code>（快照）：将数据存放到文件里，默认方式。</p><p>是将内存中的数据以快照的方式写入到二进制文件中，默认文件 dump.rdb，可以通过配置设置自动做快照持久化的方式。可配置 Redis 在 n 秒内如果超过 m 个 key 被修改就自动保存快照。比如：</p><p><code>save 900 1</code>：900 秒内如果超过 1 个 key 被修改，则发起快照保存。</p><p><code>save 300 10</code>：300 秒内如果超过 10 个 key 被修改，则快照保存。</p><p>2、<code>Append-only file</code>（缩写为 aof）：将读写操作存放到文件中。</p><p>由于快照方式在一定间隔时间做一次，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。</p><p>aof 比快照方式有更好的持久化性，是由于使用 aof 时，redis 会将每一个收到的写命令都通过 write 函数写入到文件中，当 redis 启动时会通过重新执行文件中保存的写命令来在内存中重新建立整个数据库的内容。</p><p>由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上，这样 aof 方式的持久化也还是有可能会丢失一部分数据。可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。</p><p>配置文件中的可配置参数：</p><pre><code>appendonly yes // 启用 aof 持久化方式# appendfsync always // 收到写命令就立即写入磁盘，最慢，但是保证了数据的完整持久化appendfsync everysec // 每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中# appendfsync no // 完全依赖 os，性能最好，持久化没有保证 </code></pre><p> 在 redis-cli 的命令中，<code>save</code> 命令是将数据写入磁盘中。</p><pre><code>&gt; help save&gt; save</code></pre><p>操作截图：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1558542924652.png" alt="1558542924652" style="zoom:67%;" /><h1 id="7- 一些报错"><a href="#7- 一些报错" class="headerlink" title="7. 一些报错"></a>7. 一些报错 </h1><p>（1）由于一些不正常原因，redis 安装损坏，重新<code>sudo apt install redis-server</code> 发现显示 redis 已经安装，没法再安装了。</p><p>解决办法：</p><pre><code>sudo apt-get install --reinstall redis-serversudo apt-get upgrade</code></pre><p>此时会发现 redis 已经安装好，<code>ps -aux|grep redis</code>会发现 redis 已经在后台运行。</p><p>但是，<code>redis-cli</code>会显示此命令不存在。</p><p>原因是客户端没有安装，依次输入下面的命令，即可解决。</p><pre><code>wget http://download.redis.io/redis-stable.tar.gz（下载 redis-cli 的压缩包）tar xvzf redis-stable.tar.gz（解压）cd redis-stable（进入 redis-stable 目录）make（安装）sudo cp src/redis-cli /usr/local/bin/（将 redis-cli 拷贝到 bin 下，让 redis-cli 指令可以在任意目录下直接使用）</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pymysql 与 ORM 操作数据库</title>
      <link href="/Pymysql%E4%B8%8EORM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/Pymysql%E4%B8%8EORM%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Mysql 数据库"><a href="#1、Mysql 数据库" class="headerlink" title="1、Mysql 数据库"></a>1、Mysql 数据库 </h1><p><code>MySQL</code> 是一个 DBMS（数据库管理系统），由瑞典 MySQLAB 公司开发，目前属于 Oracle (甲骨文) 公司，<code>MySQL</code> 是最流行的关系型数据库管理系统（关系数据库，是建立在关系数据库模型基础上的数据库，借助于集合代数等概念和方法来处理数据库中的数据）。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发者都选择 <code>MySQL</code> 作为网站数据库。<code>MySQL</code> 使用 <code>SQL</code> 语言进行操作。</p><p>菜鸟教程：<a href="https://www.runoob.com/mysql/mysql-administration.html">https://www.runoob.com/mysql/mysql-administration.html</a></p><p><strong>概念对比</strong></p><ul><li>DB：数据库，存放数据的容器</li><li>DBMS：数据库管理系统，用于管理 DB</li><li>SQL：结构化查询语言，是关系型数据库的通用语言</li></ul><p><strong>RDBMS 术语</strong></p><p>在我们开始学习 MySQL 数据库前，让我们先了解下 RDBMS 的一些术语：</p><ul><li><strong>数据库:</strong> 数据库是一些关联表的集合。</li><li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li><strong>列:</strong> 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。</li><li><strong>行：</strong>一行（= 元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li></ul><h2 id="1-1- 创建"><a href="#1-1- 创建" class="headerlink" title="1.1 创建"></a>1.1 创建 </h2><h3 id="1-1-1- 创建数据库"><a href="#1-1-1- 创建数据库" class="headerlink" title="1.1.1 创建数据库"></a>1.1.1 创建数据库</h3><p> 创建一个数据库，给它一个名字，比如 <code>python</code>，以后的几次操作也是对 <code>python</code> 这个数据库进行操作。 语句格式为 <code>CREATE DATABASE &lt; 数据库名字 &gt;;</code>，（注意不要漏掉分号 <code>;</code>），前面的 CREATE DATABASE 也可以使用小写，具体命令为：</p><pre><code>-- create database 数据库名 charset=utf8;-- 例：create database python charset=utf8;</code></pre><p>接下来的操作，就在刚才创建的 <code>python</code> 中进行，由于一个系统中可能会有多个数据库，要确定当前是对哪一个数据库操作，使用语句 <code>use &lt; 数据库名字 &gt;</code>：</p><pre><code>mysql&gt; use python;</code></pre><h3 id="1-1-2- 创建数据表"><a href="#1-1-2- 创建数据表" class="headerlink" title="1.1.2 创建数据表"></a>1.1.2 创建数据表 </h3><p> 数据表（<code>table</code>）简称表，它是数据库最重要的组成部分之一。数据库只是一个框架，表才是实质内容。</p><p>而一个数据库中一般会有多张表，这些各自独立的表通过建立关系被联接起来，才成为可以交叉查阅、一目了然的数据库。</p><p>如下便是一张表：</p><table><thead><tr><th>ID</th><th>name</th><th>phone</th></tr></thead><tbody><tr><td>01</td><td>Tom</td><td>110110110</td></tr><tr><td>02</td><td>Jack</td><td>119119119</td></tr><tr><td>03</td><td>Rose</td><td>114114114</td></tr></tbody></table><p>在数据库中新建一张表的语句格式为：</p><pre><code>CREATE TABLE 表的名字 (列名 a 数据类型(数据长度), 列名 b 数据类型(数据长度));</code></pre><p> 我们尝试在 <code>python</code> 中新建一张表 <code>employee</code>，包含姓名，ID 和电话信息，所以语句为：</p><pre><code>mysql&gt; CREATE TABLE employee (id int(10),name char(20),phone int(12));Query OK, 0 rows affected (0.00 sec)</code></pre><h2 id="1-2-Pymysql- 操作数据库"><a href="#1-2-Pymysql- 操作数据库" class="headerlink" title="1.2 Pymysql 操作数据库"></a>1.2 Pymysql 操作数据库</h2><p>PymySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1559376920137.png" alt=""></p><p>使用 <code>pip install pymysql</code> 可以直接安装。</p><h3 id="1-2-1- 数据库操作方法"><a href="#1-2-1- 数据库操作方法" class="headerlink" title="1.2.1 数据库操作方法"></a>1.2.1 数据库操作方法</h3><ul><li><p><code>connect</code>()</p><p>链接数据库</p></li><li><p><code>close</code>()</p><p>发送数据关闭与数据库的链接</p></li><li><p><code>commit</code>()</p><p>提交并保存数据</p></li><li><p><code>cursor</code>(<em>cursor=None</em>)</p><p>创建一个新游标，用于执行 sql 语句并获得结果</p></li><li><p><code>rollback</code>()</p><p>回滚当前事务。</p></li><li><p><code>select_db</code>(<em>db</em>)</p><p>设置当前数据库。</p><p>参数:<strong>db</strong> – 数据库的名称.</p></li></ul><h3 id="1-2-1- 连接数据库"><a href="#1-2-1- 连接数据库" class="headerlink" title="1.2.1 连接数据库"></a>1.2.1 连接数据库 </h3><p> 连接数据库对象：调用 pymysql.connect() 方法</p><pre><code class="python">import pymysqlconn=pymysql.connect(参数列表)</code></pre><p><strong>参数:</strong></p><ul><li><strong>host</strong> - 数据库服务器所在的主机</li><li><strong>user</strong> - 登录的用户名</li><li><strong>password</strong> - 要使用的密码。</li><li><strong>database</strong> - 要使用的数据库，None 不使用特定的数据库。</li><li><strong>port</strong> - 要使用的 MySQL 端口，默认通常都可以。（默认值：3306）</li><li><strong>charset</strong> - 你要使用的 Charset。</li><li><strong>db</strong> - 数据库的别名。（与 MySQLdb 兼容）</li><li><strong>passwd</strong> - 密码的别名。（与 MySQLdb 兼容）</li></ul><pre><code class="python">import pymysqlconn=pymysql.connect(    host=&#39;localhost&#39;,    port=3306,    database=&#39;python&#39;,    user=&#39;root&#39;,    password=&#39;123456&#39;,)print(conn)// 输出结果如下：&lt;pymysql.connections.Connection object at 0x0000018E4F185CF8&gt;  // 表示连接成功</code></pre><h3 id="1-2-2- 执行 -sql- 命令"><a href="#1-2-2- 执行 -sql- 命令" class="headerlink" title="1.2.2 执行 sql 命令"></a>1.2.2 执行 sql 命令 </h3><p> 执行 sql 命令，需要调用 Connection 对象的 cursor() 方法创建一个游标（Cursor）对象。</p><p>获取 Cursor 对象：</p><pre><code class="python">cursor = conn.cursor()</code></pre><p>使用 excute 执行查询指令</p><pre><code>sql = &#39; 需要执行的命令 &#39;cursor.excute(sql)</code></pre><p>如：</p><pre><code class="python">cursor=conn.cursor()tables_count=cursor.execute(&#39;show tables;&#39;)   // 查看有多少数据表</code></pre><h3 id="1-2-3- 游标对象"><a href="#1-2-3- 游标对象" class="headerlink" title="1.2.3 游标对象"></a>1.2.3 游标对象</h3><ul><li><p><code>close</code>()</p><p>关闭游标对象。</p></li><li><p><code>execute</code>(<em>query</em>, <em>args=None</em>)</p><p>执行查询</p><ul><li><p>参数:</p><p><strong>query</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a>) – 查询执行。</p><p><strong>args</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#list"><em>list</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#dict"><em>dict</em></a>) – 与查询一起使用的参数。 （可选的）</p></li><li><p>Returns(返回内容): 受影响的行数</p></li><li><p><strong>Return type:</strong>  int</p></li></ul><p>返回受影响的行数，主要用于执行 insert、update、delete 语句，也可以执行 create、alter、drop 等语句</p><p>如果 args 是列表或元组，则％s 可以用作查询中的占位符。如果 args 是 dict，则％（name）s 可以用作查询中的占位符。</p></li><li><p><code>executemany</code>(<em>query</em>, <em>args</em>)</p><p>执行多个查询</p><ul><li><p>参数</p><p><strong>query</strong> –查询在服务器上执行</p><p><strong>args</strong> –序列或映射的序列。它用作参数。</p></li></ul><p>此方法可提高多行 INSERT 和 REPLACE 的性能。否则它等同于使用 execute（）循环遍历 args。</p></li><li><p><code>fetchall</code>()</p><p>执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回</p></li><li><p><code>fetchmany</code>(<em>size=None</em>)</p><p>获取几行</p></li><li><p><code>fetchone</code>()</p><p>执行查询语句时，获取查询结果集的第一个行数据，返回一个元组</p></li></ul><h2 id="1-3- 插入数据"><a href="#1-3- 插入数据" class="headerlink" title="1.3 插入数据"></a>1.3 插入数据 </h2><p> 使用游标向数据库插入数据</p><pre><code class="python"># 插入一条数据one_data = &quot;insert into goods values(0,&#39;ipad mini 配备 retina 显示屏 &#39;,&#39; 平板电脑 &#39;,&#39; 苹果 &#39;,&#39;2788&#39;,default,default); &quot;cursor.execute(one_data)</code></pre><p>回滚</p><pre><code class="python">try:    # 执行 SQL 语句    cursor.execute(&quot;insert into goods values(0,&#39;ipad mini 配备 retina 显示屏 &#39;,&#39; 平板电脑 &#39;,&#39; 苹果 &#39;,&#39;2788&#39;,default,default); &quot;)    # 提交事务    conn.commit()except Exception as e:    # 有异常，回滚事务    conn.rollback()cursor.close()conn.close()</code></pre><h3 id="1-3-1- 案例"><a href="#1-3-1- 案例" class="headerlink" title="1.3.1 案例"></a>1.3.1 案例 </h3><p> 事先使用 mysql 在 python 这个数据库里创建一个表，名为“maoyan”，并指定列名。</p><pre><code class="sql">create database python character set utf8;use python;create table maoyan(moive_name varchar(10) primary key,    star varchar(30) ,    relasetime varchar(20) ,    scores char(3)) character set utf8;</code></pre><p>然后在代码框操作：</p><pre><code class="sql">import pymysqllist = [(&#39; 主演：秦岚, 糸井重里, 岛本须美 &#39;, &#39; 龙猫 &#39;, &#39; 上映时间：2018-12-14&#39;, &#39;9.1&#39;),          (&#39; 主演：张国荣, 张曼玉, 刘德华 &#39;, &#39; 阿飞正传 &#39;, &#39; 上映时间：2018-06-25&#39;, &#39;8.8&#39;),          (&#39; 主演：俞承豪, 金艺芬, 童孝熙 &#39;, &#39; 爱·回家 &#39;, &#39; 上映时间：2002-04-05(韩国)&#39;, &#39;9.0&#39;),          (&#39; 主演：雅克·贝汉, 姜文, 兰斯洛特·佩林 &#39;, &#39; 海洋 &#39;, &#39; 上映时间：2011-08-12&#39;, &#39;9.0&#39;),          (&#39; 主演：宋在浩, 李顺才, 尹秀晶 &#39;, &#39; 我爱你 &#39;, &#39; 上映时间：2011-02-17(韩国)&#39;, &#39;9.0&#39;),          (&#39; 主演：克林特·伊斯特伍德, 李·范·克里夫, 埃里·瓦拉赫 &#39;, &#39; 黄金三镖客 &#39;, &#39; 上映时间：1966-12-23(意大利)&#39;, &#39;8.9&#39;),          (&#39; 主演：雅克·贝汉,Philippe Labro&#39;, &#39; 迁徙的鸟 &#39;, &#39; 上映时间：2001-12-12(法国)&#39;, &#39;9.1&#39;),          (&#39; 主演：柊瑠美, 周冬雨, 入野自由 &#39;, &#39; 千与千寻 &#39;, &#39; 上映时间：2019-06-21&#39;, &#39;9.3&#39;),          (&#39; 主演：蒂姆·罗斯, 比尔·努恩, 普路特·泰勒·文斯 &#39;, &#39; 海上钢琴师 &#39;, &#39; 上映时间：2019-11-15&#39;, &#39;9.3&#39;),          (&#39; 主演：菲利浦·诺瓦雷, 赛尔乔·卡斯特利托, 蒂兹亚娜·罗达托 &#39;, &#39; 天堂电影院 &#39;, &#39; 上映时间：2019-06-15&#39;, &#39;9.2&#39;)]conn=pymysql.connect(    host=&#39;localhost&#39;,    port=3306,    database=&#39;python&#39;,    user=&#39;root&#39;,    password=&#39;123456&#39;,)cursor=conn.cursor()for i in list:    try:        sql=&quot;insert into python.maoyan (star,moive_name,relasetime,scores) values (&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;)&quot; % i        cursor.execute(sql)    except Exception as e:        conn.rollback()conn.commit()cursor.close()conn.close()</code></pre><h2 id="1-4- 查询数据"><a href="#1-4- 查询数据" class="headerlink" title="1.4 查询数据"></a>1.4 查询数据</h2><pre><code class="python">cursor.execute(&quot;select * from maoyan&quot;)one = cursor.fetchone()   // 读取一条数据print(one)all = cursor.fetchall()  // 读取所有数据print(all)</code></pre><h3 id="1-4-1- 查询一行数据"><a href="#1-4-1- 查询一行数据" class="headerlink" title="1.4.1 查询一行数据"></a>1.4.1 查询一行数据</h3><pre><code class="python">cs1 = conn.cursor()count = cs1.execute(&#39;select id,name from goods where id&gt;=4&#39;)print(&quot; 查询到 %d 条数据:&quot; % count)   # 打印受影响的行数for i in range(count):    result = cs1.fetchone()    print(result)    cs1.close()    conn.close()</code></pre><h3 id="1-4-2- 查询多行数据"><a href="#1-4-2- 查询多行数据" class="headerlink" title="1.4.2 查询多行数据"></a>1.4.2 查询多行数据</h3><pre><code class="python">cs1 = conn.cursor()count = cs1.execute(&#39;select id,name from goods where id&gt;=4&#39;)print(&quot; 查询到 %d 条数据:&quot; % count)result = cs1.fetchall()print(result)cs1.close()conn.close()</code></pre><h2 id="1-5- 修改数据"><a href="#1-5- 修改数据" class="headerlink" title="1.5 修改数据"></a>1.5 修改数据</h2><pre><code class="python">cs1 = conn.cursor()count = cs1.execute(&#39;insert into goods_cates(name) values(&quot; 硬盘 &quot;)&#39;)print(count)count = cs1.execute(&#39;insert into goods_cates(name) values(&quot; 光盘 &quot;)&#39;)print(count)conn.commit()cs1.close()conn.close()</code></pre><h2 id="1-6- 参数化"><a href="#1-6- 参数化" class="headerlink" title="1.6 参数化"></a>1.6 参数化</h2><p>sql 语句的参数化，可以有效防止 sql 注入。</p><p>注意：此处不同于 python 的字符串格式化，全部使用 %s 占位。</p><p><strong>非安全方式：</strong></p><pre><code class="python">from pymysql import *def main():    find_name = input(&quot; 请输入物品名称：&quot;)    conn = connect(host=&#39;localhost&#39;,              port=3306,user=&#39;root&#39;,              password=&#39;mysql&#39;,              database=&#39;jing_dong&#39;,              charset=&#39;utf8&#39;)    cs1 = conn.cursor()    sql = &#39;select * from goods where name=&quot;%s&quot;&#39; % find_name    result = cs1.execute(sql).fetchone    print(rsult)if __name__ == &#39;__main__&#39;:    main()// 在 `input` 时输入 `&quot; or 1=1 or &quot;`，会查询到所有数据，会造成信息泄露。</code></pre><p><strong>安全的方式：</strong></p><pre><code>params = [find_name]  // 把传入的 find_name 变成这样的# 如果要是有多个参数，需要进行参数化# 那么 params = [数值 1, 数值 2....]，此时 sql 语句中有多个 %s 即可 cs1.execute(&#39;select * from goods where name=%s&#39;, params)result = cs1.fetchone()print(result)cs1.close()conn.close()</code></pre><h2 id="1-7- 面向对象检索数据"><a href="#1-7- 面向对象检索数据" class="headerlink" title="1.7 面向对象检索数据"></a>1.7 面向对象检索数据</h2><pre><code class="python">import pymysqlclass MaoYanDB:    def __init__(self):        pass    def show_all_info(self):        &quot;&quot;&quot; 显示所有商品信息 &quot;&quot;&quot;        # 获取连接        connection = pymysql.connect(host=&#39;localhost&#39;,              port=3306,user=&#39;root&#39;,              password=&#39;mysql&#39;,              database=&#39;jing_dong&#39;,              charset=&#39;utf8&#39;  # 编码             )        cursor = connection.cursor()        &quot;&quot;&quot; 显示所有商品分类 &quot;&quot;&quot;        sql = &quot;select * from goods;&quot;        cursor.execute(sql)        for temp in cursor.fetchall():            print(temp)        cursor.close()        connection.close()    def show_names(self):        &quot;&quot;&quot; 返回所有电影的名字 &quot;&quot;&quot;        connection = pymysql.connect(host=&#39;localhost&#39;,              port=3306,user=&#39;root&#39;,              password=&#39;mysql&#39;,              database=&#39;jing_dong&#39;,              charset=&#39;utf8&#39;  # 编码              )        sql = &quot;select movie_name from maoyan;&quot;        cursor = connection.cursor()        cursor.execute(sql)        for temp in cursor.fetchall():            print(temp)        cursor.close()        connection.close()if __name__ == &#39;__main__&#39;:    my = MaoYanDB()    my.show_names()</code></pre><p><strong>封装重构之后</strong></p><pre><code class="python">import pymysqlclass MaoYanDB:    def __init__(self):        self.connection = pymysql.connect(host=&#39;localhost&#39;,              port=3306,user=&#39;root&#39;,              password=&#39;mysql&#39;,              database=&#39;jing_dong&#39;,              charset=&#39;utf8&#39;  # 编码              )        self.cursor = self.connection.cursor()    def show_all_info(self):        &quot;&quot;&quot; 显示所有商品信息 &quot;&quot;&quot;        &quot;&quot;&quot; 显示所有商品分类 &quot;&quot;&quot;        sql = &quot;select * from goods;&quot;        self.cursor.execute(sql)        for temp in self.cursor.fetchall():            print(temp)        self.cursor.close()    def show_names(self):        &quot;&quot;&quot; 返回所有电影的名字 &quot;&quot;&quot;        sql = &quot;select movie_name from maoyan;&quot;        self.cursor.execute(sql)        for temp in self.cursor.fetchall():            print(temp)if __name__ == &#39;__main__&#39;:    my = MaoYanDB()    my.show_names()</code></pre><h1 id="2、ORM"><a href="#2、ORM" class="headerlink" title="2、ORM"></a>2、ORM</h1><p>面向对象编程把所有实体看成对象（object），关系型数据库则是采用实体之间的关系（relation）连接数据。很早就有人提出，关系也可以用对象表达，这样的话，就能 <strong> 使用面向对象编程，来操作关系型数据库</strong>。</p><p>ORM 全称 <code>Object Relational Mapping</code>, 翻译过来叫 <code>对象关系映射</code> 。简单的说，ORM 将数据库中的表与面向对象语言中的类建立了一种对应关系。这样，我们要操作数据库，数据库中的表或者表中的一条记录就可以直接通过操作类或者类实例来完成。</p><ul><li>学会用 SQLALchemy 连接数据库(MySQL, SQLite, PostgreSQL)， 创建数据表；</li><li>掌握表数据之间一对一，一对多及多对多的关系并能转化为对应 SQLAlchemy 描述；</li><li>掌握使用 SQLAlchemy 进行 CURD 操作；</li><li>学会使用 Faker 生成测试数据</li></ul><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1559400744447.png" alt="1559400744447"></p><p>要实现 MySQL 数据表到 Python 类的映射，就需要 ORM 框架的帮助。在 Python 中有多个选择，例如轻量的 SQLobject 框架、Storm 框架、Django 内置的 ORM、著名的 SQLAlchemy 以及基于前者的 flask 插件 flask-SQLAlchemy 等。</p><p>SQLAlchemy 是 Python 社区最知名的 ORM 工具之一，为高效和高性能的数据库访问设计，实现了完整的企业级持久模型。</p><p>接下来我们将学习 SQLAlchemy 的使用。先安装 SQLAlchemy：</p><pre><code>$ sudo pip install sqlalchemy</code></pre><h2 id="2-1- 创建连接"><a href="#2-1- 创建连接" class="headerlink" title="2.1 创建连接"></a>2.1 创建连接 </h2><h3 id="2-1-1- 创建引擎"><a href="#2-1-1- 创建引擎" class="headerlink" title="2.1.1 创建引擎"></a>2.1.1 创建引擎</h3><p> 使用 SQLAlchemy 连接数据库需要引擎，创建引擎使用 create_engine 方法：</p><pre><code class="python">from sqlalchemy import create_engineengine = create_engine(&#39;mysql+pymysql://windows:123456@192.168.31.206:3306/study?charset=utf8&#39;)</code></pre><p>注意这里创建引擎的格式：</p><p><code>数据库类型 + 驱动:// 用户名: 密码 @主机: 端口号 / 数据库名字?charset= 编码格式</code></p><p><strong>链接其他数据库</strong></p><ul><li>Postgres:</li></ul><pre><code>postgresql://scott:tiger@localhost/mydatabase</code></pre><ul><li>MySQL:</li></ul><pre><code>mysql://scott:tiger@localhost/mydatabase</code></pre><ul><li>Oracle:</li></ul><pre><code>oracle://scott:tiger@127.0.0.1:1521/sidname</code></pre><ul><li>SQLite （注意开头的四个斜线）:</li></ul><pre><code>sqlite:////absolute/path/to/foo.db</code></pre><p>这里不同数据库创建引擎的格式不一样，但是后续创建表和查询模式都一样。</p><p>下面还是回到 Mysql 为例介绍。</p><h3 id="2-1-2- 基类"><a href="#2-1-2- 基类" class="headerlink" title="2.1.2 基类"></a>2.1.2 基类 </h3><p> 创建映射类需要继承声明基类，使用 declarative_base ：</p><pre><code>from sqlalchemy.ext.declarative import declarative_baseBase = declarative_base(engine)</code></pre><h3 id="2-1-3- 会话"><a href="#2-1-3- 会话" class="headerlink" title="2.1.3 会话"></a>2.1.3 会话</h3><pre><code class="python">from sqlalchemy.orm import sessionmakersession = sessionmaker(engine)()</code></pre><p>当我们创建了 session 实例，就启动了一个操作 MySQL 数据库的会话。对 <strong> 数据库进行了连接。</strong></p><h2 id="2-2- 创建数据"><a href="#2-2- 创建数据" class="headerlink" title="2.2 创建数据"></a>2.2 创建数据</h2><h3 id="2-2-1- 映射类"><a href="#2-2-1- 映射类" class="headerlink" title="2.2.1 映射类"></a>2.2.1 映射类</h3><blockquote><p>一对一对象</p></blockquote><p>首先 <strong> 创建 user 数据表 </strong> 的映射类，此表存放用户数据。</p><pre><code class="python">from sqlalchemy import Column, Integer, Stringclass User(Base):           // 创建映射类须继承声明基类    __tablename__ = &#39;user&#39;  // 设置数据表名字，不可省略    id = Column(Integer, primary_key=True)      name = Column(String(64), unique=True, nullable=False)    email = Column(String(64), unique=True)    # 此特殊方法定义实例的打印样式    def __repr__(self):        return &#39;&lt;User: &#123;&#125;&gt;&#39;.format(self.name)</code></pre><p>在 <code>User</code> 类中，用 <code>__tablename__</code> 指定在 MySQL 中表的名字。我们创建了三个基本字段，类中的每一个 <code>Column</code> 代表数据库中的一列，在 <code>Colunm</code>中，指定该列的一些配置。第一个字段代表类的数据类型，上面我们使用 <code>String</code>, <code>Integer</code> 俩个最常用的类型，其他常用的包括：</p><pre><code>TextBooleanSmallIntegerDateTime</code></pre><p>另外定义 <code>__repr__</code> 是为了方便调试，你可以不定义，也可以定义的更详细一些。</p><blockquote><p>一对多对象</p></blockquote><pre><code class="python">from sqlalchemy import ForeignKeyfrom sqlalchemy.orm import relationship, backrefclass Course(Base):    __tablename__ = &#39;course&#39;    id = Column(Integer, primary_key=True)    name = Column(String(64))    user_id = Column(Integer, ForeignKey(&#39;user.id&#39;, ondelete=&#39;CASCADE&#39;))    //ForeignKey 设置外键关联，第一个参数为字符串，user 为数据表名，id 为字段名    // 第二个参数 ondelete 设置删除 User 实例后对关联的 Course 实例的处理规则    //&#39;CASCADE&#39; 表示级联删除，删除用户实例后，对应的课程实例也会被连带删除    user = relationship(&#39;User&#39;,             backref=backref(&#39;course&#39;, cascade=&#39;all, delete-orphan&#39;))    //relationship 设置查询接口，以便后期进行数据库查询操作    // 第一个参数为位置参数，参数值为外键关联的映射类名，数据类型为字符串    // 第二个参数 backref 设置反向查询接口    //backref 的第一个参数 &#39;course&#39; 为查询属性，User 实例使用该属性可以获得相关课程实例的列表    //backref 的第二个参数 cascade 如此设置即可实现 Python 语句删除用户数据时级联删除课程数据    def __repr__(self):        return &#39;&lt;Course: &#123;&#125;&gt;&#39;.format(self.name)</code></pre><p><strong>定义列时常用参数表：</strong> </p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>primary_key</td><td>如果设为 True，这列就是表的主键</td></tr><tr><td>unique</td><td>默认值为 False，如果设为 True，这列不允许出现重复的值</td></tr><tr><td>index</td><td>如果设为 True，为这列创建索引，提升查询效率</td></tr><tr><td>nullable</td><td>默认值为 True，这列允许使用空值；如果设为 False，这列不允许使用空值</td></tr><tr><td>default</td><td>为这列定义默认值</td></tr></tbody></table><p>常用的 SQLAlchemy 查询关系选项（在 <strong>backref</strong> 中使用）：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>backref</td><td>在关系的另一个映射类中添加反向引用</td></tr><tr><td>lazy</td><td>指定如何加载查询记录。可选值有 select (首次访问时按需加载)、immediate (源对象加 载后就加载)、joined (加载记录，但使用联结)， noload (永不加载)和 dynamic (不加载记录，但提供加载记录的查询，比较常用)</td></tr><tr><td>cascade</td><td>设置级联删除的方式</td></tr><tr><td>uselist</td><td>如果设为 Fales，查询结果不使用列表，而使用映射类实例（下节课程会用到）</td></tr><tr><td>order_by</td><td>指定查询记录的排序方式</td></tr><tr><td>secondary</td><td>指定多对多关系中关系表的名字（下节课程会用到）</td></tr></tbody></table><h3 id="2-2-2- 创建数据表"><a href="#2-2-2- 创建数据表" class="headerlink" title="2.2.2 创建数据表"></a>2.2.2 创建数据表 </h3><p> 声明基类 Base 在创建之后并不会主动连接数据库，因为它的默认设置为惰性模式。Base 的 metadata 有个 create_all 方法，执行此方法会主动连接数据库并创建全部数据表，完成之后自动断开与数据库的连接：</p><pre><code>Base.metadata.create_all()</code></pre><p><strong>完整代码</strong> </p><p><strong>总结以上内容，写入 db.py 文件：</strong></p><pre><code class="python">from sqlalchemy import create_engine, Column, Integer, String, ForeignKeyfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import relationship, backrefengine = create_engine(&#39;mysql://root@localhost/study?charset=utf8&#39;)Base = declarative_base(engine)class User(Base):      __tablename__ = &#39;user&#39;      id = Column(Integer, primary_key=True)     name = Column(String(64), unique=True, nullable=False)    email = Column(String(64), unique=True)    def __repr__(self):        return &#39;&lt;User: &#123;&#125;&gt;&#39;.format(self.name)class Course(Base):    __tablename__ = &#39;course&#39;    id = Column(Integer, primary_key=True)    name = Column(String(64))    user_id = Column(Integer, ForeignKey(&#39;user.id&#39;, ondelete=&#39;CASCADE&#39;))    user = relationship(&#39;User&#39;,            backref=backref(&#39;course&#39;, cascade=&#39;all, delete-orphan&#39;))    def __repr__(self):        return &#39;&lt;Course: &#123;&#125;&gt;&#39;.format(self.name)if __name__ == &#39;__main__&#39;:    Base.metadata.create_all()   // 创建数据表</code></pre><p>运行后就可以看到数据库生成了数据库模型。</p><h2 id="2-3- 生成测试数据"><a href="#2-3- 生成测试数据" class="headerlink" title="2.3 生成测试数据"></a>2.3 生成测试数据 </h2><h3 id="2-3-1- 添加测试数据"><a href="#2-3-1- 添加测试数据" class="headerlink" title="2.3.1 添加测试数据"></a>2.3.1 添加测试数据</h3><p> 测试数据的创建需要用到 Python 的 faker 库，使用 pip 安装先：</p><pre><code class="python">pip install faker</code></pre><p>终端执行 ipython 命令，即可进入命令行交互解释器：</p><pre><code class="python">In [38]: from faker import Faker  # 引入 Faker 类# 创建实例，添加参数 &#39;zh-cn&#39; 是为了伪造中文数据# 该实例叫做工厂对象，它可以使用各种各样的方法伪造数据In [39]: fake = Faker(&#39;zh-cn&#39;)       In [40]: fake.name()     # 伪造姓名Out[40]: &#39; 房明 &#39;In [41]: fake.address()  # 伪造地址Out[41]: &#39; 山西省梅市上街董路 Q 座 238175&#39;In [42]: fake.email()    # 伪造邮箱Out[42]: &#39;oqiu@rn.net&#39;In [43]: fake.url()      # 伪造 URLOut[43]: &#39;https://www.yuzhu.cn/&#39;In [44]: fake.date()     # 伪造日期Out[44]: &#39;2012-07-03&#39;</code></pre><p><strong>创建实例：</strong></p><p>接下来创建 5 个课程用户，也就是 5 个 User 类的实例，每个用户对应两个课程，共 10 个 Course 类实例。将以下代码写入测试数据的 Python 文件中，文件名为 create_data.py ：</p><pre><code class="python">from sqlalchemy.orm import sessionmakerfrom faker import Fakerfrom db import Base, engine, User, Coursesession = sessionmaker(engine)()fake = Faker(&#39;zh-cn&#39;)def create_users():    for i in range(10):        # 创建 10 个 User 类实例，伪造 name 和 email        user = User(name=fake.name(), email=fake.email())        # 将实例添加到 session 会话中，以备提交到数据库        # 注意，此时的 user 对象没有 id 属性值        # 映射类的主键字段默认从 1 开始自增，在传入 session 时自动添加该属性值        session.add(user)def create_courses():    # session 有个 query 方法用来查询数据，参数为映射类的类名    # all 方法表示查询全部，这里也可以省略不写    # user 就是上一个函数 create_users 中的 user 对象    for user in session.query(User).all():        # 两次循环，对每个作者创建两个课程        for i in range(2):            # 创建课程实例，name 的值为 8 个随机汉字            course = Course(name=&#39;&#39;.join(fake.words(4)), user_id=user.id)            session.add(course)def main():    # 执行两个创建实例的函数，session 会话内就有了这些实例    create_users()    create_courses()    # 执行 session 的 commit 方法将全部数据提交到对应的数据表中    session.commit()if __name__ == &#39;__main__&#39;:    main()</code></pre><h3 id="2-3-2- 测试"><a href="#2-3-2- 测试" class="headerlink" title="2.3.2 测试"></a>2.3.2 测试 </h3><p> 完成后，可以在终端执行 python3 create_data.py 来创建数据。为了便于查看代码的执行情况，不这样做，我们在 ipython 中引入这些函数，依次执行它们来查看细节：</p><pre><code class="python"># 引入相关对象In [1]: from create_data import User, Course, session, create_users, create_courses# 执行创建 User 实例的函数In [2]: create_users()# session 查询结果为列表，每个元素就是一个 User 实例In [3]: session.query(User).all()Out[3]:[&lt;User: 安颖 &gt;, &lt;User: 赵琴 &gt;, &lt;User: 李英 &gt;, &lt;User: 邢想 &gt;, &lt;User: 高玲 &gt;, &lt;User: 戴晶 &gt;, &lt;User: 卢建平 &gt;, &lt;User: 陈强 &gt;, &lt;User: 姜帆 &gt;, &lt;User: 包柳 &gt;]# 将某个 User 实例赋值给 user 变量In [4]: user = session.query(User).all()[3]# 查看属性In [5]: user.nameOut[5]: &#39; 邢想 &#39;In [6]: user.idOut[6]: 4# 执行创建 Course 实例的函数In [7]: create_courses()# 查看前 4 个 Course 实例的 name 属性In [8]: for course in session.query(Course)[:4]:   ...:     print(course.name)   ...:开发中文电子新闻怎么发布结果详细你的只要非常如果次数通过评论等级# User 实例的 course 属性为查询接口，通过 relationship 设置# 属性值为列表，里面是两个课程实例In [9]: user.courseOut[9]: [&lt;Course: 上海这么国际时候 &gt;, &lt;Course: 对于技术两个你们 &gt;]# 将某个课程实例赋值给 course 变量In [10]: course = session.query(Course)[12]# 课程实例的 user 属性为查询接口，通过 relationship 设置In [11]: course.userOut[11]: &lt;User: 卢建平 &gt;# 将全部实例提交到对应的数据表In [12]: session.commit()In [13]:</code></pre><p>查看 MySQL 数据库中各表的数据：</p><pre><code class="sql">mysql&gt; SELECT * FROM user;+----+-----------+----------------------+| id | name      | email                |+----+-----------+----------------------+|  1 | 安颖       | fanxiuying@weiyin.cn ||  2 | 赵琴       | tao10@hotmail.com    ||  3 | 李英       | xia68@gangqiang.cn   ||  4 | 邢想       | minyi@yahoo.com      ||  5 | 高玲       | maoqiang@pa.cn       ||  6 | 戴晶       | xlin@yahoo.com       ||  7 | 卢建平     | dqian@yahoo.com      ||  8 | 陈强       | yuanjun@guiying.cn   ||  9 | 姜帆       | xiayan@tx.cn         || 10 | 包柳       | qiang78@hotmail.com  |+----+-----------+----------------------+10 rows in set (0.00 sec)mysql&gt; SELECT * FROM course;+----+--------------------------+---------+| id | name                     | user_id |+----+--------------------------+---------+|  1 | 开发中文电子新闻            |       1 ||  2 | 怎么发布结果详细            |       1 ||  3 | 你的只要非常如果            |       2 ||  4 | 次数通过评论等级            |       2 ||  5 | 经验方式文件根据            |       3 ||  6 | 资料你们各种类别            |       3 ||  7 | 上海这么国际时候            |       4 |... ...+----+--------------------------+---------+20 rows in set (0.00 sec)</code></pre><p>接下来我们在 ipython 中删除 user 实例，验证级联删除功能是否生效：</p><pre><code class="python">In [13]: session.delete(user)In [14]: session.commit()In [15]:</code></pre><p>查看数据表的情况，一如预期，user 表中 id 为 4 的行被删除，course 表中 user_id 为 4 的行也被删除：</p><pre><code class="python">mysql&gt; SELECT * FROM user;+----+-----------+----------------------+| id | name      | email                |+----+-----------+----------------------+|  1 | 安颖      | fanxiuying@weiyin.cn ||  2 | 赵琴      | tao10@hotmail.com    ||  3 | 李英      | xia68@gangqiang.cn   ||  5 | 高玲      | maoqiang@pa.cn       ||  6 | 戴晶      | xlin@yahoo.com       ||  7 | 卢建平    | dqian@yahoo.com      ||  8 | 陈强      | yuanjun@guiying.cn   ||  9 | 姜帆      | xiayan@tx.cn         || 10 | 包柳      | qiang78@hotmail.com  |+----+-----------+----------------------+9 rows in set (0.00 sec)mysql&gt; SELECT * FROM course WHERE user_id = 4;Empty set (0.00 sec)mysql&gt;</code></pre><h2 id="2-4- 关系"><a href="#2-4- 关系" class="headerlink" title="2.4 关系"></a>2.4 关系 </h2><h3 id="2-4-1- 一对一关系"><a href="#2-4-1- 一对一关系" class="headerlink" title="2.4.1 一对一关系"></a>2.4.1 一对一关系</h3><p> 本节我们来学习创建一对一、多对多关系的数据表。为了方便演示，假设我们的每个课程只有一个实验，我们要创建映射类 Lab 和表 lab，课程和实验就是一对一的关系，如何实现这种关系呢？把 lab 的主键 id 设置为外键关联到 course 的主键 id 即可，因为主键是自带唯一约束的，这样就实现了一对一关系。</p><p>创建映射类 Lab，将以下代码写入 db.py 文件：</p><pre><code class="python">class Lab(Base):    tablename = &#39;lab&#39;    # 设置主键为外键，关联 course 表的 id 字段    # 注意参数顺序，先定义外键，再定义主键    id = Column(Integer, ForeignKey(&#39;course.id&#39;), primary_key=True)    name = Column(String(128))    # 设置查询接口，Lab 实例的 course 属性值为 Course 实例    # Course 实例的 lab 属性值默认为列表，列表中有一个 Lab 实例    # uselist 参数可以设置 Course 实例的 lab 属性值为 Lab 实例而非列表    course = relationship(&#39;Course&#39;, backref=backref(&#39;lab&#39;, uselist=False))    def __repr__(self):        return &#39;&lt;Lab: &#123;&#125;&gt;&#39;.format(self.name)</code></pre><p>保存代码后，在终端运行文件即可生成数据表：</p><pre><code>$ python db.py</code></pre><p>查看数据库：</p><pre><code class="sql">mysql&gt; SHOW TABLES;+-----------------+| Tables_in_study |+-----------------+| course          || lab             || user            |+-----------------+3 rows in set (0.00 sec)</code></pre><p>接下来创建多对多关系的数据表，然后再一并生成测试数据。</p><h3 id="2-4-2- 多对多关系"><a href="#2-4-2- 多对多关系" class="headerlink" title="2.4.2 多对多关系"></a>2.4.2 多对多关系 </h3><p> 一个课程可以有多个标签，每个标签可以贴在多个课程上，我们需要实现 course 课程表和 tag 标签表的多对多关系。</p><ul><li>一对多关系：一个 User 实例（课程教师）对应多个 Course 实例，一个 Course 实例对应一个 User 实例。</li><li>一对一关系：一个 Course 实例对应一个 Lab 实例，一个 Lab 实例对应一个 Course 实例。</li><li>多对多关系：一个 Course 实例对应多个 Tag 实例，一个 Tag 实例对应多个 Course 实例。</li></ul><p>满足上述需求的多对多关系，需要在创建 Tag 映射类之前，首先创建中间表的映射类，用 Table 这个特殊类创建，此类的实例就是映射类。</p><p>将以下代码写入 db.py 文件中：</p><pre><code class="python"># 引入 Table 类from sqlalchemy import Table# 创建 Table 类的实例，即中间表映射类，赋值给变量 Rela# 该类在实例化时，接收 4 个参数：# 1、数据表名字 2、Base.metadata# 3 和 4、两个 Column（列名，数据类型，外键，主键）Rela = Table(&#39;rela&#39;, Base.metadata,        Column(&#39;tag_id&#39;, Integer, ForeignKey(&#39;tag.id&#39;), primary_key=True),        Column(&#39;course_id&#39;, Integer, ForeignKey(&#39;course.id&#39;), primary_key=True))</code></pre><p>有了中间表的映射类，就可以创建 tag 表的映射类 Tag 了，将以下代码写入 db.py 文件中：</p><pre><code class="python">class Tag(Base):    __tablename__ = &#39;tag&#39;    id = Column(Integer, primary_key=True)    name = Column(String(64), unique=True)    # 设置查询接口，secondary 指定多对多关系的中间表，注意数据类型不是字符串    course = relationship(&#39;Course&#39;, secondary=Rela, backref=&#39;tag&#39;)    def __repr__(self):        return &#39;&lt;Tag: &#123;&#125;&gt;&#39;.format(self.name)</code></pre><p>同样地，终端运行文件生成数据表：</p><pre><code class="sql">$ python db.py-- 查看数据库中的数据表：mysql&gt; SHOW TABLES;+-----------------+| Tables_in_study |+-----------------+| course          || lab             || rela            || tag             || user            |+-----------------+5 rows in set (0.00 sec)</code></pre><p>注意中间表是真实存在的数据表，它有两个字段，当我们给课程添加标签时，该表会记录相关信息：</p><pre><code class="sql">mysql&gt; DESC rela;+-----------+---------+------+-----+---------+-------+| Field     | Type    | Null | Key | Default | Extra |+-----------+---------+------+-----+---------+-------+| tag_id    | int(11) | NO   | PRI | NULL    |       || course_id | int(11) | NO   | PRI | NULL    |       |+-----------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)</code></pre><h2 id="2-5- 完善创建"><a href="#2-5- 完善创建" class="headerlink" title="2.5 完善创建"></a>2.5 完善创建 </h2><h3 id="2-5-1- 增加数据"><a href="#2-5-1- 增加数据" class="headerlink" title="2.5.1 增加数据"></a>2.5.1 增加数据</h3><p> 下面对 create_data.py 文件补充一些代码，我们用 10 个随机中文汉字作为 lab 表的 name 字段的值，创建 20 个 Lab 类的实例，10 个 Tag 类的实例，补充代码如下：</p><pre><code class="python">from db import Lab, Tagdef create_labs():    for course in session.query(Course):        lab = Lab(name=&#39;&#39;.join(fake.words(5)), id=course.id)        session.add(lab)def create_tags():    for name in [&#39;python&#39;, &#39;linux&#39;, &#39;java&#39;, &#39;mysql&#39;, &#39;lisp&#39;]:        tag = Tag(name=name)        session.add(tag)</code></pre><p>启动命令行交互解释器 ipython，引入相关对象，执行创建数据的函数：</p><pre><code class="python">In [1]: from create_data import *In [2]: create_labs()In [3]: create_tags()In [4]: session.commit()</code></pre><p>查看数据库内数据：</p><pre><code class="python">mysql&gt; SELECT * FROM lab;+----+--------------------------------+| id | name                           |+----+--------------------------------+|  1 | 北京联系其中准备技术           ||  2 | 影响一样来源已经有些           ||  3 | 建设研究工作那些我的           ||  4 | 可是注册显示应该学生           ||  5 | 起来决定不要企业资料           ||  6 | 国内电子基本类型的人           ||  9 | 方式一般的话具有系列           || 10 | 基本当然是否个人政府           || 11 | 其他教育你的类别更新           || 12 | 世界很多之后世界推荐           || 13 | 一直方法完全注意事情           || 14 | 大学不过认为世界应用           || 15 | 这么说明什么文化一个           || 16 | 状态阅读包括资料那么           || 17 | 作者继续作者人员对于           || 18 | 地区原因我的不断评论           || 19 | 基本环境表示我们情况           || 20 | 但是就是根据活动留言           |+----+--------------------------------+18 rows in set (0.00 sec)mysql&gt; SELECT * FROM tag;+----+--------+| id | name   |+----+--------+|  1 | java   ||  2 | linux  ||  3 | lisp   ||  4 | mysql  ||  5 | python |+----+--------+5 rows in set (0.00 sec)</code></pre><h3 id="2-5-2- 给课程添加标签"><a href="#2-5-2- 给课程添加标签" class="headerlink" title="2.5.2 给课程添加标签"></a>2.5.2 给课程添加标签 </h3><p> 课程实例有 tag 属性，这是在映射类中设置的查询接口，标签实例也有对应的查询接口 course，它们的属性值均为空列表，如果要给课程添加标签，只需将标签实例添加到 tag 属性的列表中，给标签添加课程同理，举例如下：</p><pre><code class="python">#  通过查询将两个课程实例赋值给变量 c1 c2 ，将两个标签实例赋值给 t1 t2In [6]: c1 = session.query(Course)[3]In [7]: c2 = session.query(Course)[11]In [8]: t1 = session.query(Tag)[1]In [9]: t2 = session.query(Tag)[2]# 课程的 tag 属性默认为空列表In [10]: c1.tagOut[10]: []# 将标签实例添加到列表In [11]: c1.tag.append(t1)In [12]: c1.tag.append(t2)# 标签的 course 属性里就有了对应的课程实例In [13]: t1.courseOut[13]: [&lt;Course: 次数通过评论等级 &gt;]# 当然了，课程实例的 tag 属性里有了两个标签实例In [14]: c1.tagOut[14]: [&lt;Tag: linux&gt;, &lt;Tag: lisp&gt;]In [15]: t2.course.append(c2)In [16]: c2.tagOut[16]: [&lt;Tag: lisp&gt;]# 执行 session.commit() 即可将它们的关系传入数据库中In [17]: session.commit()In [18]:</code></pre><p>查看数据库的中间表，可以看到给课程添加标签后，每组关系都被保存在该表中：</p><pre><code class="python">mysql&gt; SHOW TABLES;+-----------------+| Tables_in_study |+-----------------+| course          || lab             || rela            || tag             || user            |+-----------------+5 rows in set (0.00 sec)mysql&gt; SELECT * FROM rela;+--------+-----------+| tag_id | course_id |+--------+-----------+|      2 |         4 ||      3 |         4 ||      3 |        14 |+--------+-----------+3 rows in set (0.00 sec)</code></pre><h2 id="2-6- 完整代码"><a href="#2-6- 完整代码" class="headerlink" title="2.6 完整代码"></a>2.6 完整代码 </h2><p> 以上课程中我们写了两个 Python 脚本。在 db.py 中创建了 User、Course、Lab、Tag 4 个映射类 + 1 个中间表的映射类 Rela，其中包含了数据表的一对多、一对一、多对多关系；在 create_data.py 脚本中编写了向数据表中添加测试数据的代码，为了方便演示，并未在终端使用 Python 解释器执行此文件。</p><p>下面是两个 Python 脚本的完整代码，供大家测试使用：</p><pre><code class="python"># File Name: db.pyfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Tablefrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import relationship, backrefengine = create_engine(&#39;mysql://root@localhost/study?charset=utf8&#39;)Base = declarative_base(engine)class User(Base):    __tablename__ = &#39;user&#39;    id = Column(Integer, primary_key=True)    name = Column(String(64), unique=True, nullable=False)    email = Column(String(64), unique=True)    def __repr__(self):        return &#39;&lt;User: &#123;&#125;&gt;&#39;.format(self.name)// 以下创建四个数据表class Course(Base):    __tablename__ = &#39;course&#39;    id = Column(Integer, primary_key=True)    name = Column(String(64))    user_id = Column(Integer, ForeignKey(&#39;user.id&#39;, ondelete=&#39;CASCADE&#39;))    user = relationship(&#39;User&#39;,            backref=backref(&#39;course&#39;, cascade=&#39;all, delete-orphan&#39;))    def __repr__(self):        return &#39;&lt;Course: &#123;&#125;&gt;&#39;.format(self.name)class Lab(Base):    __tablename__ = &#39;lab&#39;    id = Column(Integer, ForeignKey(&#39;course.id&#39;), primary_key=True)    name = Column(String(128))    course = relationship(&#39;Course&#39;, backref=backref(&#39;lab&#39;, uselist=False))    def __repr__(self):        return &#39;&lt;Lab: &#123;&#125;&gt;&#39;.format(self.name)Rela = Table(&#39;rela&#39;, Base.metadata,        Column(&#39;tag_id&#39;, Integer, ForeignKey(&#39;tag.id&#39;), primary_key=True),        Column(&#39;course_id&#39;, Integer, ForeignKey(&#39;course.id&#39;), primary_key=True))class Tag(Base):    __tablename__ = &#39;tag&#39;    id = Column(Integer, primary_key=True)    name = Column(String(64), unique=True)    course = relationship(&#39;Course&#39;, secondary=Rela, backref=&#39;tag&#39;)    def __repr__(self):        return &#39;&lt;Tag: &#123;&#125;&gt;&#39;.format(self.name)if __name__ == &#39;__main__&#39;:    Base.metadata.create_all()</code></pre><pre><code class="python"># File Name: create_data.pyfrom sqlalchemy.orm import sessionmakerfrom faker import Fakerfrom db import engine, User, Course, Lab, Tagsession = sessionmaker(engine)()fake = Faker(&#39;zh-cn&#39;)def create_users():    for i in range(10):        user = User(name=fake.name(), email=fake.email())        session.add(user)def create_courses():    for user in session.query(User).all():        for i in range(2):            course = Course(name=&#39;&#39;.join(fake.words(4)), user=user)            session.add(course)def create_labs():    for course in session.query(Course):        lab = Lab(name=&#39;&#39;.join(fake.words(5)), id=course.id)        session.add(lab)def create_tags():    for name in [&#39;python&#39;, &#39;linux&#39;, &#39;java&#39;, &#39;mysql&#39;, &#39;lisp&#39;]:        tag = Tag(name=name)        session.add(tag)def main():    create_users()    create_courses()    create_labs()    create_tags()    session.commit()if __name__ == &#39;__main__&#39;:    main()</code></pre><p>总结</p><p>本节课程中讲解了一对一、多对多关系的数据表创建流程，并且已经嵌入了 session 增删改查的操作讲解，下面一节课程我们针对“查”进行详细的介绍。</p><h2 id="2-7- 查询"><a href="#2-7- 查询" class="headerlink" title="2.7 查询"></a>2.7 查询 </h2><p> 本节主要讲解 SQLAlchemy 的查询方法，讲解主要基于前两节的数据。通常我们对数据库的使用主要有三步：创建数据表，添加数据，查询数据。前两节完成了前两步的介绍，接下来我们针对查询尤其是过滤查询进行深入探讨。</p><p>首先在 MySQL 客户端中删除数据库 study 并重建：</p><pre><code class="python">mysql&gt; DROP SCHEMA IF EXISTS study;  # SCHEMA 等同于 DATABASEQuery OK, 5 rows affected (0.23 sec)mysql&gt; CREATE SCHEMA study CHARACTER SET = UTF8;Query OK, 1 row affected, 1 warning (0.06 sec)mysql&gt;</code></pre><p>然后在终端命令行执行 Python 脚本创建数据表、添加数据，脚本代码参见上一节文档：</p><pre><code class="shell">$ python db.py$ python create_data.py</code></pre><h3 id="2-7-1- 基本查询语句"><a href="#2-7-1- 基本查询语句" class="headerlink" title="2.7.1 基本查询语句"></a>2.7.1 基本查询语句 </h3><p> 我们使用命令行交互解释器 ipython 来学习查询语句：</p><pre><code class="python"># 首先从 create_data.py 中引入所需对象In [1]: from create_data import session, User, Course, Lab, Tag# session 的 query 方法接收类作为参数，.all 表示获取全部实例# 不论查询结果是一个还是多个，返回值都是列表，查不到的话返回值是空列表# 等同于 MySQL 语句：SELECT * FROM user;In [2]: session.query(User).all()Out[2]:[&lt;User: 王雷 &gt;, &lt;User: 朱华 &gt;, &lt;User: 汪林 &gt;, &lt;User: 夏晶 &gt;, &lt;User: 蒋桂珍 &gt;, &lt;User: 宁兵 &gt;, &lt;User: 梁龙 &gt;, &lt;User: 李博 &gt;, &lt;User: 段欣 &gt;, &lt;User: 刘文 &gt;]# 查询第一条数据In [3]: session.query(User).first()Out[3]: &lt;User: 王雷 &gt;# filter 方法过滤查询In [4]: session.query(User).filter(User.name==&#39; 王雷 &#39;).first()Out[4]: &lt;User: 王雷 &gt;# filter_by 方法也是常用的过滤方法，且写法更为简洁In [5]: session.query(User).filter_by(name=&#39; 王雷 &#39;).first()Out[5]: &lt;User: 王雷 &gt;# filter 方法支持 &gt;、&gt;=、&lt;、&lt;=、==、!= 等比较符号In [6]: session.query(User).filter(User.name!=&#39; 王雷 &#39;).all()Out[6]:[&lt;User: 朱华 &gt;, &lt;User: 汪林 &gt;, &lt;User: 夏晶 &gt;, &lt;User: 蒋桂珍 &gt;, &lt;User: 宁兵 &gt;, &lt;User: 梁龙 &gt;, &lt;User: 李博 &gt;, &lt;User: 段欣 &gt;, &lt;User: 刘文 &gt;]In [7]: session.query(User).filter(User.id&gt;=6).all()Out[7]: [&lt;User: 宁兵 &gt;, &lt;User: 梁龙 &gt;, &lt;User: 李博 &gt;, &lt;User: 段欣 &gt;, &lt;User: 刘文 &gt;]# filter_by 方法支持多条件查询In [8]: session.query(User).filter_by(name=&#39; 王雷 &#39;, id=1).all()Out[8]: [&lt;User: 王雷 &gt;]# 查询 User 表中全部数据的 name 值In [9]: session.query(User.name).all()Out[9]:[(&#39; 刘文 &#39;), (&#39; 夏晶 &#39;), (&#39; 宁兵 &#39;), (&#39; 朱华 &#39;), (&#39; 李博 &#39;), (&#39; 梁龙 &#39;), (&#39; 段欣 &#39;), (&#39; 汪林 &#39;), (&#39; 王雷 &#39;), (&#39; 蒋桂珍 &#39;)]# 注意上一个命令的查询结果列表中每个元素的数据类型是 namedtuple# 当然也可以理解为元组，取下标为 0 的元素就是 name 值In [10]: for i in session.query(User.name).all():    ...:     print(i)    ...:     print(i.name)    ...:(&#39; 刘文 &#39;,)刘文(&#39; 夏晶 &#39;,)夏晶(&#39; 宁兵 &#39;,)宁兵(&#39; 朱华 &#39;,)朱华(&#39; 李博 &#39;,)李博(&#39; 梁龙 &#39;,)梁龙(&#39; 段欣 &#39;,)段欣(&#39; 汪林 &#39;,)汪林(&#39; 王雷 &#39;,)王雷(&#39; 蒋桂珍 &#39;,)蒋桂珍</code></pre><p>like 方法进行模糊查询，% 匹配任意数量的任意字符，_ 匹配单个任意字符：</p><pre><code class="python"># 查询邮箱为谷歌邮箱的 User 实例In [12]: session.query(User).filter(User.email.like(&#39;%gmail%&#39;)).all()Out[12]: [&lt;User: 王雷 &gt;, &lt;User: 朱华 &gt;, &lt;User: 汪林 &gt;, &lt;User: 段欣 &gt;, &lt;User: 刘文 &gt;]# 查询邮箱第二个字符为 i 的 User 实例In [13]: session.query(User).filter(User.email.like(&#39;_i%&#39;)).all()Out[13]: [&lt;User: 王雷 &gt;, &lt;User: 夏晶 &gt;, &lt;User: 宁兵 &gt;, &lt;User: 李博 &gt;]</code></pre><p>in_ 方法查询 “某个字段的值属于某个列表” 的数据：</p><pre><code class="python"># 如果列表中的字段在 name 列中查不到，并不会报错In [14]: session.query(User).filter(User.name.in_([&#39; 王雷 &#39;, &#39; 夏晶 &#39;, &#39;xxx&#39;])).all()Out[14]: [&lt;User: 夏晶 &gt;, &lt;User: 王雷 &gt;]</code></pre><p>and_ 方法进行多条件查询，需要引入，等同于上面 filter_by 方法：</p><pre><code class="python">In [15]: from sqlalchemy import and_# 查询符合全部条件的数据In [16]: session.query(User).filter(and_(User.name==&#39; 王雷 &#39;, User.id==1)).all()Out[16]: [&lt;User: 王雷 &gt;]</code></pre><p>or_ 也是多条件查询，符合任一条件即可，也是需要引入：</p><pre><code class="python">In [24]: from sqlalchemy import or_# 查询符合任一条件的数据In [25]: session.query(User).filter(or_(    ...:     User.email==&#39;na55@zhouwan.cn&#39;,    ...:     User.id==1    ...: )).all()Out[25]: [&lt;User: 王雷 &gt;, &lt;User: 梁龙 &gt;]</code></pre><h3 id="2-7-2- 查询过滤器"><a href="#2-7-2- 查询过滤器" class="headerlink" title="2.7.2 查询过滤器"></a>2.7.2 查询过滤器</h3><table><thead><tr><th>过滤器</th><th>说明</th></tr></thead><tbody><tr><td>filter()</td><td>把过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>filter_by()</td><td>把等值过滤器添加到原查询上，返回一个新查询</td></tr><tr><td>limit</td><td>使用指定的值限定原查询返回的结果</td></tr><tr><td>offset()</td><td>偏移原查询返回的结果，返回一个新查询</td></tr><tr><td>order_by()</td><td>根据指定条件对原查询结果进行排序，返回一个新查询</td></tr><tr><td>group_by()</td><td>根据指定条件对原查询结果进行分组，返回一个新查询</td></tr></tbody></table><h3 id="2-7-3- 查询执行器"><a href="#2-7-3- 查询执行器" class="headerlink" title="2.7.3 查询执行器"></a>2.7.3 查询执行器</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>all()</td><td>以列表形式返回查询的所有结果</td></tr><tr><td>first()</td><td>返回查询的第一个结果，如果未查到，返回 None</td></tr><tr><td>first_or_404()</td><td>返回查询的第一个结果，如果未查到，返回 404</td></tr><tr><td>get()</td><td>返回指定主键对应的行，如不存在，返回 None</td></tr><tr><td>get_or_404()</td><td>返回指定主键对应的行，如不存在，返回 404</td></tr><tr><td>count()</td><td>返回查询结果的数量</td></tr><tr><td>paginate()</td><td>返回一个 Paginate 对象，它包含指定范围内的结果</td></tr></tbody></table><h2 id="2-8- 高级查询"><a href="#2-8- 高级查询" class="headerlink" title="2.8 高级查询"></a>2.8 高级查询 </h2><p> 下面介绍 SQLAlchemy 的排序、设置查询数量、联结查询等操作。</p><h3 id="2-8-1- 排序"><a href="#2-8-1- 排序" class="headerlink" title="2.8.1 排序"></a>2.8.1 排序</h3><pre><code class="python"># 查询全部 User 实例，按实例的 email 值排序In [27]: session.query(User).order_by(User.email).all()Out[27]:[&lt;User: 汪林 &gt;, &lt;User: 刘文 &gt;, &lt;User: 段欣 &gt;, &lt;User: 夏晶 &gt;, &lt;User: 梁龙 &gt;, &lt;User: 王雷 &gt;, &lt;User: 李博 &gt;, &lt;User: 宁兵 &gt;, &lt;User: 蒋桂珍 &gt;, &lt;User: 朱华 &gt;]In [28]: for user in session.query(User).order_by(User.email).all():    ...:     print(user.email)    ...:caoli@gmail.comfang72@gmail.comheyang@gmail.comminzhao@meng.cnna55@zhouwan.cnpingmao@gmail.comxiaping@hotmail.comxiuying77@hotmail.comyang59@hotmail.comytao@gmail.com# desc 方法进行降序排序，默认为升序In [29]: session.query(User).order_by(User.email.desc()).all()Out[29]:[&lt;User: 朱华 &gt;, &lt;User: 蒋桂珍 &gt;, &lt;User: 宁兵 &gt;, &lt;User: 李博 &gt;, &lt;User: 王雷 &gt;, &lt;User: 梁龙 &gt;, &lt;User: 夏晶 &gt;, &lt;User: 段欣 &gt;, &lt;User: 刘文 &gt;, &lt;User: 汪林 &gt;]</code></pre><p>等同于 MySQL 中的 ORDER BY 语句：</p><pre><code class="sql">mysql&gt; SELECT * FROM user ORDER BY email;+----+-----------+-----------------------+| id | name      | email                 |+----+-----------+-----------------------+|  3 | 汪林      | caoli@gmail.com       || 10 | 刘文      | fang72@gmail.com      ||  9 | 段欣      | heyang@gmail.com      ||  4 | 夏晶      | minzhao@meng.cn       ||  7 | 梁龙      | na55@zhouwan.cn       ||  1 | 王雷      | pingmao@gmail.com     ||  8 | 李博      | xiaping@hotmail.com   ||  6 | 宁兵      | xiuying77@hotmail.com ||  5 | 蒋桂珍    | yang59@hotmail.com    ||  2 | 朱华      | ytao@gmail.com        |+----+-----------+-----------------------+10 rows in set (0.01 sec)mysql&gt; SELECT email FROM user ORDER BY email;+-----------------------+| email                 |+-----------------------+| caoli@gmail.com       || fang72@gmail.com      || heyang@gmail.com      || minzhao@meng.cn       || na55@zhouwan.cn       || pingmao@gmail.com     || xiaping@hotmail.com   || xiuying77@hotmail.com || yang59@hotmail.com    || ytao@gmail.com        |+-----------------------+10 rows in set (0.00 sec)mysql&gt; SELECT * FROM user ORDER BY email DESC;+----+-----------+-----------------------+| id | name      | email                 |+----+-----------+-----------------------+|  2 | 朱华      | ytao@gmail.com        ||  5 | 蒋桂珍    | yang59@hotmail.com    ||  6 | 宁兵      | xiuying77@hotmail.com ||  8 | 李博      | xiaping@hotmail.com   ||  1 | 王雷      | pingmao@gmail.com     ||  7 | 梁龙      | na55@zhouwan.cn       ||  4 | 夏晶      | minzhao@meng.cn       ||  9 | 段欣      | heyang@gmail.com      || 10 | 刘文      | fang72@gmail.com      ||  3 | 汪林      | caoli@gmail.com       |+----+-----------+-----------------------+10 rows in set (0.00 sec)</code></pre><h3 id="2-8-2- 设置查询数量"><a href="#2-8-2- 设置查询数量" class="headerlink" title="2.8.2 设置查询数量"></a>2.8.2 设置查询数量 </h3><p> 使用 limit 方法限制查询数量：</p><pre><code class="python"># 按 id 字段降序排序，取前 4 条数据In [30]: session.query(User).order_by(User.id.desc()).limit(4).all()Out[30]: [&lt;User: 刘文 &gt;, &lt;User: 段欣 &gt;, &lt;User: 李博 &gt;, &lt;User: 梁龙 &gt;]# 因为查询结果为有序可迭代对象，所以使用列表的切片也是可以的# 但 limit 方法更可取，因为后者只查询前 4 条数据，对内存的压力要小很多In [31]: session.query(User).order_by(User.id.desc()).all()[:4]Out[31]: [&lt;User: 刘文 &gt;, &lt;User: 段欣 &gt;, &lt;User: 李博 &gt;, &lt;User: 梁龙 &gt;]</code></pre><p>对应的 MySQL 语句如下：</p><pre><code class="mysql">mysql&gt; SELECT * FROM user ORDER BY id DESC LIMIT 4;+----+--------+---------------------+| id | name   | email               |+----+--------+---------------------+| 10 | 刘文   | fang72@gmail.com    ||  9 | 段欣   | heyang@gmail.com    ||  8 | 李博   | xiaping@hotmail.com ||  7 | 梁龙   | na55@zhouwan.cn     |+----+--------+---------------------+4 rows in set (0.00 sec)</code></pre><p>count 方法统计查询数量：</p><pre><code class="python">In [33]: session.query(User).filter(User.email.like(&#39;%gmail%&#39;)).all()Out[33]: [&lt;User: 王雷 &gt;, &lt;User: 朱华 &gt;, &lt;User: 汪林 &gt;, &lt;User: 段欣 &gt;, &lt;User: 刘文 &gt;]# 注意结尾没有 .all() 了In [34]: session.query(User).filter(User.email.like(&#39;%gmail%&#39;)).count()Out[34]: 5</code></pre><p>对应的 MySQL 语句：</p><pre><code class="mysql">mysql&gt; SELECT COUNT(*) AS COUNT FROM user WHERE email LIKE &#39;%gmail%&#39;;+-------+| COUNT |+-------+|     5 |+-------+1 row in set (0.00 sec)</code></pre><h3 id="2-8-3- 联结查询"><a href="#2-8-3- 联结查询" class="headerlink" title="2.8.3 联结查询"></a>2.8.3 联结查询 </h3><p> 使用 join 方法进行联结查询：</p><pre><code class="python"># 查询王雷老师的全部课程，即查询 course 表中的数据# 条件是 name 值为 &#39; 王雷 &#39; 的 user 表外键关联的 course 表中的数据In [26]: session.query(Course).join(User).filter(User.name==&#39; 王雷 &#39;).all()Out[26]: [&lt;Course: 不能产品如何经营 &gt;, &lt;Course: 责任标题表示女人 &gt;]</code></pre><p>等同于 MySQL 中的 JOIN 语句：</p><pre><code class="mysql">mysql&gt; SELECT course.id, course.name, user_id FROM course    -&gt; JOIN user ON user.id = course.user_id     -&gt; WHERE user.name = &#39; 王雷 &#39;;   +----+--------------------------+---------+| id | name                     | user_id |+----+--------------------------+---------+|  1 | 不能产品如何经营            |       1 ||  2 | 责任标题表示女人            |       1 |+----+--------------------------+---------+2 rows in set (0.00 sec)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pymysql-ORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql 数据库</title>
      <link href="/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><code>MySQL</code> 是一个 DBMS（数据库管理系统），由瑞典 MySQLAB 公司开发，目前属于 Oracle (甲骨文)公司，是最流行的关系型数据库管理系统（关系数据库，是建立在关系数据库模型基础上的数据库，借助于集合代数等概念和方法来处理数据库中的数据）。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发者都选择 <code>MySQL</code> 作为网站数据库。<code>MySQL</code> 使用 <code>SQL</code> 语言进行操作。</p><p>菜鸟教程：<a href="https://www.runoob.com/mysql/mysql-administration.html">https://www.runoob.com/mysql/mysql-administration.html</a></p><p><strong>概念对比</strong></p><ul><li>DB：数据库，存放数据的容器</li><li>DBMS：数据库管理系统，用于管理 DB</li><li>SQL：结构化查询语言，是关系型数据库的通用语言</li></ul><p><strong>RDBMS 术语</strong></p><p>在我们开始学习 MySQL 数据库前，让我们先了解下 RDBMS 的一些术语：</p><ul><li><strong>数据库:</strong> 数据库是一些关联表的集合。</li><li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li><li><strong>列:</strong> 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。</li><li><strong>行：</strong>一行（= 元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li></ul><h1 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装 </h1><h2 id="1-1-Windows 系统"><a href="#1-1-Windows 系统" class="headerlink" title="1.1 Windows 系统"></a>1.1 Windows 系统</h2><h3 id="1-1-1- 下载"><a href="#1-1-1- 下载" class="headerlink" title="1.1.1 下载"></a>1.1.1 下载</h3><p> 安装包下载地址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>注意选择 size 大点的下载。</p><h3 id="1-1-2- 安装"><a href="#1-1-2- 安装" class="headerlink" title="1.1.2 安装"></a>1.1.2 安装 </h3><p><strong> 建议自定义安装，如下：</strong><br><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_11-32-45.png" style="zoom: 67%;" /></p><p><strong>选择模块：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_11-40-02.png" style="zoom:80%;" /><p><strong>自定义安装路径：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_11-41-05.png"  style="zoom:80%;" /><p><strong>接下来一直 next 就行。</strong></p><h3 id="1-1-3- 配置环境变量"><a href="#1-1-3- 配置环境变量" class="headerlink" title="1.1.3 配置环境变量"></a>1.1.3 配置环境变量 </h3><p> 为了避免每次需要在 CMD 命令行下，需 CD 到 Mysql 安装目录下才能启动 Mysql，可以提前配置好环境变量，这样就可以不用进入其安装目录也能执行启动命令。</p><p><strong>找到环境变量设置入口：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_11-48-00.png" style="zoom:80%;" /><p><strong>将 Mysql 安装路径加入到环境变量中：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_11-49-50.png" style="zoom:80%;" /><h2 id="1-2-Ubuntu 系统"><a href="#1-2-Ubuntu 系统" class="headerlink" title="1.2 Ubuntu 系统"></a>1.2 Ubuntu 系统 </h2><h3 id="1-2-1- 安装及配置"><a href="#1-2-1- 安装及配置" class="headerlink" title="1.2.1 安装及配置"></a>1.2.1 安装及配置</h3><p> 首先依次执行：</p><pre><code>sudo apt-get install mysql-serversudo apt install mysql-clientsudo apt install libmysqlclient-dev</code></pre><p>安装成功后可以通过下面的命令测试是否安装成功：</p><pre><code>sudo netstat -tap | grep mysql#出现……localhost:mysql……等信息说明成功 </code></pre><p> 进入 mysql：</p><pre><code>sudo mysql</code></pre><p>退出：</p><pre><code class="mysql">mysql&gt;quit</code></pre><p>设置 mysql 允许远程访问，首先编辑文件 /etc/mysql/mysql.conf.d/mysqld.cnf</p><pre><code>sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p> 注释掉 bind-address = 127.0.0.1，保存退出。</p><p>然后进入 mysql 服务，执行授权命令：</p><pre><code class="mysql">mysql&gt;grant all on *.* to root@&#39;%&#39; identified by &#39; 你的密码 &#39; with grant option;mysql&gt;flush privileges;</code></pre><p>然后执行 quit 命令退出 mysql 服务，执行如下命令重启 mysql：</p><pre><code>sudo service mysql restart</code></pre><p>现在在 windows 下可以使用 navicat 远程连接 ubuntu 下的 mysql 服务。</p><p>navicat 连接 mysql 数据库：在 general 界面输入数据库相关信息，在 SSH 界面输入 linux 系统登陆信息。</p><p><strong>默认 mysql 相关文件位置：</strong></p><pre><code class="php">/var/lib/mysql           日志文件，数据库  ［重点要知道这个］/usr/bin                 客户端程序和脚本  /usr/sbin                mysqld 服务器/usr/share/doc/packages  文档  /usr/include/mysql       包含(头) 文件  /usr/lib/mysql           库  /usr/share/mysql         错误消息和字符集文件  /usr/share/sql-bench     基准程序  </code></pre><h3 id="1-2-2- 问题修复"><a href="#1-2-2- 问题修复" class="headerlink" title="1.2.2 问题修复"></a>1.2.2 问题修复 </h3><p> 发现采用 1.3 章节设置密码后，不输入密码依然能进数据库，如：</p><pre><code>sudo mysqlmysql&gt;</code></pre><p>修复方法如下：</p><pre><code class="mysql"># 进入 mysqlsudo mysql#依次输入以下命令：mysql&gt;update user set authentication_string=PASSWORD(&quot; 密码 &quot;) where user=&#39;root&#39;;mysql&gt;update user set plugin=&quot;mysql_native_password&quot;;mysql&gt;flush privileges;mysql&gt;quit;sudo service mysql restart</code></pre><h2 id="1-3- 修改数据库密码"><a href="#1-3- 修改数据库密码" class="headerlink" title="1.3 修改数据库密码"></a>1.3 修改数据库密码</h2><pre><code class="sql">mysql&gt; set password for root@localhost = password(&#39;123&#39;); </code></pre><h1 id="2、增删改"><a href="#2、增删改" class="headerlink" title="2、增删改"></a>2、增删改 </h1><h2 id="2-1- 基本操作"><a href="#2-1- 基本操作" class="headerlink" title="2.1 基本操作"></a>2.1 基本操作</h2><h3 id="2-1-1-CMD 命令行下"><a href="#2-1-1-CMD 命令行下" class="headerlink" title="2.1.1 CMD 命令行下"></a>2.1.1 CMD 命令行下</h3><p><strong> 启动 mysql：</strong></p><pre><code class="python">mysql -uroot -p   // 启动时会提示输入密码</code></pre><p>由于已经配置了环境变量，直接输入上述命令即可。如没有配置，需要 cd 到其安装目录才能执行启动命令。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_11-54-52.png" style="zoom:80%;" /><p><strong>查看已有数据库：</strong></p><pre><code> show databases;</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_12-02-39.png" alt=""></p><p><strong>创建，使用及退出：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_12-04-58.png" alt=""></p><p>注意这里的 quit 并没有真正退出，后台还有 mysql 服务存在。</p><h3 id="2-1-2- 连接 Pycharm"><a href="#2-1-2- 连接 Pycharm" class="headerlink" title="2.1.2 连接 Pycharm"></a>2.1.2 连接 Pycharm</h3><p>首先要求 Pycharm 使用的是专业版，社区版是没有的数据库功能的。</p><p>启动数据库（保证 Mysql 服务在后台运行，在任务管理器中查看）。</p><p><strong>打开连接界面：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_12-17-06.png" alt=""></p><p><strong>进行连接：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_12-21-17.png" alt=""></p><p><strong>测试连接时，如出现错误 Server returns invalid timezone……</strong></p><p>应该是时区没设置对</p><pre><code>show variables like &#39;%time_zone%&#39;;</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_12-25-06.png" alt=""></p><p>这里的 SYSTEM 默认时的美国时间。</p><p><strong>解决办法：</strong></p><p>①</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_12-27-20.png" style="zoom:80%;" /><p>②在 mysql 的命令模式下，CMD 下输入：</p><pre><code>mysql&gt;  set global time_zone=&#39;+8:00&#39;;</code></pre><p><strong>设置完成之后，就可以进行愉快的玩耍了！</strong></p><p>尝试使用命令：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_13-38-54.png" alt="Snipaste_2020-03-05_13-38-54"></p><h2 id="2-2- 基础知识"><a href="#2-2- 基础知识" class="headerlink" title="2.2 基础知识"></a>2.2 基础知识 </h2><p> 在 pycharm 里操作数据库。</p><h3 id="2-2-1- 创建与删除"><a href="#2-2-1- 创建与删除" class="headerlink" title="2.2.1 创建与删除"></a>2.2.1 创建与删除 </h3><p><strong> 创建与删除数据库</strong></p><pre><code class="python">show databases;                                // 显示数据库create database python character set utf8;     // 创建数据库, 指定字符集，避免中文无法识别drop database 库名;                            // 删除数据库ALTER DATABASE 库名 CHARACTER SET gbk;        // 更改库的字符集</code></pre><p>创建数据库，还可以这样：</p><pre><code>create database if not exists 库名     // 不存在才创建 </code></pre><p><strong> 创建数据表</strong></p><p>只有创建了数据表才能进行数据操作。</p><pre><code class="sql">use python;                            // 指定要操作的数据库create table maoyan(moive_name varchar(50) primary key,    moive_data varchar(50),    score varchar(10)) character set utf8;            //varchar(50)指定字符串最大长度desc maoyan;     // 查看表结构</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_14-13-14.png" alt=""></p><p><strong>删除数据表</strong></p><pre><code>drop table if exists 表名;     </code></pre><p><strong>修改数据表</strong></p><pre><code>alter table maoyan modify column score char(3);</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_14-24-26.png" alt=""></p><p><strong>增加新字段</strong></p><pre><code>alter table maoyan add column star varchar(50);</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-05_14-27-47.png" alt=""></p><p><strong>删除字段</strong></p><pre><code>alter table maoyan drop column star;</code></pre><p><strong>修改表名</strong></p><pre><code>alter table maoyan rename to 新表名 ;</code></pre><h3 id="2-2-2- 数据类型"><a href="#2-2-2- 数据类型" class="headerlink" title="2.2.2 数据类型"></a>2.2.2 数据类型</h3><table><thead><tr><th>数据类型</th><th>大小(字节)</th><th>用途</th><th>格式</th></tr></thead><tbody><tr><td>INT</td><td>4</td><td>整数</td><td></td></tr><tr><td>FLOAT</td><td>4</td><td>单精度浮点数</td><td></td></tr><tr><td>DOUBLE</td><td>8</td><td>双精度浮点数</td><td></td></tr><tr><td>ENUM</td><td>–</td><td>单选, 比如性别</td><td>ENUM(‘a’,’b’,’c’)</td></tr><tr><td>SET</td><td>–</td><td>多选</td><td>SET(‘1’,’2’,’3’)</td></tr><tr><td>DATE</td><td>3</td><td>日期</td><td>YYYY-MM-DD</td></tr><tr><td>TIME</td><td>3</td><td>时间点或持续时间</td><td>HH:MM:SS</td></tr><tr><td>YEAR</td><td>1</td><td>年份值</td><td>YYYY</td></tr><tr><td>CHAR</td><td>0~255</td><td>定长字符串</td><td></td></tr><tr><td>VARCHAR</td><td>0~255</td><td>变长字符串</td><td></td></tr><tr><td>TEXT</td><td>0~65535</td><td>长文本数据</td><td></td></tr></tbody></table><p>整数除了 INT 外，还有 <code>TINYINT</code>、<code>SMALLINT</code>、<code>MEDIUMINT</code>、<code>BIGINT</code>。</p><h4 id="数值"><a href="# 数值" class="headerlink" title="数值"></a>数值</h4><ul><li><p>整数</p><ul><li><p>分类</p><ul><li>Tinyint，1 个字节</li><li>Smallint，2 个字节</li><li>Mediumint，3 个字节</li><li>Int，4 个字节</li><li>Bigint，8 个字节</li></ul></li><li><p>符号</p><ul><li>默认有符号</li><li>设置无符号的方法，使用 UNSIGNED 关键字</li></ul><pre><code class="sql">CREATE TABLE t (    t1 INT,    t2 INT UNSIGNED);</code></pre></li><li><p>长度</p><ul><li>长度表示最大显示宽度，当使用 zerofill 时，不够长度时，用 0 填空</li><li>如果不配合 zerofill，则整型的长度没用</li></ul></li><li><p>越界</p><ul><li>如果插入的数值超出范围，则报 out of range 异常，并插入最接近的临界值</li></ul></li></ul></li><li><p>浮点数</p><ul><li>Float，4 个字节</li><li>Double，8 个字节</li></ul></li><li><p>定点数</p><ul><li>DECIMAL(M,D)<ul><li>M：整数 + 小数的位数</li><li>D：小数的位数</li><li>M 默认为 10, D 默认为 0</li></ul></li></ul></li></ul><h4 id="字符型"><a href="# 字符型" class="headerlink" title="字符型"></a>字符型</h4><ul><li>较短文本<ul><li>char：固定长度，性能高，不能节约空间</li><li>varchar：可变长度，性能低，能节约空间</li><li>长度为最大长度</li></ul></li><li>较长文本<ul><li>text</li></ul></li><li>二进制<ul><li>binary：类似 char，存储的是二进制</li><li>varbinary：类似 varchar，存储的是二进制</li><li>Blob：存储数据量大的二进制，比如视频，图片</li></ul></li></ul><h4 id="日期型"><a href="# 日期型" class="headerlink" title="日期型"></a>日期型</h4><ul><li>date：2018-09-26</li><li>time：17:11:37</li><li>year：2018</li><li>datetime：2018-09-26 17:11:50，与时区无关，8 个字节</li><li>timestamp：20180926171211，受 MySQL 版本影响，与时区有关，4 个字节</li></ul><h3 id="2-2-3- 字符长度"><a href="#2-2-3- 字符长度" class="headerlink" title="2.2.3 字符长度"></a>2.2.3 字符长度 </h3><p> 一个汉字占多少长度与编码有关：</p><p>UTF-8：一个汉字＝3 个字节</p><p>GBK：一个汉字＝2 个字节</p><p>在 MySQL 中 varchar(n)和 char(n)表示 n 个字符，无论汉字和英文，Mysql 都能存入 n 个字符，仅是实际字节长度有所区别。</p><p>即 MySQL 并不会对超过长度的字符报错, 而是直接截断了。并且 char(2) 和 varchar(2) 都能存储 2 个汉字, 或者是两个英文字符。</p><h2 id="2-3- 不懂就查"><a href="#2-3- 不懂就查" class="headerlink" title="2.3 不懂就查"></a>2.3 不懂就查 </h2><h3 id="表的修改"><a href="# 表的修改" class="headerlink" title="表的修改"></a> 表的修改 </h3><h4 id="重命名一张表"><a href="# 重命名一张表" class="headerlink" title="重命名一张表"></a> 重命名一张表 </h4><p> 重命名一张表的语句有多种形式，以下 3 种格式效果是一样的：</p><pre><code>rename table 原名 to 新名字;alter table 原名 rename 新名;alter table 原名 rename to 新名;</code></pre><p>进入数据库 python：</p><pre><code>use python</code></pre><p>使用命令尝试修改 <code>table_1</code> 的名字为 <code>table_2</code> ：</p><pre><code>rename table table_1 to table_2;</code></pre><h4 id="删除一张表"><a href="# 删除一张表" class="headerlink" title="删除一张表"></a>删除一张表 </h4><p> 删除一张表的语句，类似于刚才用过的删除数据库的语句，格式是这样的：</p><pre><code>drop table 表名字;</code></pre><p>比如我们把 <code>table_2</code> 表删除：</p><pre><code>drop table table_2;</code></pre><h3 id="列的修改"><a href="# 列的修改" class="headerlink" title="列的修改"></a>列的修改</h3><blockquote><p>即对表结构的修改</p></blockquote><p>对表结构的修改，有时候一些小的错误会造成不可挽回的后果，所以请细心操作。另外需要注意，<strong>非必要情况不要修改表结构。</strong></p><h4 id="增加一列"><a href="# 增加一列" class="headerlink" title="增加一列"></a>增加一列 </h4><p> 在表中增加一列的语句格式为：</p><pre><code>alter table 表名字 add column 列名字 数据类型 约束;或：alter table 表名字 add 列名字 数据类型 约束;</code></pre><p>现在 employee 表中有 <code>id、name、age、salary、phone、in_dpt</code> 这 6 个列，我们尝试加入 <code>height</code> (身高)一个列并指定 DEFAULT 约束：</p><pre><code class="sql">alter table employee add height INT(4) default 170;</code></pre><p>新增加的列，被默认放置在这张表的最右边。如果要把增加的列插入在指定位置，则需要在语句的最后使用 AFTER 关键词(<strong>“AFTER 列 1” 表示新增的列被放置在 “列 1” 的后面</strong>)。</p><blockquote><p>提醒：语句中的 INT(4) 不是表示整数的字节数，而是表示该值的显示宽度，如果设置填充字符为 0，则 170 显示为 0170</p></blockquote><p>比如我们新增一列 <code>weight</code>(体重) 放置在 <code>age</code>(年龄) 的后面：</p><pre><code class="python">alter table employee add weight INT(4) default 120 after age;</code></pre><p>上面的效果是把新增的列加在某位置的后面，如果想放在第一列的位置，则使用 <code>FIRST</code>关键词，如语句：</p><pre><code>alter table employee add test INT(10) default 11 FIRST;</code></pre><h4 id="删除一列"><a href="# 删除一列" class="headerlink" title="删除一列"></a>删除一列 </h4><p> 删除表中的一列和刚才使用的新增一列的语句格式十分相似，只是把关键词 <code>ADD</code> 改为 <code>DROP</code> ，语句后面不需要有数据类型、约束或位置信息。具体语句格式：</p><pre><code>alter table 表名字 drop column 列名字;或： alter table 表名字 drop 列名字;</code></pre><p>我们把刚才新增的 <code>test</code> 删除：</p><pre><code>alter table employee drop test;</code></pre><h4 id="重命名一列"><a href="# 重命名一列" class="headerlink" title="重命名一列"></a>重命名一列 </h4><p> 这条语句其实不只可用于重命名一列，准确地说，它是对一个列做修改(CHANGE) ：</p><pre><code>alter table 表名字 change 原列名 新列名 数据类型 约束;</code></pre><blockquote><p><strong>注意：这条重命名语句后面的 “数据类型” 不能省略，否则重命名失败。</strong></p></blockquote><p>当 <strong> 原列名 </strong> 和<strong>新列名 </strong> 相同的时候，指定新的 <strong> 数据类型 </strong> 或<strong>约束</strong>，就可以用于修改数据类型或约束。需要注意的是，修改数据类型可能会导致数据丢失，所以要慎重使用。</p><p>我们用这条语句将 “height” 一列重命名为汉语拼音 “shengao” ，效果如下：</p><pre><code>alter table employee change height shengao INT(4) default 170;</code></pre><h4 id="改变数据类型"><a href="# 改变数据类型" class="headerlink" title="改变数据类型"></a>改变数据类型 </h4><p> 要修改一列的数据类型，除了使用刚才的 <strong>CHANGE</strong> 语句外，还可以用这样的 <strong>MODIFY</strong>语句：</p><pre><code>alter table 表名字 modify 列名字 新数据类型;</code></pre><p>再次提醒，修改数据类型必须小心，因为这可能会导致数据丢失。在尝试修改数据类型之前，请慎重考虑。</p><h3 id="内容修改"><a href="# 内容修改" class="headerlink" title="内容修改"></a>内容修改 </h3><h4 id="修改表中某个值"><a href="# 修改表中某个值" class="headerlink" title="修改表中某个值"></a> 修改表中某个值 </h4><p> 大多数时候我们需要做修改的不会是整个数据库或整张表，而是表中的某一个或几个数据，这就需要我们用下面这条命令达到精确的修改：</p><pre><code>update 表名字 set 列 1 = 值 1, 列 2= 值 2 where 条件;</code></pre><p>比如，我们要把 Tom 的 age 改为 21，salary 改为 3000：</p><pre><code>update employee set age=21,salary=3000 where name=&#39;Tom&#39;;</code></pre><blockquote><p><strong>注意：一定要有 WHERE 条件，否则会出现你不想看到的后果</strong></p></blockquote><h4 id="删除一行记录"><a href="# 删除一行记录" class="headerlink" title="删除一行记录"></a>删除一行记录 </h4><p> 删除表中的一行数据，也必须加上 WHERE 条件，否则整列的数据都会被删除。删除语句：</p><pre><code>delete from 表名字 where 条件;</code></pre><p>我们尝试把 Tom 的数据删除：</p><pre><code>delete from employee where name=&#39;Tom&#39;;</code></pre><h1 id="3、插入数据"><a href="#3、插入数据" class="headerlink" title="3、插入数据"></a>3、插入数据</h1><h2 id="3-1- 插入"><a href="#3-1- 插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h2><blockquote><p>insert into</p></blockquote><ul><li><p>语法 1 - 【常用；支持多行；可用于子查询】</p><pre><code class="sql">insert into 表名(字段 1, 字段 2, 字段 3……) values(字值 1, 字值 2, 字值 3……);</code></pre></li><li><p>注意</p><ul><li>如果想设置空值，可以用 NULL 表示</li><li>字段列表和字段值列表必须一一对应</li><li>需要自己指定 id</li><li>若字值数是完整，可以省略字段</li></ul></li><li><p>语法 2 - 【不常用；不支持多行；不可用于子查询】</p><pre><code class="sql">insert into 表名 set 字段名 = 值, 字段名 = 值,...;</code></pre></li></ul><p><strong>注意：当插入字符有中文时，需要在创建表时设置<code>character set utf8</code></strong></p><p><strong>如创建表时，指定了约束 <code>auto_increment</code>就可以不用指定 id。</strong></p><blockquote><p>replace into  数据替换更新，与 insert into 写法相同</p></blockquote><h2 id="3-2- 更新"><a href="#3-2- 更新" class="headerlink" title="3.2 更新"></a>3.2 更新</h2><blockquote><p>udate</p></blockquote><ul><li><p>语法 1 - 【单表更新】</p><pre><code class="sql">udate 表名 set 字段名 = 值, 字段名 = 值 where 筛选条件;</code></pre></li><li><p>语法 2 - 【多表更新】</p><pre><code class="sql">udate 表 1 as 别名inner | left | right join 表 2 as 别名on 连接条件set 字段名 = 值where 筛选条件;</code></pre></li><li><p>例子</p><pre><code class="sql">udate boys as binner join girls as gon b.id = g.idset g.phone = 1111where b.name = &quot; 小明 &quot;;</code></pre></li></ul><h2 id="3-3- 删除"><a href="#3-3- 删除" class="headerlink" title="3.3 删除"></a>3.3 删除</h2><blockquote><p>delete from</p></blockquote><ul><li><p>语法 1 - 【单表删除】</p><pre><code class="sql">delete from 表名 where 筛选条件;</code></pre></li><li><p>语法 2 - 【多表删除】</p><pre><code class="sql">delete from 表 1 as 别名inner | left | right join 表 2 as 别名on 连接条件where 筛选条件;</code></pre></li><li><p>例子</p><pre><code class="sql">delete from girls  as ginner join boys as bon b.id = g.idwhere b.name=&quot; 小明 &quot;;</code></pre></li></ul><h2 id="3-4- 清空"><a href="#3-4- 清空" class="headerlink" title="3.4 清空"></a>3.4 清空</h2><blockquote><p> truncate table</p></blockquote><ul><li><p>语法</p><pre><code class="sql">truncate table boys;</code></pre></li><li><p>注意事项</p><ul><li>delete from 是删除表中某些行数据， truncate table 是清空整张表</li><li>delete from 删除后，自增字段不重置； truncate table 清空后，自增字段重置为 1</li><li>delete from 可以回滚， truncate table 不能回滚</li></ul></li></ul><p>刚才我们新建了两张表，使用语句 <code>SELECT * FROM employee;</code> 查看表中的内容，可以看到 employee 表中现在还是空的：</p><pre><code>mysql&gt; SELECT * FROM employee;Empty set (0.00 sec)</code></pre><p>我们通过 INSERT 语句向表中插入数据，语句格式为：</p><pre><code>insert into 表的名字 (列名 a, 列名 b, 列名 c) values(值 1, 值 2, 值 3);</code></pre><p> 我们尝试向 employee 中加入 Tom、Jack 和 Rose：</p><pre><code>insert into employee(id,name,phone) values(01,&#39;Tom&#39;,110110110);insert into employee values(02,&#39;Jack&#39;,119119119);insert into employee(id,name) values(03,&#39;Rose&#39;);</code></pre><p>你已经注意到了，有的数据需要用单引号括起来，比如 Tom、Jack、Rose 的名字，这是由于它们的数据类型是 CHAR 型。此外 <strong>VARCHAR,TEXT,DATE,TIME,ENUM</strong> 等类型的数据也需要单引号修饰，而 <strong>INT,FLOAT,DOUBLE</strong> 等则不需要。</p><p>第一条语句比第二条语句多了一部分：<code>(id,name,phone)</code> 这个括号里列出的，是将要添加的数据 <code>(01,&#39;Tom&#39;,110110110)</code> 其中每个值在表中对应的列。而第三条语句只添加了 <code>(id,name)</code> 两列的数据，<strong>所以在表中 Rose 的 phone 为 NULL</strong>。</p><p>现在我们再次使用语句 <code>SELECT * FROM employee;</code> 查看 employee 表，可见 Tom 和 Jack 的相关数据已经保存在其中了：</p><pre><code>mysql&gt; SELECT * FROM employee;+------+------+-----------+| id   | name | phone     |+------+------+-----------+|    1 | Tom  | 110110110 ||    2 | Jack | 119119119 ||    3 | Rose |      NULL |+------+------+-----------+3 rows in set (0.00 sec)</code></pre><h1 id="4、- 查询"><a href="#4、- 查询" class="headerlink" title="4、 查询"></a>4、 查询</h1><blockquote><p>Data Query Language[DQL]</p></blockquote><p>SQL 中最常用的 SELECT 语句，用来在表中选取数据，本节实验中将通过一系列的动手操作详细学习 SELECT 语句的用法。</p><p><strong>练习用数据库导入</strong></p><ul><li>下载相关资源中的 <code>select.sql</code></li><li>执行 sql 脚本</li></ul><pre><code class="sql">source myemployees.sql;</code></pre><h2 id="4-1- 基础查询"><a href="#4-1- 基础查询" class="headerlink" title="4.1 基础查询"></a>4.1 基础查询</h2><h3 id="SELECT 子句"><a href="#SELECT 子句" class="headerlink" title="SELECT 子句"></a>SELECT 子句</h3><pre><code class="sql">select 查询字段 from 表名;-- 查询字段包括：表的字段，常量值，表达式，函数-- 查询的结果是一个虚拟的表</code></pre><ul><li><p>查询表中单个字段</p><pre><code class="sql">select name from employees;</code></pre></li><li><p>查询表中多个字段</p><pre><code class="sql">select name, salary, age from employees;</code></pre></li><li><p>查询表中所有字段</p><pre><code class="sql">select * from employees;</code></pre></li></ul><h3 id="字段起别名"><a href="# 字段起别名" class="headerlink" title="字段起别名"></a>字段起别名 </h3><pre><code class="sql"> 方式一：select name as 姓 from employees;方式二：select name 姓 from employees;特殊符号：select last_name as &quot;OUT#PUT&quot; from employees;</code></pre><h3 id="查询结果去重"><a href="# 查询结果去重" class="headerlink" title="查询结果去重"></a>查询结果去重</h3><pre><code class="sql">select distinct department_id from employees;</code></pre><h2 id="4-2- 条件查询"><a href="#4-2- 条件查询" class="headerlink" title="4.2 条件查询"></a>4.2 条件查询</h2><h3 id="WHERE 子句"><a href="#WHERE 子句" class="headerlink" title="WHERE 子句"></a>WHERE 子句</h3><pre><code class="sql">select 查询列表 from 表名 where 条件表达式;</code></pre><h3 id="比较运算符"><a href="# 比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><pre><code class="sql">&gt; &lt; &gt;= &lt;= = !=(&lt;&gt;) </code></pre><h3 id="逻辑运算符"><a href="# 逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><pre><code class="sql">&amp;&amp;      ||      !AND     OR     NOT</code></pre><p>例如：</p><pre><code class="sql">select * from maoyan where film_name =&#39; 龙猫 &#39;;</code></pre><p>结果如下（pycharm 环境下）<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-04-05_20-57-50.png" alt=""></p><h3 id="4-2-1- 模糊查询"><a href="#4-2-1- 模糊查询" class="headerlink" title="4.2.1 模糊查询"></a>4.2.1 模糊查询 </h3><h4 id="模糊查询关键字"><a href="# 模糊查询关键字" class="headerlink" title="模糊查询关键字"></a> 模糊查询关键字</h4><table><thead><tr><th>模糊查询语句</th><th>注意事项</th></tr></thead><tbody><tr><td>like</td><td>与通配符配合使用</td></tr><tr><td>between  x  and  y</td><td>包含边界，等价于 &gt;= x &amp;&amp; &lt;= y</td></tr><tr><td>in</td><td>IN (待选列表)，待选列表中的元素类型要相同</td></tr><tr><td>is null</td><td>不能用 = 判断是否是 NULL，只能用 IS 判断是否是 NULL，仅可以判断 NULL</td></tr></tbody></table><h4 id="通配符"><a href="# 通配符" class="headerlink" title="通配符"></a>通配符</h4><pre><code class="sql">% ：任意多个字符，包含 0 个_ ：任意 1 个字符</code></pre><h4 id="转义通配符"><a href="# 转义通配符" class="headerlink" title="转义通配符"></a>转义通配符</h4><pre><code class="sql">\_\%</code></pre><pre><code class="sql">select name,age,phonefrom employee where name like &#39; 张一 %&#39;;   // 找出表中 name 列中含有‘张三’的内容</code></pre><h2 id="4-3- 排序查询"><a href="#4-3- 排序查询" class="headerlink" title="4.3 排序查询"></a>4.3 排序查询</h2><h3 id="ORDER-BY 子句"><a href="#ORDER-BY 子句" class="headerlink" title="ORDER BY 子句"></a>ORDER BY 子句</h3><pre><code class="sql">select * FROM employeesorder by salary DESC; -- DESC：降序，ASC: 升序，默认为 ASC</code></pre><pre><code class="sql">// 举例：select * from maoyan order by scores;</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-04-05_22-39-48.png" alt=""></p><h3 id="多重排序标准"><a href="# 多重排序标准" class="headerlink" title="多重排序标准"></a>多重排序标准</h3><pre><code class="sql">-- 先按 salary 进行升序排序，保证满足前提条件的情况下，按 employee_id 进行降序排序select *from employeesorder by salary ASC, employee_id DESC;</code></pre><h2 id="4-4- 常用函数"><a href="#4-4- 常用函数" class="headerlink" title="4.4 常用函数"></a>4.4 常用函数 </h2><h3 id="字符函数"><a href="# 字符函数" class="headerlink" title="字符函数"></a> 字符函数</h3><ul><li>length</li></ul><pre><code class="sql">-- 求出字节的个数select length(last_name) from employees;</code></pre><ul><li>concat</li></ul><pre><code class="sql">select concat(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;) as &#39; 结果 &#39;;select concat(last_name, first_name) as name from employee;  // 合并</code></pre><ul><li>upper</li></ul><pre><code class="sql">select upper(last_name) from employees;</code></pre><ul><li>lower</li></ul><pre><code class="sql">select lower(last_name) from employees;</code></pre><ul><li>substr</li></ul><pre><code class="sql">select substr(&quot;123456789&quot;, 5)       // 56789 索引从 1 开始select substr(&quot;123456789&quot;, 5, 2)    // 567 从索引 5 开始，长度为 2</code></pre><ul><li>instr</li></ul><pre><code class="sql">select instr(&quot;123456789&quot;, &quot;567&quot;) // 返回第一次出现的索引 5select instr(&quot;123456789&quot;, &quot;xxx&quot;) // 找不到返回 0</code></pre><ul><li>trim</li></ul><pre><code class="sql">select trim(&quot;    xxx    &quot;) // 去除前后空格select trim(&quot;a&quot; from &quot;aaaaaaaaaaaaaxxxaaaxxxaaaaaaaaa&quot;) // 返回 &quot;xxxaaaxxx&quot;</code></pre><ul><li>lapd</li></ul><pre><code class="sql">select lpad(&quot;abc&quot;, 15, &quot;*&quot;) // &quot;***************abc&quot;select lpad(&quot;abc&quot;, 2, &quot;*&quot;) // &quot;ab&quot;</code></pre><ul><li>rpad</li></ul><pre><code class="sql">select rpad(&quot;abc&quot;, 15, &quot;*&quot;) // &quot;abc***************&quot;select rpad(&quot;abc&quot;, 2, &quot;*&quot;) // &quot;bc&quot;</code></pre><h3 id="数学函数"><a href="# 数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><ul><li>round</li></ul><pre><code class="sql">select round(4.56); // 5select round(-1.56) // -2select round(-1.567, 2) // -1.57 </code></pre><ul><li>cell</li></ul><pre><code class="sql">select cell(1.0001) // 2select cell(-1.02)  // -1select cell(1.00)   // 1</code></pre><ul><li>floor</li></ul><pre><code class="sql">select floor(1.0001) // 1select floor(-9.8)   //-10</code></pre><ul><li>truncate</li></ul><pre><code class="sql">select truncate(1.699999,1);  // 1.6</code></pre><h3 id="日期函数"><a href="# 日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><ul><li>NOW</li></ul><pre><code class="sql">select now();</code></pre><ul><li>CURDATE</li></ul><pre><code class="sql">select curdate();</code></pre><ul><li>CURTIME</li></ul><pre><code class="sql">select curtime();</code></pre><ul><li>YEAR</li></ul><pre><code class="sql">select year(now());select year(&quot;2018-9-14 08:23:57&quot;);</code></pre><blockquote><p>MONTH，DAY，HOUR，MINUTE，SECOND 同上</p></blockquote><ul><li>STR_TO_DATE</li></ul><pre><code class="sql">str_to date(&quot;9-13-1999&quot;, &quot;%m-%-%y&quot;)%y 18 %Y 2018%m 08 %c 8%d 08%H 24 小时制%h 12 小时制%i 35%s 05</code></pre><ul><li>DATE_FORMAT</li></ul><pre><code class="sql">date_format(&quot;2018/6/6&quot;,&quot;%Y 年 %m 月 %d 日 &quot;)</code></pre><h3 id="流程控制语句"><a href="# 流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><ul><li>IF<pre><code class="sql">select *, if(scores&lt;9,&#39; 低 &#39;,&#39; 高 &#39;) level from maoyan;</code></pre></li></ul><p>如下：新增了一列”level”</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-04-05_23-41-18.png" alt=""></p><pre><code class="sql">// 多层嵌套写法：select *,if(sex=0,&#39; 女 &#39;,if(sex=1,&#39; 男 &#39;,&#39; 保密 &#39;)) sex_l from user;</code></pre><ul><li>CASE</li></ul><pre><code class="sql">case (要判断的表达式，有就是 switch，否则是 if-else)when 常量 1 then 语句 1when 常量 2 then 语句 2...else 语句 xend// 如：select *,case when username=&#39;admin&#39; then &#39; 超级管理员 &#39; when email=&#39;root@qq.com&#39; then &#39; 系统管理员 &#39; when is_super = 2 then &#39; 测试管理员 &#39; when status =&#39;0 &#39;then &#39; 失效管理员 &#39;else &#39; 其它管理员 &#39; end &#39; 管理员类型 &#39; from db_admin_user </code></pre><h3 id="其他函数"><a href="# 其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><ul><li>IFNULL 函数</li></ul><pre><code class="sql">-- ifnull(exp1, exp2)-- exp1：将要进行判断的字段-- exp2：替换的字段-- 如果 exp1 为 NULL，则返回替换的字段select ifnull(commission_pct, 0) as &quot; 奖金率 &quot;, commission_pctfrom employees;</code></pre><h3 id="统计函数"><a href="# 统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><ul><li>SUM：忽略 NULL</li><li>AVG：忽略 NULL</li><li>MAX：忽略 NULL</li><li>MIN：忽略 NULL</li><li>COUNT：忽略 NULL</li><li>注意事项<ul><li>sum avg 可以处理数值</li><li>max，min，count 可以处理任何类型</li><li>分组函数都忽略 NULL</li><li>可以和 distinct 配合实现去重</li><li>COUNT(*) ：统计行数，只要有不含 NULL 的，都算一行</li><li>COUNT(1)：统计行数，只要有不含 NULL 的，都算一行 </li><li>和分组函数一同查询的字段要求是 group by 后的字段</li></ul></li></ul><pre><code class="sql">select sum(scores) as sum_scores from maoyan;</code></pre><h2 id="4-5- 分组查询"><a href="#4-5- 分组查询" class="headerlink" title="4.5 分组查询"></a>4.5 分组查询</h2><h3 id="GROUP-BY- 子句"><a href="#GROUP-BY- 子句" class="headerlink" title="GROUP BY 子句"></a>GROUP BY 子句</h3><pre><code class="sql">selectfromwheregroup by group by </code></pre><p>group by 强调的是一个整体，就是组，<strong>只能显示一个组里满足聚合函数的一条记录</strong>。 partition by 在整体后更强调个体，能显示组里所有个体的记录。</p><h3 id="HAVING-（过滤）子句"><a href="#HAVING-（过滤）子句" class="headerlink" title="HAVING （过滤）子句"></a>HAVING （过滤）子句</h3><pre><code class="sql">select *from maoyanwhere scores&gt;9group by made_countryhaving made_country=&#39;china&#39;order by  scores desc;</code></pre><h2 id="4-6- 连接查询"><a href="#4-6- 连接查询" class="headerlink" title="4.6 连接查询"></a>4.6 连接查询 </h2><h3 id="分类"><a href="# 分类" class="headerlink" title="分类"></a> 分类</h3><ul><li>内连接<ul><li>等值连接</li><li>非等值连接</li><li>自连接</li></ul></li><li>外连接<ul><li>左外连接</li><li>右外连接</li><li>全外连接</li></ul></li><li>交叉连接：就是笛卡尔积</li></ul><h3 id="语法"><a href="# 语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="sql">select 查询列表from 表 1 as 别名连接类型 表 2 as 别名on 连接条件wheregroup byhavingorder by连接类型内连接：inner join，可以省略 inner左外连接：left join右外连接：right join全外连接：full join交叉连接：cross join</code></pre><p><strong>例子</strong></p><pre><code class="sql">select last_name, department_namefrom employees as einner join department as don e.department_id = d.department_id;</code></pre><h2 id="4-7- 分页查询"><a href="#4-7- 分页查询" class="headerlink" title="4.7 分页查询"></a>4.7 分页查询</h2><h3 id="LIMIT 的使用"><a href="#LIMIT 的使用" class="headerlink" title="LIMIT 的使用"></a>LIMIT 的使用</h3><ul><li><p>放在全部 SQL 语句最后</p></li><li><p>LIMIT 开始索引，条目个数</p></li><li><p>如果开始索引是 0，则可以省略</p></li><li><p>例子</p></li></ul><h3 id="分页通用写法"><a href="# 分页通用写法" class="headerlink" title="分页通用写法"></a>分页通用写法</h3><pre><code class="sql">sleect 查询列表from 表limit (页码 -1) * 每页条目个数, 每页条目个数;</code></pre><h2 id="4-8- 联合查询"><a href="#4-8- 联合查询" class="headerlink" title="4.8 联合查询"></a>4.8 联合查询</h2><ul><li>将多条查询语句的结果集合并为一个结果集</li><li>关键字：UNION</li></ul><p><strong>例如</strong></p><pre><code class="sql">select * from employees where email like &#39;%a%&#39;unionselect * from employees where department_id &gt; 90;</code></pre><p><strong>注意事项</strong></p><ul><li>要求多条查询语句的查询结果列数相同</li><li>UNION 关键字默认去重，如果不想去重则 UNION ALL 可以包含重复项</li></ul><h1 id="5、- 数据约束"><a href="#5、- 数据约束" class="headerlink" title="5、 数据约束"></a>5、 数据约束</h1><blockquote><p> <code>constraint.sql</code> 文件中包含的代码可以新建一个数据库 <code>python</code>, 然后在其中创建三张表 <code>department</code>，<code>employee</code>，<code>project</code>，它们包含了各种约束。</p></blockquote><p>听名字就知道，约束是一种限制，它通过对表的行或列的数据做出限制，来确保表的数据的完整性、唯一性。</p><p>比如，规定一个用户的用户名不能为空值且没有重复的记录，这就是一种约束规则。</p><h2 id="5-1- 五大约束类型"><a href="#5-1- 五大约束类型" class="headerlink" title="5.1 五大约束类型"></a>5.1 五大约束类型 </h2><p> 在 MySQL 中，通常有这几种约束：</p><table><thead><tr><th>约束类型：</th><th>主键</th><th>默认值</th><th>唯一</th><th>外键</th><th>非空</th></tr></thead><tbody><tr><td>关键字：</td><td>primary key</td><td>default</td><td>unique</td><td>foreign key</td><td>not null</td></tr></tbody></table><h3 id="5-1-1- 主键约束"><a href="#5-1-1- 主键约束" class="headerlink" title="5.1.1 主键约束"></a>5.1.1 主键约束 </h3><p> 在数据库中，如果有两行记录数据完全一样，那么如何来区分呢？ 答案是无法区分，如果有两行记录完全相同，那么对于 <code>Mysql</code> 就会认定它们是同一个实体，这于现实生活是存在差别的。</p><p>假如我们要存储一个学生的信息，信息包含姓名，身高，性别，年龄。</p><p>不幸的是有两个女孩都叫小梦，且她们的身高和年龄相同，数据库将无法区分这两个实体，这时就需要用到主键了。</p><p>主键 (PRIMARY KEY)是用于约束表中的一行，作为这一行的唯一标识符，在一张表中通过主键就能准确定位到一行，因此主键十分重要，主键不能有重复记录且不能为空。</p><blockquote><p>还有一种特殊的主键——复合主键。主键不仅可以是表中的一列，也可以由表中的两列或多列来共同标识</p></blockquote><h3 id="5-1-2- 默认值约束"><a href="#5-1-2- 默认值约束" class="headerlink" title="5.1.2 默认值约束"></a>5.1.2 默认值约束 </h3><p> 默认值约束 (DEFAULT) 规定，当有 DEFAULT 约束的列，插入数据为空时，将使用默认值。</p><p>DEFAULT 约束只会在使用 INSERT 语句时体现出来， INSERT 语句中，如果被 DEFAULT 约束的位置没有值，那么这个位置将会被 DEFAULT 的值填充</p><h3 id="5-1-3- 唯一约束"><a href="#5-1-3- 唯一约束" class="headerlink" title="5.1.3 唯一约束"></a>5.1.3 唯一约束 </h3><p> 唯一约束 (UNIQUE) 比较简单，它规定一张表中指定的一列的值必须不能有重复值，即这一列每个值都是唯一的。</p><p>当 INSERT 语句新插入的数据和已有数据重复的时候，如果有 UNIQUE 约束，则 INSERT 失败，</p><h3 id="5-1-4- 外键约束"><a href="#5-1-4- 外键约束" class="headerlink" title="5.1.4 外键约束"></a>5.1.4 外键约束 </h3><p> 外键 (FOREIGN KEY) 既能确保数据完整性，也能表现表之间的关系。</p><p>比如，现在有用户表和文章表，给文章表中添加一个指向用户 id 的外键，表示这篇文章所属的用户 id，外键将确保这个外键指向的记录是存在的，如果你尝试删除一个用户，而这个用户还有文章存在于数据库中，那么操作将无法完成并报错。因为你删除了该用户过后，他发布的文章都没有所属用户了，而这样的情况是不被允许的。同理，你在创建一篇文章的时候也不能为它指定一个不存在的用户 id。</p><p>一个表可以有多个外键，每个外键必须 REFERENCES (参考) 另一个表的主键，被外键约束的列，取值必须在它参考的列中有对应值。</p><h3 id="5-1-5- 非空约束"><a href="#5-1-5- 非空约束" class="headerlink" title="5.1.5 非空约束"></a>5.1.5 非空约束 </h3><p> 非空约束 (NOT NULL), 听名字就能理解，被非空约束的列，在插入值时必须非空。</p><p>在 MySQL 中违反非空约束，会报错</p><h2 id="5-2- 列级约束与表级约束"><a href="#5-2- 列级约束与表级约束" class="headerlink" title="5.2 列级约束与表级约束"></a>5.2 列级约束与表级约束</h2><ul><li><p>列级约束：约束语法都不报错，但是外键约束没有效果</p></li><li><p>表级约束：支持主键约束，外键约束，唯一约束</p><pre><code class="mysql">create table 表名(    字段名 字段类型 列级约束    字段名 字段类型    constraint 表级约束名 表级约束类型(字段名))</code></pre></li><li><p>列级约束例子</p><pre><code class="mysql">create table stuinfo (    id      INT         primary key,                     # 主键约束    stuName VARCHAR(20) not null,                        # 非空约束    gender  CHAR(1)     default &#39;m&#39;,                     # 默认约束    seat    INT         unique,                          # 唯一约束    major   INT         foreign key references major(id) # 外键约束，但是没有效果);</code></pre></li><li><p>表级约束例子</p><pre><code class="mysql">create table stuinfo (    id      INT             stuName VARCHAR(20) not null,                        # 非空约束    gender  CHAR(1)     default &#39;m&#39;,                     # 默认约束    seat    INT,             major   INT,             constraint pk primary key(id), # 主键约束    constraint uq unique(seat),    # 唯一约束    constraint fk_stuinfo_major foreign key(major(id)) references major(id) # 外键约束);</code></pre></li></ul><h2 id="5-3- 主键约束和唯一约束的区别"><a href="#5-3- 主键约束和唯一约束的区别" class="headerlink" title="5.3 主键约束和唯一约束的区别"></a>5.3 主键约束和唯一约束的区别</h2><table><thead><tr><th>约束类型</th><th>保证唯一性</th><th>是否允许为空</th><th>允许多少个</th><th>是否允许组合</th></tr></thead><tbody><tr><td>主键</td><td>保证</td><td>不允许</td><td>最多 1 个</td><td>允许</td></tr><tr><td>唯一</td><td>保证</td><td>允许</td><td>可以多个</td><td>允许</td></tr></tbody></table><h2 id="5-4- 外键使用注意事项"><a href="#5-4- 外键使用注意事项" class="headerlink" title="5.4 外键使用注意事项"></a>5.4 外键使用注意事项</h2><ul><li>外键关联的必须是 Key，一般是 主键 / 唯一键</li><li>插入数据时，先插入主表，再插入从表</li><li>删除数据时，先删除从表，再删除主表</li></ul><h2 id="5-5- 联合主键"><a href="#5-5- 联合主键" class="headerlink" title="5.5 联合主键"></a>5.5 联合主键 </h2><p> 用几个列进行唯一标识一行，即若两列（n 列）作为联合主键，这两列相同，就意味这重复，就会插入数据失败。</p><pre><code class="sql">create table abc(    a date  ,    d varchar(8),    c varchar(8),    constraint a_d primary key(a,d))character set utf8;insert into abc(a,d,c) values (&#39;1993-09-02&#39;,&#39; 小明 &#39;,&#39; 男 &#39;);// 插入成功insert into abc(a,d,c) values (&#39;1993-09-02&#39;,&#39; 小红 &#39;,&#39; 男 &#39;);// 插入成功insert into abc(a,d,c) values (&#39;1993-09-02&#39;,&#39; 小明 &#39;,&#39; 女 &#39;);// 插入失败，因为 a 和 d 列相同</code></pre><h1 id="6、高级操作"><a href="#6、高级操作" class="headerlink" title="6、高级操作"></a>6、高级操作 </h1><p> 本节实验中我们将学习并实践数据库的其他基本操作：索引、视图，导入和导出，备份和恢复等。</p><p>这些概念对于数据库管理员而言都非常重要，请仔细理解并完成所有实验操作。</p><p>作为基础篇，不会涉及到关于索引和视图的高级应用和核心概念，但是基本操作大家会了解，尤其是关于索引的内容，学会建立恰当的索引可以大大提高数据库的查询效率，更高级的应用我们会在进阶篇详细讲解。</p><p><strong>知识点</strong></p><ul><li>索引</li><li>视图</li><li>导入和导出</li><li>备份和恢复</li></ul><h3 id="准备"><a href="# 准备" class="headerlink" title="准备"></a>准备</h3><blockquote><p>注：进入本节进行学习的，请先删除上一节建立的数据库<code>python</code>，删除语句为<code>DROP DATABASE python;</code>。</p></blockquote><p>在开始之前, 将<code>sql 资料</code> 文件夹下的 <code>advanced_operation.sql</code> 拷贝到桌面</p><p>代码会搭建好一个名为 <code>python</code> 的数据库(有三张表：department，employee，project)，并向其中插入数据。</p><p>输入命令开启 <code>MySQL</code> 服务并登录：</p><pre><code># 打开 MySQL 服务sudo service mysql start#使用 root 用户登录mysql -u root</code></pre><p> <code>advanced_operation.sql</code> 和 <code>in.txt</code>，其中第一个文件用于创建数据库并向其中插入数据，第二个文件用于测试数据导入功能。</p><p>如果你是接着上一个实验操作的话，首先把 <code>python</code> 数据库删掉：</p><pre><code>mysql&gt; drop database python;</code></pre><p>输入命令运行第一个文件，搭建数据库并插入数据：</p><pre><code>mysql&gt; source /home/ubuntu/Desktop/advanced_operation.sql</code></pre><h2 id="6-1- 索引"><a href="#6-1- 索引" class="headerlink" title="6.1 索引"></a>6.1 索引 </h2><p> 索引是一种与表有关的结构，它的作用相当于书的目录，可以根据目录中的页码快速找到所需的内容。</p><p>当表中有大量记录时，若要对表进行查询，没有索引的情况是全表搜索：将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录。这样做会消耗大量数据库系统时间，并造成大量磁盘 I/O 操作。</p><p>而如果在表中已建立索引，在索引中找到符合查询条件的索引值，通过索引值就可以快速找到表中的数据，可以 <strong> 大大加快查询速度</strong>。</p><p>对一张表中的某个列建立索引，有以下两种语句格式：</p><pre><code>alter table 表名字 add index 索引名 (列名);create index 索引名 on 表名字 (列名);</code></pre><p>我们用这两种语句分别建立索引：</p><pre><code>alter table employee add index idx_id (id);  #在 employee 表的 id 列上建立名为 idx_id 的索引create index idx_name on employee (name);   #在 employee 表的 name 列上建立名为 idx_name 的索引 </code></pre><p> 索引的效果是加快查询速度，当表中数据不够多的时候是感受不出它的效果的。这里我们使用命令 <strong>SHOW INDEX FROM 表名字;</strong> 查看刚才新建的索引。</p><p>在使用 SELECT 语句查询的时候，语句中 WHERE 里面的条件，会 <strong> 自动判断有没有可用的索引</strong>。</p><p>比如有一个用户表，它拥有用户名 (<code>username</code> ) 和个人签名 (<code>note</code> ) 两个字段。其中用户名具有唯一性，并且格式具有较强的限制，我们给用户名加上一个唯一索引；个性签名格式多变，而且允许不同用户使用重复的签名，不加任何索引。</p><p>这时候，如果你要查找某一用户，使用语句 <code>select * from user where username=?</code> 和 <code>select * from user where note=?</code> 性能是有很大差距的，对 <strong>建立了索引的用户名 </strong> 进行条件查询会比 <strong> 没有索引的个性签名</strong> 条件查询快几倍，在数据量大的时候，这个差距只会更大。</p><p>一些字段不适合创建索引，比如性别，这个字段存在大量的重复记录无法享受索引带来的速度加成，甚至会拖累数据库，导致数据冗余和额外的 CPU 开销。</p><h2 id="6-2- 视图"><a href="#6-2- 视图" class="headerlink" title="6.2 视图"></a>6.2 视图 </h2><p> 视图是从一个或多个表中导出来的表，是一种 <strong>虚拟存在的表</strong> 。它就像一个窗口，通过这个窗口可以看到系统专门提供的数据，这样，用户可以不用看到整个数据库中的数据，而只关心对自己有用的数据。</p><p>注意理解视图是虚拟的表：</p><ul><li>数据库中只存放了视图的定义，而没有存放视图中的数据，这些数据存放在原来的表中；</li><li>使用视图查询数据时，数据库系统会从原来的表中取出对应的数据；</li><li>视图中的数据依赖于原来表中的数据，一旦表中数据发生改变，显示在视图中的数据也会发生改变；</li><li>在使用视图的时候，可以把它当作一张表。</li></ul><p>创建视图的语句格式为：</p><pre><code class="sql">create view 视图名(列 a, 列 b, 列 c) as select 列 1, 列 2, 列 3 from 表名字;</code></pre><p>可见创建视图的语句，后半句是一个 SELECT 查询语句，所以 <strong> 视图也可以建立在多张表上 </strong>，只需在 SELECT 语句中使用<strong> 子查询 </strong> 或<strong>连接查询</strong>，这些在之前的实验已经进行过。</p><p>现在我们创建一个简单的视图，名为 <strong>v_emp</strong>，包含 <strong>v_name</strong>，<strong>v_age</strong>，<strong>v_phone</strong> 三个列：</p><pre><code class="sql">create view v_emp (v_name,v_age,v_phone) as select name,age,phone from employee;</code></pre><blockquote><p>视图的作用</p></blockquote><ul><li>提高了重用性，就像一个函数。如果要频繁获取 user 表的 name 和 goods 表的 name。若没有视图，就只能写一大段 sql 语句查询。而 view 则可以简单整合两个 name 到一张虚拟表里，查询简单很多。</li><li>对数据库重构，却不影响程序的运行。若要拆分一张表，可以视图进行虚拟拆分，又不改变原表的结构。</li><li>提高了安全性能。可以对不同的用户，设定不同的视图。</li></ul><h2 id="6-3- 备份"><a href="#6-3- 备份" class="headerlink" title="6.3 备份"></a>6.3 备份 </h2><p> 数据库中的数据十分重要，出于安全性考虑，在数据库的使用中，应该注意使用备份功能。</p><blockquote><p>备份与导出的区别：导出的文件只是保存数据库中的数据；而备份，则是把数据库的结构，包括数据、约束、索引、视图等全部另存为一个文件。</p></blockquote><p><code>mysqldump</code> 是 <code>MySQL</code> 用于备份数据库的实用程序。它主要产生一个 <code>SQL</code> 脚本文件，其中包含从头重新创建数据库所必需的命令 CREATE TABLE INSERT 等。</p><p>使用 <code>mysqldump</code> 备份的语句：</p><pre><code>mysqldump -u root 数据库名 &gt; 备份文件名;   #备份整个数据库mysqldump -u root 数据库名 表名字 &gt; 备份文件名;  #备份整个表</code></pre><blockquote><p>mysqldump 是一个备份工具，因此该命令是在终端中执行的，而不是在 mysql 交互环境下</p></blockquote><p>我们尝试备份整个数据库 <code>python</code>，将备份文件命名为 <code>bak.sql</code>，先 <code>Ctrl+D</code> 退出 MySQL 控制台，再打开 Xfce 终端，在终端中输入命令：</p><pre><code class="sql">cd /home/ubuntu/mysqldump -u root python &gt; bak.sql;</code></pre><blockquote><p>你可以用 gedit 查看备份文件的内容，可以看见里面不仅保存了数据，还有所备份的数据库的其他信息。</p></blockquote><h2 id="6-4- 恢复"><a href="#6-4- 恢复" class="headerlink" title="6.4 恢复"></a>6.4 恢复 </h2><p> 用备份文件恢复数据库，其实我们早就使用过了。在本次实验的开始，我们使用过这样一条命令：</p><pre><code>source /home/ubuntu/Desktop/advanced_operation.sql</code></pre><p>这就是一条恢复语句，它把 advanced_operation-06.sql 文件中保存的<code>python</code> 数据库恢复。</p><p>还有另一种方式恢复数据库，但是在这之前我们先使用命令新建一个 <strong> 空的数据库 test</strong>：</p><pre><code>mysql -u root -p         #因为在上一步已经退出了 MySQL，现在需要重新登录create database test;  #新建一个名为 test 的数据库</code></pre><p>再次 <strong>Ctrl+D</strong> 退出 MySQL，然后输入语句进行恢复，把刚才备份的 <strong>bak.sql</strong> 恢复到 <strong>test</strong>数据库：</p><pre><code>mysql -u root test &lt; bak.sql</code></pre><p>我们输入命令查看 test 数据库的表，便可验证是否恢复成功：</p><pre><code>mysql -u root -p          #因为在上一步已经退出了 MySQL，现在需要重新登录use test               #连接数据库 testSHOW TABLES;           #查看 test 数据库的表</code></pre><p>实验总结<br>  在本实验中，我们实践了下面几个基本概念：</p><ol><li>索引：可以加快查询速度</li><li>视图：是一种虚拟存在的表</li><li>导入：从文件中导入数据到表</li><li>导出：从表中导出到文件中</li><li>备份：<code>mysqldump</code> 备份数据库到文件</li><li>恢复：从文件恢复数据库</li></ol><p>我们将学习 MySQL 服务安装及命令使用 。</p><h1 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h1><p><strong> 查询的完整格式  不要被吓到 其实很简单 !</strong></p><pre><code class="sql">select select_expr [,select_expr,...] [            from tb_name      [where 条件判断]      [group by &#123;col_name | postion&#125; [ASC | DESC], ...]       [having where 条件判断]      [order by &#123;col_name|expr|postion&#125; [ASC | DESC], ...]      [limit &#123;[offset,]rowcount | row_count OFFSET offset&#125;]]</code></pre><ul><li>完整的 select 语句</li></ul><pre><code class="sql">select distinct *from 表名where ....group by ... having ...order by ...limit start,count</code></pre><ul><li>执行顺序为：<ul><li>from 表名</li><li>where ….</li><li>group by …</li><li>select distinct *</li><li>having …</li><li>order by …</li><li>limit start,count</li></ul></li><li>实际使用中，只是语句中某些部分的组合，而不是全部</li></ul><h1 id="附录"><a href="# 附录" class="headerlink" title="附录"></a>附录 </h1><h2 id="导入数据"><a href="# 导入数据" class="headerlink" title="导入数据"></a> 导入数据</h2><ul><li><p>mysql 命令导入</p><pre><code class="mysql">&gt;&gt; mysql -u 用户名 -p 密码 &lt; /home/abc/ 源.sql</code></pre></li><li><p>source 命令导入</p><pre><code class="mysql">mysql&gt; source /home/abc/ 源.sql</code></pre></li></ul><h2 id="导出数据"><a href="# 导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><ul><li><p>mysqldump 命令导出</p><pre><code class="bash">&gt;&gt; mysqldump -u 用户名 -p 密码 数据库名 表名 &gt; 导出文件路径</code></pre></li><li><p>select … into outfile 命令导出</p><pre><code class="mysql">select * from 表名into outfile 导出文件路径</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy 框架爬虫</title>
      <link href="/Scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/"/>
      <url>/Scrapy%E6%A1%86%E6%9E%B6%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Scrapy 简介"><a href="#1、Scrapy 简介" class="headerlink" title="1、Scrapy 简介"></a>1、Scrapy 简介 </h1><p> 官方文档：<a href="https://doc.scrapy.org/en/latest/topics/commands.html#std:command-startproject">https://doc.scrapy.org/en/latest/topics/commands.html#std:command-startproject</a></p><blockquote><p>Scrapy 是一个使用 Python 语言（基于 Twisted 框架）编写的开源网络爬虫框架，目前由 Scrapinghub Ltd 维护。Scrapy 简单易用、灵活易拓展、开发社区活跃，并且是跨平台的。在 Linux、 MaxOS 以及 Windows 平台都可以使用。 </p></blockquote><p>一个网络爬虫程序的基本执行流程可以总结三个过程：<strong>请求数据 </strong>， <strong> 解析数据 </strong>， <strong> 保存数据</strong></p><p>往往一个爬虫项目会包含多个这样的过程（请求—解析—保存），为了避免因制造轮子而消耗大量时间，一些爬虫框架会将这些工作单独分开过来，将重复的过程进行封装， 使得程序员能够我们能够专注于爬虫数据获取逻辑，提高工作效率与代码质量。</p><p>Scrapy 已经包含了协程部分，不再需要多进程多线程。</p><h2 id="1-1- 架构原理"><a href="#1-1- 架构原理" class="headerlink" title="1.1 架构原理"></a>1.1 架构原理 </h2><p><strong> 以下是爬虫框架 Scrapy 的工作流程：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-02_15-09-34.png" style="zoom:80%;" /><ol><li>scrapy 引擎向 spider 获取起始 Request 集合, 也就是 spider 中定义的 <code>start_urls</code>。如果 spider 重写了<code>start_requests()</code> 方法，那么这个方法返回的 Request 集合就是起始 Request。</li><li>scrapy 引擎将拿到的 Request 发给调度中心开始调度。</li><li>scrapy 引擎向调度中心请求获取下一个要爬取的 Request。</li><li>scrapy 引擎拿到 Request 后，然后将 Request 发给下载器。这个过程经过一系列在 <code>settings.py</code> 中配置的下载中间件，所有在 <code>settings.py</code> 中配置的下载中间件会依次对 Request 进行处理。对应 <code>DownloaderMiddleware #process_request()</code> 方法</li><li>下载器根据 Request 获取响应的内容，比如 Request 的 url 是<code>http://www.baidu.com</code>，下载器就会获取对应的网页内容下来并封装成 Response 对象。</li><li>下载器将 Response 发送给 scrapy 引擎。这个过程也会经过一系列在 <code>settings.py</code> 中配置的下载中间件，这些下载中间件会依次对 Response 进行处理。对应 <code>DownloaderMiddleware#process_response()</code> 方法</li><li>scrapy 引擎拿到 Response 后将 Response 发给 spider, 交给对应的 spider 函数处理。这里默认方法是 <code>parse()</code>, 这个回调方法构造 Request 的时候指定。引擎发送 Response 的过程会经过一系列在<code>settings.py</code> 中配置的 spider 中间件，这些 spider 中间件会依次对 Response 进行一些处理。对应<code>SpiderMiddleware#process_spider_input()</code></li><li>spider 处理完 Response 后会返回一个 result，这个 result 是一个 <code> 包含 Request 或 Item 对象的可迭代对象 (iterable)</code>。然后将 result 发给 scrapy 引擎，这个过程也会经过一系列在<code>settings.py</code> 中配置的 spider 中间件，这些 spider 中间件会依次对这个 result 进行一些处理。对应<code>SpiderMiddleware#process_spider_output()</code></li><li>scrapy 引擎拿到这个 result 后，会将其中的 Item 发送给 <code>Item Pipeline</code> 处理, 这些 item 就会被一系列我们在 <code>settings.py</code> 中配置的 <code>pipeline</code> 处理。同时，scrapy 也会将 result 中的 Request 发给调度中间准备调度。</li><li>继续重复第 2 步的步骤，直到所有的 Request 全部处理完后程序退出。</li></ol><h1 id="2、开始项目"><a href="#2、开始项目" class="headerlink" title="2、开始项目"></a>2、开始项目 </h1><h2 id="2-1- 创建一个爬虫项目"><a href="#2-1- 创建一个爬虫项目" class="headerlink" title="2.1 创建一个爬虫项目"></a>2.1 创建一个爬虫项目</h2><p><strong> 查看 scrapy 命令：</strong></p><pre><code class="python">$ scrapy// 输出如下Scrapy 1.8.0 - no active projectUsage:  scrapy &lt;command&gt; [options] [args]Available commands:  bench         Run quick benchmark test  fetch         Fetch a URL using the Scrapy downloader  genspider     Generate new spider using pre-defined templates  runspider     Run a self-contained spider (without creating a project)  settings      Get settings values  shell         Interactive scraping console  startproject  Create new project  version       Print Scrapy version  view          Open URL in browser, as seen by Scrapy  [more]      More commands available when run from project directoryUse &quot;scrapy &lt;command&gt; -h&quot; to see more info about a command</code></pre><p><strong>创建一个项目(名为 qutos)：</strong></p><pre><code class="python">cd (目标文件夹)scrapy startproject qutos</code></pre><p><strong>进入项目文件夹：</strong></p><pre><code>cd qutos</code></pre><p><strong>生成一个爬虫（quto）：</strong></p><pre><code>scrapy genspider quto toscrape.com  // 这里的 toscrape.com 是爬虫的目标域名 </code></pre><p> 此时项目目录下会创建如下文件：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-02_11-02-32.png" alt=""></p><p><code>spider</code>文件夹：</p><p>​            <code>quto.py</code>：爬虫，用于编写爬虫程序</p><p><code>__init__.py</code> ：</p><p><code>items.py</code>：用于保存抓取的数据</p><p><code>middlewares.py</code>：额外功能拓展区</p><p><code>pipelines.py</code>：核心处理器</p><p><code>settings.py</code>：爬虫的设置文件，供用户进行设置定义</p><p><code>scrapy.cfg</code>：默认配置文件</p><h2 id="2-1-quto-py 爬虫"><a href="#2-1-quto-py 爬虫" class="headerlink" title="2.1 quto.py 爬虫"></a>2.1 quto.py 爬虫</h2><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-02_11-33-05.png" style="zoom:80%;" /><p><strong>写好 quto.py 爬虫文件代码，就可以爬取数据了：</strong></p><p>启动爬虫之前，注意在 <code>settings.py</code> 里设置<code>ROBOTSTXT_OBEY = False</code> 不遵守爬虫协议</p><pre><code>scrapy crawl quto   // 启动爬虫 </code></pre><p><strong> 保存为 json 数据到本地：</strong></p><pre><code>scrapy crawl quto -o qutodata.json  //</code></pre><p><strong>一个例子 quto.py</strong></p><pre><code class="python">import scrapyimport urllibclass QutoSpider(scrapy.Spider):    name = &#39;quto&#39;   #爬虫名字    allowed_domains = [&#39;toscrape.com&#39;]      #允许爬取的范围    start_urls = [&#39;http://quotes.toscrape.com/&#39;]   #爬虫的起点，发送请求    def parse(self, response):   #网址响应的内容 response 会传到这里面        divs=response.css(&#39;.quote&#39;)        for div in divs:            text=div.css(&#39;.text::text&#39;).get()            author=div.css(&#39;.author::text&#39;).get()            tag=div.css(&#39;.tag::text&#39;).getall()            yield dict(text=text,author=author,tag=tag)   #返回的内容必须是字典 dict 或 item(scrapy 特有的)        next_page=response.css(&#39;.next a::attr(href)&#39;).get()     #获取下一页网址        next_url=urllib.parse.urljoin(response.url,next_page)   #只能通过这种方式        print(next_url)        yield scrapy.Request(next_url,callback=self.parse)</code></pre><h3 id="2-1-1- 多个起始 url"><a href="#2-1-1- 多个起始 url" class="headerlink" title="2.1.1 多个起始 url"></a>2.1.1 多个起始 url</h3><p><strong>简单写法：</strong></p><pre><code>start_urls=[f&#39;http://quotes.toscrape.com/&#123;page&#125;&#39; for page in range(1,11)]</code></pre><p><strong>重写：</strong></p><p>使用 <code>start_requests()</code> <strong> 重写 </strong><code>start_urls</code>，要使用<code>Request()</code> 方法自己发送请求：</p><pre><code class="python">def start_requests(self):    yield scrapy.Request(&#39;http://quotes.toscrape.com/&#39;,callback=self.parse)</code></pre><p>Request()对象用来描述一个 HTTP 请求，下面是其构造器方法的参数列表：</p><pre><code>Request(url, callback=None, method=&#39;GET&#39;, headers=None, body=None,        cookies=None, meta=None, encoding=&#39;utf-8&#39;, priority=0,        dont_filter=False, errback=None, flags=None, cb_kwargs=None)</code></pre><ul><li><strong>url</strong>（<em>字符串</em>）–此请求的 URL</li><li><strong>callback</strong>（<em>callable</em>）–将以请求的响应（一旦下载）作为第一个参数调用的函数。有关更多信息，请参见下面的将其他数据传递给回调函数。如果“请求”未指定回调，parse() 则将使用“Spider” 方法。请注意，如果在处理过程中引发异常，则会调用 errback。</li><li><strong>method</strong>（<em>字符串</em>）–此请求的 HTTP 方法。默认为<code>&#39;GET&#39;</code>。</li><li><strong>meta</strong>（dict）– Request.meta 属性的初始值。如果给出，则在此参数中传递的字典将被浅表复制。</li><li><strong>headers</strong>（dict）–请求头。dict 值可以是字符串（对于单值标头）或列表（对于多值标头）。如果 <code>None</code>作为值传递，则将根本不发送 HTTP 标头。</li></ul><p><strong>其中里面的 meta 参数也比较重要：</strong></p><p>主要作用是用来传递数据的</p><p>meta 是通过 Request 产生时传进去，通过 Response 对象中取出来。</p><h2 id="2-3-item 类"><a href="#2-3-item 类" class="headerlink" title="2.3 item 类"></a>2.3 item 类 </h2><p>spider 解析出数据之后，其结果是通过<code>yield</code> 一个 <code>dict</code>，但<code>dict</code> 缺少数据结构，没法保证每一处返回都能返回相同的字段。因此 scrapy 提供了 <code>Item</code> 类，用来声明爬取数据的数据结构，该类提供了 <code>dict-like</code> 的接口，因此可以很方便的使用。</p><p>items.py 用法如下：</p><pre><code class="python">import scrapyclass QutosItem(scrapy.Item):    name = scrapy.Field()    tags=scrapy.Field()</code></pre><p>item 是自定义的数据结构，涉及到 2 个类：</p><p><code>scrapy.Item</code>：基类；</p><p><code>scrapy.Field</code>：用来描述自定义数据包含哪些字段信息，也仅此而已，并没有实际的作用。</p><h2 id="2-4-ItemPipeline"><a href="#2-4-ItemPipeline" class="headerlink" title="2.4 ItemPipeline"></a>2.4 ItemPipeline</h2><p>当 item 从 spider 爬取获得之后，会被送到 ItemPipeline，在 scrapy，ItemPipeline 是处理数据的组件，它们接收 Item 参数并再其之上进行处理。</p><p>ItemPipeline 的典型用法：</p><ol><li>清理脏数据；</li><li>验证数据的有效性；</li><li>去重</li><li>保存 item 到 db，即持久化存储</li></ol><h3 id="2-4-1- 数据处理"><a href="#2-4-1- 数据处理" class="headerlink" title="2.4.1 数据处理"></a>2.4.1 数据处理 </h3><p>Scrapy 提供了 <code>pipeline</code> 模块来执行保存数据的操作。在创建的 Scrapy 项目中自动创建了一个 <code>pipelines.py</code> 文件，同时创建了一个默认的 <code>Pipeline</code> 类：</p><pre><code class="python">class TutorialPipeline(object):     // 类名是可以修改的，也可以根据需要增加    def process_item(self, item, spider):        return item</code></pre><p>在这个类中，有个方法叫 <code>process_item()</code>方法，每个 定义的 Pipeline 类 都需要调用该方法。得到 item 类数据后，就是通过 <code>process_item()</code>里传入的 <code>item</code> 参数作为一个入口，进入 Class 类中执行一些操作。</p><p><code>process_item()</code> 方法必须 <strong> 返回 </strong> 一个字典数据。默认有两个参数。如果把 <code>return item</code> 删除了那就不会再调用其他 Pipeline 方法了。</p><p>参数：</p><ul><li><p><strong>item</strong> (Item 对象 dict) </p></li><li><p><strong>spider</strong> (Spider 对象) </p></li></ul><p><strong>数据保存到 txt：</strong></p><pre><code class="python">import jsonclass TutorialPipeline(object):    def process_item(self, item, spider):        ## 保存数据        with open(&#39;data.json&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) as f:            f.write(json.dumps(dict(item), ensure_ascii=False))            f.write(&#39;\n&#39;)        return item</code></pre><p>*<em>下面是一个完整的 item pipeline 模板 *</em></p><pre><code>import somethingclass SomethingPipeline(object):    def __init__(self):            ## 可选实现，做参数初始化等        ## doing something        pass    def process_item(self, item, spider):        ## item (Item 对象) – 被爬取的 item        ## spider (Spider 对象) – 爬取该 item 的 spider        ## 这个方法必须实现，每个 item pipeline 组件都需要调用该方法，        ## 这个方法必须返回一个 Item 对象，被丢弃的 item 将不会被之后的 pipeline 组件所处理。        return item    def open_spider(self, spider):        ## spider (Spider 对象) – 被开启的 spider        ## 可选实现，当 spider 被开启时，这个方法被调用。        pass    def close_spider(self, spider):        ## spider (Spider 对象) – 被关闭的 spider        ## 可选实现，当 spider 被关闭时，这个方法才被调用        pass</code></pre><p>在 Spider 整个爬取过程中，数据库的连接和关闭操作只需要进行一次，应在开始处理数据之前连接数据库，并在处理完所有数据之后关闭数据库。因此实现以下两个方法（在 Spider 打开和关闭时被调用）：</p><p><code>open_spider(spider)</code></p><p><code>close_spider(spider)</code></p><h4 id="保存"><a href="# 保存" class="headerlink" title="保存"></a><strong>保存</strong></h4><pre><code>// 保存为 jsonimport jsonclass ItcastJsonPipeline(object):    def __init__(self):        self.file = open(&#39;item.json&#39;, &#39;wb&#39;)          // 提前创建并打开文件    def process_item(self, item, spider):        content = json.dumps(dict(item), ensure_ascii=False) + &quot;\n&quot;        self.file.write(content)        return item    def close_spider(self, spider):        self.file.close()// 保存为 excel 文件from openpyxl import Workbookclass ToexcelPipeline(object):    def __init__(self):        self.wb=Workbook()        self.ws=self.wb.active        self.ws.append([&#39; 名字 &#39;,&#39; 性别 &#39;,&#39; 身高 &#39;,&#39; 生日 &#39;,&#39; 省份 &#39;,&#39; 城市 &#39;,&#39; 文化水平 &#39;,&#39; 年薪 &#39;])    def process_item(self, item, spider):        infos=[item[&#39;username&#39;],item[&#39;gender&#39;],item[&#39;height&#39;],item[&#39;birthdayyear&#39;],              item[&#39;province&#39;] ,item[&#39;city&#39;]  ,item[&#39;education&#39;],item[&#39;salary&#39;]]        self.ws.append(infos)        self.wb.save(&#39;wzly-infos.xlsx&#39;)        return item</code></pre><h4 id="去重"><a href="# 去重" class="headerlink" title="去重"></a><strong>去重 </strong></h4><p> 当数据重复时，我们就可以不保存：</p><pre><code>from scrapy.exceptions import DropItemclass DuplicatesPipeline(object):    def __init__(self):        self.ids_seen = set()    def process_item(self, item, spider):        if item[&#39;id&#39;] in self.ids_seen:            raise DropItem(&quot;Duplicate item found: %s&quot; % item)        else:            self.ids_seen.add(item[&#39;id&#39;])            return item</code></pre><h3 id="2-4-2- 启用 -ItemPipeline"><a href="#2-4-2- 启用 -ItemPipeline" class="headerlink" title="2.4.2 启用 ItemPipeline"></a>2.4.2 启用 ItemPipeline</h3><p>上面配置的 <code>ItemPipeline</code> 类需要在 settings.py 中进行启用才能生效。</p><p><strong>启用 ItemPipeline</strong></p><p>在 <code>settings.py</code> 中添加以下内容：</p><pre><code class="python">ITEM_PIPELINES = &#123;    &#39;newproject.pipelines.ItemPipeline&#39;: 300,  &#125;</code></pre><p>其中，<code>ITEM_PIPELINES</code>是一个字典文件，<strong>【键】为在<code>pipelines.py</code> 文件中配置的 ItemPipeline 类</strong>，<strong>【值】为优先级</strong>，ItemPipeline 是按照优先级来调用的，值越小，优先级越高。通过这个值来调控 ItemPipeline 执行的顺序。</p><h3 id="2-4-3- 专用 ItemPipeline"><a href="#2-4-3- 专用 ItemPipeline" class="headerlink" title="2.4.3 专用 ItemPipeline"></a>2.4.3 专用 ItemPipeline</h3><p><strong>Scrapy 框架内部提供了两个 Item Pipeline，专门用于下载文件和图片：</strong></p><p>*<em>FilesPipeline 和 ImagesPipeline *</em></p><p>我们可以将这两个 Item Pipeline 看作特殊的下载器，用户使用时只需要通过 item 的一个特殊字段将要下载文件或图片的 url 传递给它们，它们会自动将文件或图片下载到本地，并将下载结果信息存入 item 的另一个特殊字段，以便用户在导出文件中查阅。</p><blockquote><p><strong>ImagesPipeline 使用说明</strong> </p></blockquote><p><strong>用法如下：</strong></p><pre><code class="python">from scrapy.pipelines.images import ImagesPipeline   // 记得导入class PicturePipeline(ImagesPipeline):    // 类名字无所谓，需要继承基类 ImagesPipeline    def get_media_requests(self, item, info):      // 这个定义名唯一        for image_url in item[&#39;img_s&#39;]:            yield scrapy.Request(image_url, meta=&#123;&#39;filename&#39;: item[&#39;title&#39;]&#125;)// 如果还需要对图片进行分类整理，还需重写以下方法    def file_path(self, request, response=None, info=None):        ## 重命名，若不重写这函数，图片名为哈希        ## 提取 url 前面名称作为图片名。        filename = request.meta.get(&#39;filename&#39;)        image_guid = request.url.split(&#39;/&#39;)[-1]        return os.path.join(filename, image_guid)    def item_completed(self, results, item, info):        ## 下载完进行一些处理        image_paths = [x[&#39;path&#39;] for ok, x in results if ok]        if not image_paths:            raise DropItem(&quot;Item contains no images&quot;)        item[&#39;image_paths&#39;] = image_paths        return item</code></pre><p>其中包含了下载图片或文件的最重要的组件：</p><ul><li><code>get_media_requests()</code>是用来发送请求的，需要传入图片的网址，一定要有。</li><li><code>file_path()</code>是用来指定保存的文件的名字。</li><li><code>item_completed</code>() 当请求完成后进行的操作</li><li>除了编写图片管道文件，还要在配置环境中激活，以及指定图片的存储位置。<strong>在 settings.py 在添加 IMAGES_STORE = ‘./images’</strong></li></ul><blockquote><p> <strong>FilesPipeline 使用说明</strong> </p></blockquote><p>使用 FilesPipeline 下载页面中所有 PDF 文件，可按以下步骤进行：</p><p>在配置文件 settings.py 中启用 FilesPipeline，通常将其置于其他 Item Pipeline 之前：</p><pre><code>ITEM_PIPELINES = &#123;&#39;scrapy.pipelines.files.FilesPipeline&#39;: 1&#125;</code></pre><p>在配置文件 settings.py 中，使用 FILES_STORE 指定文件下载目录，如：</p><pre><code>FILES_STORE = &#39;/home/liushuo/Download/scrapy&#39;</code></pre><p>在 Spider 解析一个包含文件下载链接的页面时，将所有需要下载文件的 url 地址收集到一个列表，赋给 item 的 file_urls 字段（<code>item[&#39;file_urls&#39;]</code>）。FilesPipeline 在处理每一项 item 时，会读取<code>item[&#39;file_urls&#39;]</code>，对其中每一个 url 进行下载。</p><p><strong>Spider</strong>中示例代码如下：</p><pre><code class="python">class DownloadBookSpider(scrapy.Spider):      def parse(response):            item = &#123;&#125;            # 下载列表            item[&#39;file_urls&#39;] = []            for url in response.xpath(&#39;//a/@href&#39;).extract():                download_url = response.urljoin(url)                # 将 url 填入下载列表                item[&#39;file_urls&#39;].append(download_url)      yield item</code></pre><p>当 FilesPipeline 下载完 <code>item[&#39;file_urls&#39;]</code> 中的所有文件后，会将各文件的下载结果信息收集到另一个列表，赋给 item 的 files 字段（<code>item[&#39;files&#39;]</code>）。下载结果信息包括以下内容：</p><p>●　Path 文件下载到本地的路径（相对于 FILES_STORE 的相对路径）。</p><p>●　Checksum 文件的校验和。</p><p>●　url 文件的 url 地址。</p><h3 id="2-4-4-POST 请求"><a href="#2-4-4-POST 请求" class="headerlink" title="2.4.4 POST 请求"></a>2.4.4 POST 请求 </h3><p> 在 Spider.py 爬虫文件里：</p><pre><code class="python">import scrapyimport requestsclass LgSpider(scrapy.Spider):    name = &#39;lg&#39;    allowed_domains = [&#39;lagou.com&#39;]    # start_urls = [&#39;http://lagou.com/&#39;]   // 不能再用这个起始 url 了，需要重写   def start_requests(self):        yield scrapy.http.JsonRequest(&#39;https://www.lagou.com/jobs/positionAjax.json?needAddtionalResult=false&#39;,        data=&#123; &#39;first&#39;: &#39;true&#39;,        &#39;pn&#39;: 1,        &#39;kd&#39;: &#39;python&#39; &#125;,        headers=headers),   def parse(self, response):        print(response.text)</code></pre><p>也可以在这个文件里继续添加请求头信息：</p><pre><code class="python">def get_cookie():    cookie=requests.get(    &#39;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&#39;,    headers=&#123;&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#39;,&#125;,    allow_redirects=False).cookies.get_dict()    return cookieheaders=&#123; &#39;Host&#39;: &#39;www.lagou.com&#39;,         &#39;Origin&#39;: &#39;https://www.lagou.com&#39;,         &#39;Referer&#39;: &#39;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&#39;,        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#39;,       &#39;cookies&#39;:get_cookie()&#125;  </code></pre><h2 id="2-5-Middlewares"><a href="#2-5-Middlewares" class="headerlink" title="2.5 Middlewares"></a>2.5 Middlewares</h2><p>Downloader Middlewares(下载器中间件)，位于 scrapy 引擎和下载器之间的一层组件。作用：</p><ul><li>引擎将 <strong>请求 </strong> 传递给下载器之前， <strong> 下载中间件 </strong> 可以对 <strong> 请求</strong> 进行一系列处理。比如设置请求的 User-Agent，设置代理等</li><li>在下载器完成将 Response 传递给引擎之前，下载中间件可以对响应进行一系列处理。比如进行 gzip 解压等。</li></ul><p>我们主要使用下载中间件处理请求，一般会对请求设置随机的 User-Agent，设置随机的代理。目的在于防止爬取网站的反爬虫策略。</p><h3 id="2-5-1-Headers 配置"><a href="#2-5-1-Headers 配置" class="headerlink" title="2.5.1 Headers 配置"></a>2.5.1 Headers 配置 </h3><p><strong> 将请求头 <code>headers</code> 放到<code>middlewares.py</code></strong></p><pre><code class="python">//middlewares.py 文件下from scrapy import signalsclass UserAgentMiddleware(object):    def process_request(self, request, spider):        request.headers.update(&#123;                          &#39;Host&#39;: &#39;www.lagou.com&#39;,                          &#39;Origin&#39;: &#39;https://www.lagou.com&#39;,                          &#39;Referer&#39;: &#39;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&#39;,                          &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#39;,                      &#125;)        return None  // 没有异常就返回 None</code></pre><p>配置完成之后记得在 settings.py 里添加：</p><pre><code>DOWNLOADER_MIDDLEWARES = &#123;   &#39;lagou.middlewares.UserAgentMiddleware&#39;: 543,&#125;</code></pre><p><strong>利用 faker 库生成 UserAgent</strong></p><pre><code class="python">from faker import Fakerclass UserAgentMiddleware(object):    def __init__(self):        self.fake=Faker()    def process_request(self, request, spider):        request.headers.update(&#123;                          &#39;Host&#39;: &#39;www.lagou.com&#39;,                          &#39;Origin&#39;: &#39;https://www.lagou.com&#39;,                          &#39;Referer&#39;: &#39;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&#39;,                          &#39;User-Agent&#39;: self.fake.user_agent(),                      &#125;)        return None</code></pre><h3 id="2-5-2-cookies 配置"><a href="#2-5-2-cookies 配置" class="headerlink" title="2.5.2 cookies 配置"></a>2.5.2 cookies 配置 </h3><p><strong> 将<code>cookies</code>放到<code>middlewares.py</code></strong></p><pre><code class="python">import requestsdef get_cookie():    cookie=requests.get(&#39;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&#39;,headers=&#123;                        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#39;,&#125;,                          allow_redirects=False).cookies.get_dict()    return cookieclass CookiesMiddleware(object):    def process_request(self, request, spider):        request.cookies.update(get_cookie())        return None</code></pre><p>配置完成之后记得添加到 settings.py 里。</p><p>cookies 也可以在 headers 里一起配置。</p><h3 id="2-5-3-Proxy 配置"><a href="#2-5-3-Proxy 配置" class="headerlink" title="2.5.3 Proxy 配置"></a>2.5.3 Proxy 配置 </h3><p><strong> 将<code>proxy</code>放到<code>middlewares.py</code></strong></p><pre><code class="python">import requestsclass ProxyMiddleware(object):    def process_request(self, request, spider):        request.meta[&#39;proxy&#39;]=&#39;http://223.199.16.186:9999&#39;        return None</code></pre><p>配置完成之后记得在 settings.py 里添加。</p><h3 id="2-5-4- 超时与重试"><a href="#2-5-4- 超时与重试" class="headerlink" title="2.5.4 超时与重试"></a>2.5.4 超时与重试 </h3><p> 有时候我们设置的代理 ip 网速比较慢，这时候就可以在 <code>settings.py</code> 里设置超时与重试。</p><pre><code>// 请求失败就换下一个代理 ipDOWNLOAD_TIMEOUT=5# RETRY_ENABLED=True  // 这个是默认的RETRY_TIMES=5</code></pre><h1 id="3、CrawlSpider"><a href="#3、CrawlSpider" class="headerlink" title="3、CrawlSpider"></a>3、CrawlSpider</h1><p><strong>Scrapy 框架中分两类爬虫：</strong></p><p>Spider 类和 CrawlSpider 类。上面介绍的都是第一类爬虫——Spider 类。</p><p>这部分我们开始介绍第二类爬虫。</p><p>Crawlspider 是 Spider 的派生类 (一个子类)，<strong>Spider 类的设计原则是只爬取 start_url 列表中的网页</strong>，而<strong>CrawlSpider 类</strong> 定义了一些规则 (Rule)，可以更方便的跟进网页中的 Link，自动捕获并请求，从而<strong> 进行全站数据爬取</strong>。</p><h2 id="3-1- 项目创建"><a href="#3-1- 项目创建" class="headerlink" title="3.1 项目创建"></a>3.1 项目创建 </h2><pre><code>scrapy startproject + 项目名称</code></pre><p><strong> 创建一个项目(名为 qutos)：</strong></p><pre><code class="python">cd (目标文件夹)scrapy startproject qutos</code></pre><p><strong>进入项目文件夹：</strong></p><pre><code>cd qutos</code></pre><p><strong>使用模板生成一个 Crawlspider：</strong></p><pre><code>scrapy genspider -t crawl 爬虫名称 + 域 </code></pre><p> 生成爬虫界面是这样的</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-04_12-14-56.png" alt=""></p><h2 id="3-2-Rules 参数"><a href="#3-2-Rules 参数" class="headerlink" title="3.2 Rules 参数"></a>3.2 Rules 参数</h2><p>CrawlSpider 使用 rules 来决定爬虫的爬取规则，并将匹配后的 url 请求提交给引擎。所以在正常情况下，CrawlSpider 不需要单独手动返回请求了。</p><p>在 rules 中包含一个或多个 Rule 对象，每个 Rule 对爬取网站的动作定义了某种特定操作，比如提取当前相应内容里的特定链接，是否对提取的链接跟进爬取，对提交的请求设置回调函数等。</p><p><strong>Rule : 规则解析器。根据链接提取器中提取到的链接，根据指定规则提取解析器链接网页中的内容。</strong></p><p><strong>一个 Rule 对象表示一种提取规则。</strong></p><h3 id="3-2-1-LinkExtractor"><a href="#3-2-1-LinkExtractor" class="headerlink" title="3.2.1 LinkExtractor"></a>3.2.1 LinkExtractor</h3><p>顾名思义，作用就是链接提取器。</p><pre><code class="python">LinkExtractor(allow=r&#39;Items/&#39;, deny=, restrict_css=, restrict_xpaths=,deny_domains=)</code></pre><p>其中 <code>allow=</code> 和<code>deny=</code>是采用 <strong> 正则匹配 </strong> 需要爬取（不爬取）的链接；</p><p><code>restrict_css=</code>和 <code>restrict_xpaths=</code> 是进一步对链接进行限制，采用 css 或 xpath 选择器；</p><p><code>deny_domains=</code>可以指定过滤掉的域名。</p><h3 id="3-2-2- 其他"><a href="#3-2-2- 其他" class="headerlink" title="3.2.2 其他"></a>3.2.2 其他</h3><p><code>callback</code>： 从 link_extractor 中每获取到链接时，参数所指定的值作为回调函数，该回调函数接受一个 response 作为其第一个参数。</p><blockquote><p>注意：当编写爬虫规则时，避免使用 parse()作为回调函数。由于 CrawlSpider 使用 parse 方法来实现其逻辑，如果覆盖了 parse 方法，crawl spider 将会运行失败。</p></blockquote><p><code>follow</code>：默认设置为 True ，否则默认为 False。指定了是否将链接提取器继续作用到链接提取器提取出的链接网页中。。</p><p><code>callback</code>：指定规则解析器解析数据的规则（回调函数）</p><p><code>process_links</code>：指定该 spider 中哪个的函数将会被调用，从 link_extractor 中获取到链接列表时将会调用该函数。该方法主要 <strong> 用来过滤</strong>。</p><p><code>process_request</code>：指定该 spider 中哪个的函数将会被调用， 该规则提取到每个 request 时都会调用该函数。 (用来过滤 request)。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与多进程爬虫</title>
      <link href="/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%88%AC%E8%99%AB/"/>
      <url>/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="1、线程与进程"><a href="#1、线程与进程" class="headerlink" title="1、线程与进程"></a>1、线程与进程 </h1><p> 几乎所有的操作系统都支持同时运行多个任务，一个任务通常就是一个程序，每一个运行中的程序就是一个进程。当一个程序运行时，内部可能包含多个顺序执行流，每一个顺序执行流就是一个线程。所以注意区分多进程与多线程的概念与不同。</p><p><strong>一个程序，多个执行流——多线程</strong></p><ul><li>进程，能够完成多任务，比如 在一台电脑上能够同时运行多个 QQ</li><li>线程，能够完成多任务，比如 一个 QQ 中的多个聊天窗口</li></ul><h3 id="定义的不同"><a href="# 定义的不同" class="headerlink" title="定义的不同"></a>定义的不同</h3><ul><li>进程是系统进行资源分配和调度的一个独立单位.</li><li>线程是进程的一个实体, 是 CPU 调度和分派的基本单位, 它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源, 只拥有一点在运行中必不可少的资源(如程序计数器, 一组寄存器和栈), 但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li><li>在硬件层面是没有协程的概念，作业片时间</li></ul><h3 id="区别"><a href="# 区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p>一个程序至少有一个进程, 一个进程至少有一个线程.</p></li><li><p>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</p></li><li><p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</p></li><li><p>线程不能够独立执行，必须依存在进程中</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/QQ20170731-192951@2x.png" alt=""></p></li></ul><p>关于多进程和多线程，教科书上最经典的一句话是“进程是资源分配的最小单位，线程是 CPU 调度的最小单位”。这句话应付考试基本上够了，但如果在工作中遇到类似的选择问题，那就没有那么简单了，选的不好，会让你深受其害。所以他也是面试者最喜欢考察的题目之一。</p><p>我们按照多个不同的维度，来看看多进程和多线程的对比（注：都是相对的，不是说一个好得不得了，另一个差的无法忍受）</p><table><thead><tr><th>维度</th><th>多进程</th><th>多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据是分开的: 共享复杂，需要用 IPC; 同步简单</td><td>多线程共享进程数据：共享简单；同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td>占用内存多，切换复杂，CPU 利用率低</td><td>占用内存少，切换简单，CPU 利用率高</td><td>线程占优</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>创建销毁、切换简单，速度快</td><td>线程占优</td></tr><tr><td>编程调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td>进程间不会相互影响</td><td>一个线程挂掉将导致整个进程挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td>适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单</td><td>适应于多核分布</td><td>进程占优</td></tr></tbody></table><p>然后我们来看下线程和进程间的比较</p><table><thead><tr><th></th><th>多进程</th><th>多线程</th></tr></thead><tbody><tr><td>优点</td><td>内存隔离，单进程已成不会导致整个应用崩溃。方便调试</td><td>提高系统的并发性，并且开销小</td></tr><tr><td>缺点</td><td>进程间调用，通讯和切换开销均比多线程大</td><td>没有内存隔离，单线程的崩溃会导致整个应用的推出，发生内存 bug 时，定位及其不方便（回调噩梦）</td></tr><tr><td>使用场景</td><td>目标子功能交互少，如果资源和性能许可，请设计由多个子应用程序来组合完成。</td><td>存在大量 IO、网络等耗时操作，或需要与用户交互时，使用多线程有利于提高系统的并行性和用户界面交互的体验。</td></tr></tbody></table><p>1)需要频繁创建销毁的优先用线程。<br>实例：web 服务器。来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。<br>2）需要进行大量计算的优先使用线程。<br>所谓大量计算，当然就是要消耗很多 cpu，切换频繁了，这种情况先线程是最合适的。<br>实例：图像处理、算法处理 <br>3）强相关的处理用线程，若相关的处理用进程。<br> 什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。<br>一般的 server 需要完成如下任务：消息收发和消息处理。消息收发和消息处理就是弱相关的任务，而消息处理里面可能又分为消息解码、业务处理，这两个任务相对来说相关性就要强多了。因此消息收发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计。<br>4）可能扩展到多机分布的用进程，多核分布的用线程。<br>5）都满足需求的情况下，用你最熟悉、最拿手的方式。 </p><p>至于”数据共享、同步“、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，只能说：没有明确的选择方法。一般有一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。</p><p>买了一台服务器  2 核 4 线程 部署一个博客项目 2G 内存</p><p>python 开发的应用 一个进程一个线程 同一时刻只能处理一个请求 并发数只有 1</p><p>并发    项目部署启动 6（2 进程 *（1+2 线程）） 并发数就是 6 线程开的越多 会消耗内存</p><p>线程并发有先后顺序，并行同时去做</p><p>并行数 最大是 2 </p><p>并行 同时做多件事情 一起做。</p><h4 id="进程"><a href="# 进程" class="headerlink" title="进程"></a>进程</h4><ul><li>不共享任何状态</li><li>调度由操作系统完成</li><li>有独立的内存空间（上下文切换的时候需要保存栈、cpu 寄存器、虚拟内存、以及打开的相关句柄等信息，开销大）</li><li>通讯主要通过信号传递的方式来实现（实现方式有多种，信号量、管道、事件等，通讯都需要过内核，效率低）</li></ul><h4 id="线程"><a href="# 线程" class="headerlink" title="线程"></a>线程</h4><ul><li>共享变量（解决了通讯麻烦的问题，但是对于变量的访问需要加锁）</li><li>调度由操作系统完成</li><li>一个进程可以有多个线程，每个线程会共享父进程的资源（创建线程开销占用比进程小很多，可创建的数量也会小很多）</li><li>通讯除了可使用进程间通讯的方式，还可以通过共享内存的方式进行通信（通过共享内存通信比通过内核要快很多）</li><li>线程的使用会给系统带来上下文切换的额外负担。</li></ul><h4 id="协程"><a href="# 协程" class="headerlink" title="协程"></a>协程</h4><ul><li>调度完全由用户控制</li><li>一个线程（进程）可以有多个协程</li><li>每个线程（进程）循环按照指定的任务清单顺序完成不同的任务（当任务被堵塞时，执行下一个任务；当恢复时，再回来执行这个任务；任务间切换只需要保存任务的上下文，没有内核的开销，可以不加锁的访问全局变量）</li><li>协程需要保证是非堵塞的且没有相互依赖</li><li>协程基本上不能同步通讯，多采用异步的消息通讯，效率比较高</li></ul><h1 id="2、多线程"><a href="#2、多线程" class="headerlink" title="2、多线程"></a>2、多线程</h1><h2 id="2-1-Threading 模块"><a href="#2-1-Threading 模块" class="headerlink" title="2.1 Threading 模块"></a>2.1 Threading 模块</h2><blockquote><p>python 的 thread 模块是底层的模块，python 的 threading 模块是对 thread 做了一些包装的，可以更加方便的被使用</p></blockquote><p>当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行流的最小单元，当设置多线程时，主线程会创建多个子线程，在 python 中，默认情况下（其实就是 setDaemon(False)），主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束。</p><pre><code class="python">import requestsimport reimport threadingimport timedef download_one_page(url, name):    print(name,url)    response = requests.get(url)    response.encoding = response.apparent_encoding    html = response.text    text = re.findall(&#39;&lt;div id=&quot;content&quot; class=&quot;showtxt&quot;&gt;(.*?)&lt;/div&gt;&#39;, html, re.S)    print(text)start_time=time.time()response = requests.get(&#39;http://www.shuquge.com/txt/8659/index.html&#39;)response.encoding = response.apparent_encodinghtml = response.textresult = re.findall(&#39;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#39;, html)for url, name in result[:5]:   // 每一次循环都启动一个新的线程, 不要同时启动太多了    host_url=&#39;http://www.shuquge.com/txt/8659/&#39;    t = threading.Thread(target=download_one_page,args=(host_url + url, name))    t.start()while len(threading.enumerate()) &gt; 1:    // 判断子线程是否结束    passprint(time.time()-start_time())   // 计算子线程全部走完所花的时间</code></pre><h2 id="2-2- 线程池"><a href="#2-2- 线程池" class="headerlink" title="2.2 线程池"></a>2.2 线程池 </h2><p> 为了合理运用内存，我们一般设置每次最多只运行若干个子线程，比如同时要运行 5 个，已经完成了 3 个，为了避免资源浪费，这时候就可以通过线程池进行补调，保证每时每刻都有 5 个线程在同时运行。</p><p>线程池模块：<code>concurrent.futures</code></p><p>创建它的最简单方法是作为上下文管理器，使用该 <code>with</code> 语句来管理池的创建和销毁。</p><pre><code>import concurrent.futuresif __name__ == &quot;__main__&quot;:    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:        executor.map(download_one_page, host_url + url, name)</code></pre><p>还可以通过如下方式创建：</p><pre><code class="python">import concurrent.futuresthread_pool=concurrent.futures.ThreadPoolExecutor(max_workers=5) // 设置最多子任务为 5for url, name in result:  # 每一次循环都启动一个新的线程    host_url = &#39;http://www.shuquge.com/txt/8659/&#39;    thread_pool.submit(download_one_page, host_url + url, name)thread_pool.shutdown()</code></pre><h1 id="3、多进程"><a href="#3、多进程" class="headerlink" title="3、多进程"></a>3、多进程</h1><p>python GIL 限制了一个程序只能使用一个进程。</p><h2 id="3-1-multiprocessing- 模块"><a href="#3-1-multiprocessing- 模块" class="headerlink" title="3.1 multiprocessing 模块"></a>3.1 multiprocessing 模块</h2><p>multiprocessing 是 Python 的标准模块，它既可以用来编写多进程，也可以用来编写多线程。multiprocessing  提供了一个 Process 类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。</p><pre><code class="python">import multiprocessingimport timedef upload():    print(&quot; 开始上传文件...&quot;)    time.sleep(1)    print(&quot; 完成上传文件...&quot;)def download():    print(&quot; 开始下载文件...&quot;)    time.sleep(1)    print(&quot; 完成下载文件...&quot;)def main():    multiprocessing.Process(target=upload).start()    multiprocessing.Process(target=download).start()if __name__ == &#39;__main__&#39;:   // 必须有个主程序    main()</code></pre><p>还可以这样：</p><pre><code class="python">import multiprocessingif __name__ == &#39;__main__&#39;:    // 必须有个主程序    for url in url_list:        mp=multiprocessing.Process(target=download_one_page,agrs=(url,))        mp.start()</code></pre><h2 id="3-2- 进程池"><a href="#3-2- 进程池" class="headerlink" title="3.2 进程池"></a>3.2 进程池 </h2><p> 也是采用 concurrent.futures 模块。</p><pre><code>import concurrent.futuresprocess_pool=concurrent.futures.ProcessPoolExecutor(max_workers=5) // 设置最多子任务为 5for url, name in result:  # 每一次循环都启动一个新的线程    host_url = &#39;http://www.shuquge.com/txt/8659/&#39;    process_pool.submit(download_one_page, host_url+url, name)process_pool.shutdown()</code></pre><h1 id="4、综合案例"><a href="#4、综合案例" class="headerlink" title="4、综合案例"></a>4、综合案例 </h1><p><strong> 采用多进程，多线程的方式爬取小说：</strong></p><pre><code class="python">import requestsimport reimport timeimport concurrent.futuresdef get_index():    response = requests.get(&#39;http://www.shuquge.com/txt/8659/index.html&#39;)    response.encoding = response.apparent_encoding    html = response.text    result = re.findall(&#39;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#39;, html)    return result# 多线程def thread_download_ebook(url, name):    print(name, url)    response = requests.get(url)    response.encoding = response.apparent_encoding    html = response.text    result = re.findall(&#39;&lt;div id=&quot;content&quot; class=&quot;showtxt&quot;&gt;(.*?)&lt;/div&gt;&#39;, html, re.S)    with open(name + &#39;.txt&#39;, mode=&#39;w&#39;, encoding=&#39;utf-8&#39;) as f:        f.write(result[0].replace(&#39;&lt;br/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#39;, &quot;&quot;).replace(&#39;&lt;br/&gt;&#39;, &quot;&quot;))# 多进程def process_download_ebook(urls):    # 每一个进程 启动五个线程 25    thread_pool = concurrent.futures.ThreadPoolExecutor(max_workers=5)    for url, name in urls:        # 往线程池里面放任务        thread_pool.submit(thread_download_ebook, &#39;http://www.shuquge.com/txt/8659/&#39; + url, name)    # 等待线程池关闭    thread_pool.shutdown()if __name__ == &#39;__main__&#39;:    content_list = get_index()[:20]    length = int(len(content_list)/5)  # 把所有任务分成五份    start_time = time.time()    # 启动五个进程    # 进程之间的相互通信 默认情况下 进程之间的变量不共享数据    process_pool = concurrent.futures.ProcessPoolExecutor(max_workers=length)    for i in range(length):        if i == length:            i += 1        process_pool.submit(process_download_ebook, content_list[i * length:(i + 1) * length])    process_pool.shutdown()    print(time.time() - start_time)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Selenium 自动化测试模拟</title>
      <link href="/Selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A8%A1%E6%8B%9F/"/>
      <url>/Selenium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Selenium 介绍"><a href="#1、Selenium 介绍" class="headerlink" title="1、Selenium 介绍"></a>1、Selenium 介绍</h1><p>Selenium 是一个用于 Web 应用程序自动化测试工具。其本来的开发目的帮助前端程序员，以来完成 web 网站项目的自动化测试。其特点是：能够完全模拟人的行为，打开浏览器，进行搜索，点击，翻页的操作。正是这些特性，在网络爬虫反反爬技术应用广泛，以躲开网站对爬虫的限制。</p><h2 id="1-1- 怎么实现浏览器控制"><a href="#1-1- 怎么实现浏览器控制" class="headerlink" title="1.1 怎么实现浏览器控制"></a>1.1 怎么实现浏览器控制 </h2><p>Selenium 具体怎么就能操纵浏览器呢？这要归功于 <strong> 浏览器驱动</strong> ，Selenium 可以通过 API 接口实现和浏览器驱动的交互，进而实现和浏览器的交互。所以要配置浏览器驱动。</p><ol><li><p>首先安装 python 第三方库：<code>pip install selenium</code></p></li><li><p>下载浏览器驱动，以用于 selenium 对浏览器的控制。</p><p>对于不同浏览器，对应不同的驱动，最常使用的浏览器是谷歌 Chrome 和火狐 Firefox。</p><p><strong>火狐驱动下载地址：</strong> <a href="http://npm.taobao.org/mirrors/geckodriver/">http://npm.taobao.org/mirrors/geckodriver/</a></p><p><strong>谷歌驱动下载地址：</strong><a href="https://chromedriver.storage.googleapis.com/index.html">https://chromedriver.storage.googleapis.com/index.html</a></p><p>注意：下载的驱动应与浏览器的版本一致。</p></li><li><p>将下载好的浏览器驱动解压，将解压出的 <code>exe</code> 文件放到 Python 的安装目录下，也就是和 <code>python.exe</code> 同目录即可。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1560611571791.png" alt=""></p></li></ol><p>配置完这一切，就能使用 python 程序控制浏览器啦！</p><p>注意：浏览器驱动也可以放置于对应浏览器的安装目录下；还可以放置与 python 程序同级目录下。</p><h1 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h1><h2 id="2-1- 初步上手"><a href="#2-1- 初步上手" class="headerlink" title="2.1 初步上手"></a>2.1 初步上手</h2><pre><code class="python">from selenium import webdriverdriver=webdriver.Chrome()driver.get(&#39;https://baidu.com&#39;)</code></pre><p>这样运行程序就能启动浏览器工作了（这里我使用的是谷歌浏览器）。</p><pre><code>drive.quit()   // 关闭驱动</code></pre><h2 id="2-2- 搜索交互"><a href="#2-2- 搜索交互" class="headerlink" title="2.2 搜索交互"></a>2.2 搜索交互</h2><h3 id="2-2-1-CSS 选择器"><a href="#2-2-1-CSS 选择器" class="headerlink" title="2.2.1 CSS 选择器"></a>2.2.1 CSS 选择器</h3><p><strong><code>.find_element_by_css_selector()</code></strong></p><pre><code>// 打开网页browser.get(&#39;https://www.jd.com&#39;) // 定位到网页搜索框 id，并清空key_button=browser.find_element_by_css_selector(&#39;#key&#39;)// 输入关键词key_button.send_keys(&#39; 固态硬盘 &#39;)  // 点击搜索按钮cilck_button=browser.find_element_by_css_selector(&#39;#search button.button&#39;).click()// 注意这里先找到 button 标签下属性为 button 的类名，在往上找到其独一无二的 id&#39;search&#39;。</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-29_23-06-26.png" alt=""></p><h3 id="2-2-2-Xpath 选择器"><a href="#2-2-2-Xpath 选择器" class="headerlink" title="2.2.2 Xpath 选择器"></a>2.2.2 Xpath 选择器</h3><p><code>.find_element_by_xpath()</code></p><pre><code class="python">key_button=browser.find_element_by_xpath(&#39;//*[@id=&quot;key&quot;]&#39;)key_button.send_keys(&#39; 固态硬盘 &#39;)cilck_button=browser.find_element_by_xpath(&#39;//*[@id=&quot;search&quot;]//div/button&#39;).click()</code></pre><h3 id="2-2-3- 其他方式"><a href="#2-2-3- 其他方式" class="headerlink" title="2.2.3 其他方式"></a>2.2.3 其他方式 </h3><p> 根据类名定位元素：<code>.find_element_by_id()</code></p><p>根据类名定位元素：<code>.find_element_by_class_name()</code></p><p>根据标签名定位元素：<code>.find_element_by_tag_name()</code></p><p>根据元素名定位元素：<code>.find_element_by_name()</code></p><p>通过文本 <strong> 链接 </strong> 来定位元素：<code>.find_element_by_link_text()</code></p><p>通过文字 <strong> 链接 </strong> 中的一部分文字定位，属于 <strong> 模糊定位</strong>：<code>.find_element_by_partial_link_text()</code></p><pre><code>browser.find_element_by_link_text(&#39; 把百度设为主页 &#39;).get_attribute(&#39;id&#39;)browser.find_element_by_partial_link_text(&#39; 把百度 &#39;).get_attribute(&#39;id&#39;)</code></pre><h2 id="2-3- 渲染"><a href="#2-3- 渲染" class="headerlink" title="2.3 渲染"></a>2.3 渲染 </h2><p> 在浏览器搜索关键词跳转到新页面之后，需要有一个渲染过程，等页面加载出来。</p><h3 id="2-3-1- 页面等待"><a href="#2-3-1- 页面等待" class="headerlink" title="2.3.1 页面等待"></a>2.3.1 页面等待 </h3><p> 现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过短导致某个 dom 元素还没出来，但是你的代码直接使用了这个 WebElement，那么就会抛出 ElementNotVisibleException 的异常。</p><p>为了避免这种元素定位困难而且会提高产生 ElementNotVisibleException 的概率。所以 Selenium 提供了两种等待方式：</p><ul><li>一种是隐式等待</li><li>一种是显式等待</li></ul><ol><li><p><strong>隐式等待</strong></p><p>隐式等待比较简单，就是简单地设置一个等待时间，单位为秒。隐式等待是等页面加载完毕，而不是元素加载！！！（隐式等待就是针对页面的，显式等待是针对元素的。）</p><pre><code class="python">browser.implicitly_wait(10)    // 最多等待 10 秒</code></pre><p>隐式等待只需设置一次，后面的都遵循这个规则，不像 <code>time.sleep</code>。<code>time.sleep</code> 属于强制等待。</p></li><li><p><strong>显式等待</strong></p><p>显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，还没有满足某个条件，那么便会抛出异常了。显式等待是等元素加载！！！</p><pre><code class="python">///WebDriverWait:    WebDriverWait(driver， timeout) 实例化的 driver  timeout 等待的时间until:    直到 xx 条件符合为止    until(条件)条件:    presence_of_element_located: 当前的元素被加载进来了    presence_of_element_located 是一个类 初始化要写定位的元素  一般是元组格式: (By.ID， &#39;vaule&#39;)///import time# 导入模块from selenium import webdriver# 导入等待的显式等待的类from selenium.webdriver.support.ui import WebDriverWait  # WebDriverWait(driver)# 导入判断元素的条件from selenium.webdriver.support import expected_conditions as EC# 导入选择元素的方法from selenium.webdriver.common.by import Byurl = &#39;https://www.receivesmsonline.net/&#39;browser = webdriver.Chrome()browser.get(url)try:    startTime = time.time() # 计算时间戳    print(&#39; 开始进入等待时间 ----&gt;&gt;&#39;， startTime)    wait = WebDriverWait(driver， 5)    # 一直去寻找 (By.ID， &#39;asdhakhkfl&#39;) 被加载进来 直到时间耗尽  如果提前找到 就提前返回    element = wait.until(EC.presence_of_element_located((By.ID， &#39;asdhakhkfl&#39;)))except:    endTime = time.time()    print(&#39; 等待了多少秒 ----&gt;&gt;&#39;， endTime - startTime)</code></pre><p>下面是一些内置的等待条件，可以直接调用，而不用自己写这些等待条件：</p><ul><li><code>title_is</code>： 判断当前页面的 title 是否完全等于（==）预期字符串，返回布尔值</li><li><code>title_contains</code> : 判断当前页面的 title 是否包含预期字符串，返回布尔值</li></ul></li></ol><ul><li><code>presence_of_element_located</code> : 判断某个元素是否被加到了 <code>dom</code> 树里，并不代表该元素一定可见<ul><li><code>visibility_of_element_located</code> : 判断某个元素是否可见. 可见代表元素非隐藏，并且元素的宽和高都不等于 0</li></ul></li><li><code>visibility_of</code> : 跟上面的方法做一样的事情，只是上面的方法要传入<code>locator</code>，这个方法直接传定位到的 element 就好了<ul><li><code>presence_of_all_elements_located</code> : 判断是否至少有 1 个元素存在于 <code>dom</code> 树中。举个例子，如果页面上有 n 个元素的 class 都是<code>column-md-3</code>，那么只要有 1 个元素存在，这个方法就返回 True</li><li><code>text_to_be_present_in_element</code> : 判断某个元素中的 text 是否 包含 了预期的字符串</li><li><code>text_to_be_present_in_element_value</code> : 判断某个元素中的 value 属性是否 包含 了预期的字符串</li><li><code>frame_to_be_available_and_switch_to_it</code> : 判断该 <code>frame</code> 是否可以 <code>switch</code> 进去，如果可以的话，返回 <code>True</code> 并且 <code>switch</code> 进去，否则返回<code>False</code></li><li><code>invisibility_of_element_located</code> : 判断某个元素中是否不存在于 <code>dom</code> 树或不可见</li><li><code>element_to_be_clickable</code> : 判断某个元素中是否可见并且是 <code>enable</code> 的，这样的话才叫<code>clickable</code></li><li><code>staleness_of</code> : 等某个元素从 <code>dom</code> 树中移除，注意，这个方法也是返回 True 或 False</li><li><code>element_to_be_selected</code> : 判断某个元素是否被选中了，一般用在下拉列表</li><li><code>element_selection_state_to_be</code> : 判断某个元素的选中状态是否符合预期</li><li><code>element_located_selection_state_to_be</code> : 跟上面的方法作用一样，只是上面的方法传入定位到的<code>element</code>，而这个方法传入<code>locator</code></li><li><code>alert_is_present</code> : 判断页面上是否存在<code>alert</code></li></ul></li></ul><h3 id="2-3-2- 切换窗口"><a href="#2-3-2- 切换窗口" class="headerlink" title="2.3.2 切换窗口"></a>2.3.2 切换窗口</h3><ul><li><p><strong>切换 Frame</strong></p><p>虽然 selenium 控制浏览器打开了网页，但是有的网页是由多个 Frame 结构组成的，我们需要切换到目标 Frame 里才能提取到想要的网页元素。</p><pre><code>browser.switch_to.frame(0)    // 切入目标框内</code></pre><p>frame 标签有 frameset、frame、iframe 三种，frameset 跟其他普通标签没有区别，不会影响到正常的定位，而 frame 与 iframe 对 selenium 定位而言是一样的，selenium 有一组方法对 frame 进行操作。</p><p><strong>从 frame 中切回主文档(switch_to.default_content())</strong></p><p><strong>嵌套 frame 的操作(switch_to.parent_frame())</strong></p></li><li><p><strong>切换浏览器窗口：</strong></p></li></ul><pre><code>browser.switch_to_window(browser.window_handles[-1])   // 切入浏览器窗口 </code></pre><h3 id="2-3-3- 下拉与翻页"><a href="#2-3-3- 下拉与翻页" class="headerlink" title="2.3.3 下拉与翻页"></a>2.3.3 下拉与翻页</h3><p> 有时候网页元素的逐步加载的，首先只加载网页上部分区域，等到拉动网页的下滑条时，才会逐步往下加载可视区域。<strong>只有网页元素加载出来，才能进行选取</strong>。</p><p><strong>执行 JS 代码，实现下拉滑动条：</strong></p><pre><code>// 执行 js 代码 下拉滑动条js = &#39;window.scrollBy(0,8000)&#39;// 执行 jsbrowser.execute_script(js)///注意:    对于含有 iframe 的框也需要先切换进入框内才可以下拉。///</code></pre><p><code>window.scrollBy(x,y)</code>， 在当前位置的基础上，再次移动 x,y 像素</p><p><code>window.scrollTo(x,y)</code>，将滚动条移动到 横坐标为 x，纵坐标为 y 的位置</p><p><strong>翻页：</strong></p><pre><code>time.sleep(5)   // 等待 5 秒// 找到下一页位置进行点击（以京东为例）browser.find_element_by_css_selector(&#39;#J_bottomPage a.pn-next&#39;).click()</code></pre><h2 id="2-4- 页面操作"><a href="#2-4- 页面操作" class="headerlink" title="2.4 页面操作"></a>2.4 页面操作 </h2><p> 除了上面已经提到的【点击 &amp; 输入文本动作】，selenium 还提供了其他丰富的操作方式。</p><h3 id="2-4-1- 选择下拉框"><a href="#2-4-1- 选择下拉框" class="headerlink" title="2.4.1 选择下拉框"></a>2.4.1 选择下拉框 </h3><p> 已经知道了怎样向文本框中输入文字，但是有时候会碰到 <select> </select> 标签的下拉框。直接点击下拉框中的选项不一定可行。Selenium 专门提供了 Select 类来处理下拉框。 其实 WebDriver 中提供了一个叫 Select 的方法，可以帮助完成这些事情：<a href="http://www.jq22.com/demo/shengshiliandong/">http://www.jq22.com/demo/shengshiliandong/</a></p><pre><code class="python">///下拉框:    Select(element) element 是下拉框的元素    选择的方法:        1. select_by_value(value)  value=&quot; 天津市 &quot;        2. select_by_index(1)  通过索引 1 2 3 4 5 6        3. select_by_visible_text(text) 通过可见的文本///import timefrom selenium import webdriverfrom selenium.webdriver.support.select import Selecturl = &#39;http://www.jq22.com/demo/shengshiliandong/&#39;# 初始化浏览器driver = webdriver.Chrome()# 打开driver.get(url)# 寻找可以选择的元素 并实例化 Selectelememt = driver.find_element_by_xpath(&#39;//*[@id=&quot;s_province&quot;]&#39;)# 实例化 Selectselect = Select(elememt)time.sleep(2)# 选择具体的值select.select_by_index(5)time.sleep(2)select.select_by_value(&#39; 河南省 &#39;)time.sleep(2)select.select_by_visible_text(&#39; 四川省 &#39;)# %%driver.quit()</code></pre><p>以上是三种选择下拉框的方式，它可以根据索引来选择，可以根据值来选择，可以根据文字来选择。注意：</p><ul><li>index 索引从 0 开始</li><li>value 是 option 标签的一个属性值，并不是显示在下拉框中的值</li><li>visible_text 是在 option 标签文本的值，是显示在下拉框的值</li></ul><h3 id="2-4-2- 鼠标动作链"><a href="#2-4-2- 鼠标动作链" class="headerlink" title="2.4.2 鼠标动作链"></a>2.4.2 鼠标动作链 </h3><p> 有些时候，需要在页面上模拟一些鼠标操作，比如双击、右击、拖拽甚至按住不动等，可以通过导入 ActionChains 类来做到：<a href="http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable">http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable</a>  比如：    </p><pre><code class="python">///拖动鼠标:    ActionChains:        ActionChains() --&gt; 直接传入 driver --&gt; ActionChains(driver) 实例化        perform --&gt; 执行动作        drag_and_drop(source， target)  source 拖动的元素  target 元素被放置的位置///import timefrom selenium import webdriverfrom selenium.webdriver import ActionChains# 网址url = &#39;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#39;# 初始化driver = webdriver.Chrome()# 打开网站driver.get(url)# 切入框内driver.switch_to.frame(0)# 找到可以拖拽的元素drag = driver.find_element_by_css_selector(&#39;#draggable&#39;)# 需要放置的位置的元素drop = driver.find_element_by_css_selector(&#39;#droppable&#39;)# 实例化action = ActionChains(driver)# 定义动作 但是不执行 没有执行action.drag_and_drop(drag， drop)# 执行action.perform()time.sleep(5)driver.quit()///注意:    perform 才是真正的执行  可以在 perform 之前定义多个动作 最后一起执行    注意切入框内 switch_to.frame(0)///</code></pre><h3 id="2-4-3- 其他 - 了解"><a href="#2-4-3- 其他 - 了解" class="headerlink" title="2.4.3 其他 (了解)"></a>2.4.3 其他 (了解)</h3><ul><li>弹窗处理</li></ul><p>当你触发了某个事件之后，页面出现了弹窗提示，处理这个提示或者获取提示信息方法如下：<code>driver.switch_to_alert()</code></p><ul><li>窗口切换</li></ul><p>一个浏览器肯定会有很多窗口，所以我们肯定要有方法来实现窗口的切换。切换窗口的方法如下：<code>switch_to.window(&quot;this is window name&quot;)</code></p><ul><li>页面前进和后退</li></ul><p>操作页面的前进和后退功能：前进：<code>driver.forward()</code> 后退：<code>driver.back()</code></p><ul><li>Cookie</li></ul><p>获取页面每个 Cookie 值：<code>driver.get_cookies()</code></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据持久化 - 文件保存本地</title>
      <link href="/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98/"/>
      <url>/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96-%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>斜杠 <code>/</code> 不需要转义，反斜杠 <code>\\</code> 才需要。</p><h1 id="数据持久化"><a href="# 数据持久化" class="headerlink" title="数据持久化"></a>数据持久化 </h1><h1 id="1- 文件操作"><a href="#1- 文件操作" class="headerlink" title="1. 文件操作"></a>1. 文件操作</h1><p> 计算机的 文件，就是存储在某种 长期储存设备 上的一段 数据</p><p>长期存储设备包括：硬盘、U 盘、移动硬盘、光盘…</p><p><strong>文本文件和二进制文件</strong> </p><ul><li>文本文件<ul><li>可以使用 文本编辑软件 查看</li><li>本质上还是二进制文件</li><li>例如：python 的源程序</li></ul></li><li>二进制文件<ul><li>保存的内容 不是给人直接阅读的，而是 提供给其他软件使用的</li><li>例如：图片文件、音频文件、视频文件等等</li><li>二进制文件不能使用 文本编辑软件 查看</li></ul></li></ul><h2 id="1-1- 文件的基本操作"><a href="#1-1- 文件的基本操作" class="headerlink" title="1.1 文件的基本操作"></a>1.1 文件的基本操作 </h2><p><strong> 操作文件的函数 / 方法</strong></p><p>在 <code>Python</code> 中要操作文件需要记住 1 个函数和 3 个方法</p><table><thead><tr><th>序号</th><th>函数 / 方法名</th><th>说明</th></tr></thead><tbody><tr><td>打开函数</td><td>open()</td><td>内置方法，打开文件，并且返回文件操作对象</td></tr><tr><td>读取方法</td><td>.read</td><td>将文件内容读取到内存</td></tr><tr><td>写入方法</td><td>.write</td><td>将指定内容写入文件</td></tr><tr><td>关闭方法</td><td>.close</td><td>关闭文件</td></tr></tbody></table><ul><li><code>open</code> 函数负责打开文件，并且返回文件对象</li><li><code>read</code>/<code>write</code>/<code>close</code> 三个方法都需要通过 文件对象 来调用</li></ul><h3 id="1-1-1- 读取文件"><a href="#1-1-1- 读取文件" class="headerlink" title="1.1.1 读取文件"></a>1.1.1 读取文件</h3><pre><code class="python">file = open(&#39;filename&#39;，mode, encoding, newline)  //newline=&#39;\r\n&#39; 可让文件换行写入</code></pre><p>  函数的第一个参数是要打开的文件名（文件名区分大小写）</p><ul><li>如果文件 存在，返回 文件操作对象，以供读写和关闭</li><li>如果文件 不存在，会 抛出异常</li></ul><ul><li><p><code>read()</code> 方法可以一次性 读入 并 返回 文件的 所有内容</p></li><li><p><code>close()</code>方法负责关闭文件</p><ul><li>如果 忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问</li></ul></li><li><p>注意：<code>read()</code> 方法执行后，会把 文件指针 移动到 文件的末尾</p></li></ul><pre><code class="python"># 1. 打开 - 文件名需要注意大小写file = open(&quot;./data.csv&quot;)# 2. 读取text = file.read()print(text)# 3. 关闭file.close()</code></pre><h3 id="1-1-2- 打开文件的方式"><a href="#1-1-2- 打开文件的方式" class="headerlink" title="1.1.2 打开文件的方式"></a>1.1.2 打开文件的方式</h3><ul><li><code>open</code> 函数 <strong> 默认 只读方式</strong> 打开文件，并且返回文件对象</li></ul><p>语法如下：</p><pre><code class="python">f = open(&quot; 文件名 &quot;, &quot; 访问方式 &quot;)</code></pre><table><thead><tr><th>访问方式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常</td></tr><tr><td>w</td><td>以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件</td></tr><tr><td>a</td><td>以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入</td></tr><tr><td>r+</td><td>以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常</td></tr><tr><td>w+</td><td>以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件</td></tr><tr><td>a+</td><td>以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入</td></tr><tr><td>rb</td><td>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。b 是二进制的意思</td></tr><tr><td>wb</td><td>以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件</td></tr><tr><td>ab</td><td>以二进制格式打开一个文件用于追加</td></tr></tbody></table><p>提示</p><ul><li>频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以 <strong>只读、只写</strong> 的方式来操作文件</li></ul><p>写入文件示例</p><pre><code class="python"># 打开文件f = open(&quot;text.txt&quot;, &quot;w&quot;)f.write(&quot;hello python！\n&quot;)f.write(&quot; 今天天气真好 &quot;)# 关闭文件f.close()</code></pre><h3 id="1-1-3- 按行读取文件内容"><a href="#1-1-3- 按行读取文件内容" class="headerlink" title="1.1.3 按行读取文件内容"></a>1.1.3 按行读取文件内容</h3><p><code>read</code> 方法默认会把文件的 所有内容 一次性读取到内存</p><p>如果文件太大，对内存的占用会非常严重</p><p><code>readline</code> 方法</p><p><code>readline</code> 方法可以一次读取一行内容</p><p>方法执行后，会把 文件指针 移动到下一行，准备再次读取</p><p>—&gt; 读取大文件的正确姿势!</p><h3 id="1-1-4-with-open"><a href="#1-1-4-with-open" class="headerlink" title="1.1.4 with open"></a>1.1.4 with open</h3><p>常用三段式的文件操作：open–&gt;read/write–&gt;close。这个我们操作完文件后必须 close，当然我们也可以这样做：</p><pre><code class="python">with open(&#39;text.txt&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:    for line in f.readlines():        print(line.strip())           # 打印内容，并把行末尾的 &#39;\n&#39; 删掉</code></pre><blockquote><p>这样就不用调用 close()方法了，可以更为简洁</p></blockquote><h2 id="1-2- 目录操作"><a href="#1-2- 目录操作" class="headerlink" title="1.2 目录操作"></a>1.2 目录操作</h2><ul><li><p>在 终端 / 文件浏览器、 中可以执行常规的 文件 / 目录 管理操作，例如：</p><ul><li>创建、重命名、删除、改变路径、查看目录内容、……</li></ul></li><li><p>在 <code>Python</code> 中，如果希望通过程序实现上述功能，需要导入 <code>os</code> 模块</p></li></ul><h3 id="1-2-1- 系统操作"><a href="#1-2-1- 系统操作" class="headerlink" title="1.2.1 系统操作"></a>1.2.1 系统操作</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/20180704141230837.png" alt=""></p><h3 id="1-2-2- 文件操作"><a href="#1-2-2- 文件操作" class="headerlink" title="1.2.2 文件操作"></a>1.2.2 文件操作</h3><table><thead><tr><th>序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>01</td><td>rename</td><td>重命名文件</td><td><code>os.rename(源文件名, 目标文件名)</code></td></tr><tr><td>02</td><td>remove</td><td>删除文件</td><td><code>os.remove(文件名)</code></td></tr></tbody></table><h3 id="1-2-3- 目录操作"><a href="#1-2-3- 目录操作" class="headerlink" title="1.2.3 目录操作"></a>1.2.3 目录操作</h3><table><thead><tr><th>序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>01</td><td>listdir</td><td>目录列表</td><td><code>os.listdir(目录名)</code></td></tr><tr><td>02</td><td>mkdir</td><td>创建目录</td><td><code>os.mkdir(目录名)</code></td></tr><tr><td>03</td><td>rmdir</td><td>删除目录</td><td><code>os.rmdir(目录名)</code></td></tr><tr><td>04</td><td>chdir</td><td>修改工作目录</td><td><code>os.chdir(目标目录)</code></td></tr><tr><td>05</td><td>makedirs</td><td>生成多层递归目录</td><td><code>os.makedirs(目标目录)</code></td></tr><tr><td>06</td><td>path.isdir</td><td>判断文件或目录是否存在</td><td><code>os.path.isdir(文件路径)</code></td></tr><tr><td>07</td><td>path.exists</td><td>判断文件是否存在</td><td><code>os.path.exists(文件路径)</code></td></tr><tr><td>08</td><td>path.isfile</td><td>判断是否为文件</td><td><code>os.path.isfile(文件路径)</code></td></tr><tr><td>09</td><td>path.join</td><td>连接目录与文件</td><td><code>os.path.join(path,name)</code></td></tr><tr><td>10</td><td>path.getsize</td><td>返回文件大小</td><td><code>os.path.getsize(文件路径)</code></td></tr><tr><td>11</td><td>path.abspath</td><td>返回绝对路径</td><td><code>os.path.abspath(name)</code></td></tr><tr><td>12</td><td>path.dirname</td><td>返回文件路径</td><td><code>os.path.dirname(name)</code></td></tr></tbody></table><blockquote><p>提示：文件或者目录操作都支持 相对路径 和 绝对路径</p></blockquote><pre><code class="python">// 判断目录是否存在，存在则删除import osfile_path=&#39;images&#39;if  os.path.exists(file_path):    os.rmdir(file_path)</code></pre><h1 id="2-excel"><a href="#2-excel" class="headerlink" title="2. excel"></a>2. excel</h1><blockquote><p>openpyxl 是一个 Python 库，用于读取 / 写入 Excel 2010 xlsx / xlsm / xltx / xltm 文件。</p><p>它的诞生是因为缺少可从 Python 本地读取 / 写入 Office Open XML 格式的库。</p></blockquote><p>官方文档：<a href="https://openpyxl.readthedocs.io/en/stable/usage.html#write-a-workbook">https://openpyxl.readthedocs.io/en/stable/usage.html#write-a-workbook</a></p><p><strong>Excel 文件三个对象</strong></p><pre><code>workbook： 工作簿，一个 excel 文件包含多个 sheet。sheet：工作表，一个 workbook 有多个，表名识别，如“sheet1”，“sheet2”等。cell： 单元格，存储数据对象</code></pre><p>1、openpyxl 读写单元格时，单元格的坐标位置起始值是（1，1），即下标最小值为 1，否则报错！</p><p>2、openpyxl 支持直接横纵坐标访问，如 A1，B2…</p><h2 id="2-1- 创建工作簿"><a href="#2-1- 创建工作簿" class="headerlink" title="2.1 创建工作簿"></a>2.1 创建工作簿 </h2><p> 只需导入<code>Workbook</code> 对象就可以创建工作簿</p><pre><code>from openpyxl import Workbook# 创建工作簿wb = Workbook()</code></pre><p>如果想写入数据就需要获取一张表</p><p>表明创建时会自动命名。它们按顺序编号（Sheet，Sheet1，Sheet2 等）。可以随时通过 <code>Worksheet.title</code> 属性更改此名称：</p><pre><code># 创建一张表ws = wb.activews.title = &#39; 表 1&#39;# 创建新表ws2 = wb.create_sheet(&#39; 表 2&#39;)# 通过表名获取表ws = wb[&#39; 表 1&#39;]</code></pre><h2 id="2-2- 写入操作"><a href="#2-2- 写入操作" class="headerlink" title="2.2 写入操作"></a>2.2 写入操作 </h2><p> 现在我们知道了如何获取工作表，可以开始修改单元格内容了。单元格可以直接作为工作表的键进行访问：</p><p>这将使单元格返回 A4，如果尚未存在，则创建一个单元格。可以直接分配值：</p><pre><code class="python"># 写入值ws[&#39;A1&#39;] = 42</code></pre><p>还有 <code>Worksheet.cell()</code> 方法可以更方便操作。</p><pre><code class="python">ws.cell(row=2, column=5).value = 99ws.cell(row=3, column=5, value=100)</code></pre><p><strong>逐行写</strong></p><pre><code class="python"># 行内容可以直接被列表覆盖# ws.append(iterable)# 添加一行到当前 sheet 的最底部（即逐行追加从第一行开始）# iterable 必须是 list,tuple,dict,range,generator 类型的。# 1，如果是 list，将 list 从头到尾顺序添加。# 2，如果是 dict，按照相应的键添加相应的键值。ws.append([&#39;This is A1&#39;， &#39;This is B1&#39;， &#39;This is C1&#39;])ws.append(&#123;&#39;A&#39;: &#39;This is A1&#39;， &#39;C&#39;: &#39;This is C1&#39;&#125;)ws.append(&#123;1: &#39;This is A1&#39;， 3: &#39;This is C1&#39;&#125;)</code></pre><p><strong>同时可以遍历单元格</strong></p><h2 id="2-3- 案例"><a href="#2-3- 案例" class="headerlink" title="2.3 案例:"></a>2.3 案例:</h2><p>将九九乘法表写入 excel 表</p><pre><code class="python"># 写入九九乘法表ws9 = wb.create_sheet(&#39; 九九乘法表 &#39;)i = 1while i &lt; 10:    j = 1    while j &lt;= i:        # print(&#39;&#123;&#125; * &#123;&#125; = &#123;&#125;&#39;.format(j， i， j * i)， end=&#39;\t&#39;)        ws9.cell(row=i， column=j).value = &#39;&#123;&#125; * &#123;&#125; = &#123;&#125;&#39;.format(j， i， j * i)        j += 1    i += 1 </code></pre><h2 id="2-4- 读表操作"><a href="#2-4- 读表操作" class="headerlink" title="2.4 读表操作"></a>2.4 读表操作</h2><pre><code class="python"># 打开文件：from openpyxl import load_workbookwb = load_workbook(&#39;sample.xlsx&#39;)# 通过表名获取获取 sheet：table = wb[&#39; 九九乘法表 &#39;]# 获取行数和列数：rows = table.max_rowcols = table.max_columnprint(rows, cols)# 获取单元格值：# 获取表格内容, 是从第一行第一列是从 1 开始的, 注意不要丢掉 .valueData = table.cell(row=1, column=1).valueprint(Data)# 获取所有表名sheet_names = wb.sheetnamesprint(sheet_names[0])ws = wb[(wb.sheetnames[0])]  # index 为 0 为第一张表# 活动表表名print(wb.active.title)</code></pre><p>逐行读取</p><pre><code class="python"># 逐行读 ws9[&#39;A1:I9&#39;]: 例如(&#39;A1:C4&#39;)# 返回一个生成器， 注意取值时要用 value，例如：for row in table[&#39;A1:I9&#39;]:    for cell in row:        print(cell.value)</code></pre><p>显示有多少张表</p><pre><code>print(wb.sheetnames)# 显示表名，表行数，表列数print(ws9.title)print(ws9.max_row)print(ws9.max_column)</code></pre><p> 保存文件</p><pre><code>wb.save(&quot;sample1.xlsx&quot;)</code></pre><h2 id="2-5- 操作实例"><a href="#2-5- 操作实例" class="headerlink" title="2.5 操作实例"></a>2.5 操作实例 </h2><p> 将猫眼爬虫的数据保存到 Excel 表。</p><h1 id="3-json"><a href="#3-json" class="headerlink" title="3. json"></a>3. json</h1><p><strong>目的：</strong> 将 Python 对象编码为 JSON 字符串，或将 JSON 字符串解码为 Python 对象。</p><p><code>json</code> 模块提供了 API，将内存中的 Python 对象转换为 JSON 序列。JSON 具有以多种语言（尤其是 JavaScript）实现的优点。它在 REST API 中 Web 服务端和客户端之间的通信被广泛应用，同时对于应用程序间通信需求也很有用。 </p><h2 id="3-1- 两个主要方法"><a href="#3-1- 两个主要方法" class="headerlink" title="3.1 两个主要方法"></a>3.1 两个主要方法 </h2><h3 id="3-1-1-json-loads"><a href="#3-1-1-json-loads" class="headerlink" title="3.1.1 json.loads()"></a>3.1.1 <strong>json.loads()</strong></h3><p> 作用：把 Json 格式字符串解码转换成 Python 字典对象 。<strong>字符串——&gt; 字典</strong> （称之为反序列化）</p><pre><code class="python">import jsonjson_str=&#39;&#123;&quot;name&quot;: &quot;ACME&quot;,&quot;shares&quot;:&quot;100&quot;,&quot;price&quot; :&quot;542.23&quot;&#125;&#39;   //json 数据dict_data=json.loads(json_str)print(type(dict_data),dict_data)// 输出结果如下：&lt;class &#39;dict&#39;&gt; &#123;&#39;name&#39;: &#39;ACME&#39;, &#39;shares&#39;: &#39;100&#39;, &#39;price&#39;: &#39;542.23&#39;&#125;</code></pre><p><strong>注意：json 中的字符串只能是双引号包围。它也是一种数据格式</strong></p><p>注意区分：json.load()用于从 json 文件中读取数据。以下举例说明：</p><pre><code class="python">import jsonfile=open(&#39;novel.json&#39;,mode=&#39;r&#39;,encoding=&#39;utf-8&#39;)a=json.load(file)   // 注意这里 file 只能有一行才能读取print(type(a))// 输出结果如下：&lt;class &#39;dict&#39;&gt;</code></pre><blockquote><p>总结，json.loads 读取内存里的数据，json.load 读取文件中的数据。都是把数据反序列化。</p></blockquote><h3 id="3-1-2-json-dumps"><a href="#3-1-2-json-dumps" class="headerlink" title="3.1.2 json.dumps()"></a>3.1.2 <strong>json.dumps()</strong></h3><p>作用：把 Python 字典对象解码转换成 Json 格式字符串。<strong>字典——&gt; 字符串</strong> （称之为序列化）</p><pre><code class="python">import jsondict_data=&#123;&#39;name&#39;: &#39;ACME&#39;,&#39;shares&#39;:100,&#39;price&#39; :542.23&#125;json_str=json.dumps(dict_data)print(type(json_str),json_str)// 输出结果如下：&lt;class &#39;str&#39;&gt; &#123;&quot;name&quot;: &quot;ACME&quot;, &quot;shares&quot;: 100, &quot;price&quot;: 542.23&#125;</code></pre><p>注意区分： json.dump()作用是将 dict 类型的数据转成 str，并写入到 json 文件中，以下举例说明：</p><pre><code class="python">import jsondict_data=&#123;&#39;name&#39;: &quot; 马克 &quot;,&quot;shares&quot;:100,&quot;price&quot; :542.23&#125;json.dump(dict_data,open(&#39;file.json&#39;,&#39;w&#39;),ensure_ascii=False)// 结果：将 dict_data 写入到本地</code></pre><h2 id="3-2- 保存为 Json"><a href="#3-2- 保存为 Json" class="headerlink" title="3.2 保存为 Json"></a>3.2 保存为 Json</h2><p>以 json 格式保存文件</p><pre><code class="python">import jsondata = &#123;    &#39;name&#39;: &#39; 青灯 &#39;,    &#39;shares&#39;: 100,    &#39;price&#39;: 542.23&#125;json_str = json.dumps(data) // 将字典序列化为 json// 写入 json 数据with open(&#39;data.json&#39;, mode=&#39;w&#39;, encoding=&#39;utf-8&#39;) as f:    f.write(json_str)</code></pre><p>输出结果如下：</p><pre><code class="python">// 本地的 data.json 文件打开如下&#123;&quot;name&quot;: &quot;\u9752\u706f&quot;, &quot;shares&quot;: 100, &quot;price&quot;: 542.23&#125;</code></pre><p>解决办法: <code>json_str = json.dumps(data, ensure_ascii=False)</code></p><h1 id="4-CSV 模块简介"><a href="#4-CSV 模块简介" class="headerlink" title="4. CSV 模块简介"></a>4. CSV 模块简介</h1><p>csv 文件格式是一种通用的电子表格和数据库导入导出格式。最近我调用 RPC 处理服务器数据时，经常需要将数据做个存档便使用了这一方便的格式。</p><p>python 中有一个读写 csv 文件的包，直接 import csv 即可。利用这个 python 包可以很方便对 csv 文件进行操作，一些简单的用法如下。</p><h2 id="4-1- 写入文件"><a href="#4-1- 写入文件" class="headerlink" title="4.1 写入文件"></a>4.1 写入文件 </h2><p> 我们把需要写入的数据放到列表中，写文件时会把列表中的元素写入到 csv 文件中。</p><pre><code class="python">import csvll = [[1, 2, 3, 4],      [1, 2, 3, 4],      [5, 6, 7, 8],      [5, 6, 7, 8]]with open(&#39;example1.csv&#39;, &#39;w&#39;, newline=&#39;&#39;) as csvfile:    &quot;&quot;&quot;    delimiter: 分割符    &quot;&quot;&quot;    spamwriter = csv.writer(csvfile, delimiter=&#39;,&#39;)    for l in ll:        spamwriter.writerow([1, 2, 3, 4])</code></pre><blockquote><p>可能遇到的问题：直接使用这种写法会导致文件每一行后面会多一个空行。使用 <code>newline=&#39;&#39;</code> 解决</p></blockquote><p><strong>使用 open 直接写入</strong></p><pre><code> with open(&#39;example2.csv&#39;, &#39;w&#39;) as csvfile:    &quot;&quot;&quot;    delimiter: 分割符    &quot;&quot;&quot;    for l in ll:        csvfile.write(&quot;,&quot;.join(map(str, l)))        csvfile.write(&#39;\n&#39;)</code></pre><h2 id="4-2- 读取文件"><a href="#4-2- 读取文件" class="headerlink" title="4.2 读取文件"></a>4.2 读取文件</h2><pre><code class="python">import csvwith open(&#39;example.csv&#39;, encoding=&#39;utf-8&#39;) as f:    csv_reader = csv.reader(f)    for row in csv_reader:        print(row)</code></pre><p><code>file:example.csv</code> <code>csv</code> 数据</p><pre><code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;][&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;][&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;][&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]</code></pre><p>默认的情况下， 读和写使用逗号做分隔符(delimiter)，当遇到特殊情况是，可以根据需要手动指定字符， 例如:</p><pre><code class="python">with open(&#39;example.csv&#39;, encoding=&#39;utf-8&#39;) as f:    reader = csv.reader(f, delimiter=&#39;,&#39;)    for row in reader:        print(row)</code></pre><p>上述示例指定冒号作为分隔符</p><p>有点需要注意的是，当用 writer 写数据时， <code>None</code> 会被写成空字符串，浮点类型会被调用 <code>repr()</code> 方法转化成字符串。所以非字符串类型的数据会被 <code>str()</code> 成字符串存储。所以当涉及到 <code>unicode</code> 字符串时，可以自己手动编码后存储或者使用 csv 提供的 <code>UnicodeWriter</code>。</p><h2 id="4-3- 写入与读取字典"><a href="#4-3- 写入与读取字典" class="headerlink" title="4.3 写入与读取字典"></a>4.3 写入与读取字典</h2><p><code>csv</code> 还提供了一种类似于字典方式的读写，方式如下:</p><pre><code class="python">class csv.DictReader(csvfile， fieldnames=None， restkey=None， restval=None， dialect=&#39;excel&#39;， *args， **kwds)class csv.DictWriter(csvfile， fieldnames， restval=&#39;&#39;， extrasaction=&#39;raise&#39;， dialect=&#39;excel&#39;， *args， **kwds)</code></pre><p>其中 fieldnames 指定字典的 key 值，如果 reader 里没有指定那么默认第一行的元素，在 writer 里一定要指定这个。 </p><pre><code class="python"># %% 写import csvwith open(&#39;names.csv&#39;, &#39;w&#39;) as csvfile:    fieldnames = [&#39;first_name&#39;, &#39;last_name&#39;]    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)    writer.writeheader()    writer.writerow(&#123;&#39;first_name&#39;: &#39;Baked&#39;, &#39;last_name&#39;: &#39;Beans&#39;&#125;)    writer.writerow(&#123;&#39;first_name&#39;: &#39;Lovely&#39;&#125;)    writer.writerow(&#123;&#39;first_name&#39;: &#39;Wonderful&#39;, &#39;last_name&#39;: &#39;Spam&#39;&#125;)</code></pre><pre><code># %% 读import csvwith open(&#39;names.csv&#39;, newline=&#39;&#39;) as csvfile:    reader = csv.DictReader(csvfile)    for row in reader:        print(row[&#39;first_name&#39;], row[&#39;last_name&#39;])</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫基础入门</title>
      <link href="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1、爬虫简介"><a href="#1、爬虫简介" class="headerlink" title="1、爬虫简介"></a>1、爬虫简介 </h1><h2 id="1-1- 爬虫分类"><a href="#1-1- 爬虫分类" class="headerlink" title="1.1 爬虫分类"></a>1.1 爬虫分类</h2><h3 id="1-1-1- 通用爬虫"><a href="#1-1-1- 通用爬虫" class="headerlink" title="1.1.1 通用爬虫"></a>1.1.1 通用爬虫</h3><p> 通用网络爬虫是捜索引擎抓取系统（Baidu、Google、Sogou 等）的一个重要组成部分。主要目的是将互联网上的网页下载到本地，形成一个互联网内容的镜像备份。为搜索引擎提供搜索支持。主要是提供检索服务，网站排名。</p><p>搜索引擎去成千上万个网站抓取数据。抓取的是整个网页，不是具体详细的信息。无法提供针对具体某个客户需求的搜索结果</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1559978600808.png" alt=""></p><h3 id="1-1-2- 聚焦爬虫"><a href="#1-1-2- 聚焦爬虫" class="headerlink" title="1.1.2 聚焦爬虫"></a>1.1.2 聚焦爬虫 </h3><p> 聚焦爬虫，是”面向特定主题需求”的一种网络爬虫程序，它与通用搜索引擎爬虫的区别在于： <strong>聚焦爬虫在实施网页抓取时会对内容进行处理筛选，尽量保证只抓取与需求相关的网页数据。</strong></p><p>后续探讨的是 <strong>聚焦爬虫</strong>。</p><h2 id="1-2-Robots 协议"><a href="#1-2-Robots 协议" class="headerlink" title="1.2 Robots 协议"></a>1.2 Robots 协议</h2><p>robots 是网站跟爬虫间的协议，用简单直接的 txt 格式文本方式告诉对应的爬虫被允许的权限，也就是说 robots.txt 是搜索引擎中访问网站的时候要查看的第一个文件。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在 robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。</p><p>Robots 协议也叫爬虫协议、机器人协议等，全称是“网络爬虫排除标准”（Robots Exclusion Protocol），<strong>网站通过 Robots 协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取</strong>。</p><p>怎么看 robots 协议：网站主域名 +robots.txt</p><p>如：淘宝：<a href="https://www.taobao.com/robots.txt">https://www.taobao.com/robots.txt</a></p><h2 id="1-3-HTTP 协议"><a href="#1-3-HTTP 协议" class="headerlink" title="1.3 HTTP 协议"></a>1.3 HTTP 协议</h2><ul><li>HTTP 协议（HyperText Transfer Protocol，超文本传输协议）：是一种发布和接收 HTML 页面的方法。</li><li>HTTPS（Hypertext Transfer Protocol over Secure Socket Layer）简单讲是 HTTP 的安全版，在 HTTP 下加入 SSL 层。</li></ul><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1559979143803.png" alt=""></p><h3 id="1-3-1- 请求与响应"><a href="#1-3-1- 请求与响应" class="headerlink" title="1.3.1 请求与响应"></a>1.3.1 请求与响应</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1559979266295.png" alt=""></p><ol><li>当我们在浏览器输入 URL 的时候，浏览器发送一个 Request 请求去获取目标 URL 的 html 文件，服务器把 Response 返回文件对象发送回给浏览器。</li><li>浏览器分析 Response 中的 HTML，发现其中引用了很多其他文件，比如 Images 文件，CSS 文件，JS 文件。 浏览器会自动再次发送 Request 去获取图片，CSS 文件，或者 JS 文件。 </li><li>当所有的文件都下载成功后，网页会根据 HTML 语法结构，完整的显示出来了。</li></ol><h3 id="1-3-2-URL 请求"><a href="#1-3-2-URL 请求" class="headerlink" title="1.3.2 URL 请求"></a>1.3.2 URL 请求 </h3><p>URL 又叫作<strong> 统一资源定位符</strong>，是用于完整地描述 Internet 上网页和其他资源的地址的一种方法。类似于 Windows 的文件路径。</p> <center><font size=8 face="Times New Roman">http://mail.163.com/index.html</font></center>** 一个网址的组成：**<ol><li><p>http://:  这个是协议，也就是 HTTP 超文本传输协议，也就是网页在网上传输的协议。</p></li><li><p>mail：这个是服务器名，代表着是一个邮箱服务器，所以是 mail。</p></li><li><p>163.com: 这个是域名，是用来定位网站的独一无二的名字。</p></li><li><p>mail.163.com： 这个是网站名，由服务器名 + 域名组成。</p></li><li><p>/： 这个是根目录，也就是说，通过网站名找到服务器，然后在服务器存放网页的根目录。</p></li><li><p>index.html： 这个是根目录下的网页。</p></li><li><p><a href="http://mail.163.com/index.html">http://mail.163.com/index.html</a> 这个叫做 URL，统一资源定位符，全球性地址，用于定位网上的资源。</p></li></ol><p><strong>请求方法：</strong></p><p>最主要分两种：</p><ol><li><code>get</code>请求：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会使用 <code>get</code> 请求。</li><li><code>post</code>请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响的时候会使用 <code>post</code> 请求。 </li></ol><h2 id="1-4- 关于编码"><a href="#1-4- 关于编码" class="headerlink" title="1.4 关于编码"></a>1.4 关于编码</h2><p>ASCII 码：处理英文字符而发明的</p><p>GB2312：为了处理中文字符发明的</p><p>GBK：中文拓展库，加入繁体，亚裔文字编码。</p><p>Unicode：万国码，包含世界范围的语言编码</p><p>UTF-8：为了提高 Unicode 存储和传输性能。</p><h1 id="2、requests 请求"><a href="#2、requests 请求" class="headerlink" title="2、requests 请求"></a>2、requests 请求</h1><ul><li>Requests 模块就是 Python 实现的简单易用的 <strong>HTTP 库</strong></li></ul><p>还有其他库例如 <code>urllib</code>，<code>urllib2</code> 等模块。但是目前来说 Requests 模块是最流行的。而且也是做好用的模块。</p><p>requests 库的安装</p><pre><code class="python">pip install requests</code></pre><h2 id="2-1-GET 请求"><a href="#2-1-GET 请求" class="headerlink" title="2.1  GET 请求"></a>2.1  GET 请求 </h2><p><strong> 请求获取数据：</strong></p><pre><code>response = requests.get(url,*karaws)</code></pre><p><strong>requests.get 中包含的方法：</strong></p><table><thead><tr><th align="center">method</th><th>含义</th></tr></thead><tbody><tr><td align="center"><strong>url</strong></td><td>指定 Request 对象的 URL</td></tr><tr><td align="center"><strong>params</strong>（可选）</td><td>指定 Request 对象的查询字符串，可以是字典（Dict）或者字节数组（Bytes）</td></tr><tr><td align="center"><strong>headers</strong>（可选）</td><td>指定 Request 对象的 HTTP 头部内容，是以字典（Dict）的形式</td></tr><tr><td align="center"><strong>proxies</strong>（可选）</td><td>指定代理网址，是以字典（Dict）的形式</td></tr><tr><td align="center"><strong>timeout</strong>（可选）</td><td>指定等待服务器响应的超时时间，可以是整形、浮点型，也可以是一个元组 (t1, t2)，如果是元组，那么 t1 表示连接超时，t2 表示读取超时</td></tr><tr><td align="center"><strong>cookies</strong>（可选）</td><td>指定 Request 对象的 cookies 内容，可以是字典（Dict）或者 CookieJar 对象</td></tr><tr><td align="center"><strong>data</strong>（可选）</td><td>指定 Request 对象的 body 内容，可以是字典（Dict）、包含元组的列表 [(key, value)]、字节数组（Bytes）或者类文件对象</td></tr><tr><td align="center">json（可选）</td><td>指定 Request 对象的 body 内容，是以 JSON 格式的形式</td></tr><tr><td align="center">files（可选）</td><td>以字典的形式上传多部分编码文件（{‘name’: file-like-objects} 或 {‘name’: file-tuple}），其中的 file-tuple 可以是一个 2 元组 (‘filename’, fileobj)，也可以是一个 3 元组 (‘filename’, fileobj, ‘content_type’)，还可以是一个 4 元组 (‘filename’, fileobj, ‘content_type’, custom_headers)。注：’content-type’ 是由一个字符串来描述上传的文件类型；custom_headers 是一个类似字典的对象，包含额外的 header 信息</td></tr><tr><td align="center">auth（可选）</td><td>启用 Basic（基础）或 Digest（摘要式）或 Custom（自定义）的 HTTP 认证</td></tr><tr><td align="center">allow_redirects（可选）</td><td>是否允许重定向，Enable（启用）或 disable（禁用）GET/OPTIONS/POST/PUT/PATCH/DELETE/HEAD 的重定向，默认值是 True</td></tr><tr><td align="center">cert（可选）</td><td>如果是字符串，那么是 ssl 客户端证书（.pem）的路径；如果是元组，那么是一个 (‘cert’, ‘key’) 的键值对</td></tr><tr><td align="center">verify（可选）</td><td>可以是一个布尔类型的值，表示是否验证服务器的 TLS 证书；也可以是一个字符串，包含一个 CA 证书的路径。默认值是 True</td></tr><tr><td align="center">stream（可选）</td><td>是否允许流式传输数据（大视频），如果为 False，响应内容会立即下载</td></tr></tbody></table><h3 id="2-1-1- 传递 URL 参数"><a href="#2-1-1- 传递 URL 参数" class="headerlink" title="2.1.1 传递 URL 参数"></a>2.1.1 传递 URL 参数 </h3><p> 给 URL 的查询字符串 (query string) 传递某种数据。如果你是手工构建 URL，也就是通过拼接字符串构造的 URL。那么数据会以键 / 值对的形式置于 URL 中，跟在一个问号的后面。</p><pre><code class="python">import requestspayload = &#123;&#39;key1&#39;: &#39;value1&#39;， &#39;key2&#39;: &#39;value2&#39;&#125;response = requests.get(&quot;http://httpbin.org/get&quot;， params=payload)print(response.url)# 结果如下：http://httpbin.org/get?key2=value2&amp;key1=value1</code></pre><h3 id="2-1-2- 传递请求头"><a href="#2-1-2- 传递请求头" class="headerlink" title="2.1.2 传递请求头"></a>2.1.2 传递请求头 </h3><p> 为了将爬虫伪装成浏览器访问，以躲过目标网站的屏蔽，可以给爬虫添加请求头信息。</p><pre><code>header=&#123;&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#39;&#125;response=requests.get(url, headers=header)</code></pre><h3 id="2-1-3- 传递代理 ip"><a href="#2-1-3- 传递代理 ip" class="headerlink" title="2.1.3 传递代理 ip"></a>2.1.3 传递代理 ip</h3><p>有时候仅仅传递请求头并不能躲避目标网站的封锁，这时候可以再加代理 ip，搭建代理 ip 池，实现匿名访问。</p><pre><code class="python">ipset=[&#39;134.209.13.16:8080&#39;,&#39;134.203.13.14:8080&#39;]response=requests.get(url, proxies=&#123;&#39;http&#39;:random.choice(ipset)&#125;)</code></pre><h3 id="2-1-4-response 返回"><a href="#2-1-4-response 返回" class="headerlink" title="2.1.4 response 返回"></a>2.1.4 response 返回</h3><pre><code class="python">print(response)  // 打印状态码   r.status_code 也可以print(response.text) // 打印返回的文本信息print(response.content)  // 打印返回的二进制信息，用于图片，视频，音频等print(response.encoding) // 打印网页的编码信息print(response.json())   // 打印 json 解码的 response 对象print(response.url)    // 打印网页的请求 urlprint(response.apparent_encoding)  // 返回网页的编码信息</code></pre><p>除了一些常用的，还包括一下这些内容：</p><pre><code>In [5]: response.apparent_encoding     cookies                   historyiter_lines            ok                        close                 elapsed               is_permanent_redirect     json                  raise_for_status      connection                encoding              is_redirect           links                     raw                   content               headers                   iter_content          next                  reason                    url.....</code></pre><h3 id="2-1-5- 文本乱码"><a href="#2-1-5- 文本乱码" class="headerlink" title="2.1.5 文本乱码"></a>2.1.5 文本乱码 </h3><p> 添加解码信息</p><p>添加一行</p><pre><code>response.encoding=&#39;utf-8&#39;</code></pre><p>万能解码</p><pre><code>response.encoding = response.apparent_encoding</code></pre><h2 id="2-2-POST 请求"><a href="#2-2-POST 请求" class="headerlink" title="2.2 POST 请求"></a>2.2 POST 请求</h2><p>POST 请求主要用来提交表单数据，然后服务器根据表单数据进行分析，再决定返回什么样的数据给客户端。</p><pre><code>response=requests.post(url, data=formdata, headers=headers,*karaws)</code></pre><p>post 请求除了要传递目标 url 以外，还需要传递表单数据给 data。</p><p>如：</p><pre><code>headers = &#123;    &#39;Cookie&#39;: cookies_str,    &#39;Host&#39;: &#39;www.lagou.com&#39;,    &#39;Origin&#39;: &#39;https://www.lagou.com&#39;,    &#39;Referer&#39;: &#39;https://www.lagou.com/jobs/list_python?labelWords=&amp;fromSearch=true&amp;suginput=&#39;,    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36&#39;,&#125;# post 的表单数据formdata = &#123;    &#39;first&#39;: &#39;true&#39;,    &#39;pn&#39;: &#39;1&#39;,    &#39;kd&#39;: &#39;python&#39;&#125;# 提交数据response = requests.post(url, data=formdata, headers=headers)# 查看数据print(response.json())</code></pre><h2 id="2-3-HTTP 响应报文"><a href="#2-3-HTTP 响应报文" class="headerlink" title="2.3 HTTP 响应报文"></a>2.3 HTTP 响应报文</h2><p>HTTP 响应报文也由三部分组成：响应行、响应头、响应体。</p><p>这里主要说说常见的状态码</p><p>总结如下：</p><pre><code>凡是以 2 开头的状态码 都是成功凡是以 4 开有的状态码 都是客户端的问题（请求不存在的内容）凡是以 5 开头的状态吗 都是服务器的问题 </code></pre><p> 如果发送了一个错误请求 (一个 4XX 客户端错误，或者 5XX 服务器错误响应)，我们可以通过 <code>response.raise_for_status()</code> 来抛出异常。</p><p>100~199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。</p><p>200~299：表示成功接收请求并已完成整个处理过程。常用 200</p><p>300~399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用 302(意味着你请求我，我让你去找别人)，307 和 304(我不给你这个资源，自己拿缓存)</p><p>400~499：客户端的请求有错误，常用 404(意味着你请求的资源在 web 服务器中没有)403(服务器拒绝访问，权限不够)</p><p>500~599：服务器端出现错误，常用 500</p><h2 id="2-4- 重定向"><a href="#2-4- 重定向" class="headerlink" title="2.4 重定向"></a>2.4 重定向 </h2><p><a href="https://baike.baidu.com/item/%E9%87%8D%E5%AE%9A%E5%90%91/9064196"> 重定向 </a> (Redirect) 就是通过各种方法将一个网络请求重新定个方向转到其它位置。可能的原因是有些网址现在已经废弃不准备再使用等。</p><p>如果你使用的是 GET、POST 等，那么你可以通过 <code>allow_redirects</code> 参数禁用重定向处理：</p><pre><code class="python">r = requests.get(url， allow_redirects=False)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS 选择器与 Xpath 数据提取</title>
      <link href="/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8EXpath%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/"/>
      <url>/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8EXpath%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1、CSS 选择器"><a href="#1、CSS 选择器" class="headerlink" title="1、CSS 选择器"></a>1、CSS 选择器 </h1><h2 id="1-1- 基本选择器"><a href="#1-1- 基本选择器" class="headerlink" title="1.1 基本选择器"></a>1.1 基本选择器</h2><p> 这里介绍标签选择器，类选择器，ID 选择器。</p><p>一段 html 网页文件，都是包含着众多标签的，如：</p><pre><code>&lt;html&gt;...&lt;/html&gt;&lt;p&gt;...&lt;/p&gt;&lt;span&gt;...&lt;/span&gt;etc...</code></pre><p>我们可以直接选择标签以提取标签里面的内容。</p><p>看看如何使用：</p><pre><code class="python">import requestsfrom parsel import Selectorhtml=requests.get(url).textselector=Selector(html)res=selector.css(&#39;XX&#39;)  // 指标签名。如 p,span 等，返回带标签的列表res=selector.css(&#39;.XX&#39;)  // 指定类名。如 class=&quot;XX&quot;，style=&quot;XX&quot;，返回带类名的列表res=selector.css(&#39;#XX&#39;)  // 指定 id 名。如 id=&quot;XX&quot;，返回带类名的列表print(res.get())print(res.extract())  //.get()和.extract()是一样的print(res.getall)     // 取到 &#39; 标签 / 类 /id 名 &#39; 所有的内容</code></pre><p>属性提取器<code>::</code></p><p>如<code>selector.css(&#39;XX::text&#39;)</code>，可提取 XX 里的文本内容。</p><p><code>selector.css(&#39;XX::attr(属性名称)&#39;)</code>，可提取指定的属性内容</p><p>多层提取</p><p><code>selector.css(&#39;XX.YY::text&#39;)</code>，意思是提取 XX 标签下的 YY 属性里的文本内容。</p><h3 id="举个例子"><a href="# 举个例子" class="headerlink" title="举个例子"></a>举个例子 </h3><p> 有如下 <code>maoyan.html</code> 文件，需要提取里面的电影名称，演员，上映时间等信息。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20210406155343374.png" alt=""></p><pre><code class="python">from parsel import Selectorsel=Selector(html)name=sel.css(&#39;p.name&#39;).css(&#39;a::text&#39;).getall()   // 首先提取 p 便签，属性为 name 内容，再进一步里面提取 a 标签里的文本star=sel.css(&#39;p.star::text&#39;).getall()   // 首先提取 p 便签，属性为 star 内容，再提取文本releasetime=sel.css(&#39;p.releasetime::text&#39;).getall()// 首先提取 p 便签，属性为 releasetime 内容，再提取文本</code></pre><h2 id="1-2- 进阶选择器"><a href="#1-2- 进阶选择器" class="headerlink" title="1.2 进阶选择器"></a>1.2 进阶选择器 </h2><h3 id="伪类选择器"><a href="# 伪类选择器" class="headerlink" title="伪类选择器"></a> 伪类选择器</h3><p><code>:</code> 伪类选择器，通过索引选择。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-27_19-17-23.png" alt=""></p><pre><code class="python">dd5=selector.css(&#39;div.main dd:nth-child(4)&#39;)   // 选择第五个标签内容dd_last=selector.css(&#39;div.main dd:last-child&#39;) // 选择最后一个 dd 标签</code></pre><p>更多用法：<a href="https://www.runoob.com/css/css-pseudo-classes.html">https://www.runoob.com/css/css-pseudo-classes.html</a></p><h1 id="2-XPath 选择器"><a href="#2-XPath 选择器" class="headerlink" title="2. XPath 选择器"></a>2. XPath 选择器</h1><h2 id="2-1-XML 介绍"><a href="#2-1-XML 介绍" class="headerlink" title="2.1 XML 介绍"></a>2.1 XML 介绍</h2><p>XML 称为可扩展标记语言，XML 是互联网数据传输的重要工具，它可以跨越互联网任何的平台，不受编程语言和操作系统的限制，可以说它是一个拥有互联网最高级别通行证的数据携带者。非常类似 HTML。</p><p>HTML 和 XML 的区别在于 HTML 主要用来显示数据，XML 是用来传输数据。</p><p>XML 都是标签闭合的。例如：<code>&lt;bookstore&gt; ... &lt;/bookstore&gt;</code>成对出现。</p><ul><li>正则：提取文字</li></ul><ul><li>css 选择器：提取网页</li></ul><ul><li>xpath：xml 节点</li></ul><pre><code class="python">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;bookstore&gt;  &lt;book category=&quot; 奇幻 &quot;&gt;    &lt;title lang=&quot;ch&quot;&gt; 冰与火之歌 &lt;/title&gt;    &lt;author&gt; 乔治 马丁 &lt;/author&gt;    &lt;year&gt;2005&lt;/year&gt;    &lt;price&gt;365.00&lt;/price&gt;  &lt;/book&gt;  &lt;book category=&quot; 童话 &quot;&gt;    &lt;title lang=&quot;ch&quot;&gt; 哈利波特与死亡圣器 &lt;/title&gt;    &lt;author&gt;J K. 罗琳 &lt;/author&gt;    &lt;year&gt;2005&lt;/year&gt;    &lt;price&gt;48.98&lt;/price&gt;  &lt;/book&gt;</code></pre><h2 id="2-2-xpath"><a href="#2-2-xpath" class="headerlink" title="2.2 xpath"></a>2.2 xpath</h2><p>XPath (XML Path Language) 是一门在 XML 文档中查找信息的语言，可用来在 XML/HTML 文档中对元素和属性进行遍历，并提取相应元素。</p><p><strong>使用 xpath 提取元素，需要有标签节点才能实现！</strong></p><h3 id="2-2-1- 提取规则"><a href="#2-2-1- 提取规则" class="headerlink" title="2.2.1 提取规则"></a>2.2.1 提取规则</h3><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>//</td><td>当前节点下任意子孙节点下的内容</td></tr><tr><td>./</td><td>当前节点下直接子节点的内容</td></tr><tr><td>.//</td><td>当前节点下任意子孙节点的内容</td></tr><tr><td>/</td><td>选取直接子节点</td></tr><tr><td>.</td><td>当前节点</td></tr><tr><td>..</td><td>当前节点的父节点</td></tr><tr><td>[]</td><td>中括号里指定需要选择的属性</td></tr><tr><td>@</td><td>选择属性</td></tr><tr><td>[@class=’name’]</td><td>选择属性名为 class，且值为‘name’的内容</td></tr><tr><td>|</td><td>选择左右两个节点</td></tr><tr><td>*</td><td>替换任何标签</td></tr><tr><td>book[1]</td><td>选取第一个 book 元素</td></tr><tr><td>//li[contains(@attrib,value)]</td><td>选取任意节点下有 li 标签且包含 attrib 和 value 属性的内容</td></tr><tr><td>//li[text()=”xxx”]</td><td>选取任意节点下有 li 标签且其文本为 xxx 的内容</td></tr><tr><td>//li/text()</td><td>选取任意节点下 li 标签下的文本内容</td></tr><tr><td>//li/a/@href</td><td>选取任意节点下 li 标签的子标签 a 属性名为 href 对应的属性值</td></tr></tbody></table><h3 id="举个例子 -1"><a href="# 举个例子 -1" class="headerlink" title="举个例子"></a><strong>举个例子 </strong></h3><p><strong> 批量提取：</strong>url=<a href="http://music.taihe.com/artist/2517">http://music.taihe.com/artist/2517</a></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-28_13-39-58.png" alt=""></p><pre><code class="python">import requestsfrom parsel import Selectorresponse=requests.get(url,headers=headers)response.encoding=&#39;utf-8&#39;html=Selector(response.text)lis=html.xpath(&#39;//div[@class=&quot;song-list-wrap&quot;]/ul/li&#39;) // 首先取到 li 标签，进行粗提取print(lis)// 输出结果 15    // 一个页面有 15 首歌曲，故也应该有 15 个 li 标签</code></pre><p>再分析 <code>li</code> 标签内的内容，进行具体信息提取：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-28_13-44-56.png" alt=""></p><p>上图截取了第一个 <code>li</code> 标签里的所有内容</p><pre><code class="python">for li in lis:    name=li.xpath(&#39;.//span[@class=&quot;songname&quot;]/a/text()&#39;).getall()[0].strip()    print(name)    // 打印歌曲名字// 其他内容提取方式相同...</code></pre><h1 id="3、异常处理"><a href="#3、异常处理" class="headerlink" title="3、异常处理"></a>3、异常处理</h1><p><strong>css 选择器遇见含空格类提取问题：</strong></p><p><strong>response.css(“.position-label.clearfix .labels::text”).extract() 即在 position-label clearfix 中的”空格”换成” . “</strong> </p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS-Xpath </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式详解</title>
      <link href="/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
      <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介 </h1><p> 正则表达式（Regular expressions 也称为 REs，或 regexes 或 regex patterns）本质上是一个微小的且高度专业化的编程语言。这个概念最初是由 <a href="https://baike.baidu.com/item/Unix">Unix</a> 中的工具软件（例如 sed 和<a href="https://baike.baidu.com/item/grep/5997841">grep</a>）普及开的。</p><p>正则表达式是对 <strong> 字符串操作 </strong> 的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。给定一个正则表达式和另一个字符串，可以通过正则表达式从字符串中获取我们想要的特定部分。正则表达式灵活性、逻辑性和功能性非常强，可以迅速地用极简单的方式达到字符串额复杂控制，但对于共接触的人来说比较晦涩难懂。由于 <strong> 正则表达式主要应用对象是文本</strong>，因此他在各种文本编辑器场合都有应用。</p><p><strong>Python 的正则表达式引擎是用 C 语言写的，所以效率是极高的。可以帮我们处理 98.3% 的文本任务。</strong></p><h2 id="1-1- 处理字符串主要有四大功能"><a href="#1-1- 处理字符串主要有四大功能" class="headerlink" title="1.1 处理字符串主要有四大功能"></a>1.1 处理字符串主要有四大功能</h2><ul><li><p><strong>匹配</strong> 查看一个字符串是否符合正则表达式的语法，一般返回 true 或者 false</p></li><li><p><strong>获取</strong>   正则表达式来提取字符串中符合要求的文本</p></li><li><p><strong>替换</strong>   查找字符串中符合正则表达式的文本，并用相应的字符串替换</p></li><li><p><strong>分割</strong>   使用正则表达式对字符串进行分割。</p></li></ul><h1 id="2、字符匹配与获取"><a href="#2、字符匹配与获取" class="headerlink" title="2、字符匹配与获取"></a>2、字符匹配与获取</h1><h2 id="2-1- 简单使用"><a href="#2-1- 简单使用" class="headerlink" title="2.1 简单使用"></a>2.1 简单使用</h2><h3 id="2-1-1- 导入库"><a href="#2-1-1- 导入库" class="headerlink" title="2.1.1 导入库"></a>2.1.1 导入库</h3><pre><code class="python">import re</code></pre><h3 id="2-1-2- 方法使用"><a href="#2-1-2- 方法使用" class="headerlink" title="2.1.2 方法使用"></a>2.1.2 方法使用</h3><p>pattern：匹配的正则表达式</p><p>string：要匹配的字符串</p><p>flags：标志位，用于控制正则表达式的匹配方式</p><ol><li><p><code>re.match(pattern,string,flags)</code></p><p>返回 string 中所有与 pattern 相匹配的 <strong> 第一个 </strong> 字符串的 Match 对象，如果字符串没有匹配，则返回 None。</p><p><code>re.match</code>函数只匹配字符串的开始字符。</p><p><strong>返回值函数</strong></p><p>match() 方法一旦匹配成功，就是一个 match object 对象，而 match object 对象有以下方法：</p><ul><li>group() 返回被 RE 匹配的字符串，默认 group(0)</li><li>start() 返回匹配开始的位置</li><li>end() 返回匹配结束的位置</li><li>span()返回一个元组包含匹配 (开始, 结束) 的位置</li></ul></li><li><p><code>re.search(pattern, string, flags)</code></p><p>返回 string 中所有与 pattern 相匹配的 <strong> 第一个 </strong> 字符串的 Match 对象，如果字符串没有匹配，则返回 None。</p><p><code>re.search()</code>方法匹配整个字符串，直到找到一个匹配的对象。</p></li><li><p><code>re.findall(pattern, string, flags)</code></p><p>返回 string 中所有与 pattern 相匹配的 <strong> 全部字符串 </strong> 对象，返回形式为数组.。</p></li><li><p><code>re.finditer(pattern, string, flags)</code></p><p>返回 string 中所有与 pattern 相匹配的 <strong> 全部字串 </strong> 对象，返回形式为迭代器。</p></li><li><p><code>re.compile(pattern, flags)</code></p><p>函数根据一个模式字符串和可选的标志参数返回一个正则表达式对象。</p></li></ol><p><strong>为什么要有 re.compile ?</strong></p><p>该函数根据包含的正则表达式的字符串创建模式对象。可以实现更有效率的匹配。</p><p>在直接使用字符串表示的正则表达式进行 search, match 和 findall 操作时，python 会将字符串转换为正则表达式对象。而使用 compile 完成一次转换之后，在每次使用模式的时候就不用重复转换。</p><h2 id="2-1- 字符匹配模式"><a href="#2-1- 字符匹配模式" class="headerlink" title="2.1 字符匹配模式"></a>2.1 字符匹配模式 </h2><p> 正则表达式 pattern 有两种匹配模式：</p><p><strong>直接匹配</strong>：如正则表达式<code>FishC</code> 将完全匹配字符串 <code>&quot;FishC&quot;</code>，给啥匹配啥，明面上的直接匹配。</p><p><strong>元字符匹配</strong>：正则表达式中定义了一类特殊字符，约定俗成的表达特定含义，进行匹配搜索。</p><h3 id="2-1-1- 直接匹配"><a href="#2-1-1- 直接匹配" class="headerlink" title="2.1.1 直接匹配"></a>2.1.1 直接匹配</h3><pre><code class="python">import rer=re.findall(&#39;Mi&#39;,&#39;Mike is Mifan,is him? &#39;)print(r)rs=re.search(&#39;Mi&#39;,&#39;Mike is Mifan,is him? &#39;)print(rs)print(rs.group())// 输出结果如下[&#39;Mi&#39;, &#39;Mi&#39;]&lt;re.Match object; span=(0, 2), match=&#39;Mi&#39;&gt;Mi</code></pre><h3 id="2-1-2- 元字符匹配"><a href="#2-1-2- 元字符匹配" class="headerlink" title="2.1.2 元字符匹配"></a>2.1.2 元字符匹配 </h3><p><strong> 首先一定要记住以下元字符及其代表的含义：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-26_13-21-19.png" alt=""></p><p><strong>贪婪匹配</strong>：正则表达式一般趋向于最大长度匹配，默认形式。</p><p><strong>非贪婪模式</strong>：在满足匹配时，匹配尽可能短的字符串。匹配到一块字符（可以为空），再去匹配下一处。</p><p><strong>还有反斜杠带来的扩展：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-26_13-21-49.png" alt=""></p><h3 id="2-1-3- 标志位"><a href="#2-1-3- 标志位" class="headerlink" title="2.1.3 标志位"></a>2.1.3 标志位 </h3><p><strong> 还有标志位 flags，用于控制正则表达式的匹配方式：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-26_13-22-18.png" alt=""></p><h3 id="2-1-4- 举例"><a href="#2-1-4- 举例" class="headerlink" title="2.1.4 举例"></a>2.1.4 举例</h3><pre><code class="python">import restr=&#39;Mike is Mifan,his age is 180 years old,and his weight is about 140 pound.&#39;r=re.findall(&#39;his age is (\d+)&#39;,str)print(r)// 输出结果如下[&#39;180&#39;]r=re.findall(&#39;his age is \d+&#39;,str)  // 与上对比，可说明 () 的作用print(r)// 输出结果如下[&#39;his age is 180&#39;]r=re.findall(&#39;his age is (\d+?)&#39;,str)    // 问号前的 \d+ 由于问号，整体变成非贪婪模式print(r)// 输出结果如下[&#39;1&#39;]r=re.findall(&#39;his age is (.+)&#39;,str)  //. 会匹配任何值，再加上 +，则会贪婪匹配后面所有内容print(r)// 输出结果如下[&#39;180 years old,and his weight is about 140 pound.&#39;]r=re.findall(&#39;\d+&#39;,str)print(r)// 输出结果如下[&#39;180&#39;, &#39;140&#39;]r=re.findall(&#39;\d&#39;,str)print(r)// 输出结果如下[&#39;1&#39;, &#39;8&#39;, &#39;0&#39;, &#39;1&#39;, &#39;4&#39;, &#39;0&#39;]r=re.findall(&#39;is about (.*[.]$)&#39;,str)   //[]里填其他字符无效，会取出空值print(r)// 输出结果如下[&#39;140 pound.&#39;]rs = re.search(&#39;is about (.*[.]$)&#39;,str)print(rs)print(rs.group())print(rs.group(1))// 输出结果如下&lt;re.Match object; span=(54, 73), match=&#39;is about 140 pound.&#39;&gt;is about 140 pound.140 pound.r=re.findall(&#39;his (.*)&#39;,str)print(r)rs=re.findall(&#39;his (.*) years&#39;,str)   // 这里的 &#39;[空格]years&#39; 有拦截效果print(rs)ra=re.findall(&#39;his (.*?) years&#39;,str)  print(ra)// 输出结果如下[&#39;age is 180 years old,and his weight is about 140 pound.&#39;][&#39;age is 180&#39;][&#39;age is 180&#39;]// 上面第三个匹配多一个问号的区别在于是非贪婪模式，匹配到一个 &#39;his (.*?) years&#39; 就停止匹配;// 贪婪模式会输出所有符合 &#39;his (.*) years&#39; 的结果r=re.findall(&#39;his (.*?) &#39;,str)  // 注意括号后有空格，若去掉空格，则返回为空print(r)// 输出结果如下[&#39;age&#39;, &#39;weight&#39;]</code></pre><p><strong>小心空格，一不小心就成了拦截符！</strong>，对非贪婪匹配结果有大影响。</p><h1 id="3、字符替换与分割"><a href="#3、字符替换与分割" class="headerlink" title="3、字符替换与分割"></a>3、字符替换与分割 </h1><h2 id="3-1- 方法使用"><a href="#3-1- 方法使用" class="headerlink" title="3.1 方法使用"></a>3.1 方法使用</h2><p> 首先将正则表达式的字符串创建成模式对象，再来使用：</p><p><code>rx = re.compile(pattern, flags)</code></p><ol><li><p><code>rx.split(string,maxsplit)</code>  </p><p>在正则表达式匹配的地方进行分割，并返回一个列表。</p></li><li><p><code>rx.sub(replacement, string, count)</code></p><p>返回替换后的字符串，这个字符串从最左边开始，所有 RE 匹配的地方都替换成 <em>replacement</em></p></li><li><p><code>rx.subn(replacement, string, count)</code> </p><p>返回值为一个包含有两个元素的元组：替换后的字符串，替换的数目</p></li></ol><h1 id="4、常用的正则表达式"><a href="#4、常用的正则表达式" class="headerlink" title="4、常用的正则表达式"></a>4、常用的正则表达式 </h1><p><strong> 邮箱地址（Email）</strong></p><pre><code>pattern = r&quot;([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+)&quot;</code></pre><p><strong>域名（domain）</strong></p><pre><code>pattern = r&quot;http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+&quot;</code></pre><p><strong>IP 地址</strong></p><pre><code>pattern = r&quot;((?:(?:25[0-5]|2[0-4]\d|(?:1\d&#123;2&#125;|[1-9]?\d))\.)&#123;3&#125;(?:25[0-5]|2[0-4]\d|(?:1\d&#123;2&#125;|[1-9]?\d)))&quot;</code></pre><p><strong>电话号码</strong></p><pre><code>pattern = r&quot;\d&#123;3,4&#125;-\d&#123;7,8&#125;&quot;</code></pre><p> <strong>手机号码</strong></p><pre><code>pattern = r&quot;(?:13[0-9]|15[0-9]|17[0678]|18[0-9]|14[57]|09)&#123;1&#125;[0-9]&#123;8&#125;&quot;</code></pre><p><strong>身份证号码（18 位）</strong></p><pre><code>pattern = r&quot;(?:[1-9]\d&#123;5&#125;[12]\d&#123;3&#125;(?:0[1-9]|1[012])(?:0[1-9]|[12][0-9]|3[01])\d&#123;3&#125;[0-9xX])&quot;</code></pre><p><strong>中文字符</strong></p><pre><code>pattern = r&quot;[\u4e00-\u9fa5]&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Seaborn-Pygal-Pyecharts 可视化</title>
      <link href="/Seaborn-Pygal-Pyecharts%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/Seaborn-Pygal-Pyecharts%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Seaborn- 前言"><a href="#1-Seaborn- 前言" class="headerlink" title="1.Seaborn 前言"></a>1.Seaborn 前言</h1><p><strong>Seaborn 和 Matplotlib 同为 Python 最强大的两个可视化库。Seaborn 是在 matplotlib 的基础上进行了更高级的 API 封装，让你能用更少的代码去调用 matplotlib 的方法，从而使得作图更加容易，在大多数情况下使用 seaborn 就能做出很具有吸引力的图，而使用 matplotlib 就能制作具有更多特色的图。应该把 Seaborn 视为 matplotlib 的补充，而不是替代物。</strong></p><p><strong>Seaborn：作图更容易，图像更漂亮。主要的缺点则是定制化能力会比较差，只能实现固化的一些可视化模板类型</strong>。</p><p><strong>Matplotlib：可以实现高度定制化绘图的，高度定制化可以让你获得最符合心意的可视化输出结果，但也因此需要设置更多的参数，因而代码更加复杂一些。</strong></p><p><font size=5 face="微软雅黑">Seaborn 官方文档</font> <a href="http://seaborn.pydata.org/tutorial">http://seaborn.pydata.org/tutorial</a></p><p>建议阅读顺序：Plot aesthetics，Plotting functions，Multi-plot grids。</p><h2 id="1-1- 快速优化图形"><a href="#1-1- 快速优化图形" class="headerlink" title="1.1 快速优化图形"></a><strong>1.1 快速优化图形</strong></h2><p>Seaborn 以多变优雅的绘图风格出名，首先热个身：</p><pre><code>import numpy as npimport seaborn as snsimport matplotlib.pyplot as pltdef sinplot(flip=1):    x = np.linspace(0, 14, 100)    for i in range(1, 7):        plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip)sinplot()  // 输出如图 1sns.set()sinplot()  // 输出如图 2</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-22_17-50-16.png" alt=""></p><p>使用 Seaborn 完成图像快速优化的方法非常简单。只需要将 Seaborn 提供的样式声明代码 <code>sns.set()</code> 放置在绘图前即可。</p><p> <strong><code>sns.set()</code>还可进行细致化设置：</strong></p><pre><code>sns.set(context=, style=, palette=, font=, font_scale=, color_codes=, rc=)</code></pre><ul><li><code>context=</code> 参数控制着默认的画幅大小，分别有 <code>&#123;paper, notebook, talk, poster&#125;</code> 四个值。其中，<code>poster &gt; talk &gt; notebook &gt; paper</code>。</li><li><code>style=</code> 参数控制默认样式，分别有 <code>&#123;darkgrid, whitegrid, dark, white, ticks&#125;</code>，你可以自行更改查看它们之间的不同。默认为<code>darkgrid</code>。</li><li><code>palette=</code> 参数为预设的调色板。分别有 <code>&#123;deep, muted, bright, pastel, dark, colorblind&#125;</code> 等，你可以自行更改查看它们之间的不同。</li><li>剩下的 <code>font=</code> 用于设置字体，<code>font_scale=</code> 设置字体大小，<code>color_codes=</code> 不使用调色板而采用先前的 <code>&#39;r&#39;</code> 等色彩缩写。</li></ul><p><strong>另外，还有两个直接控制风格的函数方法：<code>sns.set_style()</code>和<code>sns.axes_style()</code>。</strong></p><p>其包含两个参数<code>style=</code>，可直接设置样式；<code>rc=</code>，字典值，其参数映射将覆盖预设的 seaborn 样式字典中的值。对于<code>sns.axes_style()</code>，如没有进行赋值，则返回当前默认设置，字典格式数据。</p><h2 id="1-2- 去掉坐标轴"><a href="#1-2- 去掉坐标轴" class="headerlink" title="1.2 去掉坐标轴"></a>1.2 去掉坐标轴</h2><pre><code>sns.despine(offset=,trim=,left=)</code></pre><h2 id="1-3- 临时绘图风格"><a href="#1-3- 临时绘图风格" class="headerlink" title="1.3 临时绘图风格"></a>1.3 临时绘图风格</h2><pre><code>with sns.axes_style(&quot;white&quot;):    // 用来切换绘图风格    ax = f.add_subplot(gs[0, 0])    sinplot1()sinplot2()          //sinplot1()和 sinplot2() 绘图风格不一样</code></pre><h2 id="1-4- 缩放图风格"><a href="#1-4- 缩放图风格" class="headerlink" title="1.4 缩放图风格"></a>1.4 缩放图风格</h2><pre><code>sns.set()  // 重置函数// 包含四个预设，相对大小的顺序，paper，notebook，talk，和 poster</code></pre><pre><code>// 包含四个预设，相对大小的顺序为 paper，notebook，talk，和 postersns.set_context(&quot;paper&quot;)</code></pre><h1 id="2-Seaborn- 绘图 -API"><a href="#2-Seaborn- 绘图 -API" class="headerlink" title="2. Seaborn 绘图 API"></a>2. Seaborn 绘图 API</h1><p>Seaborn 一共拥有 50 多个 API 类，相比于 Matplotlib 数千个的规模，可以算作是短小精悍了。其中，根据图形的适应场景，Seaborn 的绘图方法大致分类 6 类，分别是：</p><p><strong>关联图、类别图、分布图、回归图、矩阵图和组合图。</strong></p><p>而这 6 大类下面又包含不同数量的绘图函数。</p><p>Seaborn 中的 API 分为 Figure-level 和 Axes-level 两种。</p><p>Figure-level 和 Axes-level API 的区别在于，Axes-level 的函数可以实现与 Matplotlib 更灵活和紧密的结合，而 Figure-level 则更像是「懒人函数」，适合于快速应用。</p><h2 id="2-1- 关联图"><a href="#2-1- 关联图" class="headerlink" title="2.1 关联图"></a>2.1 关联图 </h2><p> 关联图的 Figure-level 接口是<a href="http://seaborn.pydata.org/tutorial/relational.html"><code>relplot</code></a>。【relating plot】</p><p>总函数：<code>sns.relplot()</code>，主要有 <strong> 散点图 </strong> 和<strong>折线图</strong> 2 种样式。</p><p>分函数：<code>sns.scatterplot()</code>，<code>sns.lineplot()</code>。</p><pre><code>sns.relplot(x=, y=, data=,kind=, palette=, ax=, hue=, style=,  *kwargs)</code></pre><ul><li><code>x=, y=</code>：传 <code>data=</code> 中的数字自变量和因变量。</li><li><code>data=</code>：DataFrame 类型的数据表。</li><li><code>kind=</code>：指定绘制的图像类型，选项为 <code>&#39;scatter&#39;</code>和<code>&#39;line&#39;</code>，与分函数对应。默认散点图。</li><li><code>palette=</code>：调色板，可指定内置的样式，色彩丰富。</li><li><code>ax=</code>：指定图标绘画在哪个坐标系。</li><li><code>hue=</code>：指定绘制数据的颜色映射集。</li><li><code>style=</code>：赋予不同类别的散点不同的形状映射集</li><li><code>*kwargs</code>：包含<code>size=</code>，指定图点大小映射集；<code>sizes=</code>，既可以是某个具体数值，也可以是映射集。</li></ul><p>分函数用法与之相同，只是不用指定 kind。</p><p><strong>如想水平绘图，交换 xy 数据就行。</strong></p><h2 id="2-2- 类别图"><a href="#2-2- 类别图" class="headerlink" title="2.2 类别图"></a>2.2 类别图 </h2><p> 与关联图相似，类别图的 Figure-level 接口是 <code>catplot</code>。 【categorical plot】</p><p>总函数：<code>sns.catplot()</code>，主要有 <strong> 分类散点图 </strong>，<strong> 分类分布图 </strong>，<strong> 分类估计图</strong> 3 类样式。</p><pre><code>sns.catplot(x=, y=, kind=, data=, palette=, hue=)   // 参数意义同关联图, 默认 kind=&quot;strip&quot;</code></pre><p><a href="http://seaborn.pydata.org/tutorial/categorical.html#categorical-scatterplots"><strong>分类散点图：</strong></a></p><p><code>sns.stripplot()</code>(<code>kind=&quot;strip&quot;</code>)：带状散点图，一个类别的所有点都将沿着与分类变量相对应的轴落在同一位置。</p><p><code>sns.swarmplot()</code> (<code>kind=&quot;swarm&quot;</code>)：带状散点图（散点不重叠），使用防止重叠的算法沿分类轴调整点。它仅适用于相对较小的数据集，但它可以更好地表示观测值的分布。</p><p>例：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201030224405664.png" alt=""></p><p><a href="http://seaborn.pydata.org/tutorial/categorical.html#distributions-of-observations-within-categories"><strong>分类分布图：</strong></a></p><p><code>sns.boxplot()</code> (<code>kind=&quot;box&quot;</code>)：箱线图</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201030224446519.png" alt=""></p><p><code>sns.violinplot()(kind=&quot;violin&quot;)</code>：小提琴图</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201030224536093.png" alt=""></p><p><code>sns.boxenplot()</code> (<code>kind=&quot;boxen&quot;</code>)：增强箱线图</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201030224607358.png" style="zoom:120%;" /><p><a href="http://seaborn.pydata.org/tutorial/categorical.html#statistical-estimation-within-categories"><strong>分类估计图：</strong></a></p><p><code>sns.pointplot()</code>(<code>kind=&quot;point&quot;</code>)：点线图</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20201030224709044.png" alt=""></p><p><code>sns.barplot()</code>(<code>kind=&quot;bar&quot;</code>)：条形图</p><ul><li>分类图中的条形图只是将点线图中的平均值以条形方框展示而已；置信区间还是以线的形式展示。</li></ul><p><code>sns.countplot()</code> (<code>kind=&quot;count&quot;</code>)：计数条形图</p><h2 id="2-3- 分布图"><a href="#2-3- 分布图" class="headerlink" title="2.3 分布图"></a>2.3 分布图 </h2><p> 分布图主要是用于可视化变量的分布情况，一般分为单变量分布和双变量分布。</p><h3 id="2-3-1-jointplot"><a href="#2-3-1-jointplot" class="headerlink" title="2.3.1 jointplot()"></a>2.3.1 jointplot()</h3><p><a href="http://seaborn.pydata.org/generated/seaborn.jointplot.html?highlight=jointplot#seaborn.jointplot"><code>sns.jointplot(x=, y=, data=,kind= color=, *kwargs)</code></a></p><p>kind=“scatter” | “reg” | “resid” | “kde” | “hex” </p><p>主要是用于绘制二元变量分布图。散点图，六边形图，核密度估计</p><h3 id="2-3-2-pairplot"><a href="#2-3-2-pairplot" class="headerlink" title="2.3.2 pairplot()"></a>2.3.2 pairplot()</h3><p><a href="http://seaborn.pydata.org/generated/seaborn.pairplot.html?highlight=pairplot#seaborn.pairplot"><code>sns.pairplot(data=, hue=, vars=， *kwargs)</code></a></p><p>支持一次性将数据集中的特征变量两两对比绘图。默认情况下，对角线上是单变量分布图，而其他则是二元变量分布图。</p><h3 id="2-3-3-distplot"><a href="#2-3-3-distplot" class="headerlink" title="2.3.3 distplot()"></a>2.3.3 distplot()</h3><p><a href="http://seaborn.pydata.org/generated/seaborn.displot.html?highlight=displot#seaborn.displot"><code>sns.distplot(a, bins=, hist=, kde=, color=, label=, *kwargs)</code></a></p><p>绘制单变量分布。直方图，核密度估计，拟合参数分布</p><h3 id="2-3-4-kdeplot"><a href="#2-3-4-kdeplot" class="headerlink" title="2.3.4 kdeplot()"></a>2.3.4 kdeplot()</h3><p><a href="http://seaborn.pydata.org/generated/seaborn.kdeplot.html#seaborn.kdeplot"><code>sns.kdeplot(data, shade=, vertical=, *kwargs)</code></a></p><p>绘制二维核密度图</p><h2 id="2-4- 回归图"><a href="#2-4- 回归图" class="headerlink" title="2.4 回归图"></a>2.4 回归图 </h2><p><a href="http://seaborn.pydata.org/generated/seaborn.lmplot.html?highlight=lmplot#seaborn.lmplot">lmplot()</a> 与<a href="http://seaborn.pydata.org/generated/seaborn.regplot.html?highlight=regplot#seaborn.regplot">regplot()</a></p><p><code>sns.lmplot(x=, y=, hue=, data=, *kwargs)</code></p><p>同样是用于绘制回归图，但 <code>lmplot</code> 支持引入第三维度进行对比</p><p><code>sns.regplot(x=, y=, data=, *kwargs)</code></p><p>绘制回归图时，只需要指定自变量和因变量即可，<code>regplot</code> 会自动完成线性回归拟合。</p><h2 id="2-5- 矩阵图"><a href="#2-5- 矩阵图" class="headerlink" title="2.5 矩阵图"></a>2.5 矩阵图</h2><h3 id="2-5-1-heatmap"><a href="#2-5-1-heatmap" class="headerlink" title="2.5.1 heatmap()"></a>2.5.1 heatmap()</h3><p><a href="http://seaborn.pydata.org/generated/seaborn.heatmap.html?highlight=heatmap#seaborn-heatmap"><code>sns.heatmap(data, vmin=, vmax=, cmap=, center=, *kwargs)</code></a></p><p>主要用于绘制热力图。</p><h3 id="2-5-2-clustermap"><a href="#2-5-2-clustermap" class="headerlink" title="2.5.2 clustermap()"></a>2.5.2 clustermap()</h3><p><a href="http://seaborn.pydata.org/generated/seaborn.clustermap.html?highlight=clustermap#seaborn.clustermap"><code>sns.clustermap(data, method=, metric=, *kwargs)</code></a></p><p>支持绘制层次聚类结构图。</p><h1 id="3-pygal 库"><a href="#3-pygal 库" class="headerlink" title="3. pygal 库"></a>3. pygal 库</h1><p>Pygal 是另一个简单易用的数据图库，它以面向对象的方式来创建各种数据图，而且使用 Pygal 可以非常方便地生成各种格式的数据图，包括 PNG、SVG 等。</p><p>其最大的特点是能够生成 <strong> 矢量图形 </strong>SVG，还可进行点击显示<strong> 交互</strong>。</p><h2 id="3-1- 安装"><a href="#3-1- 安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h2><pre><code class="python">pip install pygal -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><h2 id="3-2- 使用"><a href="#3-2- 使用" class="headerlink" title="3.2 使用"></a>3.2 使用</h2><p>pygal 有非常简单清晰的官方文档，需要用时直接查阅就好。</p><p><strong>Pygal 官方文档</strong></p><p><a href="http://www.pygal.org/en/stable/documentation/index.html">http://www.pygal.org/en/stable/documentation/index.html</a></p><h1 id="4-Pyecharts 库"><a href="#4-Pyecharts 库" class="headerlink" title="4. Pyecharts 库"></a>4. Pyecharts 库</h1><p><a href="https://github.com/ecomfe/echarts">Echarts</a> 是一个由百度开源的数据可视化，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。而 Python 是一门富有表达力的语言，很适合用于数据处理。</p><p><strong>特点：良好的交互性，支持链式调用，精巧的图表设计</strong></p><p><strong>官方文档是中文滴！</strong><a href="http://pyecharts.org/#/zh-cn/intro">http://pyecharts.org/#/zh-cn/intro</a></p><p>要想使用直接阅读官方文档即可。其中的【<a href="http://pyecharts.org/#/zh-cn/quickstart?id=_5- 分钟上手">5 分钟上手</a>】初学者一定要看。</p><p>为了更快的读懂官方文档，在下面会做一些总结。</p><h2 id="4-1- 初识语法"><a href="#4-1- 初识语法" class="headerlink" title="4.1 初识语法"></a>4.1 初识语法 </h2><p> 首先给一段简单代码看看 Pyecharts 是怎么画图的：</p><pre><code class="python">// 条形图绘制from pyecharts.charts import Barbar1 = Bar()  // 首先创建一个条形图画板bar1.add_xaxis([&quot; 衬衫 &quot;, &quot; 羊毛衫 &quot;, &quot; 雪纺衫 &quot;, &quot; 裤子 &quot;, &quot; 高跟鞋 &quot;, &quot; 袜子 &quot;])bar1.add_yaxis(&quot; 商家 A&quot;, [5, 20, 36, 10, 75, 90])bar1.add_yaxis(&quot; 商家 B&quot;, [10, 25, 35, 6, 100, 70])bar1.render()//render 会生成本地 HTML 文件，默认会在当前目录生成 render.html 文件// 也可以传入路径参数，如 bar.render(&quot;mycharts.html&quot;)</code></pre><p>打开生成的 render.html 文件如下：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-23_22-17-54.png" alt=""></p><p><strong>要想直接在 jupyter notebook 中直接显示，可采用如下方式：</strong></p><p><code>bar1.render_notebook()</code></p><p>以上画图方法简单吧。下面再看看怎么进行更多的设置。</p><h2 id="4-2- 会用官方文档"><a href="#4-2- 会用官方文档" class="headerlink" title="4.2 会用官方文档"></a><strong>4.2 会用官方文档 </strong></h2><h3 id="4-2-1- 会看图表说明"><a href="#4-2-1- 会看图表说明" class="headerlink" title="4.2.1 会看图表说明"></a>4.2.1 会看图表说明</h3><p> 想要对图表进行进一步的设置，则看官方文档中对应的设置部分，对于条形图 Bar：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-23_22-45-12.png" alt=""></p><p>上述中 <code>def</code> 定义了函数名<code>add_yaxis</code>，调用格式：<code>Bar().add_yaxis()</code>，括号的可以传入的参数和用法即为在画红下划线里的那些。有等于号 = 的通过赋值传参，没有等于号的直接传参。</p><p><strong>举个例子：</strong></p><pre><code>from pyecharts.charts import LineL=Line()L.add_xaxis([&#39;1 月份 &#39;,&#39;2 月份 &#39;,&#39;3 月份 &#39;,&#39;4 月份 &#39;,&#39;5 月份 &#39;,&#39;6 月份 &#39;])L.add_yaxis(&quot; 商家 A&quot;, [5, 20, 36, 10, 75, 90])L.add_yaxis(&quot; 商家 B&quot;, [10, 25, 35, 6, 100, 70],            is_smooth = True,            linestyle_opts = opts.LineStyleOpts(type_=&#39;dotted&#39;))  // 给商家 B 搞点不一样L.render_notebook()</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/can323132132131vvas.png" alt=""></p><p>上述中给商家 B 搞点不一样，就是 <strong> 参照官方文档中的用法进行了设置。查看应用路径如下：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-23_23-22-03.png" alt=""></p><p><strong>这下学会怎么看官方文档了吧！！！</strong></p><p><strong>点个赞，快！</strong></p><p>接下来如果想要添加【标题】或者修改【图例】等，需要在 <strong> 全局配置项 </strong> 中添加。</p><h3 id="4-2-2- 会用全局配置项"><a href="#4-2-2- 会用全局配置项" class="headerlink" title="4.2.2 会用全局配置项"></a>4.2.2 会用全局配置项 </h3><p><strong> 全局配置项中可对这些元素进行配置：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/57307650-8a4d0280-7117-11e9-921f-69b8e9c5e4aa.png" alt=""></p><blockquote><p><strong>全局配置项可通过 <code>set_global_options</code> 方法设置。</strong></p></blockquote><p>在使用全局变量时，需要再 import 一个方法：</p><pre><code class="python">from pyecharts import options as opts // 使用 options 配置项，在 pyecharts 中，一切皆 Options。</code></pre><p>首先找到全局配置项的那一部分，看目录，如我需要给图表加标题，则找到【TitleOpts：标题配置项】。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-24_00-00-10.png" alt=""></p><p>如我需要给图表加视觉映射，则找到【VisualMapOpts：视觉映射配置项】。</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-24_00-09-06.png" alt=""></p><p>看了这两个例子应该学会举一反三，配置任何全局变量了吧！</p><h3 id="4-2-3- 链式调用"><a href="#4-2-3- 链式调用" class="headerlink" title="4.2.3 链式调用"></a>4.2.3 链式调用 </h3><p><strong> 在使用 Pyecharts 过程中，一般都会采用链式调用的方法去写代码，当然怎么选择可凭个人习惯。</strong></p><p>先看段代码：</p><pre><code class="python">from pyecharts import options as optsfrom pyecharts.charts import Scatterdef scatter_spliteline() -&gt; Scatter:     // 这里是 python 中一种特殊写法，下面会有解释。    c = (Scatter()                     // 该函数的方法调用就是链式调用        .add_xaxis([&#39;1 月份 &#39;,&#39;2 月份 &#39;,&#39;3 月份 &#39;,&#39;4 月份 &#39;,&#39;5 月份 &#39;,&#39;6 月份 &#39;,])        .add_yaxis(&quot; 商家 A&quot;, [80, 55, 35, 10, 100, 70])        .set_global_opts(title_opts=opts.TitleOpts(title=&quot;Scatter- 显示分割线 &quot;),            xaxis_opts=opts.AxisOpts(splitline_opts=opts.SplitLineOpts(is_show=True)),            yaxis_opts=opts.AxisOpts(splitline_opts=opts.SplitLineOpts(is_show=True)),        )    )    return cscatter_spliteline().render_notebook()</code></pre><p>首先定义一个变量 c，去接收画的图表；括号里传入图表类型函数 Scatter()，代表要绘制散点图，再分别调用 Scatter()里面的 add_xaxis()，add_yaxis()，set_global_opts()三个函数，用点连接，代表方法调用。</p><p><strong>【如何理解链式调用】</strong></p><ul><li><p>所谓链式调用，就是一个函数可以“叠加”使用其中的方法。比如普通类 Car()中定义了三个方法，A，B，C，当使用其中的方法时，只能分别调用，如：</p><pre><code>Car().A()Car().B()Car().C()</code></pre><p>而链式调用，则可以直接：</p><pre><code class="python">Car().A().B().C()   #同时调用 A，B,C 三个函数#上面的画图函数就是这样写的：Scatter().add_xaxis()         .add_xaxis()         .set_global_opts()</code></pre><p>当然要实现这样的调用，类函数 Car()中的方法要 return 本身。</p><p>如：</p><pre><code class="python">class Chain():    def __init__(self,name):        self.name=name    def A(self):        print(&#39;%s 正在调用方法 A&#39;%self.name)        return self    def B(self):        print(&#39; 正在调用方法 B&#39;)        return self    def C(self):        print(&#39; 正在调用方法 C&#39;)        return selfchain=Chain(name=&#39;author&#39;)chain.A().B().C()#输出结果为：author 正在调用方法 A正在调用方法 B正在调用方法 C#以上这就是链式调用</code></pre><p>以上过程可以这样理解：</p><p>第一层：<code>chain.A()</code>调用方法 A，打印出“author 正在调用方法 A”，随后 <code>return</code> 回<code>self</code>（就是 <code>Chain()</code> 本身，即 <code>chain.A()</code> 又相当于<code>Chain()</code>）</p><p>第二层：<code>chain.A().B()</code>等价于<code>chain.B()</code>。依次类推。</p></li></ul><p><strong>【如何理解 python 代码中的箭头<code>—&gt;</code>】</strong></p><ul><li><p>函数参数中的箭头指向是参数的 <code> 类型建议符</code>，以告诉程序员希望传入的实参的类型。是 Python 3.5 新加的功能。</p></li><li><p>值得注意的是，类型建议符并非强制规定和检查，也就是说即使传入的实际参数与建议参数不符，也不会报错。</p></li><li><p>可以把它看成一种注释即可。不编译，不执行。</p><pre><code class="python">def add(x, y) -&gt; int:  # 这里 —&gt; int 表示：告诉程序员这里 x,y 建议输入数据类型为整型    return x+y</code></pre></li></ul><h3 id="4-2-4- 输出图片"><a href="#4-2-4- 输出图片" class="headerlink" title="4.2.4 输出图片"></a>4.2.4 输出图片 </h3><p>Pyecharts 默认的输出方式为 html 网页文件，要想输出图片，可参阅官方文档【<a href="http://pyecharts.org/#/zh-cn/render_images"> 渲染图片</a>】</p><h2 id="4-3- 进阶用法"><a href="#4-3- 进阶用法" class="headerlink" title="4.3 进阶用法"></a>4.3 进阶用法 </h2><p> 等到我需要用到的时候再进行更新吧。</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Seaborn </tag>
            
            <tag> pygal </tag>
            
            <tag> Pyecharts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 之 Matplotlib 可视化</title>
      <link href="/python%E4%B9%8BMatplotlib%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/python%E4%B9%8BMatplotlib%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Matplotlib 库入门"><a href="#1-Matplotlib 库入门" class="headerlink" title="1. Matplotlib 库入门"></a>1. Matplotlib 库入门 </h1><p><code>Matplotlib</code> 是一个 <code>Python</code> 的<code>2D</code>绘图库，通过 <code>Matplotlib</code>，开发者可以仅需要几行代码，便可以生成折线图，直方图，条形图，饼状图，散点图，箱线图等，是<code>python</code> 中最为常见的平面绘图库。</p><p>库安装：</p><pre><code class="python">//CMD 命令行下pip install matplotlib</code></pre><p>库导入：</p><pre><code class="python">import matplotlib.pyplot as pltplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;] // 指定默认字体plt.rcParams[&#39;axes.unicode_minus&#39;] = False  // 解决图像中出现负号 &#39;-&#39; 显示为方块异常的问题</code></pre><p><font size=5 face="黑体"><strong>官方文档：</strong></font><a href="https://matplotlib.org/api/pyplot_summary.html">https://matplotlib.org/api/pyplot_summary.html</a></p><h1 id="2- 线图"><a href="#2- 线图" class="headerlink" title="2.  线图"></a>2.  线图 </h1><p><strong> 主要包括折线图，曲线图。</strong></p><h2 id="2-1- 基本绘图函数"><a href="#2-1- 基本绘图函数" class="headerlink" title="2.1 基本绘图函数"></a>2.1 基本绘图函数</h2><pre><code class="python">// 基本绘图函数plt.plot(x, y, &#39;xxx&#39;, label=, linewidth=, marker=)</code></pre><p>① <code>x</code>：位置参数，横坐标，可迭代对象（若省略，可自动生成 0-n 个数与 y 的长度对应）。</p><p>② <code>y</code>：位置参数，纵坐标，可迭代对象。</p><p>③ <code>&#39;XXX&#39;</code>：样式参数，可指定 <strong> 线条样式 </strong>，<strong> 颜色</strong>。</p><p><strong>线条样式 linestyle</strong>有实线，虚线，点线等，如<code>linestyle=&quot;--&quot;</code>，linestyle= 可以省略，具体表示方法如下：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/5-rwerweq ty11.png" style="zoom:100%;" /><p><strong>线条颜色 color</strong>表示方法有：color= <code>&#39;r&#39;</code>|    <code>&#39;red&#39;</code>    |<code>&#39;#000100&#39;</code>|    <code>(0.1, 0.5, 0.4)</code>，四种表示方法，其中前三种 color= 可以省略(color 可以简写为 c)。</p><p>④ <code>lable</code>：关键字参数，设置图例，需要调用 plt 或子图的 legend 方法，需要添加一行<code>plt.legend()</code>，图例标签才会显示。</p><p>⑤ <code>linewidth</code>：关键字参数，设置线的粗细。</p><p>⑥ <code>marker</code>：设置关键点显示方式。如 <code>marker=&#39;o&#39;</code>，设置关键点以实心圆点显示，<code>markersize=10</code> 可指定圆点大小为 10，<code>markerfacecolor=&#39;k&#39;</code>，可设置关键点的颜色。</p><h2 id="2-2- 细节设置"><a href="#2-2- 细节设置" class="headerlink" title="2.2 细节设置"></a>2.2 细节设置</h2><pre><code class="python">plt.xlabel(&#39;x 轴 &#39;)           // 设置 x 轴标签plt.ylabel(&#39;y 轴 &#39;)           // 设置 y 轴标签plt.title(&#39; 折线图 &#39;)          // 设置图像标题plt.xticks(range(0,10,2))　　// 设置 x 轴刻度属性plt.yticks(range(0,10,2))   // 设置 y 轴刻度属性plt.ylim(-2, 2)             // 设置 y 轴的上下限plt.grid()                  // 设置网格背景plt.legend()                // 显示图例plt.figure(figsize=(15,5))  // 设置画布大小，要在画图之前设置，不然不起作用plt.style.use(&quot;dark_background&quot;)  // 设置绘图风格plt.axis(&#39;off&#39;)                   // 设置不显示坐标轴plt.show()                  // 显示图</code></pre><p><strong>关于轴刻度：</strong></p><p><code>plt.xticks(_xticks, [labels], *kwargs)</code>可设置【应当放置刻度的位置列表】，【在给定 <em> 位置 </em> 放置的显式标签的列表】，【控制标签的外观】（如 rotation=45，以 45 度旋转显示；fontsize=10，设置刻度字体大小为 10）。<code>_xticksy</code>与 <code>[labels]</code> 一一对应。y 轴同理。</p><p><strong>关于画布：</strong></p><p><code>plt.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True)</code>来实现。 其中 <code>num</code> 是图的编号，<code>figsize</code>的单位是英寸，<code>dpi</code>是每英寸的像素点，<code>facecolor</code>是图片背景颜色，<code>edgecolor</code>是边框颜色，<code>frameon</code>代表是否绘制画板。</p><p><strong>关于图例：</strong></p><p><code>legend((line1, line2, line3), (&#39;label1&#39;, &#39;label2&#39;, &#39;label3&#39;),*kwargs)</code>，前者指定绘制的图线，后者指定对应的样式。如都为空，则按照默认的显示。</p><p>其他参数<code>*kwargs</code>：位置<code>loc=</code>，值有：角落位置【<code>&#39;upper left&#39;, &#39;upper right&#39;, &#39;lower left&#39;, &#39;lower right&#39;</code>】，边缘中心【<code>&#39;upper center&#39;, &#39;lower center&#39;, &#39;center left&#39;, &#39;center right&#39;</code>】，中心【<code>&#39;center’</code>】。默认最佳位置【<code>&#39;best&#39;</code>】；位置<code>bbox_to_anchor=</code>，可传入 2 元组（横纵坐标）或 4 元浮点数（x, y, width, height）。</p><p>字体大小<code>fontsize=</code></p><p>图例中元素排列方式<code>ncol=</code>，可指定按行排列。默认值为 1，上下排列。</p><p><strong>关于绘图风格：</strong></p><p><code>matplotlib</code>图片默认内置了几种风格。我们可以通过 <code>plt.style.available</code> 来查看内置的所有风格。</p><p><strong>关于坐标轴设置：</strong></p><p><code>axis()</code>：返回当前的坐标轴范围 [xmin, xmax, ymin, ymax]</p><p><code>axis(v)</code>：传参用来设置坐标轴范围</p><p><code>axis(&#39;off&#39;)</code>：不显示坐标轴和坐标轴名称</p><p><code>axis(&#39;equal&#39;)</code>：提高某一个轴的范围以保持图表大小及比例不变</p><p><code>axis(&#39;scaled&#39;)</code>：设置轴的数值范围不变</p><p><code>axis(&#39;tight&#39;)</code>：减少两个轴的数值范围，并尽量让数据居中</p><p><code>axis(&#39;image&#39;)</code>：将图表比例按照图片的比例进行调整（缩放）</p><p><code>axis(&#39;square&#39;)</code>：将图表变成正方形，并确保 (xmax-xmin) 与 (ymax-ymin) 相同</p><p><code>axis(&#39;auto&#39;)</code>：恢复自动范围</p><h3 id="举个例子"><a href="# 举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npplt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;] plt.rcParams[&#39;axes.unicode_minus&#39;] = False  x1=np.linspace(0,25)y1=np.sin(x)plt.plot(x1,y1,marker=&#39;o&#39;,label=&#39;sin 函数 &#39;) plt.plot(range(20),[np.random.randint(0,5) for x in range(20)],&#39;r:&#39;,linewidth=5,label=&#39; 折线图 &#39;)   //&#39;r:&#39; 颜色和线型写在一块plt.xlabel(&#39;x 轴 &#39;)           plt.ylabel(&#39;y 轴 &#39;)           plt.title(&#39; 折线图 &#39;)plt.xticks(range(0,20,2))plt.legend()plt.grid()                  plt.figure(figsize=(30,10))plt.show()   // 有时可以省略</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/int i78 9t 8r00dex.png"  style="zoom:120%;" /><p>注意：对于有时候画图后不显示图，而需要 show 的时候，为了避免繁琐的 show，可以在导入库之后加入一行代码 <code>%matplotlib inline</code> 就可以 plot 画图后直接输出图。</p><h2 id="2-3- 多图合一"><a href="#2-3- 多图合一" class="headerlink" title="2.3 多图合一"></a>2.3 多图合一 </h2><p><strong> 绘制多个子图的时候，我们可以使用 <code>plt.subplot</code> 或<code>plt.subplots</code>来实现。</strong></p><p><strong>1)<code>plt.subplot</code></strong> </p><pre><code class="python">plt.subplot(221)                           //2 行 2 列第 1 个图plt.plot(np.arange(10),c=&#39;r&#39;)plt.subplot(222)                           //2 行 2 列第 2 个图plt.plot(np.sin(np.arange(10)),c=&#39;b&#39;)plt.subplot(223)                           //2 行 2 列第 3 个图plt.plot(np.cos(np.arange(10)),c=&#39;y&#39;)plt.subplot(224)                           //2 行 2 列第 4 个图plt.plot(np.tan(np.arange(10)),c=&#39;g&#39;)</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/subplot1.png" alt=""></p><p><strong>2) 也可以使用 <code>fig,axs=plt.subplots(rows,cols,figsize=,*kwargs)</code> 来绘制多个图形，可以指定行列数，画布大小。返回值是一个元组，其中的 <code>fig</code> 参数是 <code>figure</code> 对象，<code>axs</code>是 <code>axes</code> 对象的<code>array</code>。</strong></p><pre><code class="python">figure,axes = plt.subplots(2,2,sharex=True,sharey=True)axes[0,0].plot(np.sin(np.arange(10)),c=&#39;r&#39;)axes[0,1].plot(np.cos(np.arange(10)),c=&#39;b&#39;)axes[1,0].plot(np.tan(np.arange(10)),c=&#39;y&#39;)axes[1,1].plot(np.arange(10),c=&#39;g&#39;)</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/subplot2.png" alt=""></p><p>关于返回值，也可以这样接收：</p><pre><code>figure,[ax1,ax2,ax3,ax4]= plt.subplots(2,2)</code></pre><p>再将坐标系 ax1-4 通过画图函数传参交给所需的图，如</p><pre><code class="python">bar1=plt.bar(x, height, ax=ax1)hist2=plt.hist(x, bins, ax=ax2)scatter3=plt.scatter(x, y, ax=ax3)bo33=plt.boxplot(x,ax=ax4)</code></pre><h2 id="2-4- 设置注释文本"><a href="#2-4- 设置注释文本" class="headerlink" title="2.4 设置注释文本"></a>2.4 设置注释文本 </h2><p> 在图形中的某个点标记或者注释一下，我们可以使用 <code>plt.annotate(text,xy,xytext,arrowprops=&#123;&#125;)</code> 来实现，其中 <code>text</code> 是注释的文本，<code>xy</code>是需要注释的点的坐标，<code>xytext</code>是注释文本的坐标，<code>arrowprops</code>是箭头的样式属性。</p><pre><code class="python">ax = plt.subplot(111)           x = np.arange(0.0, 5.0, 0.01)y = np.cos(2*np.pi*x)plt.plot(x, y,linewidth=2)// 设置注释文本plt.annotate(&#39;local max&#39;, xy=(2, 1), xytext= (3,1.5),                  arrowprops=dict(facecolor=&#39;black&#39;, shrink=0.05))plt.ylim(-2, 2)  // 设置 y 轴的上下限</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/inuitiotuttdex.png" alt=""></p><h2 id="2-5- 图片保存"><a href="#2-5- 图片保存" class="headerlink" title="2.5 图片保存"></a>2.5 图片保存</h2><pre><code class="python"> plt.savefig(path)</code></pre><h1 id="3- 条形图"><a href="#3- 条形图" class="headerlink" title="3. 条形图"></a>3. 条形图</h1><h2 id="3-1- 基本条形图"><a href="#3-1- 基本条形图" class="headerlink" title="3.1 基本条形图"></a>3.1 基本条形图</h2><pre><code class="python">// 基本绘图函数 plt.bar(x, height, width=, bottom=, align=, color=, *kwargs)</code></pre><p>① <code>x</code>：位置参数，条形图 x 轴的坐标点。</p><p>② <code>height</code>：位置参数，条形图 y 轴的坐标点。</p><p>③ <code>width</code>：条形宽度，取值在 0-1 之间。默认 0.8。</p><p>④ <code>bottom</code>：条形的起始位置。默认为 0。</p><p>⑤ <code>align</code>：条形的中心位置。默认中心’center’。还有边缘’edge’，靠边对齐，具体靠右边还是靠左边，看 <code>width</code> 的正负。</p><p>⑥ <code>color</code>：条形的颜色，“r”,”b”,”g”,”#123465”，默认“b”</p><p>⑦ <code>*kwargs</code>：包括边框颜色<code>edgecolor</code>，变宽<code>linewidth</code>，下标的标签<code>tick_label</code>，y 轴使用科学计算法表示<code>log</code>，是竖直条还是水平条<code>orientation</code>(竖直：<code>&quot;vertical&quot;</code>，水平条：<code>&quot;horizontal&quot;</code>)，亮度深浅调整<code>alpha=0-1</code>。</p><p><strong>细节设置等其他设置同 2.2。</strong></p><h3 id="举个例子 -1"><a href="# 举个例子 -1" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code class="python"> movies = &#123;    &quot; 流浪地球 &quot;:40.78,    &quot; 飞驰人生 &quot;:15.77,    &quot; 疯狂的外星人 &quot;:20.83,    &quot; 新喜剧之王 &quot;:6.10,    &quot; 廉政风云 &quot;:1.10,    &quot; 神探蒲松龄 &quot;:1.49,    &quot; 小猪佩奇过大年 &quot;:1.22,    &quot; 熊出没·原始时代 &quot;:6.71&#125; x = np.arange(len(movies)) y=list(movies.values()) plt.bar(x,y,width=0.3,align=&#39;edge&#39;,color=&#39;r&#39;) _xticks= np.arange(len(movies))     plt.xticks(_xticks,list(movies.keys()),rotation=45)  // 设置 x 轴要显示的刻度数，以及以 movies.keys()文本显示，为了避免文本刻度拥挤，设置旋转显示 _yticks=range(0,50,5)    // 设置 y 轴显示刻度数 plt.yticks(_yticks,[&#39;%d 亿 &#39;%i for i in _yticks]) //  显示在 y 轴上，并在刻度上加上 &#39; 亿 &#39; plt.grid() plt.figure(dpi=80)</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/inuyuytresdex.png" style="zoom:120%;" /><h2 id="3-2- 横向条形图"><a href="#3-2- 横向条形图" class="headerlink" title="3.2 横向条形图"></a>3.2 横向条形图</h2><pre><code>// 基本绘图函数 plt.barh(y, width, height=, left=, align=, color=, *kwargs)</code></pre><p>① <code>y</code>：位置参数，条形图 y 轴的坐标点。</p><p>② <code>width</code>：位置参数，条形图在 <code>x</code> 轴上的值。</p><p>③ <code>height</code>：条形宽度，取值在 0-1 之间。默认 0.8。</p><p>④ <code>left</code>：条形的基线起始位置。默认为 0。</p><p>⑤ <code>align</code>：条形的中心位置。默认中心’center’，还有边缘’edge’</p><p>⑥ <code>color</code>：条形的颜色，“r”,”b”,”g”,”#123465”，默认“b”</p><p>⑦ <code>*kwargs</code>：包括边框颜色<code>edgecolor</code>，边宽<code>linewidth</code>，下标的标签<code>tick_label</code>，y 轴使用科学计算法表示<code>log</code>，是竖直条还是水平条<code>orientation</code>(竖直：<code>&quot;vertical&quot;</code>，水平条：<code>&quot;horizontal&quot;</code>)</p><p><strong>细节设置等其他设置同 2.2。</strong></p><h2 id="3-3- 分组条形图"><a href="#3-3- 分组条形图" class="headerlink" title="3.3 分组条形图"></a>3.3 分组条形图 </h2><p> 基本绘图函数同 3.1 和 3.2。拿基本条形图（竖直条形图）来讲，只是 x 轴一个区间要分成几部分，放置同类型的条形图。</p><h3 id="举个例子 1"><a href="# 举个例子 1" class="headerlink" title="举个例子 1"></a>举个例子 1</h3><pre><code>movies = &#123;    &quot; 流浪地球 &quot;:[2.01,4.59,7.99,11.83,16],    &quot; 飞驰人生 &quot;:[3.19,5.08,6.73,8.10,9.35],    &quot; 疯狂的外星人 &quot;:[4.07,6.92,9.30,11.29,13.03],    &quot; 新喜剧之王 &quot;:[2.72,3.79,4.45,4.83,5.11],    &quot; 廉政风云 &quot;:[0.56,0.74,0.83,0.88,0.92],    &quot; 神探蒲松龄 &quot;:[0.66,0.95,1.10,1.17,1.23],    &quot; 小猪佩奇过大年 &quot;:[0.58,0.81,0.94,1.01,1.07],    &quot; 熊出没·原始时代 &quot;:[1.13,1.96,2.73,3.42,4.05]&#125;</code></pre><p>需要将上面数据画成分组条形图，每部电影有 5 个数据，首先明确怎么画图：电影名称作为横坐标，需设置 <code>len(movies.keys())</code> 共 8 个坐标，每个坐标上有 5 个数据条，先统一画第一个坐标点的第一个数据条，再画第二个数据条……（内循环），画完之后画第二个坐标点的数据，以此循环（外循环）。</p><p>具体解法如下：</p><pre><code class="python">// 预处理 width = 0.75                     // 设置每部电影总条形图的宽度 bin_width = width/5              // 将宽度分成 5 部分，以用于 5 个数据 movie_pd = pd.DataFrame(movies)  // 将电影数据变成数表，便于索引取值 ind = np.arange(0,len(movies))   // 电影数为 x 轴坐标，分为 5 段</code></pre><p>第一种解法：</p><pre><code class="python"> first_day = movie_pd.iloc[0]   //(ind-bin_width*2)每段的第 1 个位置 plt.bar(ind-bin_width*2,first_day,width=bin_width,label=&#39; 第一天 &#39;) // 绘制每部电影第 1 天数据 second_day = movie_pd.iloc[1]   //(ind-bin_width)每段的第 2 个位置 plt.bar(ind-bin_width,second_day,width=bin_width,label=&#39; 第二天 &#39;) // 绘制每部电影第 2 天数据 third_day = movie_pd.iloc[2]    // ind 每段的第 3 个位置 plt.bar(ind,third_day,width=bin_width,label=&#39; 第三天 &#39;)      // 绘制每部电影第 3 天数据 four_day = movie_pd.iloc[3]     //(ind+bin_width)每段的第 4 个位置 plt.bar(ind+bin_width,four_day,width=bin_width,label=&#39; 第四天 &#39;)   // 绘制每部电影第 4 天数据 five_day = movie_pd.iloc[4]    //(ind+bin_width*2)每段的第 5 个位置 plt.bar(ind+bin_width*2,five_day,width=bin_width,label=&#39; 第五天 &#39;)  // 绘制每部电影第 5 天数据 plt.xticks(ind,list(movies.keys()),fontsize=20)   // 设置 x 轴刻度标签 plt.yticks(list(range(0,18,2)),fontsize=20)       // 设置 y 轴刻度标签 plt.ylabel(&#39; 单位：亿 &#39;,fontsize=25) plt.legend(bbox_to_anchor=(0.8,0.8),fontsize=20)  // 指定图例的位置及字体大小</code></pre><p>![](<a href="https://image--1.oss-cn-shenzhen.aliyuncs.com/indeqrwr">https://image--1.oss-cn-shenzhen.aliyuncs.com/indeqrwr</a> rwq rqrq14421ex.png)</p><p>第二种解法：</p><pre><code class="python"> for index in movie_pd.index:     day_tickets = movie_pd.iloc[index]    // 按行选取数据     xs = ind-(bin_width*(2-index))        // 定好位置     plt.bar(xs,day_tickets,width=bin_width,label=&quot; 第 %d 天 &quot;%(index+1))     // 画图     for ticket,x in zip(day_tickets,xs):     // 在条形图上加数字标签         plt.annotate(ticket,xy=(x,ticket),xytext=(x-0.1,ticket+0.1)) plt.xticks(ind,list(movies.keys()),fontsize=20)    plt.yticks(list(range(0,18,2)),fontsize=20)        plt.ylabel(&#39; 单位：亿 &#39;,fontsize=25) plt.legend(bbox_to_anchor=(0.8,0.8),fontsize=20)  </code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/induuuuuuuuuuuuex.png" alt=""></p><h3 id="举个例子 2"><a href="# 举个例子 2" class="headerlink" title="举个例子 2"></a>举个例子 2</h3><p>要求：把年份当做 x 轴，报名人数当做 y 轴的值。</p><pre><code class="python">&gt;&gt;&gt; data = &#123;    &quot; 普通本科 &quot;:[721,738,749,761,791],    &quot; 中等职业教育 &quot;: [620,601,593,582,557],    &quot; 普通高中 &quot;: [797,797,803,800,793]&#125;&gt;&gt;&gt; data_df=pd.DataFrame(data,index=[&#39;2014&#39;,&#39;2015&#39;,&#39;2016&#39;,&#39;2017&#39;,&#39;2018&#39;])       普通本科    中等职业教育　普通高中2014     721     620     7972015     738     601     7972016     749     593     8032017     761     582     8002018     791     557     793&gt;&gt;&gt; width=0.75&gt;&gt;&gt; bin_width=width/3&gt;&gt;&gt; ind=np.arange(0,5)　　　　　　　　　　　// 一共 5 个横坐标刻度&gt;&gt;&gt; for col in range(3):　　　　　　　　　　// 每个横坐标包含３个数据条&gt;&gt;&gt;     num=data_df.iloc[:,col]&gt;&gt;&gt;     xt=ind-bin_width*(1-col)&gt;&gt;&gt;     plt.bar(xt,num,width=bin_width,label=data_df.columns[col])&gt;&gt;&gt;     for n,x in zip(num,xt):&gt;&gt;&gt;        plt.annotate(n,xy=(x,n),xytext=(x-0.1,n+10))&gt;&gt;&gt; plt.xticks(ind,data_df.index)&gt;&gt;&gt; plt.ylim(0,1200)&gt;&gt;&gt; plt.legend(ncol=3)&gt;&gt;&gt; plt.show()</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/inde555555x.png" style="zoom:120%;" /><h2 id="3-4- 堆叠条形图"><a href="#3-4- 堆叠条形图" class="headerlink" title="3.4 堆叠条形图"></a>3.4 堆叠条形图 </h2><p> 堆叠条形图，是将一组相关的条形图堆叠在一起进行比较的条形图。基本绘图函数同 3.1 和 3.2。拿基本条形图（竖直条形图）来讲，只需要对 bottom 参数进行设置，叠放同类型的条形图。</p><pre><code class="python"> menMeans = (20, 35, 30, 35, 27) womenMeans = (25, 32, 34, 20, 25) groupNames = (&#39;G1&#39;,&#39;G2&#39;,&#39;G3&#39;,&#39;G4&#39;,&#39;G5&#39;) xs = np.arange(len(menMeans)) bar1 = plt.bar(xs,menMeans,width=0.5) bar2 = plt.bar(xs,womenMeans,bottom=menMeans,width=0.5)    // 注意这里的 bottom plt.xticks(xs,groupNames,fontsize=15) plt.legend((bar1,bar2),(&#39; 男性平均值 &#39;,&#39; 女性平均值 &#39;))  // 设置图例</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/ind3333333333344444ex.png" alt=""></p><h1 id="4- 直方图"><a href="#4- 直方图" class="headerlink" title="4. 直方图"></a>4. 直方图 </h1><p> 直方图(Histogram)，又称质量分布图，是一种统计报告图，由一系列高度不等的条纹表示数据分布的情况。一般用横轴表示数据类型，纵轴表示分布情况。</p><pre><code>// 基本绘图函数 plt.hist(x, bins, range,density=, cumulative=, *kwargs)</code></pre><p>① <code>x</code>：需要划分的数组。直方图将会从这组数据中进行分组。</p><p>② <code>bins</code>：指定划分范围。如果是数字，代表的是要分成多少组；如果是序列，那么就会按照序列中指定的值进行分组。</p><p>③ <code>range</code>：元组或者 None，如果为元组，那么指定 <code>x</code> 划分区间的最大值和最小值。如果 <code>bins</code> 是一个序列，那么 <code>range</code> 没有有没有设置没有任何影响。</p><p>④ <code>density</code>：频率统计参数。默认是<code>False</code>。如果等于<code>True</code>，那么将会使用频率分布直方图。</p><p>⑤ <code>cumulative</code>：频率统计参数。如果这个和 <code>density</code> 都等于<code>True</code>，那么返回值的第一个参数会不断的累加，最终等于<code>1</code>。</p><p>⑥ <code>*kwargs</code>：包括<code>color</code>，<code>edgecolor</code>，<code>label</code>，<code>align</code>，<code>bottom</code>，<code>orientation= &#123;&#39;horizontal&#39;, &#39;vertical&#39;&#125;</code>，等。</p><p>这个函数可以接收返回值：<code>n，bins, patches = plt.hist()</code><br><code>n</code>：数组，每个区间内值出现的个数；<br><code>bins</code>：数组，区间序列；<br><code>patches</code>：直方图每个图块序列的信息。</p><p><strong>细节设置等其他设置同 2.2。</strong></p><h3 id="举个例子 -2"><a href="# 举个例子 -2" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code class="python"> data = np.random.randint(10,100,size=(100)) nums,bins,patches = plt.hist(data,bins=                       (10,20,30,40,50,60,70,80,90,100),edgecolor=&#39;r&#39;) plt.xticks(bins,bins) for num,bin in zip(nums,bins):     plt.annotate(num,xy=(bin,num),xytext=(bin+1.5,num+0.2)) plt.ylim(0,20)</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/indwwwwwwwwwwweqex.png" alt=""></p><h1 id="5- 散点图"><a href="#5- 散点图" class="headerlink" title="5. 散点图"></a>5. 散点图 </h1><h2 id="5-1- 基本散点图"><a href="#5-1- 基本散点图" class="headerlink" title="5.1 基本散点图"></a>5.1 基本散点图</h2><p> 散点图也叫 X-Y 图，它将所有的数据以点的形式展现在直角坐标系上，以显示变量之间的相互影响程度，点的位置由变量的数值决定。通过观察散点图上数据点的分布情况，我们可以推断出变量间的相关性。</p><pre><code>// 基本绘图函数 plt.sactter(x, y, s=, c=, marker=, *kwargs)</code></pre><p>① <code>x,y</code>：分别是 x 轴和 y 轴的数据集。两者的数据长度必须一致。</p><p>② <code>s</code>：点的尺寸。可以是一个数字，也可以是一个序列。</p><p>③ <code>c</code>：点的颜色，可以为具体的颜色，也可以为一个序列或者是一个 <code>cmap</code> 对象。</p><p>④ <code>marker</code>：标记点，默认是圆点。</p><p>⑤ <code>*kwargs</code>：包括 <code>edgecolor</code>，<code>label</code>，<code>alpha</code> 等。</p><p><strong>关于颜色映射：</strong></p><p><code>c=[nums], cmap=plt.cm.Reds</code>，将一个需要映射的序列传给 c，cmap 便会根据 c 值的大小给出相应颜色的深浅。</p><p><strong>细节设置等其他设置同 2.2。</strong></p><h3 id="举个例子 -3"><a href="# 举个例子 -3" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code class="python"> x=np.random.randint(1,20,size=(200)) y=np.random.randint(10,50,size=(200)) plt.scatter(x,y,s=10,c=y,cmap=plt.cm.Blues)</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/indeqwert54x.png" style="zoom:120%;" /><h2 id="5-2- 回归方程"><a href="#5-2- 回归方程" class="headerlink" title="5.2 回归方程"></a>5.2 回归方程 </h2><p> 有一组数据后，我们可以对这组数据进行回归分析，回归分析可以帮助我们了解这组数据的大体走向。</p><p>回归分析按照涉及的变量的多少，分为一元回归和多元回归分析；</p><p>按照自变量的多少，可分为简单回归分析和多重回归分析；</p><p>按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析。</p><p>如果在回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且自变量之间存在线性相关，则称为多重线性回归分析。</p><p>回归方程的绘制我们需要借助 <code>scikit-learn</code> 库，这个库是专门做机器学习用的，我们需要使用里面的线性回归类<code>sklearn.liear_regression.LinearRegression</code>。这里我们只是粗略了解下。</p><pre><code class="python">from sklearn.linear_model import LinearRegression// 假如有两组数据xtrain = male_athletes[&#39;Height&#39;]ytrain = male_athletes[&#39;Weight&#39;]model = LinearRegression()  // 线性回归分析模型xtrain = xtrain[:,np.newaxis]  // 把因变量转换成 1 列多行的数据, 也可用 reshape 函数model.fit(xtrain[:,np.newaxis],ytrain)   // 喂训练数据进去model.coef_                    // 斜率model.intercept_               // 截距new_y = model.predict(new_x)   // 根据回归方程计算出的 y 轴坐标</code></pre><h1 id="6- 饼图"><a href="#6- 饼图" class="headerlink" title="6. 饼图"></a>6. 饼图 </h1><p> 饼图是一个划分为几个扇形的圆形统计图表，用于描述量、频率或百分比之间的相对关系的。 在 <code>matplotlib</code> 中，可以通过 <code>plt.pie</code> 来实现。</p><pre><code>// 基本绘图函数plt.pie(x, labels=, explode=, autopct=, shadow=, textprops=, *kwargs)</code></pre><p>① <code>x</code>：饼图的比例数据序列。</p><p>② <code>labels</code>：饼图上每个分块的名称文字。</p><p>③ <code>explode</code>：设置某几个分块是否要分离饼图。</p><p>④ <code>autopct</code>：设置比例文字的展示方式。比如保留几个小数等。</p><p>⑤ <code>shadow</code>：是否显示阴影。</p><p>⑥ <code>textprops</code>：文本的属性（颜色，大小等）。</p><p>⑦<code>*kwargs</code>：包括颜色序列 <code>color</code>，饼图半径<code>radius</code>，标签与饼图距离<code>labeldistance</code> 等。</p><p>这个函数可以接收返回值：<code>patches, texts, autotexts=plt.pie()</code><br><code>patches</code>：饼图上每个分块的对象；<br><code>texts</code>：分块的名字文本对象；<br><code>autotexts</code>：分块的比例文字对象。</p><h3 id="举个例子 -4"><a href="# 举个例子 -4" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code class="python">oses = &#123;&#39;windows7&#39;:60.86,&#39;windows10&#39;: 18.46,&#39;windows8&#39;: 3.61,        &#39;windows xp&#39;: 10.3,&#39;mac os&#39;: 6.78,&#39; 其他 &#39;: 1.12&#125;names = oses.keys()percents = oses.values()plt.pie(percents,labels=names,autopct=&quot;%.2f%%&quot;,explode=(0,0.05,0,0,0,0))plt.show()</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/inde2333332wex.png" style="zoom:120%;" /><h1 id="7- 箱线图"><a href="#7- 箱线图" class="headerlink" title="7. 箱线图"></a>7. 箱线图 </h1><p> 箱线图（Box-plot）又称为盒须图、盒式图或箱型图，是一种用作显示一组数据分散情况资料的统计图。因形状如箱子而得名。在各种领域也经常被使用，它主要用于反映原始数据分布的特征，还可以进行多组数据分布特征的比较。箱线图的绘制方法是：先找出一组数据的 <strong> 上限值、下限值、中位数（Q2）和下四分位数（Q1）以及上四分位数（Q3）</strong>；然后，连接两个四分位数画出箱子；再将最大值和最小值与箱子相连接，中位数在箱子中间。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/5-2222223.png" style="zoom:80%;" /><pre><code>// 基本绘图函数 plt.boxplot(x, notch=, sym=, vert=, whis=, position=, *kwargs)</code></pre><p>① <code>x</code>：需要绘制箱线图的数据。</p><p>② <code>notch</code>：是否展示置信区间，默认为 False。</p><p>③ <code>sym</code>：异常点符号表示，默认小圆点。</p><p>④ <code>vert</code>：是否是垂直，默认 True。</p><p>⑤ <code>whis</code>：计算上下限所用的的系数，默认 1.5。如果数据本身就为序列，则无需用到。</p><p>⑥ <code>position</code>：设置每个盒子位置。</p><p>⑦<code>*kwargs</code>：还包括盒子宽度 <code>widths</code>，盒子标签<code>labels</code>，<code>meanline</code> 和<code>showmeans</code>都为 True 则指定绘制平均值线条。</p><p>此 <code>plt.boxplot()</code> 函数有返回值：返回一个字典，有以下<code>key</code>：</p><p><code>boxes</code>：箱图的主体，显示四分位数和中位数的置信区间（如果启用）。</p><p><code>medians</code>：每个框的中间的水平线。</p><p><code>whiskers</code>：垂直线延伸到最极端的非异常数据点。</p><p><code>caps</code>：晶须末端的水平线。</p><p><code>fliers</code>：表示超出晶须（传单）的数据的点。</p><p><code>means</code>：表示均值的点或线。</p><p><strong>细节设置等其他设置同 2.2。</strong></p><h3 id="举个例子 -5"><a href="# 举个例子 -5" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code class="python">df = pd.DataFrame(np.random.rand(10,5),columns=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;])// 输出结果如下：          A         B         C         D         E0  0.504272  0.613087  0.463340  0.294463  0.4373891  0.225515  0.792266  0.975446  0.450801  0.5649912  0.617762  0.691476  0.948907  0.073688  0.8213993  0.067783  0.149183  0.507391  0.458275  0.8501594  0.304483  0.300143  0.073447  0.017097  0.7288685  0.514748  0.735109  0.931701  0.489415  0.6500876  0.153983  0.161155  0.633645  0.717268  0.2503047  0.833904  0.890038  0.023813  0.812960  0.9843428  0.793293  0.027440  0.842855  0.854892  0.5892199  0.818400  0.981712  0.441924  0.257464  0.284837</code></pre><p><strong>画图：</strong></p><pre><code class="python">import numpy as npimport pandas as pdimport matplotlib.pyplot as pltplt.figure(figsize=(20,10))plt.boxplot(df.T,sym=&#39;o&#39;)  // 默认按行作图，所以这里转置了下，使得按列作图plt.xticks(range(1,6),[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;])plt.show()</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20200310173339531.png" alt=""></p><h1 id="8- 雷达图"><a href="#8- 雷达图" class="headerlink" title="8. 雷达图"></a>8. 雷达图 </h1><p> 雷达图（Radar Chart）又被叫做蜘蛛网图，适用于显示三个或更多的维度的变量的强弱情况。比如英雄联盟中某个影响的属性（法术伤害，物理防御等），或者是某个企业在哪些业务方面的投入等，都可以用雷达图方便的表示。</p><pre><code>// 基本绘图函数 plt.polar(theta, y, *kwargs)</code></pre><p>① <code>theta</code>：对应数值的坐标弧度，根据数据量将 2π分几个区间</p><p>② <code>y</code>：所需绘制的数组数据</p><p>③ <code>*kwargs</code>：其他参数可参照<code>plt.plot</code></p><p>注意事项：</p><p>1）因为 <code>polar</code> 并不会完成线条的闭合绘制，所以我们在绘制的时候需要在 <code>theta</code> 中和 <code>values</code> 中在最后多重复添加第 0 个位置的值，然后在绘制的时候就可以和第 1 个点进行闭合了。</p><p>2）<code>polar</code>只是绘制线条，所以如果想要把里面进行颜色填充，那么需要调用 <code>fill</code> 函数来实现。</p><p>3）<code>polar</code>默认的圆圈的坐标是角度，如果我们想要改成文字显示，那么可以通过 <code>xticks</code> 来设置。</p><h3 id="举个例子 -6"><a href="# 举个例子 -6" class="headerlink" title="举个例子"></a>举个例子</h3><pre><code class="python"> properties = [&#39; 输出 &#39;,&#39;KDA&#39;,&#39; 发育 &#39;,&#39; 团战 &#39;,&#39; 生存 &#39;] values = [40,91,44,90,95,40]         // 增加数据 40 使首尾闭合 theta = np.linspace(0,np.pi*2,6)     // 一定要写弧度值，个数与 values 对应 plt.polar(theta,values,&#39;y&#39;) plt.fill(theta,values,&#39;g&#39;)           // 填空颜色块 plt.xticks(theta,properties)         // 将刻度换成文本标签</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/indeeeerqdfex.png" alt=""></p><h1 id="9- 辅助线"><a href="#9- 辅助线" class="headerlink" title="9. 辅助线"></a>9. 辅助线 </h1><h2 id="9-1- 有限垂直线"><a href="#9-1- 有限垂直线" class="headerlink" title="9.1 有限垂直线"></a>9.1 有限垂直线</h2><pre><code>plt.vlines(x, ymin, ymax, colors=&#39;k&#39;, label=&#39;&#39;)</code></pre><h2 id="9-2- 有限水平线"><a href="#9-2- 有限水平线" class="headerlink" title="9.2 有限水平线"></a>9.2 有限水平线</h2><pre><code>plt.hlines(y, xmin, xmax, colors=&#39;k&#39;, label=&#39;&#39;)</code></pre><h2 id="9-3- 无限垂直线"><a href="#9-3- 无限垂直线" class="headerlink" title="9.3 无限垂直线"></a>9.3 无限垂直线</h2><pre><code>plt.axvline(x=0, ymin=0-1, ymax=0-1, hold=None, **kwargs)</code></pre><h2 id="9-4- 无限水平线"><a href="#9-4- 无限水平线" class="headerlink" title="9.4 无限水平线"></a>9.4 无限水平线</h2><pre><code>plt.axhline(y=0, xmin=0-1, xmax=0-1, hold=None, **kwargs)</code></pre><h2 id="9-5- 垂直区域"><a href="#9-5- 垂直区域" class="headerlink" title="9.5 垂直区域"></a>9.5 垂直区域</h2><pre><code>plt.axvspan(xmin, xmax, ymin=0-1, ymax=0-1, hold=None, **kwargs)</code></pre><h2 id="9-6- 水平区域"><a href="#9-6- 水平区域" class="headerlink" title="9.6 水平区域"></a>9.6 水平区域</h2><pre><code>plt.axhspan(ymin, ymax, xmin=0-1, xmax=0-1, hold=None, **kwargs)</code></pre><h1 id="10-matplotlib 绘图分析"><a href="#10-matplotlib 绘图分析" class="headerlink" title="10. matplotlib 绘图分析"></a>10. matplotlib 绘图分析</h1><h2 id="图像解剖分析"><a href="# 图像解剖分析" class="headerlink" title="图像解剖分析"></a> 图像解剖分析</h2><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/matplotlib%E5%9B%BE%E5%83%8F%E5%89%96%E6%9E%90%E8%AF%A6%E8%A7%A3.jpg" alt=""></p><ol><li><code>Figure</code>：图形绘制的画板，他就相当于一个黑板，所有的图都是绘制在 <code>Figure</code> 上面。</li><li><code>Axes</code>：每个图都是 <code>Axes</code> 对象。一个 <code>Figure</code> 上可以有多个 <code>Axes</code> 对象。</li><li><code>Axis</code>：<code>x</code>轴、<code>y</code>轴的对象。</li><li><code>Tick</code>：<code>x</code>轴和 <code>y</code> 轴上的刻度对象。每一个刻度都是一个 <code>Tick</code> 对象。</li><li><code>TickLabel</code>：每个刻度上都要显示文字，这个文字的显示就是在 <code>TickLabel</code> 上。</li><li><code>AxisLabel</code>：<code>x</code>轴和 <code>y</code> 轴的名称的文字显示。</li><li><code>Legend</code>：图例对象。</li><li><code>Title</code>：<code>Axes</code>图的标题对象。</li><li><code>Line2D</code>：绘制在 <code>Axes</code> 上的线条对象，比如折线图等。</li><li><code>Reactangle</code>：绘制在 <code>Axes</code> 上的矩形对象，比如条形图等。</li><li><code>Marker</code>：标记点，比如绘制散点图上的每个点就是这个对象。</li><li><code>Artist</code>：只要是绘制在 <code>Figure</code> 上的元素（包括 Figure），都是 <code>Artist</code> 的子类。</li></ol><h2 id="10-1-Figure 容器"><a href="#10-1-Figure 容器" class="headerlink" title="10.1 Figure 容器"></a>10.1 Figure 容器 </h2><p><code>Figure</code> 容器是最底层的容器，他几乎包含了这个图的所有对象。通过 <code>add_subplot</code> 和<code>add_axes</code>方法可以添加 <code>Axes</code> 对象，这两个方法添加的都是 <code>Axes</code> 及其子类的对象。添加完成后是存储在 <code>figure.axes</code> 中。</p><h3 id="10-1-1- 添加 Axes 对象"><a href="#10-1-1- 添加 Axes 对象" class="headerlink" title="10.1.1 添加 Axes 对象"></a>10.1.1 添加 Axes 对象 </h3><p><code>Figure</code> 只是一个黑板，如果想要绘图，需要先添加 <code>Axes</code>。添加<code>Axes</code> 可以通过 <code>add_axes</code> 和<code>add_subplot</code>来实现。示例代码如下：</p><pre><code class="python">fig = plt.figure()          // 创建一个 figure 对象ax1 = fig.add_subplot(211)  // 添加一个 Axesax2 = fig.add_axes([0.1,0.1,0.8,0.3])   // 添加一个 Axes，其中参数是 left,bottom,width,height</code></pre><h3 id="10-1-2- 操作当前 Axes 对象"><a href="#10-1-2- 操作当前 Axes 对象" class="headerlink" title="10.1.2  操作当前 Axes 对象"></a>10.1.2  操作当前 Axes 对象 </h3><p> 可以通过 <code>figure.gca</code> 以及 <code>figure.sca</code> 来设置和获取当前的 <code>axes</code> 对象。</p><pre><code class="python">&gt;&gt;&gt; fig = plt.figure()&gt;&gt;&gt; ax1 = fig.add_subplot(211)&gt;&gt;&gt; ax2 = fig.add_axes([0,0,1,0.3])&gt;&gt;&gt; print(fig.gca())&gt;&gt;&gt; print(fig.sca(ax1))Axes(0,0;1x0.3)AxesSubplot(0.125,0.536818;0.775x0.343182)</code></pre><h3 id="10-1-3- 删除 Axes 对象"><a href="#10-1-3- 删除 Axes 对象" class="headerlink" title="10.1.3  删除 Axes 对象"></a>10.1.3  删除 Axes 对象 </h3><p><code>Figure</code> 上的所有 <code>Axes</code> 对象都是保存在 <code>fig.axes</code> 中，但是如果想要删除某个 <code>Axes</code> 对象，那么必须通过 <code>delaxes</code> 来实现。</p><pre><code class="python">ig = plt.figure()ax1 = fig.add_subplot(211)ax2 = fig.add_axes([0,0,1,0.3])fig.delaxes(ax1)</code></pre><h3 id="10-1-4- 获取所有的 axes"><a href="#10-1-4- 获取所有的 axes" class="headerlink" title="10.1.4 获取所有的 axes"></a>10.1.4 获取所有的 axes</h3><pre><code class="python">for ax in fig.axes:    ax.grid(True)       // 设置打开网格</code></pre><h3 id="10-1-5-Figure 的属性汇总"><a href="#10-1-5-Figure 的属性汇总" class="headerlink" title="10.1.5 Figure 的属性汇总"></a>10.1.5 Figure 的属性汇总</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/5-2242422222r8.png" alt=""></p><h2 id="10-2-Axes 容器"><a href="#10-2-Axes 容器" class="headerlink" title="10.2 Axes 容器"></a>10.2 Axes 容器 </h2><p><code>Axes</code> 容器是用来创建具体的图形的。比如画曲线，柱状图，都是画在上面。所以之前我们学的使用 <code>plt.xx</code> 绘制各种图形（比如条形图，直方图，散点图等）都是对 <code>Axes</code> 的封装。比如 <code>plt.plot</code> 对应的是 <code>axes.plot</code>，比如<code>plt.hist</code> 对应的是 <code>axes.hist</code>。针对图的所有操作，都可以在<code>Axes</code> 上找到对应的 <code>API</code>。另外后面要讲到的<code>Axis</code> 容器，是轴的对象，也是绑定在 <code>Axes</code> 上面。</p><h3 id="10-2-1- 设置 x 和 y 轴"><a href="#10-2-1- 设置 x 和 y 轴" class="headerlink" title="10.2.1 设置 x 和 y 轴"></a>10.2.1 设置 x 和 y 轴</h3><pre><code class="python">fig = plt.figure()  axes = fig.add_subplot(111)  axes.plot(np.random.randn(10))axes.set_xlim(-2,12)  // 设置 x 轴的最大值和最小值axes.set_ylim(-3,3)   // 设置 y 轴的最大值和最小值</code></pre><h3 id="10-2-2- 添加文本"><a href="#10-2-2- 添加文本" class="headerlink" title="10.2.2  添加文本"></a>10.2.2  添加文本 </h3><p> 之前添加文本我们用的是 <code>annotate</code>，但是如果不是需要做注释，其实还有另外一种更加简单的方式，那就是使用<code>text</code> 方法：</p><pre><code class="python">data = np.random.randn(10)fig = plt.figure()axes = fig.add_subplot(111)axes.plot(data)axes.text(0,0,&quot;hello&quot;，ha=&#39;center&#39;)  // 添加文本，比 annotate 更加方便</code></pre><h3 id="10-2-3- 绘制双 Y 轴"><a href="#10-2-3- 绘制双 Y 轴" class="headerlink" title="10.2.3 绘制双 Y 轴"></a>10.2.3 绘制双 <code>Y</code> 轴</h3><pre><code class="python">fig = plt.figure()ax1 = fig.add_subplot(211)ax1.bar(np.arange(0,10,2),np.random.rand(5))ax1.set_yticks(np.arange(0,1,0.25))ax2 = ax1.twinx()                     // 克隆一个共享 x 轴的 axes 对象ax2.plot(np.random.randn(10),c=&quot;b&quot;)plt.show()</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/indewr ww wex.png" style="zoom:150%;" /><h2 id="10-3-Axis 容器"><a href="#10-3-Axis 容器" class="headerlink" title="10.3 Axis 容器"></a>10.3 Axis 容器 </h2><p><code>Axis</code> 代表的是 <code>x</code> 轴或者 <code>y</code> 轴的对象。包含 <code>Tick</code>（刻度）对象，<code>TickLabel</code> 刻度文本对象，以及 <code>AxisLabel</code> 坐标轴文本对象。<code>axis</code>对象有一些方法可以操作刻度和文本等。</p><h3 id="10-3-1- 设置 label 的位置"><a href="#10-3-1- 设置 label 的位置" class="headerlink" title="10.3.1 设置 label 的位置"></a>10.3.1 设置 label 的位置</h3><pre><code class="python">fig = plt.figure()axes = fig.add_subplot(111)axes.plot(np.random.randn(10))axes.set_xlabel(&quot;x coordate&quot;)axes.xaxis.set_label_coords(0,-0.1)  // 设置 x 轴 label 的位置为(0.-0.1)</code></pre><h3 id="10-3-2- 设置刻度格式"><a href="#10-3-2- 设置刻度格式" class="headerlink" title="10.3.2 设置刻度格式"></a>10.3.2 设置刻度格式</h3><pre><code class="python">import matplotlib.ticker as tickerfig = plt.figure()axes = fig.add_subplot(111)axes.plot(np.random.randn(10))axes.set_xlabel(&quot;x coordate&quot;)formatter = ticker.FormatStrFormatter(&#39;%.2f&#39;)   // 创建格式化对象axes.yaxis.set_major_formatter(formatter)       // 设置格式化对象</code></pre><h3 id="10-3-3- 设置轴的属性"><a href="#10-3-3- 设置轴的属性" class="headerlink" title="10.3.3 设置轴的属性"></a>10.3.3 设置轴的属性</h3><pre><code class="python">fig = plt.figure()ax1 = fig.add_axes([0.1, 0.3, 0.4, 0.4])ax1.set_facecolor(&#39;lightslategray&#39;)for label in ax1.xaxis.get_ticklabels():  // 设置刻度上文本的属性    # label 是一个 Label 对象    label.set_color(&#39;red&#39;)    label.set_rotation(45)    label.set_fontsize(16)for line in ax1.yaxis.get_ticklines():    // 设置刻度上线条的属性    line.set_color(&#39;green&#39;)              //line 是一个 Line2D 对象    line.set_markersize(25)    line.set_markeredgewidth(3)plt.show()</code></pre><h2 id="10-4-Tick 容器"><a href="#10-4-Tick 容器" class="headerlink" title="10.4 Tick 容器"></a>10.4 Tick 容器 </h2><p><code>Tick</code> 是用来做刻度的，包括刻度和网格对象。其中可操作的属性如下：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/5wwrwr43-31.png" alt=""></p><pre><code class="python">import matplotlib.ticker as tickernp.random.seed(19680801)fig, ax = plt.subplots()ax.plot(100*np.random.rand(20))formatter = ticker.FormatStrFormatter(&#39;$%.2f&#39;)ax.yaxis.set_major_formatter(formatter)for tick in ax.yaxis.get_major_ticks():    tick.label1On = False    tick.label2On = True    tick.label2.set_color(&#39;green&#39;)plt.show()</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/5-334242r2.png" alt=""></p><h1 id="11- 多图布局"><a href="#11- 多图布局" class="headerlink" title="11. 多图布局"></a>11. 多图布局 </h1><h2 id="11-1- 宽松布局"><a href="#11-1- 宽松布局" class="headerlink" title="11.1 宽松布局"></a>11.1 宽松布局</h2><p> 在一个 <code>Figure</code> 上面，可能存在多个 <code>Axes</code> 对象，如果 <code>Figure</code> 比较小，那么有可能会造成一些图形元素重叠，这时候我们就可以通过 <code>fig.tight_layout</code> 或者是 <code>fig.subplots_adjust</code> 方法来帮我们调整。假如现在没有经过调整，那么以下代码的效果图如下：</p><pre><code class="python">import matplotlib.pyplot as pltimport numpy as npdef example_plot(ax, fontsize=12):    ax.plot([1, 2])    ax.set_xlabel(&#39;x-label&#39;, fontsize=fontsize)    ax.set_ylabel(&#39;y-label&#39;, fontsize=fontsize)    ax.set_title(&#39;Title&#39;, fontsize=fontsize)fig,axes = plt.subplots(2,2)fig.set_facecolor(&quot;y&quot;)example_plot(axes[0,0])example_plot(axes[0,1])example_plot(axes[1,0])example_plot(axes[1,1])// 加下面一行代码，可图变不拥挤plt.tight_layout()</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/ind241ssssssssex.png" alt=""></p><p>也可传入参数自定义调整：</p><pre><code class="python">tight_layout(w_pad,h_pad)  // 可设置水平，垂直方向图的间距fig.subplots_adjust(left,bottom,righte,top,wspace=,hspace=)</code></pre><h2 id="11-2- 自定义布局"><a href="#11-2- 自定义布局" class="headerlink" title="11.2 自定义布局"></a>11.2 自定义布局 </h2><p> 如果布局不是固定的几宫格的方式，而是某个图占据了多行或者多列，那么就需要采用一些手段来实现。如果不是很复杂，那么直接可以通过 <code>subplot</code> 等方法来实现。示例代码如下：</p><pre><code class="python">ax1 = plt.subplot(221)    // 分成 2x2，占用第 1 个，即第一行第一列的子图ax2 = plt.subplot(223)    // 分成 2x2，占用第 3 个，即第二行第一列的子图ax3 = plt.subplot(122)   // 分成 1x2，占用第二个，即第二列</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/5-32222226.png" alt=""></p><p>但是如果实现的布局比较复杂，那么就需要采用 <code>GridSpec</code> 对象来实现：</p><pre><code class="python">fig = plt.figure()gs = fig.add_gridspec(3,3)  // 创建 3 行 3 列的 GridSpec 对象ax1 = fig.add_subplot(gs[0,0:3])ax1.set_title(&quot;[0,0:3]&quot;)ax2 = fig.add_subplot(gs[1,0:2])ax2.set_title(&quot;[1,0:2]&quot;)ax3 = fig.add_subplot(gs[1:3,2])ax3.set_title(&quot;[1:3,2]&quot;)ax4 = fig.add_subplot(gs[2,0])ax4.set_title(&quot;[2,0]&quot;)ax5 = fig.add_subplot(gs[2,1])ax5.set_title(&quot;[2,1]&quot;)plt.tight_layout()</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/5-242342437.png" alt=""></p><p>也可以设置宽高比例。示例代码如下：</p><pre><code>widths = (1,2,1)         // 设置宽度比例为 1:2:1heights = (2,2,1)        // 设置高度比例为 2:2:1fig = plt.figure()// 创建 GridSpec 对象的时候指定宽高的比gs = fig.add_gridspec(3,3,width_ratios=widths,height_ratios=heights)for row in range(0,3):    for col in range(0,3):        fig.add_subplot(gs[row,col])plt.tight_layout()</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/5-312312318.png" alt=""></p><h2 id="11-3- 手动设置位置"><a href="#11-3- 手动设置位置" class="headerlink" title="11.3 手动设置位置"></a>11.3 手动设置位置 </h2><p> 通过 <code>fig.add_axes</code> 的方式添加 <code>Axes</code> 对象，可以直接指定位置。也可以在添加完成后，通过 <code>axes.set_position</code> 的方式设置位置。示例代码如下：</p><pre><code>// add_axes 的方式fig = plt.figure()fig.add_subplot(111)fig.add_axes([0.2,0.2,0.4,0.4])// 设置 position 的方式fig,axes = plt.subplots(1,2)axes[1].set_position([0.2,0.2,0.4,0.4])</code></pre><h2 id="11-4- 实践"><a href="#11-4- 实践" class="headerlink" title="11.4 实践"></a>11.4 实践</h2><pre><code>fig = plt.figure(figsize=(8,8))widths = (2,0.5)heights = (0.5,2)gs = fig.add_gridspec(2,2,width_ratios=widths,height_ratios=heights)// 顶部的直方图ax1 = fig.add_subplot(gs[0,0])ax1.hist(male_athletes[&#39;Height&#39;],bins=20)for tick in ax1.xaxis.get_major_ticks():    tick.label1On = False// 中间的散点图ax2 = fig.add_subplot(gs[1,0])ax2.scatter(&#39;Height&#39;,&#39;Weight&#39;,data=male_athletes)// 右边的直方图ax3 = fig.add_subplot(gs[1,1])ax3.hist(male_athletes[&#39;Weight&#39;],bins=20,orientation=&#39;horizontal&#39;)for tick in ax3.yaxis.get_major_ticks():    tick.label1On = Falsefig.tight_layout(h_pad=0,w_pad=0)</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/5-23123139.png" alt=""></p><h1 id="12-Matplotlib 配置"><a href="#12-Matplotlib 配置" class="headerlink" title="12. Matplotlib 配置"></a>12. Matplotlib 配置 </h1><h2 id="12-1- 修改默认的配置"><a href="#12-1- 修改默认的配置" class="headerlink" title="12.1 修改默认的配置"></a>12.1 修改默认的配置</h2><p> 修改默认的配置可以通过 <code>matplotlib.rcParams</code> 来设置，比如修改字体，修改线条大小和宽度等。示例代码如下：</p><pre><code class="python">import matplotlib.pyplot as plt// 设置字体为仿宋plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;FangSong&#39;]// 设置字体大小为 20plt.rcParams[&#39;font.size&#39;] = 20// 设置线条宽度plt.rcParams[&#39;lines.linewidth&#39;] = 2// 设置线条颜色plt.rcParams[&#39;axes.prop_cycle&#39;] = plt.cycler(&#39;color&#39;, [&#39;r&#39;, &#39;y&#39;])</code></pre><p>字体设置值对照表：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/5-4231231eww0.png" alt=""></p><h2 id="12-2- 自定义配置文件"><a href="#12-2- 自定义配置文件" class="headerlink" title="12.2 自定义配置文件"></a>12.2 自定义配置文件 </h2><p> 有时候我们可能需要设置一大堆参数，并且这个配置在后面很多项目中可能都会用到，那么这时候我们就可以把这些配置信息放到文件中（可配置项见下），文件的命名规则为 <code>[名称].mplstyle</code>，然后把这个文件放到<code>matplotlib.get_configdir()/stylelib</code> 的目录中，在写代码的时候根据名称加载这个配置文件，示例代码如下：</p><pre><code>plt.style.use(&quot; 名称 &quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas 数据分析处理实操</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E5%AE%9E%E6%93%8D/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86%E5%AE%9E%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h1 id="1- 案例一"><a href="#1- 案例一" class="headerlink" title="1. 案例一"></a>1. 案例一</h1><h2 id="1-1- 数据读取"><a href="#1-1- 数据读取" class="headerlink" title="1.1 数据读取"></a>1.1 数据读取</h2><pre><code class="python">&gt;&gt;&gt; df=pd.read_csv(&#39;D:\ 数据分析素材 \DataAnalyst.csv&#39;,encoding=&#39;gb2312&#39;)&gt;&gt;&gt; df</code></pre><p>前几列：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_11-03-16.jpg" alt=""></p><p>后几列：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_11-17-10.jpg" alt=""></p><p><strong>上述呈现形式只能看个大概，需要对这些数据进一步进行粗略统计分析观察</strong></p><h2 id="1-2- 预分析"><a href="#1-2- 预分析" class="headerlink" title="1.2 预分析"></a>1.2 预分析</h2><pre><code class="python">&gt;&gt;&gt; df.info()</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_11-07-21.jpg" style="zoom:80%;" /><p>由此可以看到，每一列应该包含 6876 个数据，但是 index=3,6……等数据有空，其数据是不完整的。</p><p>表格数据中’positionId’这一列代表的招聘公司及职位的 ID，具有唯一性，有多少 ID，就有多少招聘岗位。其他为重复值。</p><pre><code class="python">&gt;&gt;&gt; len(df.positionId.unique())5031</code></pre><p>由此可以看到有效数据量为 5031 条。</p><h2 id="1-3- 数据清洗"><a href="#1-3- 数据清洗" class="headerlink" title="1.3 数据清洗"></a>1.3 数据清洗 </h2><p><strong> 删除重复值</strong></p><pre><code class="python">&gt;&gt;&gt; df1=df.drop_duplicates([&#39;positionId&#39;])     // 按 positionID 列删除重复值&gt;&gt;&gt; df1.info()</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_11-49-26.jpg" style="zoom:80%;" /><p><strong>数据规整</strong></p><p>我们最为关心的数据之一就是薪水，它给出的是一个范围，我们要提取其中最大和最小值。</p><pre><code class="python">// 定义一个切词函数def cut_word(word,method):    position=word.find(&#39;-&#39;)   // 在 word 里找 &#39;-&#39;，找到了返回其索引位置，找不到返回 -1    length=len(word)    if position != -1:                 bottom_salary=word[:position-1]        // 如 word 为 &#39;6k-9k&#39;, 则返回 6        top_salary=word[position+1:length-1]    else:        bottom_salary=word[:word.upper().find(&#39;K&#39;)] // 有的 word 里是 &#39;10K 以上 &#39;，没有 &#39;-&#39;，则只取数字部分        top_salary=bottom_salary    if method == &#39;bottom&#39;:        return bottom_salary    else:        return top_salary&gt;&gt;&gt; df1[&#39;bottom_salary&#39;]=df1.salary.apply(cut_word,method=&#39;bottom&#39;) // 注意这里传参方式&gt;&gt;&gt; df1[&#39;top_salary&#39;]=df1.salary.apply(cut_word,method=&#39;top&#39;)&gt;&gt;&gt; df1.head() </code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_12-20-02.jpg" style="zoom:80%;" /><p>这里的’bottom_salary’和’top_salary’都是字符类型数据，需要转换成整型数据。</p><pre><code class="python">&gt;&gt;&gt; df1.bottom_salary = df1.bottom_salary.astype(&#39;int&#39;)  // 数据类型转换&gt;&gt;&gt; df1.top_salary = df1.top_salary.astype(&#39;int&#39;)&gt;&gt;&gt; df1[&#39;avg_salary&#39;] = df1.apply(lambda x:(x.bottom_salary+x.top_salary)/2,axis=1)&gt;&gt;&gt; df1.head()</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_12-36-05.jpg" style="zoom:80%;" /><p><strong>最后只提取我们的需要的核心数据</strong></p><pre><code class="python">&gt;&gt;&gt; df2 = df1[[&#39;city&#39;,&#39;companyShortName&#39;,&#39;companySize&#39;,&#39;education&#39;,            &#39;positionName&#39;,&#39;positionLables&#39;,&#39;workYear&#39;,&#39;avg_salary&#39;]] // 注意这里两个括号&gt;&gt;&gt; df2</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_12-43-46.jpg" style="zoom:80%;" /><pre><code class="python">&gt;&gt;&gt; df2=df2.reset_index()   // 可以将数据行索引变成 0-5030</code></pre><h2 id="1-4- 数据分析"><a href="#1-4- 数据分析" class="headerlink" title="1.4 数据分析"></a>1.4 数据分析 </h2><p><strong> 描述性统计</strong></p><pre><code>&gt;&gt;&gt; df2.city.value_counts()   // 统计城市职位需求北京    2347上海     979深圳     527杭州     406广州     335成都     135南京      83武汉      69西安      38苏州      37厦门      30长沙      25天津      20Name: city, dtype: int64</code></pre><pre><code class="python">&gt;&gt;&gt; df2.describe()    // 只有 avg_salary 数据列为整型数据，故只统计 avg_salary　　　　　avg_salarycount     5031.000000mean     17.111409std     8.996242min     1.50000025%     11.50000050%     15.00000075%     22.500000max     75.000000</code></pre><h2 id="1-5- 可视化"><a href="#1-5- 可视化" class="headerlink" title="1.5 可视化"></a>1.5 可视化</h2><p><strong>Pandas 其实内置了简单的可视化工具</strong></p><p><strong>城市工资情况统计：</strong></p><pre><code class="python">&gt;&gt;&gt; df2.avg_salary.hist()   // 直方图</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_13-43-03.jpg" alt=""></p><pre><code class="python">&gt;&gt;&gt; df2.boxplot(column=&#39;avg_salary&#39;,by=&#39;city&#39;,figsize=(9,7))  // 箱线图</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/4324vvfdxf.png" style="zoom:80%;" /><p>上述箱线图横坐标城市本来为框，显示异常，可填入如下代码使之显示正常。</p><pre><code class="python">// 导入相关工具包&gt;&gt;&gt; import matplotlib.pyplot as plt&gt;&gt;&gt; %matplotlib inline    // 为了可以直接在 jupyter notebook 中直接输出图表, 其实可以省略&gt;&gt;&gt; plt.style.use(&#39;ggplot&#39;)&gt;&gt;&gt; plt.rcParams[&#39;font.sans-serif&#39;] = [&#39;SimHei&#39;] // 指定默认字体&gt;&gt;&gt; plt.rcParams[&#39;axes.unicode_minus&#39;] = False  // 解决保存图像是负号 &#39;-&#39; 显示为方块的问题</code></pre><p><strong>职位关键词统计：</strong></p><pre><code class="python">&gt;&gt;&gt; df2.positionLables              // 观察 positionLables 列的内容格式&gt;&gt;&gt; word = df2.positionLables.str[1:-1].replace(&#39; &#39;,&#39;&#39;)  // 去掉中括号, 去掉空格</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_14-05-07.jpg" alt=""></p><pre><code>&gt;&gt;&gt; df_word=word.dropna().str.split(&#39;,&#39;).apply(pd.value_counts)  // 统计每个关键词在每行出现的次数</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_14-22-08.jpg" alt=""></p><pre><code class="python">&gt;&gt;&gt; df_word_counts = df_word.unstack().dropna().reset_index().groupby(&#39;level_0&#39;).count()// 将 DataFrame 变成 Series，再按照 level_0 统计每个词出现的个数</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-20_14-27-35.jpg" style="zoom:80%;" /><p><strong>生成词云图：</strong></p><pre><code class="python">&gt;&gt;&gt; from wordcloud import WordCloud&gt;&gt;&gt; df_word_counts.index = df_word_counts.index.str.replace(&quot;&#39;&quot;,&quot;&quot;)&gt;&gt;&gt; wordcloud = WordCloud(font_path=&#39;C:\Windows\Fonts\simsun.ttc&#39;,                          width=900,height=400,                          background_color=&#39;white&#39;)&gt;&gt;&gt; f,axs = plt.subplots(figsize=(15,15))&gt;&gt;&gt; wordcloud.fit_words(df_word_counts.level_1)&gt;&gt;&gt; axs = plt.imshow(wordcloud)&gt;&gt;&gt; plt.axis(&#39;off&#39;)&gt;&gt;&gt; plt.show()</code></pre><p>![](<a href="https://image--1.oss-cn-shenzhen.aliyuncs.com/dhasiudhasud">https://image--1.oss-cn-shenzhen.aliyuncs.com/dhasiudhasud</a> hae34.png)</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 文本编辑技巧</title>
      <link href="/Markdown%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E6%8A%80%E5%B7%A7/"/>
      <url>/Markdown%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown</strong>是一种可以使用普通文本编辑器编写的标记语言，通过类似 HTML 的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持众多富文本功能的。</p><ul><li><strong>此文章的主要目的是：给 markdown 文本提供更多的编辑表现可能。</strong></li></ul><h1 id="1- 开始前"><a href="#1- 开始前" class="headerlink" title="1. 开始前"></a>1. 开始前 </h1><h2 id="认识网页结构"><a href="# 认识网页结构" class="headerlink" title="认识网页结构"></a><strong> 认识网页结构 </strong></h2><p> 网页一般由三部分组成：分别是：</p><ul><li><p><strong>HTML 超文本标记语言</strong>，是整个网页的结构，相当于整个网页的框架</p><p>常见的标签如下：</p><pre><code>&lt;html&gt;...&lt;/html&gt;          表示标记中间的元素是网页&lt;head&gt;...&lt;/head&gt;          用来申明使用的脚本语言，以及网页传输时使用的方式&lt;body&gt;...&lt;/body&gt;          表示用户可见的内容&lt;div&gt;...&lt;/div&gt;            表示框架&lt;p&gt;...&lt;/p&gt;                表示段落&lt;h1&gt;...&lt;/h1&gt;              表示标题&lt;li&gt;...&lt;/li&gt;              表示列表&lt;ul&gt;...&lt;/ul&gt;              表示无序列表&lt;ol&gt;...&lt;/ol&gt;              表示有序列表&lt;img&gt;...&lt;/img&gt;            表示图片&lt;a href=&quot;   &quot;&gt;...&lt;/a&gt;     表示超链接 </code></pre></li><li><p><strong>CSS 层叠样式表</strong>，用来定义外观</p></li><li><p><strong>JScript</strong>，表示功能，交互的内容和各种特效都在里面。</p></li></ul><p><strong>可以这样理解：如果用人体来比喻，HTML 是人体的骨架，并且定义了嘴巴，眼睛，耳朵要长在那里，这是人的基本要素。CSS 是人的外观细节，如嘴巴长什么样子，眼睛是单还是双眼皮，皮肤是黑还是白等。JScript 表示人的技能，如会不会跳舞，唱歌，演奏乐器等。</strong></p><h1 id="2- 字体，字号和颜色"><a href="#2- 字体，字号和颜色" class="headerlink" title="2. 字体，字号和颜色"></a>2. 字体，字号和颜色 </h1><pre><code>&lt;font color=#0099ff size=7 face=&quot; 黑体 &quot;&gt; 这是我的显示效果 &lt;/font&gt;</code></pre><p><font color=#0099ff size=7 face="黑体"> 这是我的显示效果</font></p><p>颜色对照表<a href="https://blog.csdn.net/weixin_37998647/article/details/79428290">https://blog.csdn.net/weixin_37998647/article/details/79428290</a></p><h1 id="3- 背景色设置"><a href="#3- 背景色设置" class="headerlink" title="3. 背景色设置"></a>3. 背景色设置 </h1><pre><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt; 这是我的背景色 &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></pre><table><tr><td bgcolor=#D1EEEE> 这是我的背景色</td></tr></table><h1 id="4- 居中，左右对齐"><a href="#4- 居中，左右对齐" class="headerlink" title="4. 居中，左右对齐"></a>4. 居中，左右对齐</h1><pre><code>&lt;center&gt;&lt;font size=5 face=&quot; 黑体 &quot;&gt; 这是我的显示效果 &lt;/font&gt;&lt;/center&gt;                    居中&lt;p align=&#39;left&#39;&gt;&lt;font size=5 face=&quot; 黑体 &quot;&gt; 这是我的显示效果 &lt;/font&gt;&lt;/p align=&#39;left&#39;&gt;    左对齐&lt;p align=&#39;right&#39;&gt;&lt;font size=5 face=&quot; 黑体 &quot;&gt; 这是我的显示效果 &lt;/font&gt;&lt;/p align=&#39;right&#39;&gt;  有对齐 </code></pre><center><font size=5 face="黑体"> 这是我的显示效果</font></center><p align='left'><font size=5 face="黑体">这是我的显示效果</font></p align='left'><p align='right'><font size=5 face="黑体">这是我的显示效果</font></p align='right'><h1 id="5- 矩阵形式输入"><a href="#5- 矩阵形式输入" class="headerlink" title="5. 矩阵形式输入"></a>5. 矩阵形式输入 </h1><p><strong> 首先通过编辑器插入公式块，再添加内容</strong>。</p><p><strong>不带括号</strong></p><pre><code>$$\begin&#123;matrix&#125;1&amp;2\\3&amp;4\\5&amp;6\end&#123;matrix&#125;</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/%E4%B8%8D%E5%B8%A6%E6%8B%AC%E5%8F%B7.jpg" alt="不带括号"></p><p><strong>带中括号</strong></p><pre><code>$$\left[\begin&#123;matrix&#125;1&amp;2\\3&amp;4\\5&amp;6\end&#123;matrix&#125;\right]$$</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/%E5%B8%A6%E4%B8%AD%E6%8B%AC%E5%8F%B7.jpg" alt="带中括号"></p><p><strong>带大括号</strong></p><pre><code>$$\left\&#123;\begin&#123;matrix&#125;1&amp;2\\3&amp;4\\5&amp;6\end&#123;matrix&#125;\right\&#125;$$</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/%E5%B8%A6%E5%A4%A7%E6%8B%AC%E5%8F%B7.jpg" alt="带大括号"></p><h1 id="6- 更多"><a href="#6- 更多" class="headerlink" title="6. 更多"></a>6. 更多 </h1><p> 参考<a href="https://blog.csdn.net/silver1225/article/details/89036250?utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/silver1225/article/details/89036250?utm_source=distribute.pc_relevant.none-task</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 之 Pandas 库从入门到实战</title>
      <link href="/Python%E4%B9%8BPandas%E5%BA%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
      <url>/Python%E4%B9%8BPandas%E5%BA%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是 Pandas"><a href="# 什么是 Pandas" class="headerlink" title="什么是 Pandas?"></a>什么是 Pandas?</h1><blockquote><p>Pandas 的名称来自于面板数据（panel data）</p></blockquote><p>Pandas 是一个强大的分析结构化数据的工具集，基于 NumPy 构建，提供了 <strong> 高级数据结构 </strong> 和<strong>数据操作工具</strong>，它是使 Python 成为强大而高效的数据分析环境的重要因素之一。</p><ul><li>一个强大的分析和操作大型结构化数据集所需的工具集</li><li>基础是 NumPy，提供了高性能矩阵的运算</li><li>提供了大量能够快速便捷地处理数据的函数和方法</li><li>应用于数据挖掘，数据分析</li><li>提供数据清洗功能</li></ul><h1 id="为什么要学习 pandas"><a href="# 为什么要学习 pandas" class="headerlink" title="为什么要学习 pandas?"></a>为什么要学习 pandas?</h1><p>NumPy 已经能够帮助我们处理数据，能够结合 matplotlib 解决我们数据分析的问题，那么 pandas 学习的目的在什么地方呢？</p><p>NumPy 能够帮我们处理处理数值型数据，但是这还不够， 很多时候，我们的数据除了数值之外，还有字符串，还有时间序列等。</p><h1 id="1- 数据结构"><a href="#1- 数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构 </h1><h2 id="1-1-Series"><a href="#1-1-Series" class="headerlink" title="1.1 Series"></a>1.1 Series</h2><h3 id="1-1-1- 创建"><a href="#1-1-1- 创建" class="headerlink" title="1.1.1 创建"></a>1.1.1 创建</h3><p><strong> 从列表创建：</strong></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; pd.Series([1,2,3,4,5])0    11    22    33    44    5dtype: int64</code></pre><p><strong>从数组创建：</strong></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; pd.Series(np.arange(5))0    01    12    23    34    4dtype: int32</code></pre><p><strong>自定义索引：</strong></p><pre><code class="python">&gt;&gt;&gt; a=pd.Series([1,2,3,4,5],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])    // 自定义索引&gt;&gt;&gt; a                             a    1b    2c    3d    4e    5               // 此时 a,b,c,d,e 叫标签，索引还是 0-4dtype: int64&gt;&gt;&gt; a.valuesarray([1, 2, 3, 4, 5], dtype=int64)&gt;&gt;&gt; a.indexIndex([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;], dtype=&#39;object&#39;)</code></pre><p><strong>从字典创建：</strong></p><pre><code class="python">&gt;&gt;&gt; dict=&#123;&#39;name&#39;:&#39; 姚明 &#39;,&#39;age&#39;:46,&#39;height&#39;:190&#125;&gt;&gt;&gt; pd.Series(dict)name      姚明age        46height    190dtype: object</code></pre><h3 id="1-1-2- 基本使用"><a href="#1-1-2- 基本使用" class="headerlink" title="1.1.2 基本使用"></a>1.1.2 基本使用</h3><pre><code class="python">&gt;&gt;&gt; dict=&#123;&#39;name&#39;:&#39; 姚明 &#39;,&#39;age&#39;:46,&#39;height&#39;:190&#125;&gt;&gt;&gt; a=pd.Series(dict,index=[&#39;name&#39;,&#39;age&#39;,&#39;sex&#39;])&gt;&gt;&gt; aname     姚明age      46sex     NaNdtype: object&gt;&gt;&gt; a.isnull()  // 检查是否为空name    Falseage     Falsesex      Truedtype: bool&gt;&gt;&gt; a.notnull()   // 检查是否不为空</code></pre><h4 id="索引"><a href="# 索引" class="headerlink" title="索引"></a>索引</h4><pre><code class="python">&gt;&gt;&gt; a[0]             // 位置索引&gt;&gt;&gt; a[&#39;name&#39;]        // 标签索引&gt;&gt;&gt; a[-1]            // 负号索引&gt;&gt;&gt; a[[0,2]]         // 选取多个，也可标签 a[[&#39;name&#39;,&#39;sex&#39;]]&gt;&gt;&gt; s=pd.Series(np.arange(5))&gt;&gt;&gt; s[s&gt;3]           // 布尔索引</code></pre><h4 id="切片"><a href="# 切片" class="headerlink" title="切片"></a>切片</h4><pre><code class="python">&gt;&gt;&gt; a[0:2]&gt;&gt;&gt; a[&#39;name&#39;:&#39;sex&#39;]</code></pre><h4 id="广播"><a href="# 广播" class="headerlink" title="广播"></a>广播</h4><pre><code class="python">&gt;&gt;&gt; s=pd.Series(np.arange(5),index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;])&gt;&gt;&gt; s+2a    2b    3c    4d    5e    6dtype: int32</code></pre><h4 id="补充"><a href="# 补充" class="headerlink" title="补充"></a>补充</h4><p><code>s.index.unique()</code> 返回索引唯一值</p><p><code>s.index.is_unique()</code>  判断是否为唯一值 返回<code>True/False</code></p><p><code>s.value_counts()</code>     返回值以及计数，组成一个 Series</p><p><code>s.isin([8])</code> 判断 s 里面是否有 8  返回布尔类型的 Series    # 也可对 DataFrame 进行判断</p><h2 id="1-2-DataFrame"><a href="#1-2-DataFrame" class="headerlink" title="1.2 DataFrame"></a>1.2 DataFrame</h2><p>表格型数据结构</p><h3 id="1-2-1- 创建"><a href="#1-2-1- 创建" class="headerlink" title="1.2.1 创建"></a>1.2.1 创建 </h3><p><strong> 从字典类</strong></p><blockquote><p>数组，列表和元祖构成的字典创建 dataframe</p><p>Series 构成的字典创建 dataframe</p><p>字典构成的字典创建 dataframe</p></blockquote><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; data=&#123;    &quot;a&quot;:[1,2,3,4],    &quot;b&quot;:(5,6,7,8),    &quot;c&quot;:np.arange(9,13),    &quot;d&quot;:pd.Series(np.range(4))&#125;&gt;&gt;&gt; df=pd.DataFrame(data)     // 创建 DataFrame 可以指定 index=&gt;&gt;&gt; df     a     b     c     d0     1     5     9     01     2     6     10     12     3     7     11     23     4     8     12     3&gt;&gt;&gt; data=&#123;    &quot;a&quot;:&#123;&#39;apple&#39;:&quot;4&quot;,&#39;banana&#39;:&#39;2.5&#39;&#125;,    &quot;b&quot;:&#123;&#39;apple&#39;:&quot;3.5&quot;,&#39;banana&#39;:&#39;3&#39;&#125;,    &quot;c&quot;:&#123;&#39;apple&#39;:&quot;3.5&quot;&#125;&#125;&gt;&gt;&gt; pd.DataFrame(data)          a     b      c    apple       4   3.5      3.5   banana     2.5     3      NaN</code></pre><p><strong>从列表类</strong></p><blockquote><p>2D ndarray 创建 dataframe</p><p>字典构成的列表创建 dataframe</p><p>Series 构成的字典创建 dataframe</p></blockquote><pre><code class="python">&gt;&gt;&gt;pd.DataFrame(np.arange(12).reshape(3,4),index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],columns=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;])     A     B     C     Da     0     1     2     3b     4     5     6     7c     8     9     10     11          //index 和 columns 指定索引名称</code></pre><h3 id="1-2-2- 基本使用"><a href="#1-2-2- 基本使用" class="headerlink" title="1.2.2 基本使用"></a>1.2.2 基本使用 </h3><h4 id="属性"><a href="# 属性" class="headerlink" title="属性"></a> 属性</h4><pre><code class="python">&gt;&gt;&gt; df     a     b     c     d0     1     5     9     01     2     6     10     12     3     7     11     23     4     8     12     3&gt;&gt;&gt; df.index     // 查看数据表的行索引RangeIndex(start=0, stop=4, step=1)&gt;&gt;&gt; df.columns   // 查看数据表的列索引Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39; ,&#39;d&#39;], dtype=&#39;object&#39;)&gt;&gt;&gt; df.values    // 查看数据表的值array([[1,  5,  9,  0],       [2,  6, 10,  1],       [3,  7, 11,  2],       [4,  8, 12,  3]], dtype=int64)&gt;&gt;&gt; df.dtypes   // 查看每列数据格式&gt;&gt;&gt; df.info()   // 查看数据表的信息（维度，列名，数据格式。所占空间等）&gt;&gt;&gt; df[&#39;d&#39;].astype(&#39;float&#39;)  // 将数据格式转换成浮点型</code></pre><h4 id="转置"><a href="# 转置" class="headerlink" title="转置"></a>转置</h4><pre><code class="python">&gt;&gt;&gt; df.T     a     b     cA     0     4     8B     1     5     9C     2     6     10D     3     7     11</code></pre><h4 id="列索引"><a href="# 列索引" class="headerlink" title="列索引"></a>列索引</h4><pre><code class="python">&gt;&gt;&gt; df.T[&#39;a&#39;]    // 直接索引默认只能列索引  且只能标签索引，不能位置索引A    0B    1C    2D    3Name: a, dtype: int32</code></pre><h4 id="增加列"><a href="# 增加列" class="headerlink" title="增加列"></a>增加列</h4><pre><code class="python">&gt;&gt;&gt; df.T[&#39;d&#39;]=[&#39;2&#39;,&#39;2&#39;,&#39;2&#39;,&#39;2&#39;]&gt;&gt;&gt; df.T     a     b     c     dA     0     4     8     2B     1     5     9     2C     2     6     10     2D     3     7     11     2</code></pre><h4 id="删除列"><a href="# 删除列" class="headerlink" title="删除列"></a>删除列</h4><pre><code class="python">&gt;&gt;&gt; del(df.T[&#39;d&#39;])&gt;&gt;&gt; df.T     a     b     c A     0     4     8     B     1     5     9     C     2     6     10     D     3     7     11     </code></pre><h4 id="取值"><a href="# 取值" class="headerlink" title="取值"></a>取值</h4><pre><code class="python">&gt;&gt;&gt; df.T[&#39;b&#39;][2]   // 列索引之后变成了 Series, 故其后可以进行 &#39; 位置索引 &#39;&#39; 标签索引 &#39;&#39; 负号索引 &#39;&#39; 布尔索引 &#39;6</code></pre><h1 id="2-DataFrame- 基本操作"><a href="#2-DataFrame- 基本操作" class="headerlink" title="2. DataFrame 基本操作"></a>2. DataFrame 基本操作 </h1><h2 id="2-1- 索引"><a href="#2-1- 索引" class="headerlink" title="2.1 索引"></a>2.1 索引</h2><p> 列名索引：<code>df[&#39; 列名 &#39;]</code>   —   适用列索引</p><p>标签索引：<code>df.loc[&#39; 行名 &#39;]</code> —  适用行索引</p><p>位置索引：<code>df.iloc[]</code>  —  列行索引均可</p><p>切片：<code>df[:]</code>—  行切片</p><h3 id="列索引 -1"><a href="# 列索引 -1" class="headerlink" title="列索引"></a>列索引</h3><pre><code class="python">&gt;&gt;&gt; df     A     B     C     a     0     1     2     b     3     4     5     c     6     7     8     &gt;&gt;&gt; df[&#39;A&#39;]      // 列名索引，取 A 列数据a    0b    4c    8Name: A, dtype: int32&gt;&gt;&gt; df.columns[1]&#39;B&#39;&gt;&gt;&gt; df.columns[&#39;A&#39;]   // 会报错&gt;&gt;&gt; df.iloc[:,1]     // 位置索引，可取到 B 列数据</code></pre><h3 id="行索引"><a href="# 行索引" class="headerlink" title="行索引"></a>行索引</h3><pre><code class="python">&gt;&gt;&gt; df     A     B     C     a     0     1     2     b     3     4     5     c     6     7     8 #index 索引&gt;&gt;&gt; df.index[1]&#39;b&#39;&gt;&gt;&gt; df.index[1]=&#39;e&#39;   // 会报错，不支持修改行索引名称&gt;&gt;&gt; df.index[&#39;a&#39;]     // 会报错，无法取出 &#39;a&#39; 行数据# 标签索引 loc&gt;&gt;&gt; df.loc[&#39;a&#39;]     // 终于能取到行数据了，也能增加行……此法不能取列A    0B    1C    2Name: a, dtype: int32#支持切片索引&gt;&gt;&gt; df[:2]     A     B     Ca     0     1     2b     3     4     5#位置索引 iloc&gt;&gt;&gt; df.iloc[2]   // 选取第三行数据</code></pre><h3 id="重新索引"><a href="# 重新索引" class="headerlink" title="重新索引"></a><strong>重新索引 </strong></h3><p><strong> 行重建</strong></p><pre><code class="python">&gt;&gt;&gt; df.reindex([&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;])      A       B      C       DA     NaN     NaN     NaN     NaNB     NaN     NaN     NaN     NaNC     NaN     NaN     NaN     NaND     NaN     NaN     NaN     NaNE     NaN     NaN     NaN     NaN// 以上只能再新增 A-E 行数据而已&gt;&gt;&gt; df.reindex([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])      A     B           C     Da     0.0     1.0     2.0     3.0b     4.0     5.0     6.0     7.0c     8.0     9.0     10.0     11.0d     NaN     NaN     NaN     NaN// a,b,c 照旧，新增了 d 行  </code></pre><p><strong>列重建</strong></p><pre><code class="python">&gt;&gt;&gt; df     A     B     C     Da     0     1     2     3b     4     5     6     7c     8     9     10     11&gt;&gt;&gt; df.reindex(columns=[&#39;C&#39;,&#39;A&#39;,&#39;B&#39;,&#39;E&#39;])     C     A     B     Ea     2     0     1     NaNb     6     4     5     NaNc     10     8     9     NaN</code></pre><p><strong>列变索引</strong></p><pre><code class="python">&gt;&gt;&gt; df.set_index(&#39;D&#39;)   // 将“D”列变成索引     A     B     CD             3     0     1     27     4     5     611     8     9     10</code></pre><h3 id="增加列 -1"><a href="# 增加列 -1" class="headerlink" title="增加列"></a>增加列</h3><pre><code class="python">&gt;&gt;&gt; df     A     B     C     a     0     1     2     b     3     4     5     c     6     7     8 &gt;&gt;&gt; df[0]=[1,1,1]      // 默认往后增加列          A     B     C     0a     0     1     2     1b     3     4     5     1c     6     7     8     1&gt;&gt;&gt; df.insert(0,&#39;E&#39;,[88,88,88])   // 指定位置插入列     E     A     B     Ca     88     0     1     2b     88     3     4     5c     88     6     7     8</code></pre><h3 id="增加行"><a href="# 增加行" class="headerlink" title="增加行"></a>增加行</h3><pre><code class="python">&gt;&gt;&gt; df.loc(6)=[1,1,1]&gt;&gt;&gt; df     A     B     Ca     0     1     2b     3     4     5c     6     7     86     1     1     1&gt;&gt;&gt; row=&#123;&#39;A&#39;:3,&#39;B&#39;:3,&#39;C&#39;:3&#125;&gt;&gt;&gt; df.append(row,ignore_index=True)  // 默认为 false, 但是为 true 时，会自动使用新索引     A     B     C0     0     1     21     3     4     52     6     7     83     1     1     14     3     3     3</code></pre><h3 id="删除"><a href="# 删除" class="headerlink" title="删除"></a>删除</h3><pre><code class="python">&gt;&gt;&gt; df     A     B     Ca     0     1     2b     3     4     5c     6     7     8# del&gt;&gt;&gt; del(df[&#39;A&#39;])         // 只能删除列，且每次只能删除一个#.drop&gt;&gt;&gt; df.drop(columns=[&#39;A&#39;,&#39;B&#39;])   // 删除列&gt;&gt;&gt; df.drop(index=[&#39;a&#39;,&#39;b&#39;])     // 删除行&gt;&gt;&gt; df.drop([&#39;a&#39;,&#39;b&#39;])           // 删除行// 此法还可以指定 axis 来取行还是列&gt;&gt;&gt; df.drop(&#39;a&#39;,inplace=True)  // 直接在原数据上删除，不返回新对象</code></pre><h3 id="改"><a href="# 改" class="headerlink" title="改"></a>改</h3><pre><code class="python">&gt;&gt;&gt; df     A     B     Ca     0     1     2b     3     4     5c     6     7     8&gt;&gt;&gt; df[&#39;A&#39;]=[1,1,1]   // 直接对 A 修改&gt;&gt;&gt; df.A = 1          // 这样也是可以的&gt;&gt;&gt;df.loc[&#39;a&#39;,&#39;A&#39;]=100   // 修改某一个值     A     B     Ca 100     1     2b     3     4     5c     6     7     8</code></pre><h3 id="切片 -1"><a href="# 切片 -1" class="headerlink" title="切片"></a>切片</h3><pre><code class="python">&gt;&gt;&gt; df.loc[&#39;a&#39;:&#39;b&#39;,&#39;A&#39;:&#39;B&#39;]   // 标签索引切片     A     Ba     0     1b     3     4&gt;&gt;&gt; de.iloc(1:2,0:2)          // 位置索引切片</code></pre><h2 id="2-2- 运算"><a href="#2-2- 运算" class="headerlink" title="2.2 运算"></a>2.2 运算</h2><h3 id="2-2-1- 对齐运算"><a href="#2-2-1- 对齐运算" class="headerlink" title="2.2.1 对齐运算"></a>2.2.1 对齐运算</h3><pre><code class="python">&gt;&gt;&gt; df1=pd.DataFrame(np.arange(12).reshape(4,3),index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;],columns=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;])     A     B     Ca     0     1     2b     3     4     5c     6     7     8d     9     10     11&gt;&gt;&gt; df2=pd.DataFrame(np.arange(9).reshape(3,3),index=[&#39;a&#39;,&#39;d&#39;,&#39;f&#39;],columns=list(&quot;ABD&quot;))     A     B     Da     0     1     2d     3     4     5f     6     7     8&gt;&gt;&gt; df1 + df2       A       B       C       Da     0.0     2.0     NaN     NaNb     NaN     NaN     NaN     NaNc     NaN     NaN     NaN     NaNd     12.0     14.0     NaN     NaNf     NaN     NaN     NaN     NaN// 不存在默认为为空，进行相加</code></pre><p>DataFrame 与数组 numpy 数据一样，可以进行加减乘除多元运算，但是不能进行直接进行多元逻辑运算（逻辑或，逻辑与）。<br>要想进行多元逻辑运算，可使用 <code>np.logical_and(arr1,arr2,arr3)</code> 对<code>arr1,arr2,arr3</code>进行与集运算，但要求这三个数组形状一样。同理，逻辑或为<code>np.logical_or(arr1,arr2,arr3)</code>。</p><h3 id="2-2-2- 填充缺失值运算"><a href="#2-2-2- 填充缺失值运算" class="headerlink" title="2.2.2 填充缺失值运算"></a>2.2.2 填充缺失值运算</h3><pre><code class="python">&gt;&gt;&gt; df1.add(df2.fill_value=0)       A       B       C       Da     0.0     2.0     2.0     2.0b     3.0     4.0     5.0     NaNc     6.0     7.0     8.0     NaNd     12.0     14.0     11.0     5.0f     6.0     7.0     NaN     8.0// 遇到数字加空值，这个空值填充为 0, 按数字加零进行计算，若是空值加空值，还是为空</code></pre><h1 id="3-Pandas 的函数应用"><a href="#3-Pandas 的函数应用" class="headerlink" title="3. Pandas 的函数应用"></a>3. Pandas 的函数应用</h1><h2 id="3-1- 应用函数"><a href="#3-1- 应用函数" class="headerlink" title="3.1 应用函数"></a>3.1 应用函数</h2><ul><li><strong>apply 将函数应用到列或者行</strong></li></ul><pre><code class="python">&gt;&gt;&gt; df=pd.DataFrame(np.random.randn(3,4))&gt;&gt;&gt; df           0           1            2            30     0.330759     0.730455     -1.579240     -0.7319511     0.612881     0.097846     1.265440     2.2858022     -1.503725     1.155428     1.156895     0.776801&gt;&gt;&gt; f=lambda x:x.max()   // 定义一个匿名函数，给一个 x，就求 x 的最大值&gt;&gt;&gt; df.apply(f)          // 默认 axis=0, 按列求每一列的最大值0    0.6128811    1.1554282    1.2654403    2.285802dtype: float64</code></pre><ul><li><strong>applymap 将函数应用到每一个数据</strong></li></ul><pre><code class="python">&gt;&gt;&gt; f=lambda x:&quot;%.2f&quot;%x     // 定义一个匿名函数，给一个 x，就对 x 保留两位小数&gt;&gt;&gt; df.applymap(f)      0       1       2       30     0.33     0.73     -1.58     -0.731     0.61     0.10     1.27     2.292     -1.50     1.16     1.16     0.78</code></pre><p><code>agg(), aggregate(), apply()</code>这三种函数有着类似的功能。</p><h2 id="3-2- 排序"><a href="#3-2- 排序" class="headerlink" title="3.2 排序"></a>3.2 排序</h2><ul><li><strong>按索引排序</strong></li></ul><pre><code class="python">&gt;&gt;&gt; df=pd.DataFrame(np.arange(12).reshape(3,4),index=list(&quot;bca&quot;),columns=list(&#39;CBDA&#39;))&gt;&gt;&gt; df    C     B     D     Ab     0     1     2     3c     4     5     6     7a     8     9     10     11&gt;&gt;&gt; df.sort_index()     // 按行索引大小排序……若想倒序 设置 ascending=False     C     B     D     Aa     8     9     10     11b     0     1     2     3c     4     5     6     7                       // 若按照列索引排序，只需设置 axis=1</code></pre><ul><li><strong>按值排序</strong></li></ul><pre><code class="python">&gt;&gt;&gt; df=pd.DataFrame(&#123;&#39;a&#39;:[3,7,0,9],&#39;c&#39;:[5,2,8,0],&#39;b&#39;:[9,5,2,8]&#125;)&gt;&gt;&gt; df     a     c     b0     3     5     91     7     2     52     0     8     23     9     0     8&gt;&gt;&gt; df.sort_values(by=[&#39;a&#39;,&#39;c&#39;])      // 按照 a 列数值大小排列，若 a 列相同，则按 c 列     a     c     b2     0     8     20     3     5     91     7     2     53     9     0     8</code></pre><h2 id="3-3- 处理缺失值"><a href="#3-3- 处理缺失值" class="headerlink" title="3.3 处理缺失值"></a>3.3 处理缺失值</h2><p><code>df.isnull()</code> 判断每个位置是否有缺失值，返回布尔类型的 DataFrame</p><p><code>df.notnull()</code> 判断每个位置是否无缺失值，返回布尔类型的 DataFrame</p><p><code>df.dropna()</code> 删除有缺失值的行 ，可传参<code>how=&#39;all&#39;</code> 默认为<code>&#39;any&#39;</code>，整行都是 nan 才删 / 只要有一个 nan 就删。</p><pre><code class="python">&gt;&gt;&gt; df       a       c     b0     3.0     5.0     91     7.0     NaN     52     NaN     8.0     23     9.0     0.0     8&gt;&gt;&gt; df.dropna()            // 默认按行删除   增加 axis=1 可按列删除             a       c     b0     3.0     5.0     93     9.0     0.0     8</code></pre><p><code>df.fillna()</code> 填充缺失值：</p><p>可传参<code>&#123;0:1,1:100&#125;</code>，意思是第 0 列缺失值填充为 1，第 1 列缺失值填充为 100；</p><p>可传参<code>method=(&#39;ffill&#39;)</code>，意思是缺失值填充为它的上方的数据，继承上一行的数据；</p><p>可传参<code>method=(&#39;ffill&#39;,limit=2)</code>，意思是对继承的次数进行限制。</p><pre><code class="python">&gt;&gt;&gt; df.fillna(-100)       // 将所有缺失值补充填为 -100      a       c     b0     3.0     5.0     91     7.0     -100.0     52     -100.0     8.0     23     9.0     0.0     8</code></pre><h1 id="4- 层级索引"><a href="#4- 层级索引" class="headerlink" title="4. 层级索引"></a>4. 层级索引</h1><pre><code class="python">&gt;&gt;&gt; s=pd.Series(np.random.randn(6),index=[[&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;b&#39;],[0,1,2,0,1,2]])a  0   -0.981812   1   -0.101430   2   -1.254341b  0    0.371863   1    0.434470   2   -0.729295dtype: float64&gt;&gt;&gt; s.index               // 多层索引MultiIndex([(&#39;a&#39;, 0),            (&#39;a&#39;, 1),            (&#39;a&#39;, 2),            (&#39;b&#39;, 0),            (&#39;b&#39;, 1),            (&#39;b&#39;, 2)],           )</code></pre><h2 id="4-1- 选取"><a href="#4-1- 选取" class="headerlink" title="4.1 选取"></a>4.1 选取</h2><p><code>s[&#39;a&#39;]</code> 外层选取</p><p><code>s[:,2]</code>内层选取</p><pre><code class="python">&gt;&gt;&gt; s[:,2]    // 选取内层为 2 的数据a   -1.254341b   -0.729295dtype: float64</code></pre><p><code>s[&#39;a&#39;,1]</code> 选取某一个值</p><h2 id="4-2- 交换"><a href="#4-2- 交换" class="headerlink" title="4.2 交换"></a>4.2 交换</h2><p><code>s.swaplevel()</code> 交换内外层的索引</p><pre><code class="python">&gt;&gt;&gt; s.swaplevel()0  a   -0.9818121  a   -0.1014302  a   -1.2543410  b    0.3718631  b    0.4344702  b   -0.729295dtype: float64</code></pre><h2 id="4-3- 排序"><a href="#4-3- 排序" class="headerlink" title="4.3 排序"></a>4.3 排序</h2><p><code>s.sortlevel()</code> 先按照外层索引排序，再对内层索引排序</p><h2 id="4-4- 重塑"><a href="#4-4- 重塑" class="headerlink" title="4.4 重塑"></a>4.4 重塑 </h2><p><code>df.stack()</code> 将 DataFrame 变成层级 Series</p><p><code>s.unstack()</code> 将层级 Series 变成 DataFrame</p><pre><code class="python">&gt;&gt;&gt; s=pd.Series(np.random.randn(6),index=[[&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;b&#39;],[0,1,2,0,1,2]])a  0   -0.981812   1   -0.101430   2   -1.254341b  0    0.371863   1    0.434470   2   -0.729295&gt;&gt;&gt; s.unstack()         // 将层级 Series 变成 DataFrame           0          1             2a     -0.981812     -0.10143     -1.254341b     0.371863     0.43447     -0.729295</code></pre><p>这样就可以对数据进行切片了。</p><h1 id="5- 统计计算"><a href="#5- 统计计算" class="headerlink" title="5. 统计计算"></a>5. 统计计算</h1><p><code>df.sum()</code>   默认按列数据求和……补充 axis=1 按行数据求和</p><p><code>df.cumsum()</code>  按列往下进行求和</p><pre><code class="python">&gt;&gt;&gt; df=pd.DataFrame(&#123;&#39;a&#39;:[3,7,np.nan,9],&#39;c&#39;:[5,np.nan,8,0],&#39;b&#39;:[9,5,2,8]&#125;)       a       c     b0     3.0     5.0     91     7.0     NaN     52     NaN     8.0     23     9.0     0.0     8&gt;&gt;&gt; df.cumsum()    // 默认 skipna=True 跳过缺失值求和       a       c     b0     3.0     5.0     91     10.0     NaN     142     NaN     13.0     163     19.0     13.0     24</code></pre><p><code>df.mean()</code>  默认按列数据求平均值</p><p><code>df.max()</code>默认按列数据最大值</p><p><code>df.min()</code>默认按列数据最小值</p><p><code>df.idxmax()</code> 求每列最大的数值对应的行索引</p><p><code>df[&#39;XX&#39;].value_counts()</code> 统计 XX 列中的种类及其个数</p><h2 id="统计描述"><a href="# 统计描述" class="headerlink" title="统计描述"></a>统计描述</h2><p><code>df.describe()</code>  汇总统计</p><pre><code class="python">&gt;&gt;&gt; df.describe()               a           c           bcount     3.000000     3.000000     4.000000mean     6.333333     4.333333     6.000000std     3.055050     4.041452     3.162278min     3.000000     0.000000     2.00000025%     5.000000     2.500000     4.25000050%     7.000000     5.000000     6.50000075%     8.000000     6.500000     8.250000max     9.000000     8.000000     9.000000</code></pre><p>统计函数对 Series 也适用，下面举一个字符类型的 Series 的例子</p><pre><code class="python">&gt;&gt;&gt; s=pd.Series([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;e&#39;])0    a1    b2    c3    b4    a5    a6    edtype: object&gt;&gt;&gt; s.describe()count     7unique    4top       a            // 统计出现频率最多的freq      3dtype: object</code></pre><h1 id="6- 数据处理"><a href="#6- 数据处理" class="headerlink" title="6. 数据处理"></a>6. 数据处理</h1><h2 id="6-1- 文件读取"><a href="#6-1- 文件读取" class="headerlink" title="6.1 文件读取"></a>6.1 文件读取</h2><h3 id="6-1-1- 常用"><a href="#6-1-1- 常用" class="headerlink" title="6.1.1 常用"></a>6.1.1 常用</h3><p><strong>CSV 文件：</strong></p><pre><code class="python">&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; pd.read_csv(&#39;scores.csv&#39;,encoding=&#39;gbk&#39;)     数学      英语0     59.0     89.01     78.0     45.02     24.0     NaN3     NaN     56.04     23.0     56.0&gt;&gt;&gt; pd.read_table(&#39;scores.csv&#39;,sep=&quot;,&quot;,encoding=&#39;gbk&#39;)     数学      英语0     59.0     89.01     78.0     45.02     24.0     NaN3     NaN     56.04     23.0     56.0</code></pre><p><strong>txt 文件：</strong></p><pre><code class="python">&gt;&gt;&gt; list(open(&#39;demo.txt&#39;))[&#39;A  B   C\n&#39;, &#39;1  2   3\n&#39;, &#39;4  5    6&#39;]&gt;&gt;&gt; p=pd.read_table(&#39;demo.txt&#39;)     A B C0      1 2 31      4 5 6&gt;&gt;&gt; p[&#39;A&#39;]       // 报错……不管怎么索引都会出错&gt;&gt;&gt; p=pd.read_table(&#39;demo.txt&#39;,sep=&#39;\s+&#39;)    // 应该这样读取…… \s 空白符     A     B     C0     1     2     31     4     5     6&gt;&gt;&gt; p[&#39;a&#39;]0    11    4Name: A, dtype: int64</code></pre><p><strong>以下需要好好领悟</strong></p><pre><code class="python">&gt;&gt;&gt; pd.read_table(&#39;demo.csv&#39;,sep=&quot;,&quot;)                          // 本来是这样的     key1     key2     value1     value20     one       a       1       21     one       b         2       42     two       c       3       63     two       d       4       84     three       e       5       105     three       f       6       12&gt;&gt;&gt; p=pd.read_table(&#39;demo.csv&#39;,sep=&quot;,&quot;,index_col=[&#39;key1&#39;,&#39;key2&#39;])    // 这样读取！             value1  value2                                           // 将列变成索引key1     key2         one     a       1     2        b       2     4two     c       3     6        d       4     8three     e       5     10        f       6     12&gt;&gt;&gt; p.indexMultiIndex([(&#39;one&#39;, &#39;a&#39;),            (&#39;one&#39;, &#39;b&#39;),            (&#39;two&#39;, &#39;c&#39;),            (&#39;two&#39;, &#39;d&#39;),            (&#39;three&#39;, &#39;e&#39;),            (&#39;three&#39;, &#39;f&#39;)],           names=[&#39;key1&#39;, &#39;key2&#39;])</code></pre><p>去头：括号传参<code>head=None</code></p><p>赋头：括号传参<code>names=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,...]</code></p><p>加列索引：括号传参<code>index_col=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,...]</code></p><h3 id="6-1-2- 总结"><a href="#6-1-2- 总结" class="headerlink" title="6.1.2 总结"></a>6.1.2 总结</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-17_17-25-29.png" alt=""></p><p><strong>包含的参数</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-17_17-25-51.png" alt="先看着，有空再改清晰点"></p><h3 id="6-1-3- 大文件分块读取"><a href="#6-1-3- 大文件分块读取" class="headerlink" title="6.1.3 大文件分块读取"></a>6.1.3 大文件分块读取 </h3><p> 对于千万级以上的数据读取时，不能一次性全部读取，电脑内存受不了，这时就需要分块读取。</p><ol><li>指定 CHUNKSIZE 分块读取文件，用以指定一个块大小（每次读取多少行），返回一个可迭代的 <code>TextFileReader</code> 对象。</li></ol><pre><code class="python">&gt;&gt;&gt; table=pd.read_csv(&#39;fn.csv&#39;,chunksize=100)       // 每 100 行的读&gt;&gt;&gt; table.get_chunk(5)         // 获取前 5 行  注意这是迭代处理&gt;&gt;&gt; for df in table:           // 循环处理         对 df 处理</code></pre><ol start="2"><li>指定迭代 = 真</li></ol><pre><code class="python">&gt;&gt;&gt; reader = pd.read_table(&#39;tmp.sv&#39;, sep=&#39;\t&#39;, iterator=True) &gt;&gt;&gt; reader.get_chunk(10000)    // 通过 get_chunk(size)，返回一个 size 行的块</code></pre><p>举个例子：</p><pre><code class="python">&gt;&gt;&gt; reader = pd.read_table(&#39;tmp.sv&#39;, sep=&#39;\t&#39;, iterator=True)&gt;&gt;&gt; chunkSize = 1000&gt;&gt;&gt; chunks = []&gt;&gt;&gt; loop=True&gt;&gt;&gt; while loop:&gt;&gt;&gt;     try:&gt;&gt;&gt;         chunk = reader.get_chunk(chunkSize)&gt;&gt;&gt;         chunks.append(chunk)&gt;&gt;&gt;     except StopIteration:&gt;&gt;&gt;         loop=False&gt;&gt;&gt;         print (&quot;Iteration is stopped.&quot;)&gt;&gt;&gt; df = pd.concat(chunks, ignore_index=True)// 这样数据就被读取出来了</code></pre><h2 id="6-2- 文件保存"><a href="#6-2- 文件保存" class="headerlink" title="6.2 文件保存"></a>6.2 文件保存 </h2><p><strong> 写入 CSV 文件：</strong></p><p><code>pd.to_csv(file_path or buf,sep,columns,header,index,na_rep,mode)</code></p><p><code>file_path</code>：保存文件路径, 默认 None</p><p><code>sep</code>：分隔符，默认’,’ </p><p><code>columns</code>：是否保留某列数据，默认 None</p><p><code>header</code>：是否保留列名，默认 True</p><p><code>index</code>：是否保留行索引，默认 True</p><p><code>na_rep</code>：指定字符串来代替空值，默认是空字符</p><p><code>mode</code>：默认’w’，追加’a’</p><p>也可以<code>df.to_excel(file_path or buf,sep,columns,header,index,na_rep,mode)</code></p><p><strong>保存为二进制文件：</strong></p><p><code>df.to_pickle()</code>       此用法不多</p><h2 id="6-3- 数据清洗"><a href="#6-3- 数据清洗" class="headerlink" title="6.3 数据清洗"></a>6.3 数据清洗 </h2><h3 id="6-3-1- 处理缺失值"><a href="#6-3-1- 处理缺失值" class="headerlink" title="6.3.1 处理缺失值"></a>6.3.1 处理缺失值</h3><p> 参照 3.3 节内容。</p><h3 id="6-3-2- 处理重复行"><a href="#6-3-2- 处理重复行" class="headerlink" title="6.3.2 处理重复行"></a>6.3.2 处理重复行 </h3><p> 检查重复数据：</p><p><code>data.duplicated()</code>  返回布尔类型数据，重复的那一行为 True。</p><p>删除重复数据：</p><p><code>data.drop_duplicates()</code>返回删除重复行后剩下的数据。默认检查行中所有的列数据。</p><p>可传参<code>[&#39;B&#39;]，keep=&#39;last&#39;</code>，意思是以 B 列为准，判断是否有重复的行，如第三行的 B 列与第五行的 B 列数据重复，就会删除前一行，保留后一行。</p><p>再看看下面的例子：</p><pre><code class="python">&gt;&gt;&gt; data=pd.DataFrame(&#123;&#39;food&#39;:[&#39;Apple&#39;,&#39;banana&#39;,&#39;orange&#39;,&#39;apple&#39;,&#39;mango&#39;,&#39;tomato&#39;],                       &#39;price&#39;:[4,3,3.5,6,12,3]&#125;)     food     price0     Apple     4.01     banana     3.02     orange     3.53     apple     6.04     mango     12.05     tomato     3.0</code></pre><p>其中 apple 有重复，需要按 food 列删除。</p><p>food 列大小写统一化处理：</p><pre><code class="python">&gt;&gt;&gt; lower=data[&#39;food&#39;].str.lower()         //lower()小写，upper()大写0     apple1    banana2    orange3     apple4     mango5    tomatoName: food, dtype: object</code></pre><h3 id="6-3-3- 数据分类"><a href="#6-3-3- 数据分类" class="headerlink" title="6.3.3 数据分类"></a>6.3.3 数据分类 </h3><p> 对 food 进行分类：</p><pre><code class="python">&gt;&gt;&gt; classf=&#123;&#39;apple&#39;:&#39;fruit&#39;,&#39;banana&#39;:&#39;fruit&#39;,&#39;orange&#39;:&#39;fruit&#39;,&#39;mango&#39;:&#39;fruit&#39;,&#39;tomato&#39;:&#39;vagetables&#39;&#125;&gt;&gt;&gt; data[&#39;classf&#39;]=lower.map(classf)&gt;&gt;&gt; data     food     price     classf0     Apple     4.0     fruit1     banana     3.0     fruit2     orange     3.5     fruit3     apple     6.0     fruit4     mango     12.0     fruit5     tomato     3.0     vagetables// 也可以采用下面这种方式&gt;&gt;&gt; data[&#39;classf&#39;]=data[&#39;food&#39;].map(lambda x:classf[x.lower()])</code></pre><h3 id="6-3-4- 替换值"><a href="#6-3-4- 替换值" class="headerlink" title="6.3.4 替换值"></a>6.3.4 替换值 </h3><p><code>data.replace(A,B)</code> 把 data 中的 A 替换成 B</p><h3 id="6-3-5- 重命名轴索引"><a href="#6-3-5- 重命名轴索引" class="headerlink" title="6.3.5 重命名轴索引"></a>6.3.5 重命名轴索引</h3><pre><code class="python">&gt;&gt;&gt; data=pd.DataFrame((np.arange(12)).reshape(3,4),index=[&#39;Beijing&#39;,&#39;Tokyo&#39;,&#39;New York&#39;],columns=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;,&#39;four&#39;])&gt;&gt;&gt; data           one    two     three    fourBeijing       0    1       2    3Tokyo       4    5       6    7New York   8    9      10    11</code></pre><p><strong>方法 1：</strong></p><pre><code class="python">&gt;&gt;&gt; data.index=[&#39;B&#39;,&#39;T&#39;,&#39;N&#39;]        // 重命名行&gt;&gt;&gt; data     one     two     three     fourB       0       1       2     3T       4       5       6     7N       8       9       10     11&gt;&gt;&gt; data.columns=[&#39;One&#39;,&#39;Two&#39;,&#39;Three&#39;,&quot;Four&quot;]   // 重命名列     One     Two     Three     FourB       0       1       2     3T       4       5       6     7N       8       9       10     11</code></pre><p><strong>方法 2：</strong></p><pre><code class="python">&gt;&gt;&gt; data.rename(index=&#123;&#39;B&#39;:&#39;BJ&#39;&#125;,columns=&#123;&#39;Four&#39;:&#39; 第四年 &#39;&#125;)     One     Two     Three     第四年BJ       0       1       2     3T       4       5       6     7N       8       9       10     11</code></pre><p>想要改变原数据时，即 data 本身也改变，可赋值<code>inplace=True</code></p><h3 id="6-3-6- 离散化与面元划分"><a href="#6-3-6- 离散化与面元划分" class="headerlink" title="6.3.6 离散化与面元划分"></a>6.3.6 离散化与面元划分 </h3><p><strong> 对列表进行划分：</strong></p><pre><code class="python">&gt;&gt;&gt; ages=[34,56,12,34,45,8,2,78,90,4]&gt;&gt;&gt; bin=[0,3,12,18,30,60,100]&gt;&gt;&gt; a=pd.cut(ages,bin)             // 对 ages 中的数字按照 bin 里的分区进行划分&gt;&gt;&gt; a[(30, 60], (30, 60], (3, 12], (30, 60], (30, 60], (3, 12], (0, 3], (60, 100], (60, 100], (3, 12]]Categories (6, interval[int64]): [(0, 3] &lt; (3, 12] &lt; (12, 18] &lt; (18, 30] &lt; (30, 60] &lt; (60, 100]]// 以上区间默认是左开右闭，可传入 right=False，就会变成左闭右开&gt;&gt;&gt; a.codes       // 返回 ages 中的每个数据在第几个区间array([4, 4, 1, 4, 4, 1, 0, 5, 5, 1], dtype=int8)&gt;&gt;&gt; pd.value_counts(a)    // 对 a 中的区间进行计数(30, 60]     4(3, 12]      3(60, 100]    2(0, 3]       1(18, 30]     0(12, 18]     0dtype: int64&gt;&gt;&gt; labels=[&#39; 幼儿 &#39;,&#39; 儿童 &#39;,&#39; 青少年 &#39;,&#39; 青年 &#39;,&#39; 中年 &#39;,&#39; 老年 &#39;]&gt;&gt;&gt; a=pd.cut(ages,bin,labels=labels)    #传入 label 标签&gt;&gt;&gt; a[中年, 中年, 儿童, 中年, 中年, 儿童, 幼儿, 老年, 老年, 儿童] Categories (6, object): [幼儿 &lt; 儿童 &lt; 青少年 &lt; 青年 &lt; 中年 &lt; 老年]&gt;&gt;&gt; s=pd.cut(ages,4)   // 将 ages 分成 4 个等分区间[(24.0, 46.0], (46.0, 68.0], (1.912, 24.0], (24.0, 46.0], (24.0, 46.0], (1.912, 24.0], (1.912, 24.0], (68.0, 90.0], (68.0, 90.0], (1.912, 24.0]]Categories (4, interval[float64]): [(1.912, 24.0] &lt; (24.0, 46.0] &lt; (46.0, 68.0] &lt; (68.0, 90.0]]// 可传入参数 precision=2，即可对数据保留两位小数&gt;&gt;&gt; pd.qcut(ages,4)   // 将 ages 分成 4 个区间, 每个区间中包含的数据个数相等</code></pre><h3 id="6-3-7- 提取异常值"><a href="#6-3-7- 提取异常值" class="headerlink" title="6.3.7 提取异常值"></a>6.3.7 提取异常值</h3><pre><code>&gt;&gt;&gt; data[(np.abs[data]&gt;3).any(1)]    // 只要 data 中有一个大于 3 的，就取出来&gt;&gt;&gt; np.where(data.Size.str.contains(&#39; 室 &#39;)) // 把 data 中 Size 那一列中包含 &#39; 室 &#39; 的行索引号取出来 </code></pre><h3 id="6-3-7- 采样与随机排列"><a href="#6-3-7- 采样与随机排列" class="headerlink" title="6.3.7 采样与随机排列"></a>6.3.7 采样与随机排列</h3><p><strong> 采样：</strong></p><pre><code>&gt;&gt;&gt; df.sample(n=2)   // 在 df 中随机采取 2 行数据 </code></pre><p><strong> 随机排列：</strong></p><pre><code>&gt;&gt;&gt; sam=np.random.permutation(5)  // 生成 0-4 共 5 个数，并随机排列&gt;&gt;&gt; df.take(sam)   // 对 df 按照 sam 的顺序排列</code></pre><h2 id="6-4- 字符串操作"><a href="#6-4- 字符串操作" class="headerlink" title="6.4 字符串操作"></a>6.4 字符串操作</h2><h3 id="6-4-1- 字符串方法"><a href="#6-4-1- 字符串方法" class="headerlink" title="6.4.1 字符串方法"></a>6.4.1 字符串方法</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-18_21-39-52.jpg" alt=""></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-18_21-40-11.jpg" alt="Snipaste_2020-02-18_21-40-11"></p><h3 id="6-4-2- 正则表达式方法"><a href="#6-4-2- 正则表达式方法" class="headerlink" title="6.4.2 正则表达式方法"></a>6.4.2 正则表达式方法</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-18_21-40-27.jpg" alt=""></p><h3 id="6-4-pandas 字符串方法"><a href="#6-4-pandas 字符串方法" class="headerlink" title="6.4 pandas 字符串方法"></a>6.4 pandas 字符串方法 </h3><p><strong> 首先举个例子：</strong></p><pre><code class="python">&gt;&gt;&gt; data=pd.Series([&#39;dace@qq.com&#39;,&#39;dace@gmail.com&#39;,&#39;dace@163.com&#39;],index=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])a       dace@qq.comb    dace@gmail.comc      dace@163.comdtype: object&gt;&gt;&gt; data.str    // 注意这种用法很重要！！！&lt;pandas.core.strings.StringMethods at 0x1ffaa3ecdd8&gt;&gt;&gt;&gt; data.str.contains(&#39;gmail&#39;)       // 判断 data 里是否包含‘gmail’a    Falseb     Truec    Falsedtype: bool&gt;&gt;&gt; data.str[:5]       // 字符串化之后，切片取值前 5 个字符a    dace@b    dace@c    dace@dtype: object</code></pre><p><strong>归纳如下：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-18_21-40-41.jpg" alt=""></p><p>注意：以上判断字符串是否数字的函数，只能对整型数字进行判断，不能判断浮点类型数据。</p><ul><li><p><strong><code>isalnum()</code>用法：</strong>只要不出现特殊符号则返回真</p><pre><code class="python">&gt;&gt;&gt; &#39;ytvu2313131y 树 &#39;.isalnum()  True&gt;&gt;&gt; &#39;+&#39;.isalnum()  //&#39;./&#39;.isalnum()False//False</code></pre></li><li><p><strong><code>isalpha()</code>用法：</strong>只要不出现阿拉伯数字或者特殊符号则返回真</p><pre><code class="python">&gt;&gt;&gt; &#39;Wqwuu 数 &#39;.isalpha()   //&#39;wqwuu 数十 &#39;.isalpha()True//True&gt;&gt;&gt; &#39;wqwuu 数十。&#39;.isalpha()  //&#39;wqwuu 数十 123&#39;.isalpha()False//False</code></pre></li><li><p><strong><code>isdecimal()</code>用法：</strong></p><p>True: Unicode 数字，全角数字（双字节）<br>False: 罗马数字，汉字数字，<strong>小数</strong><br>Error: byte 数字（单字节） </p><pre><code class="python">&gt;&gt;&gt; &#39;123&#39;.isdecimal() True&gt;&gt;&gt; &#39;123.34&#39;.isdecimal() //&#39;123.34fff&#39;.isdecimal()False//False</code></pre></li><li><p><strong><code>isdigit()</code>用法：</strong></p><p>True: Unicode 数字，byte 数字（单字节），全角数字（双字节）<br>False: 汉字数字，罗马数字，<strong>小数</strong></p><pre><code class="python">&gt;&gt;&gt; &#39;123&#39;.isdigit()  //&#39;２３３&#39; .isdigit()True</code></pre></li><li><p><strong><code>isnumeric()</code>用法：</strong></p><p>True: Unicode 数字，全角数字（双字节），罗马数字，汉字数字 <br>False: <strong> 小数</strong><br>Error: byte 数字（单字节）</p><pre><code class="python">&gt;&gt;&gt; &#39; 二十 3&#39; .isnumeric()True</code></pre></li><li><p><strong><code>islower()</code>用法：</strong>只要不出现大写字符则返回真</p><pre><code class="python">&gt;&gt;&gt; &#39;zuo 天 123。&#39; .islower() True</code></pre></li><li><p><strong><code>isupper()</code>用法：</strong>只要不出现小写字母则返回真</p><pre><code class="python">&gt;&gt;&gt; &#39;ZUO 天 123。&#39; .isupper()True</code></pre></li></ul><h2 id="6-5- 数据规整"><a href="#6-5- 数据规整" class="headerlink" title="6.5 数据规整"></a>6.5 数据规整</h2><h3 id="6-5-1- 规整分块"><a href="#6-5-1- 规整分块" class="headerlink" title="6.5.1 规整分块"></a>6.5.1 规整分块</h3><pre><code class="python">&gt;&gt;&gt; frame=pd.DataFrame(&#123;&#39;a&#39;:np.arange(7),&#39;b&#39;:np.arange(7,0,-1),                      &#39;c&#39;:[&#39;one&#39;,&#39;one&#39;,&#39;one&#39;,&#39;two&#39;,&#39;two&#39;,&#39;two&#39;,&#39;two&#39;],                      &#39;d&#39;:[0,1,2,0,1,2,3]&#125;&gt;&gt;&gt; frame　　a　b　c　　d0　0　7　one　01　1　6　one　12　2　5　one　23　3　4　two　04　4　3　two　15　5　2　two　26　6　1　two　3</code></pre><p><strong>对数据进行规整分块</strong></p><pre><code class="python">&gt;&gt;&gt; frame.set_index([&#39;c&#39;,&#39;d&#39;])   //c 列作为主索引，d 列作为次索引　　　　a　bc　　d         one　0　0　7　　　1　1　6　　　2　2　5two　0　3　4　　　1　4　3　　　2　5　2　　　3　6　1// 括号传参 drop=Flase 则在后面继续保留 c,d 列</code></pre><h3 id="6-5-2- 数据连接"><a href="#6-5-2- 数据连接" class="headerlink" title="6.5.2 数据连接"></a>6.5.2 数据连接</h3><ol><li><p><code>pd.merge()</code></p><ul><li><p>根据单个或多个键将不同 DataFrame 的行连接起来</p></li><li><p>类似数据库的连接操作</p></li><li><p><code>pd.merge(left, right, how=&#39;inner&#39;,on=None,left_on=None, right_on=None)</code></p><p>left：合并时左边的 DataFrame</p><p>right：合并时右边的 DataFrame</p><p>how：合并的方式, 默认’inner’，还有’outer’, ‘left’, ‘right’</p><p>on：需要合并的列名, 必须两边都有的列名，并以 left 和 right 中的列名的交集作为连接键</p><p>left_on: left Dataframe 中用作连接键的列</p><p>right_on: right Dataframe 中用作连接键的列</p></li><li><p>内连接 inner：对两张表都有的键的交集进行联合</p></li><li><p>外连接 outer：对两张表都有的键的并集进行联合</p></li><li><p>左连接 left：对所有左表的键进行联合</p></li><li><p>右连接 right：对所有右表的键进行联合</p></li></ul></li></ol><p><strong>举个例子</strong></p><pre><code>&gt;&gt;&gt; left = pd.DataFrame(&#123;&#39;key1&#39;: [&#39;K0&#39;, &#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;],                         &#39;key2&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K0&#39;, &#39;K1&#39;],                           &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;],                           &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;, &#39;B3&#39;]&#125;)&gt;&gt;&gt; right = pd.DataFrame(&#123;&#39;key1&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K1&#39;, &#39;K2&#39;],                          &#39;key2&#39;: [&#39;K0&#39;, &#39;K0&#39;, &#39;K0&#39;, &#39;K0&#39;],                            &#39;C&#39;: [&#39;C0&#39;, &#39;C1&#39;, &#39;C2&#39;, &#39;C3&#39;],                            &#39;D&#39;: [&#39;D0&#39;, &#39;D1&#39;, &#39;D2&#39;, &#39;D3&#39;]&#125;)&gt;&gt;&gt; pd.merge(left,right, how=&#39;left&#39;, on=[&#39;key1&#39;, &#39;key2&#39;])</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_12-54-24.jpg" alt=""></p><p><strong>处理重复列名：</strong></p><p>参数 suffixes：默认为_x, _y</p><pre><code class="python">&gt;&gt;&gt; df1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],                        &#39;data&#39; : np.random.randint(0,10,7)&#125;)&gt;&gt;&gt; df2= pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;],                        &#39;data&#39; : np.random.randint(0,10,3)&#125;)&gt;&gt;&gt; pd.merge(df1, df2, on=&#39;key&#39;, suffixes=(&#39;_left&#39;, &#39;_right&#39;)) </code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_12-35-27.jpg" style="zoom:80%;" /><p><strong>按索引连接：</strong></p><p>参数 left_index=True 或 right_index=True，留下左索引 / 右索引。</p><ol start="2"><li><code>df1.append(df2)</code></li><li><code>left.join(right,on=&#39;key&#39;)</code></li></ol><h3 id="6-5-3- 数据合并"><a href="#6-5-3- 数据合并" class="headerlink" title="6.5.3 数据合并"></a>6.5.3 数据合并</h3><ol><li><p><code>np.concatenate(a,b)</code></p><p>介绍 Numpy 库中已经介绍。</p></li><li><p><code>pd.concat([a,b],axis,join, ignore_index=True)</code></p><ul><li>注意指定轴方向，默认 axis=0，按行拼接</li><li>join 指定合并方式，默认为’outer’，取并集合并，还可指定’inner’，取交集合并</li><li>Series 合并时查看行索引有无重复</li></ul></li></ol><h3 id="6-5-4- 轴向旋转"><a href="#6-5-4- 轴向旋转" class="headerlink" title="6.5.4 轴向旋转"></a>6.5.4 轴向旋转</h3><pre><code class="python">&gt;&gt;&gt; df = pd.DataFrame(&#123;&#39;date&#39;:[&#39;2018-1&#39;,&#39;2018-1&#39;,&#39;2018-2&#39;,&#39;2018-2&#39;,&#39;2018-3&#39;],                       &#39;class&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;],                       &#39;values&#39;:[5,3,2,6,1],                      &#39;values1&#39;:[4,5,6,8,9]&#125;,columns=[&#39;date&#39;,&#39;class&#39;,&#39;values&#39;,&#39;values1&#39;])&gt;&gt;&gt; df.pivot(&#39;date&#39;,&#39;class&#39;,&#39;values&#39;)</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_14-27-54.jpg" style="zoom:80%;" /><h2 id="6-6- 数据聚合与分组"><a href="#6-6- 数据聚合与分组" class="headerlink" title="6.6 数据聚合与分组"></a>6.6 数据聚合与分组 </h2><p><strong> 聚合的分组的含义：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_16-46-49.jpg" style="zoom:80%;" /><p><strong>分组函数：<code>df.groupby()</code></strong></p><p><strong>分组：</strong></p><pre><code class="python">&gt;&gt;&gt; df = pd.DataFrame(&#123;&#39;fruit&#39;:[&#39;apple&#39;,&#39;banana&#39;,&#39;orange&#39;,&#39;apple&#39;,&#39;banana&#39;],                        &#39;color&#39;:[&#39;red&#39;,&#39;yellow&#39;,&#39;yellow&#39;,&#39;red&#39;,&#39;cyan&#39;],                        &#39;price&#39;:[8.5,6.8,5.6,7.8,6.4]&#125;)&gt;&gt;&gt; df　　fruit　　　color　　price0　　apple　　　red　　　8.51　　banana　　yellow　　6.82　　orange　　yellow　　5.63　　apple　　　red　　　7.84　　banana　　cyan　　　6.4&gt;&gt;&gt; df[&#39;fruit&#39;].value_counts()    // 统计水果列种类及个数// 分组函数的应用&gt;&gt;&gt; g = df.groupby(by=&#39;fruit&#39;)&gt;&gt;&gt; type(g)pandas.core.groupby.generic.DataFrameGroupBy// 分组输出&gt;&gt;&gt;for name,group in g:      print(name)          // 输出组名      print(&#39;-&#39;*50)      print(group)         // 输出数据块    dataframe 类型apple--------------------------------------------------   fruit color  price0  apple   red    8.53  apple   red    7.8banana--------------------------------------------------    fruit   color  price1  banana  yellow    6.84  banana    cyan    6.4orange--------------------------------------------------    fruit   color  price2  orange  yellow    5.6// 选取任意数据块&gt;&gt;&gt; dict(list(df.groupby(by=&#39;fruit&#39;)))[&#39;apple&#39;]   // 先变成列表，再变成字典结构，易于索引      fruit     color     price0     apple     red     8.53     apple     red     7.8</code></pre><p><strong>通过字典或 Series 进行分组</strong></p><pre><code class="python">&gt;&gt;&gt; people = pd.DataFrame(np.random.randn(5, 5),                      columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],                      index=[&#39;Sam&#39;, &#39;Make&#39;, &#39;Tony&#39;, &#39;Jim&#39;, &#39;Nana&#39;])&gt;&gt;&gt; m = &#123;&#39;a&#39;: &#39;red&#39;, &#39;b&#39;: &#39;red&#39;, &#39;c&#39;: &#39;blue&#39;,&#39;d&#39;: &#39;blue&#39;, &#39;e&#39;: &#39;red&#39;, &#39;f&#39; : &#39;orange&#39;&#125;&gt;&gt;&gt; people.groupby(m,axis=1).sum()</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_18-02-02.jpg" style="zoom:80%;" /><p><strong>通过函数进行分组</strong></p><pre><code class="python">&gt;&gt;&gt; people.groupby(len).sum()     // 按索引的字符长度进行求和     　　　a     　　　　b     　　　　　c　　　　　    d     　　　　　e3     1.067155     -0.081729     -1.635495     -0.659798     0.5363734     0.671735     0.274625     1.936964     -0.420179     0.449990</code></pre><p><strong>聚合：</strong></p><pre><code class="python">&gt;&gt;&gt; df.groupby([&#39;fruit&#39;,&#39;color&#39;])[[&#39;price&#39;]].mean()         　　　　　pricefruit     color     apple     red     8.15banana　cyan     6.40　　　　　yellow　6.80orange     yellow     5.60</code></pre><p><code>as_index</code>：对于聚合输出, 返回以组便签为索引的对象，仅对 DataFrame</p><pre><code class="python">&gt;&gt;&gt; df.groupby(&#39;fruit&#39;)[&#39;price&#39;].mean()         // 返回 Series 对象&gt;&gt;&gt; df.groupby(&#39;fruit&#39;,as_index=False)[&#39;price&#39;].mean()    // 返回 DataFrame 对象</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_17-44-18.jpg" style="zoom:80%;" /><pre><code class="python">&gt;&gt;&gt; df　　fruit　　　color　　price0　　apple　　　red　　　8.51　　banana　　yellow　　6.82　　orange　　yellow　　5.63　　apple　　　red　　　7.84　　banana　　cyan　　　6.4&gt;&gt;&gt; def diff(arr):    return arr.max() - arr.min()&gt;&gt;&gt; df.groupby(&#39;fruit&#39;)[&#39;price&#39;].agg(diff)   // 求差价fruitapple     0.7banana    0.4orange    0.0Name: price, dtype: float64</code></pre><h1 id="7- 时间序列"><a href="#7- 时间序列" class="headerlink" title="7. 时间序列"></a>7. 时间序列</h1><h2 id="7-1- 基础"><a href="#7-1- 基础" class="headerlink" title="7.1 基础"></a>7.1 基础</h2><h3 id="7-1-1- 创建及索引"><a href="#7-1-1- 创建及索引" class="headerlink" title="7.1.1 创建及索引"></a>7.1.1 创建及索引</h3><pre><code class="python">&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import pandas as pd&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; dates = [datetime(2011, 1, 2), datetime(2011, 1, 5),             datetime(2011, 1, 7), datetime(2011, 1, 8),             datetime(2011, 1, 10), datetime(2011, 1, 12)]&gt;&gt;&gt; ts = pd.Series(np.random.randn(6), index=dates)2011-01-02   -0.5408782011-01-05   -1.7361952011-01-07   -1.7514032011-01-08   -0.6839072011-01-10   -0.4582342011-01-12   -1.284808dtype: float64dtype: float64&gt;&gt;&gt; ts.indexDatetimeIndex([&#39;2011-01-02&#39;, &#39;2011-01-05&#39;, &#39;2011-01-07&#39;, &#39;2011-01-08&#39;,               &#39;2011-01-10&#39;, &#39;2011-01-12&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=None)// 除了常规的一些标签，位置索引外，还支持以下的索引&gt;&gt;&gt; ts[&#39;20100110&#39;]-0.4582336049173489</code></pre><p><strong>时间范围索引</strong></p><pre><code class="python">&gt;&gt;&gt; ts = pd.Series(np.random.randn(1000),index=pd.date_range(&#39;1/1/2000&#39;,periods=1000))&gt;&gt;&gt; ts    // 时间序列默认每天生成，periods=1000 意思是生成 1000 天的时间</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_20-42-03.jpg" style="zoom:80%;" /><p><strong>索引：</strong></p><pre><code class="python">&gt;&gt;&gt; ts[&#39;2002&#39;]   // 会选取 2002 年的所有数据, 还可指定月份&gt;&gt;&gt; ts[datetime(2002,9,23):]  // 返回 2002-9-23 及以后 ts1 中有的值&gt;&gt;&gt; ts[&#39;2002-9-23&#39;:&#39;2002-12-30&#39;]=1&gt;&gt;&gt; ts    // 结果如下，这不同于切片，有的才赋值，没有就不管</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_21-03-48.jpg" style="zoom:80%;" /><pre><code class="python">&gt;&gt;&gt; ts.truncate(after=&#39;1/9/2001&#39;)  // 取 1/9/2001（不包含）之前的数据</code></pre><p><strong>重复的时间索引：</strong></p><pre><code class="python">&gt;&gt;&gt; dates = pd.DatetimeIndex([&#39;1/1/2000&#39;, &#39;1/2/2000&#39;, &#39;1/2/2000&#39;,&#39;1/2/2000&#39;, &#39;1/3/2000&#39;])&gt;&gt;&gt; ts = pd.Series(np.arange(5), index=dates)&gt;&gt;&gt; ts2000-01-01    02000-01-02    12000-01-02    22000-01-02    32000-01-03    4dtype: int32&gt;&gt;&gt; ts.index.is_unique       // 检查是否为唯一False&gt;&gt;&gt; ts[&#39;1/2/2000&#39;]2000-01-02    12000-01-02    22000-01-02    3dtype: int32&gt;&gt;&gt; ts.groupby(level=0).count()   //  还支持分组2000-01-01    12000-01-02    32000-01-03    1dtype: int64</code></pre><h3 id="7-1-2- 时间索引的范围，频率，及移动"><a href="#7-1-2- 时间索引的范围，频率，及移动" class="headerlink" title="7.1.2 时间索引的范围，频率，及移动"></a>7.1.2 时间索引的范围，频率，及移动 </h3><pre><code>&gt;&gt;&gt; index = pd.date_range(begin_time, end_time, periods, freq)</code></pre><p> 默认<code>periods=None</code>，若没有指定 end_time，可由 periods 指定生成天数。</p><p>默认<code>freq=&#39;D&#39;</code>，还支持以下偏移：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_21-25-41.jpg" style="zoom:80%;" /><p>举个例子：</p><pre><code class="python">&gt;&gt;&gt; ts=pd.date_range(&#39;2012-01-01&#39;,&#39;2012-12-31&#39;,freq=&#39;M&#39;)  // 生成每个月的最后一天DatetimeIndex([&#39;2012-01-31&#39;, &#39;2012-02-29&#39;, &#39;2012-03-31&#39;, &#39;2012-04-30&#39;,               &#39;2012-05-31&#39;, &#39;2012-06-30&#39;, &#39;2012-07-31&#39;, &#39;2012-08-31&#39;,               &#39;2012-09-30&#39;, &#39;2012-10-31&#39;, &#39;2012-11-30&#39;, &#39;2012-12-31&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;M&#39;)</code></pre><p><strong>日期偏移量</strong></p><pre><code class="python">&gt;&gt;&gt; from pandas.tseries.offsets import Hour,Minute&gt;&gt;&gt; pd.date_range(&#39;2012-01-01&#39;,&#39;2012-01-02&#39;,freq=&#39;4h&#39;)    // 按小时来偏移DatetimeIndex([&#39;2012-01-01 00:00:00&#39;, &#39;2012-01-01 04:00:00&#39;,               &#39;2012-01-01 08:00:00&#39;, &#39;2012-01-01 12:00:00&#39;,               &#39;2012-01-01 16:00:00&#39;, &#39;2012-01-01 20:00:00&#39;,               &#39;2012-01-02 00:00:00&#39;],              dtype=&#39;datetime64[ns]&#39;, freq=&#39;4H&#39;)&gt;&gt;&gt; ts.shift(2) // 将 value 向下偏移两个位置，也可传入 freq 参数</code></pre><h2 id="7-2- 重采样及频率转换"><a href="#7-2- 重采样及频率转换" class="headerlink" title="7.2 重采样及频率转换"></a>7.2 重采样及频率转换 </h2><p><strong> 重采样（resampling）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（downsampling），而将低频率数据转换到高频率则称为升采样（upsampling）。</strong></p><p><strong>降采样示例：</strong></p><pre><code class="python">&gt;&gt;&gt; t = pd.DataFrame(np.random.uniform(10,50,(100,1)),index=pd.date_range(&#39;20170101&#39;,periods=100))&gt;&gt;&gt; t　　　　　　　　　02017-01-01     19.6062282017-01-02     26.5944142017-01-03     40.7417612017-01-04     27.2510842017-01-05     10.215133...     ...2017-04-06     22.9514632017-04-07     23.5165112017-04-08     32.3276092017-04-09     22.5036532017-04-10     19.498829100 rows × 1 columns&gt;&gt;&gt; t.resample(&#39;M&#39;).sum()　　　　// 将 t 里面的数据按月求和　　　　　　　　　　02017-01-31     920.0566152017-02-28     888.4025582017-03-31     1026.1738922017-04-30     305.172146</code></pre><p><strong>升采样示例：</strong></p><pre><code class="python">&gt;&gt;&gt; frame = pd.DataFrame(np.random.randn(2, 4),                       index=pd.date_range(&#39;1/1/2000&#39;, periods=2,freq=&#39;W-WED&#39;),                       columns=[&#39; 上海 &#39;, &#39; 北京 &#39;, &#39; 深圳 &#39;, &#39; 广州 &#39;])&gt;&gt;&gt; frame　　　　　　　　　上海　　　　　　北京　　　　　深圳　　　　　广州2000-01-05　-1.081783　　-0.340245　　-1.626201　　0.0213192000-01-12　-0.126046　　0.656332　　　-0.114384　　-1.840728&gt;&gt;&gt; frame.resample(&#39;D&#39;).asfreq()</code></pre><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_22-16-14.jpg" style="zoom:80%;" /><p>resample 是一个灵活高效的方法，可用于处理非常大的时间序列。</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_22-19-23.jpg" style="zoom:80%;" /><h2 id="7-3- 应用案例"><a href="#7-3- 应用案例" class="headerlink" title="7.3 应用案例"></a>7.3 应用案例</h2><pre><code class="python">&gt;&gt;&gt; df = pd.read_csv(&#39;911.csv&#39;)&gt;&gt;&gt; df.head()</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_22-24-10.jpg" alt=""></p><pre><code class="python">&gt;&gt;&gt; df[&#39;timeStamp&#39;] = pd.to_datetime(df[&#39;timeStamp&#39;])   // 转换成时间格式&gt;&gt;&gt; df.set_index(&#39;timeStamp&#39;,inplace=True)  // 设置其中一列为索引</code></pre><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-19_22-29-37.jpg" alt=""></p><h1 id="8- 老师总结"><a href="#8- 老师总结" class="headerlink" title="8. 老师总结"></a>8. 老师总结</h1><p><a href="https://docs.qq.com/pdf/DYmV0WXpOZFZLaW1G">Pandas 总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 之 Numpy 库从入门到实战</title>
      <link href="/Python%E4%B9%8BNumpy%E5%BA%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
      <url>/Python%E4%B9%8BNumpy%E5%BA%93%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>官方中文文档：<a href="https://www.numpy.org.cn/user/">https://www.numpy.org.cn/user/</a></p><p>这里使用 jupyter notebook 进行演示。</p><p>安装：<code>pip install jupyter</code></p><p>启动：<code>jupyter notebook</code></p><h1 id="1- 数组的创建"><a href="#1- 数组的创建" class="headerlink" title="1. 数组的创建"></a>1. 数组的创建 </h1><h2 id="1-1- 类型转变"><a href="#1-1- 类型转变" class="headerlink" title="1.1 类型转变"></a>1.1 类型转变</h2><p> 从列表：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_17-39-46.png" alt=""></p><p>从元祖：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_17-41-58.png" alt=""></p><p>从字符串：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_17-44-32.png" alt=""></p><h2 id="1-2- 从头创建"><a href="#1-2- 从头创建" class="headerlink" title="1.2 从头创建"></a>1.2 从头创建 </h2><h3 id="1-2-1- 一维数组"><a href="#1-2-1- 一维数组" class="headerlink" title="1.2.1 一维数组"></a>1.2.1 一维数组</h3><p> 按顺序生成：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_17-55-39.png" style="zoom: 80%;" /></p><blockquote><p>使用 np.random 模块可随机生成</p></blockquote><p>按等间距生成：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_01-12-07.png" style="zoom:80%;" /></p><p>生成全为“1”数组：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_17-58-56.png" style="zoom:80%;" /></p><p>生成全为“0”数组：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_18-02-02.png" style="zoom:80%;" /></p><p>对角线全为“1”数组：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_18-05-21.png" style="zoom:80%;" /></p><p>注意：默认生成浮点型数值，可在括号里加参数<code>dtype=int</code>，使得生成整型数值。</p><p>归纳为以下：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_18-08-33.png" alt=""></p><h3 id="1-2-2- 多维数组"><a href="#1-2-2- 多维数组" class="headerlink" title="1.2.2 多维数组"></a>1.2.2 多维数组</h3><ul><li><code>.reshape()</code>的使用：</li></ul><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_19-40-35.png" style="zoom:80%;" /><p>使用 <code>.reshape()</code> 方法可将 n 维数组变成任意指定形状的数组，但是元素个数要对的上。</p><p><strong>将 n 维数组变成一维：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_20-14-20.png" style="zoom:80%;" /><p><strong>将一维行数据数据变成列数据：</strong></p><pre><code class="python">&gt;&gt;&gt; s=np.arange(5)array([0, 1, 2, 3, 4])&gt;&gt;&gt; s.reshape(5,1)array([[0],       [1],       [2],       [3],       [4]])</code></pre><p><code>.reshape()</code>和 <code>.resize()</code> 区别：前者不改变原形状，后者改变。</p><p><code>.flatten()</code>和 <code>.ravel()</code> 区别：执行命令后再进行赋值操作，前者不改变元素，后者改变（此用法不多）。</p><ul><li><code>size()</code>的使用：</li></ul><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_21-04-13.png" style="zoom:80%;" /><h3 id="1-2-3-np-random 模块"><a href="#1-2-3-np-random 模块" class="headerlink" title="1.2.3 np.random 模块"></a>1.2.3 np.random 模块</h3><table><thead><tr><th>方法</th><th>使用说明</th></tr></thead><tbody><tr><td><code>np.random.random((m,n))</code></td><td>随机生成 (0,1) 之间的数组，m 行 n 列</td></tr><tr><td><code>np.random.rand(m,n)</code></td><td>随机生成 [0,1)之间的数组，m 行 n 列</td></tr><tr><td><code>np.random.randint(x,y,size=(m,n))</code></td><td>随机生成整型数组，数字 (x,y) 之间，m 行 n 列</td></tr><tr><td><code>np.random.uniform(x,y,size=(m,n))</code></td><td>随机生成浮点数组，数字 [x,y) 之间，m 行 n 列</td></tr><tr><td><code>np.random.choice(data)</code></td><td>随机采样生成数组，从 data 中</td></tr><tr><td><code>np.random.shuffle(data)</code></td><td>随机按行打乱数组，从 data 中，改变原数组</td></tr><tr><td><code>np.random.permutation(data)</code></td><td>随机按行打乱数组，从 data 中，不改原数组</td></tr><tr><td><code>np.random.seed()</code></td><td>调控随机数的生成，根据种子值</td></tr><tr><td><code>np.random.randn(m,n)</code></td><td>随机生成标准正态分布数组，符合 N(0,1)</td></tr><tr><td><code>np.random.normal(μ,σ,size=(m,n))</code></td><td>随机生成正态分布数组，符合 N(μ,σ)</td></tr><tr><td><code>np.random.poisson(lam,size=(m,n))</code></td><td>随机生成泊松分布数组，事件发生率 lam</td></tr></tbody></table><p>以上均可很据括号里传入维度的不同，可以创建 1~N 维数组。</p><h2 id="1-3- 数组属性"><a href="#1-3- 数组属性" class="headerlink" title="1.3 数组属性"></a>1.3 数组属性</h2><table><thead><tr><th>属性</th><th>使用说明</th></tr></thead><tbody><tr><td><code>.ndim</code></td><td>秩，即数据轴的个数</td></tr><tr><td><code>.shape</code></td><td>数组的维度</td></tr><tr><td><code>.size</code></td><td>元素的总个数</td></tr><tr><td><code>.dtype</code></td><td>数据类型</td></tr><tr><td><code>.itemsize</code></td><td>数组中每个元素的字节大小</td></tr><tr><td><code>.T</code></td><td>数组的转置，即行列进行交换 / <code>.transpose</code>作用一样，但它会改变原数组</td></tr></tbody></table><p>使用以上方法不需要加括号。</p><p>举一个例子：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_19-59-50.png" style="zoom:80%;" /></p><h1 id="2- 数组的操作"><a href="#2- 数组的操作" class="headerlink" title="2. 数组的操作"></a>2. 数组的操作 </h1><h2 id="2-1- 索引"><a href="#2-1- 索引" class="headerlink" title="2.1 索引"></a>2.1 索引</h2><h3 id="2-1-1- 普通索引"><a href="#2-1-1- 普通索引" class="headerlink" title="2.1.1 普通索引"></a>2.1.1 普通索引</h3><p> 位置索引：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_20-28-10.png" style="zoom:80%;" /><p>布尔索引：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_20-49-58.png" style="zoom:80%;" /><h3 id="2-1-2- 花哨索引"><a href="#2-1-2- 花哨索引" class="headerlink" title="2.1.2 花哨索引"></a>2.1.2 花哨索引 </h3><p> 选取数据：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_00-25-31.png" style="zoom:80%;" /><p>选择块：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_00-40-09.png" style="zoom:80%;" /><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_12-07-29.png" style="zoom:80%;" /><p>调换行：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_00-31-45.png" style="zoom:80%;" /><h2 id="2-2- 切片"><a href="#2-2- 切片" class="headerlink" title="2.2 切片"></a>2.2 切片 </h2><p> 连续的切片：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_20-41-33.png" style="zoom:80%;" /><p>不连续的切片：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_20-46-01.png"  style="zoom:80%;" /><h2 id="2-3- 值的替换"><a href="#2-3- 值的替换" class="headerlink" title="2.3 值的替换"></a>2.3 值的替换 </h2><p> 根据索引赋值</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_21-01-18.png" style="zoom:80%;" /><h2 id="2-4- 数组拼接"><a href="#2-4- 数组拼接" class="headerlink" title="2.4 数组拼接"></a>2.4 数组拼接</h2><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_21-36-03.png" alt=""></p><h2 id="2-5- 数组切割"><a href="#2-5- 数组切割" class="headerlink" title="2.5 数组切割"></a>2.5 数组切割</h2><h3 id="2-5-1- 普通切割"><a href="#2-5-1- 普通切割" class="headerlink" title="2.5.1 普通切割"></a>2.5.1 普通切割</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_22-03-42.png" alt=""></p><h3 id="2-5-2- 复杂切割"><a href="#2-5-2- 复杂切割" class="headerlink" title="2.5.2 复杂切割"></a>2.5.2 复杂切割</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-14_22-06-11.png" alt=""></p><h2 id="2-6- 数组运算"><a href="#2-6- 数组运算" class="headerlink" title="2.6 数组运算"></a>2.6 数组运算</h2><h3 id="2-6-1- 通用函数"><a href="#2-6-1- 通用函数" class="headerlink" title="2.6.1 通用函数"></a>2.6.1 通用函数</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_00-44-07.png" alt=""></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_00-44-29.png" alt=""></p><p><strong>注意：这里的逻辑运算如逻辑与 np.logical_and()是进行多元运算的。括号里传入的数组必须形状相同。</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_00-45-07.png" alt=""></p><p>NAN 安全版本：为了应对数组里的缺失值 <code>np.nan</code> 的。如下：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_12-26-15.png" style="zoom:80%;" /><h3 id="2-6-2- 布尔数组函数"><a href="#2-6-2- 布尔数组函数" class="headerlink" title="2.6.2 布尔数组函数"></a>2.6.2 布尔数组函数</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_00-55-07.png" alt=""></p><p>对传入的数组进行是否有空值判断。传入的数组也可以为布尔数组。只能进行一元判断。</p><h2 id="2-7- 数组排序"><a href="#2-7- 数组排序" class="headerlink" title="2.7 数组排序"></a>2.7 数组排序</h2><h3 id="2-7-1- 普通排序"><a href="#2-7-1- 普通排序" class="headerlink" title="2.7.1 普通排序"></a>2.7.1 普通排序</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_01-03-47.png" alt=""></p><p>如要 降序 排列，只需传入负号即可：<code>np.sort(-arr)</code>。</p><h3 id="2-7-2- 排序并返回唯一值"><a href="#2-7-2- 排序并返回唯一值" class="headerlink" title="2.7.2 排序并返回唯一值"></a>2.7.2 排序并返回唯一值</h3><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_01-23-06.png" style="zoom:80%;" /><p>对传入的数组中的元素排序，并返回对应元素出现的个数。</p><h2 id="2-8- 数组广播机制"><a href="#2-8- 数组广播机制" class="headerlink" title="2.8 数组广播机制"></a>2.8 数组广播机制 </h2><p><strong> 如果两个数组的后缘维度（trailing dimension，即从末尾开始算起的维度）的轴长度相符或其中一方的长度为 1，则认为他们是广播兼容的。广播会在缺失和（或）长度为 1 的维度上进行。</strong></p><p>举例说明：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_01-29-58.png" style="zoom:80%;" /><h1 id="3- 文件操作"><a href="#3- 文件操作" class="headerlink" title="3. 文件操作"></a>3. 文件操作</h1><h2 id="3-1- 文件保存"><a href="#3-1- 文件保存" class="headerlink" title="3.1 文件保存"></a>3.1 文件保存</h2><pre><code>np.savetxt(frame, array, fmt=&#39;%.18e&#39;, delimiter=None)</code></pre><ul><li><strong>frame</strong> : 文件、字符串或产生器，可以是.gz 或.bz2 的压缩文件    如 “example.csv”</li><li><strong>array</strong> : 存入文件的数组</li><li>fmt : 写入文件的格式，例如：%d  %.2f   %.18e                             可以省略</li><li>delimiter : 分割字符串，默认是任何空格                                     根据需要是否要指定</li></ul><h2 id="3-2- 读取文件"><a href="#3-2- 读取文件" class="headerlink" title="3.2 读取文件"></a>3.2 读取文件</h2><pre><code>np.loadtxt(frame, dtype=np.float, delimiter=None, unpack=False)</code></pre><ul><li><strong>frame</strong>：文件、字符串或产生器，可以是.gz 或.bz2 的压缩文件。</li><li>dtype：数据类型，可选。</li><li>delimiter：分割字符串，默认是任何空格。</li><li>skiprows：跳过前面 x 行。</li><li>usecols：读取指定的列，用元组组合。</li><li>unpack：如果 True，读取出来的数组是转置后的。</li></ul><p><strong>保存和读取文件举例：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_16-26-28.png" alt=""></p><p>注意这里的 <code>skiprows=1</code> 的意思是忽略第一行数据。</p><h2 id="3-3-numpy 独有存储格式"><a href="#3-3-numpy 独有存储格式" class="headerlink" title="3.3 numpy 独有存储格式"></a>3.3 numpy 独有存储格式</h2><ol><li>存储：<code>np.save(&#39;fname.np&#39;,array)</code>或 <code>np.savez(&#39;fname.npz&#39;,array)</code>。后者<code>fname.npz</code> 是经过压缩的。</li><li>加载：<code>np.load(fname)</code>。</li></ol><h1 id="4- 补充知识点"><a href="#4- 补充知识点" class="headerlink" title="4. 补充知识点"></a>4. 补充知识点 </h1><h2 id="4-1-Axis 理解"><a href="#4-1-Axis 理解" class="headerlink" title="4.1 Axis 理解"></a>4.1 Axis 理解</h2><p> 方便大家理解，可以认为 <strong><code>axis=0</code> 代表的是行 </strong>，<strong><code>axis=1</code> 代表的是列 </strong>。但其实不是这么简单理解的。这里具体解释一下这个<code>axis</code> 轴的概念。</p><p>简单来说， <strong>最外面的括号代表着 axis=0，依次往里的括号对应的 axis 的计数就依次加 1</strong>：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/1-1581749184285.png" alt=""></p><p> <strong>操作方式：如果指定轴进行相关的操作，那么他会使用轴下的每个直接子元素的第 0 个，第 1 个，第 2 个…分别进行相关的操作。</strong></p><p><strong>二维的数组求和：</strong></p><pre><code class="python">&gt;&gt;&gt;x = np.array([[0,1],                 [2,3]])&gt;&gt;&gt;x.sum(axis=0)array([2, 4])&gt;&gt;&gt;x.sum(axis=1)array([1, 5])</code></pre><p>按照 <code>axis=0</code> 的方式进行相加，那么就会把最外面轴下的所有直接子元素中的第 0 个位置 <code>x[0][0]</code> 与<code>x[1][0]</code></p><p>进行相加，第 1 个位置 <code>x[0][1]</code> 与<code>x[1][1]</code>进行相加…依此类推。</p><p>按照 <code>axis=1</code> 的方式进行相加，那么就会把轴为 1 里面的元素拿出来进行求和，<code>x[0][0]</code>与 <code>x[0][1]</code> 进行相加，<code>x[1][0]</code>与 <code>x[1][1]</code> 进行相加…依此类推。</p><p><strong>用 <code>np.delete</code> 在<code>axis=0</code>和 <code>axis=1</code> 两种情况下删除元素：</strong></p><pre><code class="python">&gt;&gt;&gt;x = np.random.randint(0,10,size=(3,5))&gt;&gt;&gt; np.delete(x,0,axis=0)array([[0, 4, 2, 5, 2],       [2, 2, 1, 0, 8]])         #删除了行</code></pre><p><code>np.delete</code>是个例外。我们按照 <code>axis=0</code> 的方式进行删除，那么他会首先找到最外面的括号下的直接子元素中的第 0 个，然后删掉，剩下最后一行的数据。</p><p><strong>三维数组：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/2-1581750404175.png" style="zoom:80%;" /><p>按照 <code>axis=0</code> 的方式进行相加：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/3-1581750466746.png" alt=""></p><p>按照 <code>axis=1</code> 的方式进行相加：<img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/4-1581750497037.png" alt=""></p><h2 id="4-2-NAN 和 INF 值处理"><a href="#4-2-NAN 和 INF 值处理" class="headerlink" title="4.2 NAN 和 INF 值处理"></a>4.2 NAN 和 INF 值处理 </h2><p><strong> 意义解释：</strong></p><ol><li><code>NAN</code>：<code>Not A number</code>，不是一个数字的意思，但是他是属于浮点类型的，所以想要进行数据操作的时候需要注意他的类型。</li><li><code>INF</code>：<code>Infinity</code>，代表的是无穷大的意思，也是属于浮点类型。<code>np.inf</code>表示正无穷大，<code>-np.inf</code>表示负无穷大，一般在出现除数为 0 的时候为无穷大。比如<code>2/0</code></li></ol><p><strong>特点：</strong></p><ol><li>NAN 和 NAN 不相等。比如 <code>np.NAN != np.NAN</code> 这个条件是成立的。</li><li>NAN 和任何值做运算，结果都是 NAN。</li></ol><p><strong>删除缺失值：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_15-36-25.png" style="zoom:80%;" /><p><strong>替换缺失值：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_16-34-56.png" alt=""></p><p>打开表格 <code>scores.csv</code> 可看到如下表格：</p><table><thead><tr><th>数学</th><th>英语</th></tr></thead><tbody><tr><td>59</td><td>89</td></tr><tr><td>90</td><td>32</td></tr><tr><td>78</td><td>45</td></tr><tr><td>34</td><td>nan</td></tr><tr><td>nan</td><td>56</td></tr><tr><td>23</td><td>56</td></tr></tbody></table><p>替换缺失值为 0：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_16-37-04.png" alt=""></p><h2 id="4-3- 深浅拷贝"><a href="#4-3- 深浅拷贝" class="headerlink" title="4.3 深浅拷贝"></a>4.3 深浅拷贝 </h2><p> 在操作数组的时候，它们的数据有时候拷贝进一个新的数组，有时候又不是。这经常是初学者感到困惑。下面有三种情况：</p><p><strong>不拷贝：</strong></p><p>如果只是 <strong> 简单的赋值</strong>，那么不会进行拷贝。示例代码如下：</p><pre><code class="python">a = np.arange(12)b = a #这种情况不会进行拷贝print(b is a) #返回 True，说明 b 和 a 是相同的</code></pre><p><strong>View 或者浅拷贝：</strong></p><p>有些情况，会进行 <strong> 变量的拷贝 </strong>，但是他们所<strong> 指向的内存空间都是一样的</strong>，那么这种情况叫做浅拷贝，或者叫做<code>View(视图)</code>。比如以下代码：</p><pre><code class="python">a = np.arange(12)c = a.view()print(c is a) #返回 False，说明 c 和 a 是两个不同的变量c[0] = 100print(a[0]) #打印 100，说明对 c 上的改变，会影响 a 上面的值，说明他们指向的内存空间还是一样的，这种叫做浅拷贝，或者说是 view</code></pre><p><strong>深拷贝：</strong></p><p>将之前数据 <strong> 完完整整的拷贝一份放到另外一块内存空间中</strong>，这样就是两个完全不同的值了。示例代码如下：</p><pre><code class="python">a = np.arange(12)d = a.copy()print(d is a) #返回 False，说明 d 和 a 是两个不同的变量d[0] = 100print(a[0]) #打印 0，说明 d 和 a 指向的内存空间完全不同了。</code></pre><p><strong>图例说明：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_16-54-54.png" alt=""></p><p>像之前讲到的 <code>flatten</code> 和<code>ravel</code>就是这种情况，<code>ravel</code>返回的就是 View，而 <code>flatten</code> 返回的就是深拷贝。</p><h1 id="5-Numpy 实际应用"><a href="#5-Numpy 实际应用" class="headerlink" title="5. Numpy 实际应用"></a>5. Numpy 实际应用 </h1><h2 id="5-1- 图像处理"><a href="#5-1- 图像处理" class="headerlink" title="5.1 图像处理"></a>5.1 图像处理</h2><p> 以下简单举例 Numpy 数组在图像处理领域的应用：</p><p><strong>读取图片并将其转化成数组数据：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_17-38-39.png" style="zoom: 80%;" /><p><strong>处理数组数据并还原成图片：</strong></p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-15_17-44-07.png" style="zoom:80%;" /><p>图像处理库 Pillow(PIL)更多用法参考：<a href="https://www.cnblogs.com/yhjoker/p/10773444.html">https://www.cnblogs.com/yhjoker/p/10773444.html</a></p><p>官方文档：<a href="https://pillow.readthedocs.io/en/stable/index.html">https://pillow.readthedocs.io/en/stable/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python pip 国内镜像大全及库的安装</title>
      <link href="/python%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E9%95%9C%E5%83%8F%E6%BA%90%E7%BD%91%E5%9D%80/"/>
      <url>/python%E4%B8%AD%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E9%95%9C%E5%83%8F%E6%BA%90%E7%BD%91%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p><strong>在使用 python 第三方库的时候，经常碰到 pip 安装失败的情况，链接超时情况，这时可采用国内镜像网站替换的办法。</strong></p><h1 id="国内镜像"><a href="# 国内镜像" class="headerlink" title="国内镜像"></a>国内镜像 </h1><p><strong> 阿里：</strong></p><p><a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></p><p><strong>清华：</strong></p><p><a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></p><p><strong>中国科学技术大学：</strong></p><p><a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a> </p><p><strong>豆瓣：</strong></p><p><a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a> </p><h1 id="使用办法"><a href="# 使用办法" class="headerlink" title="使用办法"></a><strong>使用办法 </strong></h1><h2 id="直接在线安装"><a href="# 直接在线安装" class="headerlink" title="直接在线安装"></a> 直接在线安装 </h2><p> 在 CMD 命令行下，采用如下格式</p><p><code>pip install [库名] -i [镜像地址]</code></p><p>如：</p><pre><code>pip install seaborn -i https://mirrors.aliyun.com/pypi/simple/</code></pre><h2 id="本地安装"><a href="# 本地安装" class="headerlink" title="本地安装"></a>本地安装 </h2><p> 首先在镜像源网址上下载对应的库，放在本地电脑上，再执行本地安装。</p><p>如：</p><pre><code>pip install D:\Desktop\pyecharts-1.6.2-py3-none-any.whl</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 的三种输出格式</title>
      <link href="/python%E7%9A%84%E4%B8%89%E7%A7%8D%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/"/>
      <url>/python%E7%9A%84%E4%B8%89%E7%A7%8D%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="拼接"><a href="# 拼接" class="headerlink" title="拼接"></a>拼接</h1><ul><li><p><code>+</code>加号拼接</p><pre><code class="python">name=&#39;zs&#39;print(&#39;hello,&#39;+ name)#输出结果：hello,zs</code></pre></li><li><p><code>，</code>逗号拼接</p><pre><code class="python">name=&#39;zs&#39;print(&#39;hello,&#39;, name)#输出结果：hello,zs</code></pre></li></ul><h1 id="占位符方法"><a href="# 占位符方法" class="headerlink" title="占位符方法"></a>占位符方法</h1><pre><code class="python">name=&#39;zs&#39;print(&#39;hello,%s&#39;%name)    #这里 s% 就是一个占位符，为“字符串”占位#输出结果：hello,zs</code></pre><p><strong>常见占位符：</strong></p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/obytmcy9FdS91eEl3PT0.png" alt=""></p><p><strong>为输出设置限制条件：</strong></p><ul><li>%3s 表示输出的字符串类型最少 3 个字符，少于 3 个用空格填充</li><li>%.5s 表示输出的字符串类型最多 5 个字符，超出 3 个会被删掉</li><li>%3f 少于 3 位数，小数点后面用 0 填充</li><li>%.3f 控制小数点后的位数，保留 3 位小数。</li></ul><p><strong>下面补充一些相关知识：转义符</strong> </p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/kVrcUZTQzRBPT0.png" style="zoom: 80%;" /><h1 id="格式化输出"><a href="# 格式化输出" class="headerlink" title="格式化输出"></a>格式化输出 </h1><h2 id="第一种："><a href="# 第一种：" class="headerlink" title="第一种："></a> 第一种：</h2><pre><code class="python">name=&#39;zs&#39;print(f&#39;hello,&#123;name&#125;&#39;)   #输出结果：hello,zs</code></pre><h2 id="第二种："><a href="# 第二种：" class="headerlink" title="第二种："></a>第二种：</h2><pre><code class="python">name=&#39;zs&#39;print(&#39;hello,&#123;&#125;&#39;.format(name))   #输出结果：hello,zs</code></pre><ul><li><p>在大括号里 <code>&#123;&#125;</code> 指定位置参数：</p><pre><code class="python">print(&#39;&#123;1&#125;,&#123;0&#125;,&#123;1&#125;&#39;.format(&#39;abc&#39;,18))#输出结果：18,abc,18</code></pre></li><li><p>格式控制信息还包括【填充】，【对齐】，【宽度】，【千位分隔符】，【精度】，【类型】等。</p><pre><code class="python">print(&#39;&#123;0:30&#125;&#39;.format(&#39;python&#39;))   #宽度#输出结果：python                             #python 字符后面有空格的，总长度 30print(&#39;&#123;0:&gt;30&#125;&#39;.format(&#39;python&#39;))  #对齐 &lt;，&gt;，^ 分别表示左对齐，右对齐，居中#输出结果：                        pythonprint(&#39;&#123;0:*^30&#125;&#39;.format(&#39;python&#39;))  #填充#输出结果：************python************print(&#39;&#123;0:-^20,&#125;&#39;.format(123456456789))  #逗号为千位分隔符#输出结果：--123,456,456,789---print(&#39;&#123;0:.2f&#125;&#39;.format(123.45645))   #精度控制#输出结果：123.46print(&#39;&#123;0:.4&#125;&#39;.format(&#39;python&#39;))   #字符分割#输出结果：pythprint(&#39;&#123;0:.2%&#125;&#39;.format(3.14152))  #类型控制#输出结果：314.15%</code></pre></li></ul><p>更多用法详见官方文档：<a href="https://docs.python.org/zh-cn/3/library/string.html#format-string-syntax">https://docs.python.org/zh-cn/3/library/string.html#format-string-syntax</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python 中的时间模块</title>
      <link href="/python%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/"/>
      <url>/python%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="时间的表现形式"><a href="# 时间的表现形式" class="headerlink" title="时间的表现形式"></a>时间的表现形式 </h1><h2 id="1-struct-time 类型"><a href="#1-struct-time 类型" class="headerlink" title="1. struct_time 类型"></a>1. struct_time 类型</h2><p> 它是一个具有命名元组接口的对象：可以通过索引和属性名访问值。存在以下值：</p><ul><li>index—attribute—values</li><li>0—tm_year—年份</li><li>1—tm_mon—月份 range[1,12]</li><li>2—tm_mday—天数 range[1,31]</li><li>3—tm_hour—小时 range[0,23]</li><li>4—tm_min—分钟 range[0,59]</li><li>5—tm_sec—秒数 range[0,61]</li><li>6—tm_wday—星期 range[0,6],0 是星期日</li><li>7—tm_yday—一年中的一天 range[1,366]</li><li>8—tm_isdst—tm_isdst 可以在夏令时生效时设置为 1，而在夏令时不生效时设置为 0。值 -1 表示这是未知的。</li><li>N/A—tm_zone—时区名称的缩写</li><li>N/A—tm_gmtoff—协调世界时以东偏移，以秒为单位.</li></ul><p>例如，time.struct_time(tm_year=2019, tm_mon=3, tm_mday=20, tm_hour=23, tm_min=11, tm_sec=33, tm_wday=2, tm_yday=79, tm_isdst=0)</p><h2 id="2- 格式化时间类型"><a href="#2- 格式化时间类型" class="headerlink" title="2. 格式化时间类型"></a>2. 格式化时间类型 </h2><p> 例如，’Wed Mar 20 23:12:26 2019’</p><h2 id="3- 时间戳类型"><a href="#3- 时间戳类型" class="headerlink" title="3. 时间戳类型"></a>3. 时间戳类型 </h2><p> 时间戳是指格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒 (北京时间 1970 年 01 月 01 日 08 时 00 分 00 秒) 起至现在的总毫秒数。<br> 例如，time.time()得到的 float 类型的秒数。</p><h2 id="4- 时间格式化指令"><a href="#4- 时间格式化指令" class="headerlink" title="4 时间格式化指令"></a>4 时间格式化指令</h2><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/20200323.png" alt=""></p><h1 id="一、time 模块"><a href="# 一、time 模块" class="headerlink" title="一、time 模块"></a>一、time 模块</h1><p><strong>time 模块的主要功能分三个方面：</strong></p><ul><li>获取系统时间</li><li>时间格式化</li><li>计时</li></ul><h2 id="1-1- 获取系统时间"><a href="#1-1- 获取系统时间" class="headerlink" title="1.1 获取系统时间"></a>1.1 获取系统时间</h2><ul><li><p><code>time.time()</code>  返回当前时间的时间戳</p></li><li><p><code>time.gmtime()</code>  获取 UTC 对应的 struct_time 对象，元祖的表现形式</p></li><li><p><code>time.localtime()</code>   获取当前本地时间的 struct_time 对象，元祖的表现形式</p></li><li><p><code>time.ctime()</code>    获取当前时间对应的易读字符串形式（符合美国人的阅读习惯）</p></li></ul><p><strong># 上述后三个方法括号中可以加时间戳 timestmap，即获取时间戳对应的时间。</strong></p><h2 id="1-2- 时间格式化"><a href="#1-2- 时间格式化" class="headerlink" title="1.2 时间格式化"></a>1.2 时间格式化</h2><ul><li><p><code>time.mktime(struct_time)</code>   把元祖形式的时间转化为时间戳</p><p>struct_time—结构化的时间或者完整的 9 位元组元素。</p></li><li><p><code>time.strftime(format, struct_time)</code>  以指定的通用格式输出时间</p></li><li><p><code>time.strptime(string_time, format)</code>  与 time.strftime()相反，生成元祖式时间</p><p>format 对应 (string_time) 的时间格式</p></li></ul><h2 id="1-3- 计时"><a href="#1-3- 计时" class="headerlink" title="1.3 计时"></a>1.3 计时</h2><ul><li><code>time.sleep(5)</code>  休息 5 秒再执行</li></ul><h2 id="1-4- 总结"><a href="#1-4- 总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h2><h3 id="1-4-1- 时间相互转化"><a href="#1-4-1- 时间相互转化" class="headerlink" title="1.4.1 时间相互转化"></a>1.4.1 时间相互转化</h3><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-03-23_23-42-34.png" alt=""></p><h1 id="二、datetime 模块"><a href="# 二、datetime 模块" class="headerlink" title="二、datetime 模块"></a>二、datetime 模块</h1><p>datetime 模块是 time 模块的进一步封装，对用户更加友好，在时间各属性的获取上回更加方便一些，当然，在效率上会略微低一些。datetime 模块的功能主要都几种在 datetime、date、time、timedelta、tzinfo 五个类中。这五个类功能如下表所示：</p><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody><tr><td>date</td><td>提供处理日期（年月日）接口</td></tr><tr><td>time</td><td>提供处理时间（时分秒）接口</td></tr><tr><td>datetime</td><td>同时处理日期和时间</td></tr><tr><td>timedelta</td><td>提供时间运算接口</td></tr><tr><td>tzinfo</td><td>提供处理时区信息接口</td></tr></tbody></table><h2 id="2-1-date 类"><a href="#2-1-date 类" class="headerlink" title="2.1 date 类"></a>2.1 date 类 </h2><p> 使用 date 类的时候，一般会先传入参数：<code>date(year,month,day)</code></p><h3 id="2-1-1- 元祖变日期："><a href="#2-1-1- 元祖变日期：" class="headerlink" title="2.1.1 元祖变日期："></a>2.1.1 元祖变日期：</h3><pre><code class="python">from datetime import datedate(2020,2,3)//print 输出如下：2020-02-03  type&lt;datetime.date&gt;…………………………………………………………………………………………………………………………………………………………………………date(2020,2,3).isoformat()//print 输出如下：2020-02-03   type&lt;str&gt;</code></pre><p>以上用法不多。</p><h3 id="2-1-2- 时间戳变日期"><a href="#2-1-2- 时间戳变日期" class="headerlink" title="2.1.2 时间戳变日期"></a>2.1.2 时间戳变日期</h3><p><code>date.fromtimestamp(timestamp)</code></p><pre><code class="python">from datetime import dateimport timedate.fromtimestamp(time.time())//print 输出如下：2020-03-23    type&lt;class &#39;datetime.date&#39;&gt;</code></pre><h3 id="2-1-3- 元祖变周数"><a href="#2-1-3- 元祖变周数" class="headerlink" title="2.1.3 元祖变周数"></a>2.1.3 元祖变周数</h3><ul><li><p><code>date(year,month,day).isocalendar()</code></p><p>以元组 (iso year, iso_week, iso_weekday) 的形式返回日期</p><pre><code class="python">date(2019,2,5).isocalendar()//print 输出如下：(2019,6,2)   type&lt;tuple&gt;// 意思为 2019 年第 6 周周二</code></pre></li><li><p><code>date(year,month,day).isoweekday()</code></p><p>返回传入日期是星期几</p><pre><code class="python">date(2019,2,5).isoweekday()//print 输出如下：2   type&lt;int&gt;// 意思为传入的日期是周二</code></pre></li></ul><h3 id="2-1-4- 元祖变格式化日期"><a href="#2-1-4- 元祖变格式化日期" class="headerlink" title="2.1.4 元祖变格式化日期"></a>2.1.4 元祖变格式化日期</h3><p><code>date(year,month,day).strftime(format)</code></p><p>按照给定的 format 进行格式化输出</p><pre><code class="python">date(2019,2,5).strftime(&quot;%Y-%m-%d&quot;)//print 输出如下：2019-02-05   type&lt;str&gt;</code></pre><h3 id="2-1-5- 元祖变结构化日期"><a href="#2-1-5- 元祖变结构化日期" class="headerlink" title="2.1.5 元祖变结构化日期"></a>2.1.5 元祖变结构化日期</h3><p><code>date(year,month,day).timetuple()</code></p><p>返回日期对应的 time.struct_time 对象，6 维元祖</p><pre><code class="python">date(2019,2,5).timetuple()//print 输出如下：time.struct_time(tm_year=2019, tm_mon=2, tm_mday=5, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=1, tm_yday=36, tm_isdst=-1)</code></pre><h3 id="2-1-6- 元祖变英文日期"><a href="#2-1-6- 元祖变英文日期" class="headerlink" title="2.1.6 元祖变英文日期"></a>2.1.6 元祖变英文日期</h3><p><code>date(year,month,day).ctime()</code></p><pre><code>date(2019,2,3).ctime()//print 输出如下：un Feb  3 00:00:00 2019</code></pre><h3 id="2-1-7- 替换日期"><a href="#2-1-7- 替换日期" class="headerlink" title="2.1.7 替换日期"></a>2.1.7 替换日期</h3><p><code>date(year,month,day).replace(year1,month1,day1)</code></p><p>替换给定日期，但不改变原日期</p><h3 id="2-1-8- 获取系统日期"><a href="#2-1-8- 获取系统日期" class="headerlink" title="2.1.8 获取系统日期"></a>2.1.8 获取系统日期</h3><p><code>date.today()</code></p><pre><code class="python">date.today()//print 输出如下：2020-03-23   type&lt;class &#39;datetime.date&#39;&gt;</code></pre><h3 id="2-1-9- 其他"><a href="#2-1-9- 其他" class="headerlink" title="2.1.9 其他"></a>2.1.9 其他</h3><p><code>date(year,month,day).year</code> </p><p><code>date(year,month,day).month</code></p><p><code>date(year,month,day).day</code></p><h2 id="2-2-time 类"><a href="#2-2-time 类" class="headerlink" title="2.2 time 类"></a>2.2 time 类 </h2><p> 使用 time 类的时候，一般会先传入参数：<code>time(hour,minute,second[,microsecond,tzoninfo])</code></p><h3 id="2-2-1- 元祖变格式化时间"><a href="#2-2-1- 元祖变格式化时间" class="headerlink" title="2.2.1 元祖变格式化时间"></a>2.2.1 元祖变格式化时间</h3><p><code>time(hour,minute,second).strftime(format)</code></p><p>按照给定的 format 进行格式化输出</p><pre><code class="python">from datetime import timetime(12,30,20).strftime(&#39;%H:%M:%S&#39;)//print 输出如下：12:30:20    type&lt;str&gt;</code></pre><h3 id="2-2-2- 时区名字"><a href="#2-2-2- 时区名字" class="headerlink" title="2.2.2 时区名字"></a>2.2.2 时区名字</h3><p><code>time(hour,minute,second,microsecond,tzoninfo).tzname()</code></p><h3 id="2-2-3- 时区偏移"><a href="#2-2-3- 时区偏移" class="headerlink" title="2.2.3 时区偏移"></a>2.2.3 时区偏移</h3><p><code>time(hour,minute,second,microsecond,tzoninfo).utcoffset()</code></p><h2 id="2-3-datetime 类"><a href="#2-3-datetime 类" class="headerlink" title="2.3 datetime 类"></a>2.3 datetime 类</h2><h3 id="2-3-1- 获取系统日期和时间"><a href="#2-3-1- 获取系统日期和时间" class="headerlink" title="2.3.1 获取系统日期和时间"></a>2.3.1 获取系统日期和时间</h3><ul><li><p><code>datetime.now()</code></p><p>返回当前系统时间</p></li><li><p><code>datetime.now().date()</code></p><p>返回当前系统时间的日期部分</p></li><li><p><code>datetime.now().time()</code></p><p>返回当前系统时间的时间部分</p></li></ul><pre><code class="python">datetime.now()//print 输出如下：2020-03-23 21:47:59.372159    type&lt;class &#39;datetime.datetime&#39;&gt;</code></pre><h3 id="2-3-2- 时间戳变日期和时间"><a href="#2-3-2- 时间戳变日期和时间" class="headerlink" title="2.3.2 时间戳变日期和时间"></a>2.3.2 时间戳变日期和时间</h3><p><code>datetime.fromtimestamp(timestamp)</code></p><p>返回时间戳 timestamp 对应的时间，type&lt;class ‘datetime.datetime’&gt;</p><h3 id="2-3-3- 元祖变英文时间"><a href="#2-3-3- 元祖变英文时间" class="headerlink" title="2.3.3 元祖变英文时间"></a>2.3.3 元祖变英文时间</h3><p><code>datetime(year, month, day[, hour,……]).ctime()</code></p><pre><code class="python">datetime(2019,2,13,12).ctime()//print 输出如下：Sun Feb  13 12:00:00 2019   type&lt;str&gt;</code></pre><h3 id="2-3-4- 字符串变格式化时间"><a href="#2-3-4- 字符串变格式化时间" class="headerlink" title="2.3.4 字符串变格式化时间"></a>2.3.4 字符串变格式化时间</h3><p><code>datetime.strptime(&#39;xx&#39;,format)</code></p><p>由时间字符串 xx 格式转化为日期格式</p><pre><code class="python">datetime.strptime(&#39;2019-4-3&#39;,&#39;%Y-%m-%d&#39;)//print 输出如下：2019-04-03 00:00:00  &lt;class &#39;datetime.datetime&#39;&gt;</code></pre><h3 id="2-3-5- 格式化输出"><a href="#2-3-5- 格式化输出" class="headerlink" title="2.3.5 格式化输出"></a>2.3.5 格式化输出</h3><p><code>datetime(year, month, day[, hour,……]).strftime(format)</code></p><p>按照给定的 format 进行格式化输出</p><pre><code class="python">datetime.now().strftime(&#39;%b-%d-%Y %H:%M:%S&#39;)//print 输出如下：Mar-23-2020 22:09:44   type&lt;class &#39;str&#39;&gt;</code></pre><h2 id="2-4-timedelta 类"><a href="#2-4-timedelta 类" class="headerlink" title="2.4 timedelta 类"></a>2.4 timedelta 类</h2><h3 id="1-4-1- 日期和时间计算"><a href="#1-4-1- 日期和时间计算" class="headerlink" title="1.4.1 日期和时间计算"></a>1.4.1 日期和时间计算</h3><pre><code class="python">from datetime import timedeltafrom datetime import datetimetomorrow=datetime.now()+timedelta(days=1)//print 输出如下：2020-03-24 22:16:18.440283  &lt;class &#39;datetime.datetime&#39;&gt;</code></pre><h3 id="2-4-2- 计算相隔天数 - 秒数"><a href="#2-4-2- 计算相隔天数 - 秒数" class="headerlink" title="2.4.2 计算相隔天数 / 秒数"></a>2.4.2 计算相隔天数 / 秒数</h3><pre><code class="python">a=datetime(2016, 10, 20)-datetime(2015, 11, 2)a.daysa.total_seconds()//print 输出如下：35330499200.0type(a)&lt;class &#39;datetime.timedelta&#39;&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python 查看任何第三方库的用法的方法</title>
      <link href="/python%E6%9F%A5%E7%9C%8B%E4%BB%BB%E4%BD%95%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/python%E6%9F%A5%E7%9C%8B%E4%BB%BB%E4%BD%95%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E7%94%A8%E6%B3%95%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong> 在 CMD 终端 </strong></p><p><strong> 输入 </strong> </p><pre><code>python -m pydoc -p 0</code></pre><p><strong> 此时它会返回 <code>pydoc server ready at 本地网址 </code></strong></p><p><strong> 浏览器打开本地网址，就会看到很多第三方库 </strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda 环境配置与 pyinstaller 程序打包</title>
      <link href="/Anaconda%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8Epyinstaller%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"/>
      <url>/Anaconda%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8Epyinstaller%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装 Anaconda"><a href="# 一、安装 Anaconda" class="headerlink" title="一、安装 Anaconda"></a>一、安装 Anaconda</h1><p>安装 Anaconda3 环境，安装路径：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>版本可以选择 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2023.03-Linux-x86_64.sh">Anaconda3-2023.03-Linux-x86_64.sh</a></p><p><strong>安装</strong>：下载完成后，直接在 Linux 里运行<code>./Anaconda3-2023.03-Linux-x86_64.sh</code> 安装即可</p><p><strong>配置环境变量</strong>：./anaconda3/bin 到 PATH 里面</p><h2 id="1-1- 常见命令"><a href="#1-1- 常见命令" class="headerlink" title="1.1 常见命令"></a>1.1 常见命令 </h2><p> 使用 <code>conda</code> 创建虚拟环境是一个非常直接的过程，以下是具体步骤：</p><pre><code class="shell">conda create --name myenv   # 使用 anaconda 创建虚拟环境conda activate myenv        # 激活环境#安装第三方的包conda install numpypip install numpy#列出所有已有的 conda 环境conda env list#列出当前环境中所有已安装的包conda list#退出当前环境conda deactivate</code></pre><h2 id="1-2- 特点"><a href="#1-2- 特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h2><ol><li><p><strong>环境的独立性</strong>：每个 Conda 虚拟环境都是相互独立的。这意味着在一个环境中安装的包不会自动出现在其他环境中。因此，如果你希望在新的虚拟环境中使用某些包，则确实需要在该环境中重新安装这些包。</p></li><li><p><strong>环境导出和导入</strong>：当你使用 Anaconda 创建一个新的虚拟环境时，默认情况下，这个新环境并不会自动包含 Anaconda 安装时自带的所有包。新创建的 Conda 环境通常只包含一些最基本、最核心的包，比如 <code>python</code> 和 <code>pip</code>，以及其他少量基础工具。</p><ul><li>但是如果你想拷贝一些包到新的虚拟环境，可以：</li></ul><pre><code class="shell">conda create --name myenv python=3.10 numpy pandas matplotlib</code></pre><ul><li>如果你已经有一个包含所需包的环境，并且想要在另一个环境中复制相同的配置（包括所有已安装的包及其版本），你可以使用 <code>conda env export</code> 命令来导出当前环境的配置为 YAML 文件，然后在新环境中使用 <code>conda env create</code> 根据这个 YAML 文件创建一个完全相同的环境。例如：</li></ul><pre><code class="shell">conda env export --name existing_env &gt; environment.ymlconda env create --file environment.yml</code></pre><ul><li>如果你希望新创建的环境包含与基础 Anaconda 环境相同的包集合，可以这样做：</li></ul><pre><code class="shell">conda activate base                            #先激活基础环境conda env export --no-builds &gt; environment.yml #再导出基础环境的包#基于 yml 文件生成新的环境，新环境的名字将取决于 environment.yml 文件中的定义conda env create -f environment.yml</code></pre></li><li><p><strong>共享包存储库</strong>：虽然每个 Conda 环境是独立的，但它们可以共享同一个 Conda 存储库中的包。也就是说，如果多个环境都需要某个特定版本的包，Conda 只需下载一次该包并将其存储在其包缓存中，然后在不同的环境中链接到这个包。这样可以节省磁盘空间和下载时间。</p></li><li><p><strong>跨环境移动包</strong>：严格来说，你不能直接“移动”包从一个 Conda 环境到另一个。但是，通过上述的环境导出 / 导入功能，你可以高效地在不同环境中复制包配置。</p></li></ol><h1 id="二、Pyinstaller- 使用"><a href="# 二、Pyinstaller- 使用" class="headerlink" title="二、Pyinstaller 使用"></a>二、Pyinstaller 使用</h1><blockquote><p><strong>作用：</strong>PyInstaller 是一个非常流行的开源工具，用于将 Python 应用程序打包成独立的可执行文件，适用于 Windows、macOS 和 Linux 等多个平台。它能够帮助开发者将复杂的项目及其所有依赖项整合到一起，从而简化分发流程。</p></blockquote><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/0.png" style="zoom:50%;" /><p><strong>主要特点</strong></p><ul><li><strong>跨平台支持</strong>：可以在不同操作系统上运行，生成对应平台的可执行文件。</li><li><strong>包含所有依赖</strong>：自动分析你的 Python 脚本，并收集所有的依赖库和资源文件，确保在目标机器上无需额外安装即可运行。</li><li><strong>多种输出格式</strong>：根据不同的需求，可以生成单个可执行文件或包含多个文件的目录。</li><li><strong>兼容性广</strong>：支持多种 Python 版本及大量的第三方库。</li></ul><h2 id="2-1- 安装与介绍"><a href="#2-1- 安装与介绍" class="headerlink" title="2.1 安装与介绍"></a>2.1 安装与介绍 </h2><p><strong> 安装 pyinstaller</strong>，检查是否有 pyinstaller，如无，安装 <code>pip install pyinstaller</code></p><p><strong>Pyinstaller 常用选项</strong></p><ul><li><code>-F</code> 或 <code>--onefile</code>：打包成单个可执行文件。</li><li><code>-w</code> 或 <code>--windowed</code>（仅适用于 macOS 和 Windows 上的 GUI 应用）：避免打开控制台窗口。</li><li><code>-n</code> 或 <code>--name</code>：指定输出的可执行文件名称。</li><li><code>-i</code> 或 <code>--icon</code>：为生成的可执行文件添加图标。</li></ul><p>PyInstaller 还允许通过编写 <code>.spec</code> 文件来进一步定制打包过程，比如处理动态导入模块、添加数据文件等复杂场景。</p><ol><li><p><strong>生成 .spec 文件</strong>： 在首次运行 PyInstaller 时不直接生成可执行文件，而是只生成 <code>.spec</code> 文件，可以使用 <code>-y</code> 参数：</p><pre><code class="shell">pyinstaller --onefile -n myapp -y myscript.py</code></pre><p>这将生成一个名为 <code>myscript.spec</code> 的文件。</p></li><li><p><strong>编辑 .spec 文件</strong>： 打开生成的 <code>.spec</code> 文件进行编辑。以下是一些常见的高级用法示例。</p><pre><code class="shell"># -*- mode: python ; coding: utf-8 -*-#指定是否使用加密算法block_cipher = None#打包流程的核心部分之一。它负责分析你的脚本及其依赖关系，并准备所有必要的信息以便后续步骤使用。a = Analysis([&#39;myscript.py&#39;],  #要打包的主脚本列表    pathex=[&#39;/path/to/my/project&#39;],  #包含额外的路径以搜索模块    binaries=[],  #需要包含的二进制文件（如动态链接库）    datas=[(&#39;resources/*&#39;, &#39;.&#39;)], # 添加数据文件    hiddenimports=[&#39;module_name&#39;], # 显式声明隐藏导入，那些不会被自动检测到的隐式导入模块    hookspath=[&#39;./hooks&#39;], # 自定义钩子路径    runtime_hooks=None,    excludes=None,    win_no_prefer_redirects=False,    win_private_assemblies=False,    cipher=block_cipher,)#Python ZIP 应用程序档案，包含了所有经过压缩的纯 Python 模块pyz = PYZ(a.pure, a.zipped_data,          cipher=block_cipher,          )#定义了最终生成的可执行文件的详细信息。包括名称、图标、是否启用控制台窗口等。exe = EXE(pyz,          a.scripts,          [],          exclude_binaries=True,          name=&#39;myapp&#39;,          debug=False,          strip=False,          upx=True,          console=True,          icon=&#39;myicon.ico&#39;, # 应用图标          key=&#39;my_secret_key&#39;) # 加密密钥#用于收集所有需要的资源，包括二进制文件、ZIP 文件和数据文件，并将它们与 exe 组合在一起形成最终的输出目录结构。coll = COLLECT(exe,               a.binaries,               a.zipfiles,               a.datas,               strip=False,               upx=True,               upx_exclude=[],               name=&#39;myapp&#39;)</code></pre></li></ol><h2 id="2-2- 开始打包"><a href="#2-2- 开始打包" class="headerlink" title="2.2 开始打包"></a>2.2 开始打包 </h2><p> 切换到你的工作目录，就是你的 python 程序所在的路径，创建虚拟环境：</p><p><strong>方法一</strong>：<code>python -m venv v_env</code></p><pre><code class="shell">python -m venv v_env   # 使用 Python 的 venv 模块来创建一个新的虚拟环境 v_envsource v_env/bin/activate.csh   #如果当前是 csh 环境source v_env/bin/activate       #如果当前是 bash 环境pip install pyqt5 pyinstaller   #在虚拟环境 v_env 安装需要用到的包pyinstaller --onfile --windowed --hidden-import PyQt5.sip xxx.py</code></pre><p><strong>方法二</strong>：<code>conda create --name myenv</code>  </p><pre><code class="shell">conda create --name myenv python=3.10 pyqt5 pyinstaller  # 使用 anaconda 创建虚拟环境，并夹带一些指定的包conda activate myenv        # 激活环境pyinstaller --onfile --windowed --hidden-import PyQt5.sip xxx.py</code></pre><blockquote><p>当你使用 Anaconda 创建一个新的虚拟环境时，默认情况下，这个新环境并不会自动包含 Anaconda 安装时自带的所有包。新创建的 Conda 环境通常只包含一些最基本、最核心的包，比如 <code>python</code> 和 <code>pip</code>，以及其他少量基础工具。</p></blockquote><p><strong>更建议的做法是将这个过程写成一个 shell 脚本，省事</strong></p><p>以 <code>python -m venv v_env</code> 创建的虚拟环境为例</p><pre><code class="shell">#!/bin/cshsource v_env/bin/activate.csh       #先激活虚拟环境pyinstaller --onfile --windowed \            --add_data &quot;assets:assets&quot;        #静态资源目录            --hidden-import PyQt5.sip         #声明隐藏依赖            --icon=app.ico                    #程序图标            xxx.py  </code></pre><h2 id="2-3- 其他相关知识点"><a href="#2-3- 其他相关知识点" class="headerlink" title="2.3 其他相关知识点"></a>2.3 其他相关知识点</h2><p><code>python -m venv</code> 和 Anaconda（或更具体地说是 <code>conda</code> 命令用于创建虚拟环境）都是用于创建独立的 Python 环境，但它们之间存在一些关键差异：</p><ol><li>包管理</li></ol><ul><li><strong><code>venv</code></strong>: 使用标准的 Python 包管理工具 <code>pip</code> 来安装和管理包。这意味着你需要手动解决依赖关系，并确保所有需要的包都可以通过 PyPI 获得。</li><li><strong>Anaconda (<code>conda</code>)</strong>: 提供了自己的包管理和环境管理系统，叫做 <code>conda</code>。它不仅能够管理 Python 包，还能处理非 Python 依赖项，例如编译器、系统库等。此外，<code>conda</code> 可以从 Anaconda 的仓库中获取包，这些仓库通常包含比 PyPI 更新的版本或者直接提供预编译的二进制文件，这在某些情况下可以简化安装过程。</li></ul><ol start="2"><li>跨平台兼容性与易用性</li></ol><ul><li><strong><code>venv</code></strong>: 主要专注于 Python 开发者的使用场景，对于简单的项目和纯 Python 依赖非常有效。但是，在处理跨平台兼容性问题时可能需要额外的工作，特别是在处理不同操作系统之间的差异时。</li><li><strong>Anaconda (<code>conda</code>)</strong>: 设计时考虑到了数据科学领域的需求，因此在处理跨平台兼容性和复杂的依赖关系方面表现出色。<code>conda</code> 创建的环境更容易在不同的操作系统之间迁移，且支持多种语言的包管理，不仅仅限于 Python。</li></ul><ol start="3"><li>环境隔离</li></ol><ul><li><strong><code>venv</code></strong> 和 <strong><code>conda</code></strong> 都能有效地创建隔离的环境，使得不同的项目可以拥有独立的库版本和依赖关系。然而，由于 <code>conda</code> 还可以管理非 Python 依赖，所以在某些情况下它可以提供更强的隔离能力。</li></ul><ol start="4"><li>性能与大小</li></ol><ul><li><strong><code>venv</code></strong>: 生成的虚拟环境相对较小，因为它们只包含必要的 Python 文件和激活脚本。</li><li><strong>Anaconda (<code>conda</code>)</strong>: 创建的环境可能会更大，因为它包含了更多的默认包（尤其是数据科学相关的库），以及为了支持多语言和复杂依赖而增加的功能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Hexo+Github 搭建个人免费博客</title>
      <link href="/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/"/>
      <url>/%E4%BD%BF%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>此文基本转自：<a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html">http://blog.haoji.me/build-blog-website-by-hexo-github.html</a></p><h1 id="1- 前言"><a href="#1- 前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p> 使用 github pages 服务搭建博客的好处有：</p><blockquote><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于 github 的；</li><li>数据绝对安全，基于 github 的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li></ol></blockquote><h2 id="1-1- 准备工作"><a href="#1-1- 准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作 </h2><p> 在开始一切之前，你必须已经：</p><ul><li>有一个 github 账号，没有的话去注册一个；</li><li>安装了 git for windows（或者其它 git 客户端）；<blockquote><p> <a href="https://gitforwindows.org/">下载地址</a><br> 双击下载好的 exe 文件，一路 next 就好</p></blockquote></li><li>安装了 node.js、npm，并了解相关基础知识<blockquote><p>Hexo 是基于 nodeJS 环境的静态博客，会用到里面的 npm 工具。 </p><p><a href="https://nodejs.org/en/">下载地址</a>（LTS 为长期支持版，Current 为当前最新版）</p><p>下载好 msi 文件后，双击打开安装，也是一路 next，不过在 Custom Setup 这一步记得选 <code>Add to PATH</code>这样你就不用自己去配置电脑上环境变量了，装完在 cmd 中输入 <code>path</code> 可以看到你的 node 是否配置在里面（环境变量），没有的话你就自由发挥吧。</p></blockquote></li><li>安装 hexo<blockquote><p>a. 先创建一个文件夹（用来存放所有 blog 的东西），然后 <code>cd</code> 到该文件夹下。<br>b. 安装 hexo 命令：<code>$ npm i -g hexo</code><br>c. 初始化命令：<br><code>$ cd /f/Workspaces/hexo/</code><br><code>$ hexo init</code><br>初始化完成之后打开所在的文件夹可以看到以下文件：<br><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/hexo-init.png" alt=""><br>其中：<br> node_modules：是依赖包<br>public：存放的是生成的 html 页面 , 这些文件将来都是要提交到 github 去的<br>scaffolds：命令生成文章等的模板<br>source：用命令创建的各种文章<br>themes：主题<br>_config.yml：整个博客的基础配置<br>db.json：source 解析所得到的<br>package.json：项目所需模块项目的配置信息</p></blockquote></li></ul><h1 id="2- 搭建 github 博客"><a href="#2- 搭建 github 博客" class="headerlink" title="2. 搭建 github 博客"></a>2. 搭建 github 博客 </h1><h2 id="2-1- 新建仓库"><a href="#2-1- 新建仓库" class="headerlink" title="2.1 新建仓库"></a>2.1 新建仓库</h2><p> 在你的个人 github 账户页面新建一个名为 <code>username.github.io</code> 的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <code>https://username.github.io</code></p><p>由此可见，每一个 github 账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h2 id="2-2- 绑定域名"><a href="#2-2- 绑定域名" class="headerlink" title="2.2 绑定域名"></a>2.2 绑定域名 </h2><p> 当然，你不绑定域名肯定也是可以的，就用默认的 <code>xxx.github.io</code> 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是 OK 的。</p><p>创建域名后，然后到你的 github 项目根目录新建一个名为 CNAME 的文件（无后缀），里面填写你的域名。域名配置最常见有 2 种方式，CNAME 和 A 记录，CNAME 填写域名，A 记录填写 IP</p><p>注意：在你绑定了新域名之后，原来的 <code> 你的用户名.github.io</code>并没有失效，而是会自动跳转到你的新域名。</p><h1 id="3- 配置 SSH-key"><a href="#3- 配置 SSH-key" class="headerlink" title="3 配置 SSH key"></a>3 配置 SSH key</h1><p>你提交代码肯定要拥有你的 github 权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用 ssh key 来解决本地和服务器的连接问题。</p><p>用 git bash 执行如下命令：</p><pre><code>$ cd ~/. ssh #检查本机已存在的 ssh 密钥 </code></pre><p> 如果提示：No such file or directory 说明你是第一次使用 git</p><pre><code>ssh-keygen -t rsa -C &quot; 邮件地址 &quot;</code></pre><p> 然后连续 3 次回车，最终会生成一个文件在用户目录下，打开用户目录，找到 <code>.ssh\id_rsa.pub</code> 文件，记事本打开并复制里面的内容，打开你的 github 主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/dshsfhsdjfhs2w3442.png" alt=""> </p><h2 id="3-1- 测试是否成功"><a href="#3-1- 测试是否成功" class="headerlink" title="3.1 测试是否成功"></a>3.1 测试是否成功 </h2><pre><code>$ ssh -T git@github.com -i ~/.ssh/id_rsa    # 注意邮箱地址不用改</code></pre><p> 如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入 yes，然后会看到：</p><blockquote><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>看到这个信息说明 SSH 已配置成功！<br>此时你还需要配置：</p><pre><code>$ git config --global user.name &quot;liuxianan&quot;// 你的 github 用户名，非昵称$ git config --global user.email  &quot;xxx@qq.com&quot;// 填写你的 github 注册邮箱</code></pre><h1 id="4- 发布"><a href="#4- 发布" class="headerlink" title="4 发布"></a>4 发布</h1><h2 id="4-1- 初始界面"><a href="#4-1- 初始界面" class="headerlink" title="4.1 初始界面"></a>4.1 初始界面</h2><pre><code>$ hexo g # 生成$ hexo s # 启动服务 </code></pre><p><code>hexo s</code> 是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为 4000 这个端口太常见了，解决端口冲突问题请参考这篇文章：</p><p><a href="http://blog.liuxianan.com/windows-port-bind.html">http://blog.liuxianan.com/windows-port-bind.html</a></p><p>第一次初始化的时候 hexo 已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑，打开时就是这个样子：<br><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/qweqweqw3432423432.png" alt=""></p><h2 id="4-2- 修改主题"><a href="#4-2- 修改主题" class="headerlink" title="4.2 修改主题"></a>4.2 修改主题 </h2><p> 既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 <a href="https://hexo.io/themes/">官方主题</a>。</p><p>个人比较喜欢的 2 个主题：<a href="https://github.com/yelog/hexo-theme-3-hexo">hexo-theme-3-hexo</a> 和 <a href="https://github.com/litten/hexo-theme-yilia">hexo-theme-yilia</a>。</p><p>首先下载这个主题：</p><pre><code>$ cd /f/Workspaces/hexo/$ git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</code></pre><p>下载后的主题都在这里：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/wqeqwewqewqe342342342.png" alt=""></p><p>修改项目根目录下 <code>_config.yml</code> 中的 <code>theme: landscape</code> 改为 theme: 3-hexo，然后重新执行 <code>hexo g</code> 来重新生成。</p><p>当然模板是作者提供的，可根据自己的喜好修改 themes/3-hexo/_config.yml 里面的内容</p><p>3-hexo 使用说明：<a href="https://yelog.org/2017/03/23/3-hexo-instruction/">https://yelog.org/2017/03/23/3-hexo-instruction/</a></p><p>如果出现一些莫名其妙的问题，可以先执行 <code>hexo clean</code> 来清理一下 public 的内容，然后再来重新生成和发布。</p><h2 id="4-2- 上传到 Github"><a href="#4-2- 上传到 Github" class="headerlink" title="4.2 上传到 Github"></a>4.2 上传到 Github</h2><p>在上传代码到 github 之前，一定要记得先把你以前所有代码下载下来（虽然 github 有版本管理，但备份一下总是好的），因为从 hexo 提交代码时会把你以前的所有代码都删掉。<br>如果你一切都配置好了，发布上传很容易，一句 <code>hexo d</code> 就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，<code>ssh key</code>肯定要配置好。</p><p>其次，项目根目录配置 <code>_config.yml</code> 中有关 deploy 的部分：</p><p>正确写法：</p><pre><code>deploy:  type: git  repository: git@github.com:liuxianan/liuxianan.github.io.git  branch: master</code></pre><p> 上传中直接执行 <code>hexo d</code> 的话一般会报如下错误：</p><pre><code>Deployer not found: github 或者 Deployer not found: git</code></pre><p>原因是还需要安装一个插件：</p><pre><code>$ npm install hexo-deployer-git --save</code></pre><p>部署这个命令一定要用 git bash，否则会提示<code>Permission denied (publickey).</code></p><h2 id="4-3- 保留 CNAME、README-md 等文件"><a href="#4-3- 保留 CNAME、README-md 等文件" class="headerlink" title="4.3 保留 CNAME、README.md 等文件"></a>4.3 保留 CNAME、README.md 等文件 </h2><p> 提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非 md 文件可以把他们放到 source 文件夹下，这里的所有文件都会原样复制（除了 md 文件）到 public 目录的：</p><p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/wewrwervwv54523v32w.png" alt=""></p><p>由于 hexo 默认会把所有 md 文件都转换成 html，包括 README.md，所有需要每次生成之后、上传之前，手动将 README.md 复制到 public 目录，并删除 README.html。</p><h1 id="5- 常用 hexo 命令"><a href="#5- 常用 hexo 命令" class="headerlink" title="5 常用 hexo 命令"></a>5 常用 hexo 命令 </h1><p> 常见命令：</p><pre><code>hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至 public 目录hexo server #开启预览访问端口（默认端口 4000，&#39;ctrl + c&#39; 关闭 server）hexo deploy #部署到 GitHubhexo help  # 查看帮助hexo version  #查看 Hexo 的版本 </code></pre><p> 缩写：</p><pre><code>hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy</code></pre><p>组合命令：</p><pre><code>hexo s -g #生成并本地预览hexo d -g #生成并上传 </code></pre><p> 根目录下的_config.yml 里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。</p><p>需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。</p><h1 id="6- 写博客"><a href="#6- 写博客" class="headerlink" title="6 写博客"></a>6 写博客 </h1><p> 定位到我们的 hexo 根目录，执行命令：</p><pre><code>hexo new &#39;my-first-blog&#39;#hexo n &#39;my-first-blog&#39;</code></pre><p>hexo 会帮我们在 <code>_posts</code> 目录下生成同名.md 文件</p><p>我们只需要打开这个文件就可以开始写博客了</p><blockquote><p>注意：这里的.md 文件是根据 scaffolds 目录里的 post.md 文件为模板生成的。</p></blockquote><p>一般完整格式如下：</p><pre><code>---    title: postName               #创建的文章名称，    date: 2013-12-02 15:30:16     #文章生成时间，一般不改，当然也可以任意修改    categories:                   #分类，可以在模板中设置默认值    tags: [tag1,tag2,tag3]        #文章标签，可空，多标签请用格式，注意: 后面有个空格    description: 附加一段文章摘要，字数最好在 140 字以内，会出现在 meta 的 description 里面---    以下是正文 </code></pre><p> 写完之后，可通过一下命令预览及上传：</p><pre><code>$ hexo s -g   #生成并本地预览$ hexo d -g   #生成并部署到 Github</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于 hexo 使用过程中报错问题汇总</title>
      <link href="/%E5%85%B3%E4%BA%8Ehexo%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/%E5%85%B3%E4%BA%8Ehexo%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="一 - 用 hexo 进行初始化，文件加载不动，卡慢"><a href="# 一 - 用 hexo 进行初始化，文件加载不动，卡慢" class="headerlink" title="一. 用 hexo 进行初始化，文件加载不动，卡慢"></a>一. 用 hexo 进行初始化，文件加载不动，卡慢 </h1><p> 在对文件执行 git bash 并且在 git bash 中输入<code>hexo init</code>，代码如下：</p><pre><code> $ cd /f/Workspaces/hexo/ $ hexo init</code></pre><p>出现如下问题：其中部分文件下载不动 <br> 原因：github 上不去，可以打开 cmd 窗口，输入 <code>ping github.com</code>，出现<code> 请求超时 </code>。<br> 参考解决方案：<br>在 hosts(“C:\Windows\System32\drivers\etc\hosts”)文件末尾添加：</p><p>#github hosts<br>192.30.253.112 github.com<br>199.232.5.194 github.global.ssl.fastly.net</p><p>按照上述方案，基本可以解决此问题。</p><h1 id="二 - 创建文章时出现报错"><a href="# 二 - 创建文章时出现报错" class="headerlink" title="二. 创建文章时出现报错"></a>二. 创建文章时出现报错 </h1><p> 输入<code>hexo new &quot;title&quot;</code>，返回如下结果：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/image-20250228015408395.png" style="zoom:33%;" />经查，已经使用 `npm install hexo-generator-topindex --save` 安装所需的插件，仍然报错。原因：修改了 scaffolds/post.md 文件，我往里面添加了新参数，top:/tags:/categories:其中把英文冒号打成了中文冒号，故导致无法通过 post.md 模板创建文章。<h1 id="三 -Hexo 文章上传本地图片在网页上无法显示的解决办法"><a href="# 三 -Hexo 文章上传本地图片在网页上无法显示的解决办法" class="headerlink" title="三.  Hexo 文章上传本地图片在网页上无法显示的解决办法"></a>三.  Hexo 文章上传本地图片在网页上无法显示的解决办法</h1><h2 id="3-1- 使用坚果云编辑 -md 文件时"><a href="#3-1- 使用坚果云编辑 -md 文件时" class="headerlink" title="3.1 使用坚果云编辑.md 文件时"></a>3.1 使用坚果云编辑.md 文件时</h2><ol><li>找到 <code>Hexo</code> 下的 <code>_config.yml</code> 里的 <code>post_asset_folder</code>，把这个选项从<code>false</code> 改成<code>true</code>。</li><li>git bash 安装插件：npm install <a href="https://github.com/7ym0n/hexo-asset-image">https://github.com/7ym0n/hexo-asset-image</a> –save（这是个修改过的插件，经测试无问题），使用这个插件来引入图片。</li><li>在 git bash 里运行 <code>hexo n &quot;title&quot;</code>在 /Hexo/source/_posts 文件夹创建 md 文章，与此同时，此文件夹里会同时出现同名文件夹，如下图，将 title 里需要插入的图片先放入 title 文件夹，再进行插入文章，即可显示。<br><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-13_12-42-03.png" alt="">))</li></ol><h2 id="3-2- 使用 Typora 编辑器时"><a href="#3-2- 使用 Typora 编辑器时" class="headerlink" title="3.2 使用 Typora 编辑器时"></a>3.2 使用 Typora 编辑器时</h2><ul><li><p>首先，在项目根目录下 <code>source</code> 文件下新建一个 <code>assets</code> 文件夹</p></li><li><p>设置 Typora：Typora 文件 -&gt; 偏好设置，图片插入的地方选择“复制到指定路径”，如图所示：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-13_23-06-16.png" style="zoom: 50%;" /></li><li><p>设置 <code>格式—图像—设置图片根目录</code>，把目录设置到 source    （每次插入图片前记得检查此项）</p></li><li><p>最后就可以愉快的插入图片了，格式如图：</p><img src="https://image--1.oss-cn-shenzhen.aliyuncs.com/Snipaste_2020-02-13_22-41-42.png" style="zoom:50%;" /></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
